#!/usr/bin/env python3
"""
WebSocket Manager Import Path SSOT Fix Script

CRITICAL GOLDEN PATH ISSUE:
- 314 files have incorrect import paths for UnifiedWebSocketManager
- Blocking all smoke tests and test collection
- Preventing golden path validation

ROOT CAUSE:
Files importing from: netra_backend.app.websocket_core.websocket_manager
Should import from: netra_backend.app.websocket_core.canonical_import_patterns

Business Impact:
- BLOCKS test infrastructure
- PREVENTS golden path validation
- REVENUE RISK: $500K+ ARR dependent on working tests

Fix Strategy:
1. Replace incorrect import statements across all 314 files
2. Update both class imports and factory function imports
3. Ensure SSOT compliance with canonical import patterns
4. Validate fixes with smoke tests

Generated by Claude Code for Issue Analysis
"""

import os
import re
import sys
from pathlib import Path
from typing import List, Dict, Tuple
import subprocess

def get_project_root() -> Path:
    """Get the project root directory."""
    current_dir = Path(__file__).parent
    while current_dir != current_dir.parent:
        if (current_dir / "CLAUDE.md").exists():
            return current_dir
        current_dir = current_dir.parent
    return Path.cwd()

def find_files_with_incorrect_imports(root_dir: Path) -> List[Path]:
    """Find all files with incorrect WebSocket manager imports."""
    print("Searching for files with incorrect WebSocket manager imports...")

    # Use grep to find files with the incorrect import pattern
    try:
        cmd = [
            "grep", "-r", "-l",
            "from netra_backend\\.app\\.websocket_core\\.websocket_manager import UnifiedWebSocketManager",
            str(root_dir)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, cwd=root_dir)

        if result.returncode == 0:
            files = []
            for line in result.stdout.strip().split('\n'):
                if line:
                    file_path = Path(line.strip())
                    if file_path.exists() and file_path.suffix == '.py':
                        files.append(file_path)
            return files
        else:
            print("grep command failed, falling back to manual search...")
            return find_files_manual_search(root_dir)

    except Exception as e:
        print(f"Error with grep: {e}, falling back to manual search...")
        return find_files_manual_search(root_dir)

def find_files_manual_search(root_dir: Path) -> List[Path]:
    """Manual search for files with incorrect imports."""
    files_with_incorrect_imports = []
    incorrect_pattern = re.compile(
        r"from\s+netra_backend\.app\.websocket_core\.websocket_manager\s+import\s+UnifiedWebSocketManager"
    )

    for py_file in root_dir.rglob("*.py"):
        try:
            content = py_file.read_text(encoding='utf-8')
            if incorrect_pattern.search(content):
                files_with_incorrect_imports.append(py_file)
        except Exception as e:
            print(f"Warning: Error reading {py_file}: {e}")
            continue

    return files_with_incorrect_imports

def fix_file_imports(file_path: Path) -> Tuple[bool, int]:
    """Fix import statements in a single file.

    Returns:
        Tuple of (success, number_of_replacements)
    """
    try:
        content = file_path.read_text(encoding='utf-8')
        original_content = content

        # Pattern 1: Direct class import (most common)
        pattern1 = re.compile(
            r"from\s+netra_backend\.app\.websocket_core\.websocket_manager\s+import\s+UnifiedWebSocketManager"
        )
        replacement1 = "from netra_backend.app.websocket_core.canonical_import_patterns import UnifiedWebSocketManager"
        content = pattern1.sub(replacement1, content)

        # Pattern 2: Factory function import
        pattern2 = re.compile(
            r"from\s+netra_backend\.app\.websocket_core\.websocket_manager\s+import\s+get_websocket_manager"
        )
        replacement2 = "from netra_backend.app.websocket_core.canonical_import_patterns import get_websocket_manager"
        content = pattern2.sub(replacement2, content)

        # Pattern 3: Mixed imports (UnifiedWebSocketManager and get_websocket_manager)
        pattern3 = re.compile(
            r"from\s+netra_backend\.app\.websocket_core\.websocket_manager\s+import\s+([^,\n]*UnifiedWebSocketManager[^,\n]*)"
        )
        def replace_mixed_import(match):
            import_list = match.group(1)
            return f"from netra_backend.app.websocket_core.canonical_import_patterns import {import_list}"
        content = pattern3.sub(replace_mixed_import, content)

        # Pattern 4: Alternative import formats with parentheses/line breaks
        pattern4 = re.compile(
            r"from\s+netra_backend\.app\.websocket_core\.websocket_manager\s+import\s+\(\s*([^)]*UnifiedWebSocketManager[^)]*)\s*\)",
            re.MULTILINE | re.DOTALL
        )
        def replace_multiline_import(match):
            import_list = match.group(1).strip()
            return f"from netra_backend.app.websocket_core.canonical_import_patterns import (\n    {import_list}\n)"
        content = pattern4.sub(replace_multiline_import, content)

        # Count replacements
        replacements = 0
        if content != original_content:
            replacements = (
                len(pattern1.findall(original_content)) +
                len(pattern2.findall(original_content)) +
                len(pattern3.findall(original_content)) +
                len(pattern4.findall(original_content))
            )

            # Write the fixed content back
            file_path.write_text(content, encoding='utf-8')
            return True, replacements

        return True, 0

    except Exception as e:
        print(f"Error fixing {file_path}: {e}")
        return False, 0

def main():
    """Main function to fix all WebSocket import path violations."""
    print("WebSocket Manager Import Path SSOT Fix Script")
    print("=" * 60)

    root_dir = get_project_root()
    print(f"Project root: {root_dir}")

    # Find all files with incorrect imports
    files_to_fix = find_files_with_incorrect_imports(root_dir)
    total_files = len(files_to_fix)

    if total_files == 0:
        print("No files found with incorrect import paths!")
        return 0

    print(f"Found {total_files} files with incorrect import paths")
    print()

    # Process all files
    fixed_files = 0
    total_replacements = 0
    failed_files = []

    for i, file_path in enumerate(files_to_fix, 1):
        print(f"[{i:3d}/{total_files}] Fixing {file_path.relative_to(root_dir)}")

        success, replacements = fix_file_imports(file_path)
        if success:
            if replacements > 0:
                fixed_files += 1
                total_replacements += replacements
                print(f"    Fixed {replacements} import(s)")
            else:
                print(f"    No changes needed")
        else:
            failed_files.append(file_path)
            print(f"    Failed to fix")

    print()
    print("=" * 60)
    print("SUMMARY")
    print("=" * 60)
    print(f"Total files processed: {total_files}")
    print(f"Files successfully fixed: {fixed_files}")
    print(f"Total import replacements: {total_replacements}")
    print(f"Failed files: {len(failed_files)}")

    if failed_files:
        print("\nFailed files:")
        for file_path in failed_files:
            print(f"  - {file_path.relative_to(root_dir)}")

    print()
    if fixed_files > 0:
        print("Import path fixes completed successfully!")
        print("Next step: Run smoke tests to validate fixes")
        print("   Command: python tests/unified_test_runner.py --categories smoke --fast-fail")
        return 0
    else:
        print("No fixes were needed")
        return 0

if __name__ == "__main__":
    sys.exit(main())