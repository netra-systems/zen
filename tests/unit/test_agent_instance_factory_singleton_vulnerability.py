"""
Unit tests for Issue #1116: Agent Instance Factory Singleton Vulnerability

PURPOSE: Prove that get_agent_instance_factory() singleton causes user context leakage
- User A's responses going to User B due to shared factory instance
- Testing the vulnerability that create_agent_instance_factory(user_context) should fix

VULNERABILITY HYPOTHESIS: 
- Singleton factory shares state between users
- UserExecutionContext gets contaminated across requests
- Agent instances leak data between concurrent users

EXPECTED RESULT: These tests should FAIL initially, proving the vulnerability exists
"""
import pytest
import asyncio
import uuid
from unittest.mock import Mock, patch
from concurrent.futures import ThreadPoolExecutor
import threading
import time
from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.agents.supervisor.agent_instance_factory import get_agent_instance_factory
from netra_backend.app.agents.supervisor_agent_modern import SupervisorAgent
from netra_backend.app.services.user_execution_context import UserExecutionContext

@pytest.mark.unit
class TestAgentInstanceFactorySingletonVulnerability(SSotAsyncTestCase):
    """
    Test suite to PROVE singleton vulnerability in agent instance factory.
    
    These tests should FAIL to demonstrate:
    1. Singleton factory shares state between users
    2. UserExecutionContext contamination across requests  
    3. Agent responses going to wrong users
    """

    def setUp(self):
        """Set up test environment with mock user contexts."""
        super().setUp()
        self.user_a_context = UserExecutionContext(user_id='user_a_12345', thread_id=str(uuid.uuid4()), run_id=str(uuid.uuid4()), request_id=str(uuid.uuid4()), websocket_client_id='ws_alice_123', agent_context={'user_name': 'Alice', 'role': 'admin'})
        self.user_b_context = UserExecutionContext(user_id='user_b_67890', thread_id=str(uuid.uuid4()), run_id=str(uuid.uuid4()), request_id=str(uuid.uuid4()), websocket_client_id='ws_bob_456', agent_context={'user_name': 'Bob', 'role': 'user'})

    def test_singleton_factory_shares_instance_vulnerability(self):
        """
        VULNERABILITY TEST: Prove singleton factory returns same instance
        
        EXPECTED: This test should PASS (proving vulnerability exists)
        - Same factory instance returned for different users
        - State contamination risk confirmed
        """
        factory_1 = get_agent_instance_factory()
        factory_2 = get_agent_instance_factory()
        self.assertIs(factory_1, factory_2, 'SINGLETON VULNERABILITY CONFIRMED: Same factory instance for all users')
        self.assertEqual(id(factory_1), id(factory_2), 'MEMORY ADDRESS CONFIRMATION: Singleton shares memory between users')

    def test_user_context_contamination_vulnerability(self):
        """
        VULNERABILITY TEST: Prove user context gets contaminated
        
        EXPECTED: This test should FAIL (proving vulnerability)  
        - User A's context contaminated by User B
        - Data leakage between user sessions
        """
        factory = get_agent_instance_factory()
        agent_a = asyncio.run(factory.create_agent('supervisor', self.user_a_context))
        original_user_a_id = agent_a.user_execution_context.user_id
        original_metadata_a = agent_a.user_execution_context.agent_context.copy()
        agent_b = asyncio.run(factory.create_agent('supervisor', self.user_b_context))
        self.assertEqual(agent_a.user_execution_context.user_id, original_user_a_id, f"VULNERABILITY: User A's ID changed from {original_user_a_id} to {agent_a.user_execution_context.user_id}")
        self.assertEqual(agent_a.user_execution_context.agent_context, original_metadata_a, f"VULNERABILITY: User A's metadata contaminated: Original: {original_metadata_a}, Current: {agent_a.user_execution_context.agent_context}")

    def test_concurrent_agent_creation_race_condition(self):
        """
        VULNERABILITY TEST: Prove race condition in concurrent agent creation
        
        EXPECTED: This test should FAIL (proving race condition)
        - Concurrent agent creation causes context mixing
        - Thread safety violations confirmed
        """
        factory = get_agent_instance_factory()
        results = {}
        errors = []

        def create_agent_for_user(user_id, user_context):
            """Create agent and verify context integrity."""
            try:
                agent = asyncio.run(factory.create_agent('supervisor', user_context))
                time.sleep(0.01)
                actual_user_id = agent.user_execution_context.user_id
                results[user_id] = {'expected_user_id': user_context.user_id, 'actual_user_id': actual_user_id, 'context_match': actual_user_id == user_context.user_id, 'thread_id': threading.current_thread().ident}
            except Exception as e:
                errors.append(f'User {user_id}: {str(e)}')
        user_contexts = {}
        for i in range(5):
            user_id = f'user_{i}'
            user_contexts[user_id] = UserExecutionContext(user_id=user_id, thread_id=str(uuid.uuid4()), run_id=str(uuid.uuid4()), request_id=str(uuid.uuid4()), websocket_client_id=f'ws_{user_id}', agent_context={'user_name': f'User{i}', 'role': 'test'})
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = []
            for user_id, context in user_contexts.items():
                future = executor.submit(create_agent_for_user, user_id, context)
                futures.append(future)
            for future in futures:
                future.result()
        self.assertEqual(len(errors), 0, f'Errors during concurrent creation: {errors}')
        contaminated_users = []
        for user_id, result in results.items():
            if not result['context_match']:
                contaminated_users.append({'user_id': user_id, 'expected': result['expected_user_id'], 'actual': result['actual_user_id'], 'thread': result['thread_id']})
        self.assertEqual(len(contaminated_users), 0, f'RACE CONDITION VULNERABILITY: {len(contaminated_users)} users had contaminated contexts: {contaminated_users}')

    def test_agent_state_persistence_vulnerability(self):
        """
        VULNERABILITY TEST: Prove agent state persists between user requests
        
        EXPECTED: This test should FAIL (proving state persistence vulnerability)
        - Previous user's state affects new user's agent
        - Factory doesn't properly isolate agent instances
        """
        factory = get_agent_instance_factory()
        agent_a = asyncio.run(factory.create_agent('supervisor', self.user_a_context))
        agent_a._execution_history = ['User A executed task 1', 'User A executed task 2']
        agent_a._current_workflow_state = {'step': 'analysis', 'user': 'Alice'}
        agent_b = asyncio.run(factory.create_agent('supervisor', self.user_b_context))
        self.assertEqual(getattr(agent_b, '_execution_history', []), [], f"VULNERABILITY: Agent B inherited execution history from User A: {getattr(agent_b, '_execution_history', [])}")
        self.assertEqual(getattr(agent_b, '_current_workflow_state', {}), {}, f"VULNERABILITY: Agent B inherited workflow state from User A: {getattr(agent_b, '_current_workflow_state', {})}")

    def test_websocket_manager_cross_contamination(self):
        """
        VULNERABILITY TEST: Prove WebSocket managers get cross-contaminated
        
        EXPECTED: This test should FAIL (proving WebSocket contamination)
        - User A's WebSocket manager used for User B  
        - Messages sent to wrong user's WebSocket connection
        """
        factory = get_agent_instance_factory()
        websocket_a = Mock()
        websocket_a.user_id = 'user_a_12345'
        websocket_a.connection_id = 'conn_a'
        websocket_b = Mock()
        websocket_b.user_id = 'user_b_67890'
        websocket_b.connection_id = 'conn_b'
        agent_a = asyncio.run(factory.create_agent('supervisor', self.user_a_context))
        agent_b = asyncio.run(factory.create_agent('supervisor', self.user_b_context))
        self.assertEqual(agent_a.user_execution_context.websocket_client_id, 'ws_alice_123', f'VULNERABILITY: Agent A has wrong WebSocket client ID. Expected: ws_alice_123, Got: {agent_a.user_execution_context.websocket_client_id}')
        self.assertEqual(agent_b.user_execution_context.websocket_client_id, 'ws_bob_456', f'VULNERABILITY: Agent B has wrong WebSocket client ID. Expected: ws_bob_456, Got: {agent_b.user_execution_context.websocket_client_id}')
        websocket_a_id = agent_a.user_execution_context.websocket_client_id
        websocket_b_id = agent_b.user_execution_context.websocket_client_id
        self.assertNotEqual(websocket_a_id, websocket_b_id, f'VULNERABILITY: WebSocket client IDs are same: User A: {websocket_a_id}, User B: {websocket_b_id}')
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')