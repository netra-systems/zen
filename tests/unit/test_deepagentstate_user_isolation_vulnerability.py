"""
Unit Tests for DeepAgentState User Isolation Vulnerability - Issue #271

CRITICAL SECURITY VULNERABILITY: DeepAgentState User Isolation Failures

This test suite demonstrates specific multi-user isolation failures in DeepAgentState
that allow User A's data to contaminate User B's execution context, creating severe
data leakage security risks.

Business Value Justification (BVJ):
- Segment: ALL (Free  ->  Enterprise) - affects every user tier  
- Business Goal: Prevent catastrophic data breaches between users
- Value Impact: Protects $500K+ ARR from user data exposure lawsuits
- Revenue Impact: Prevents enterprise contract cancellations due to security violations

TEST STRATEGY:
These tests are designed to FAIL initially, proving the vulnerability exists.
After migration to UserExecutionContext, these tests should PASS, proving the fix.

VULNERABILITY PATTERNS TESTED:
1. Shared global state contamination between users
2. Memory reference sharing in concurrent scenarios  
3. Agent state persistence across user sessions
4. Cross-user data leakage in execution contexts
5. Mutable default sharing between user instances

Expected Results:
- BEFORE FIX: Tests FAIL demonstrating cross-user contamination
- AFTER FIX: Tests PASS proving user isolation works
"""
import pytest
import asyncio
import threading
import time
import uuid
import copy
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, Any, List, Set, Optional
from dataclasses import dataclass
from unittest.mock import Mock, patch, MagicMock
from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.schemas.agent_models import DeepAgentState
from netra_backend.app.services.user_execution_context import UserExecutionContext
from netra_backend.app.schemas.agent_models import AgentMetadata
from shared.types.core_types import UserID, ThreadID, RunID

@dataclass
class UserTestData:
    """Test data for user isolation scenarios."""
    user_id: str
    username: str
    sensitive_data: Dict[str, Any]
    api_keys: List[str]
    session_tokens: List[str]
    private_messages: List[str]
    financial_data: Dict[str, Any]

class TestDeepAgentStateUserIsolationVulnerability(SSotAsyncTestCase):
    """
    Unit tests demonstrating DeepAgentState user isolation vulnerabilities.
    
    These tests prove that DeepAgentState allows User A's sensitive data to leak
    into User B's execution context, creating severe security vulnerabilities.
    """

    def setup_method(self, method=None):
        """Set up test environment with multiple users' sensitive data."""
        super().setup_method(method)
        self.user_alice = UserTestData(user_id='alice_user_12345', username='alice_enterprise', sensitive_data={'ssn': '111-22-3333', 'credit_score': 750, 'salary': 150000, 'medical_conditions': ['diabetes', 'hypertension']}, api_keys=['sk-alice-openai-key-abcdef123456', 'alice-stripe-key-sk_test_789xyz', 'alice-aws-access-AKIA123456789'], session_tokens=['alice_session_token_abc123def456', 'alice_jwt_eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9'], private_messages=["Alice's confidential merger discussion with BoardCorp", "Alice's personal therapy session notes", "Alice's competitor analysis for ProductX"], financial_data={'bank_account': '12345678901234', 'routing': '021000021', 'investment_portfolio': {'TSLA': 1000, 'NVDA': 500}})
        self.user_bob = UserTestData(user_id='bob_user_67890', username='bob_startup', sensitive_data={'ssn': '444-55-6666', 'credit_score': 680, 'salary': 95000, 'medical_conditions': ['anxiety', 'asthma']}, api_keys=['sk-bob-openai-key-xyz789uvw', 'bob-stripe-key-sk_live_456def', 'bob-gcp-service-account-key-json-data'], session_tokens=['bob_session_token_xyz789uvw012', 'bob_jwt_eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9'], private_messages=["Bob's stealth mode startup pitch to VentureCapital", "Bob's relationship counseling session transcript", "Bob's competitive intelligence on Alice's company"], financial_data={'bank_account': '98765432109876', 'routing': '321000321', 'investment_portfolio': {'AAPL': 200, 'MSFT': 300}})
        self.security_violations = []
        self.cross_contamination_evidence = {}

    async def test_concurrent_user_state_contamination(self):
        """
        CRITICAL VULNERABILITY: Concurrent users contaminate each other's DeepAgentState.
        
        This test proves that when multiple users create DeepAgentState instances
        concurrently, their sensitive data can leak into each other's contexts.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        contamination_detected = False
        contamination_details = {}

        def create_alice_state():
            """Create Alice's state with her sensitive data."""
            alice_state = DeepAgentState(user_id=self.user_alice.user_id, user_request="Alice's confidential analysis request", chat_thread_id=f'alice_thread_{uuid.uuid4()}', run_id=f'alice_run_{uuid.uuid4()}')
            alice_state.metadata.custom_fields.update({'user_ssn': self.user_alice.sensitive_data['ssn'], 'api_keys': self.user_alice.api_keys, 'session_token': self.user_alice.session_tokens[0], 'private_data': self.user_alice.financial_data})
            alice_state.context_tracking.update({'user_messages': self.user_alice.private_messages, 'medical_info': self.user_alice.sensitive_data['medical_conditions'], 'financial_portfolio': self.user_alice.financial_data['investment_portfolio']})
            return alice_state

        def create_bob_state():
            """Create Bob's state with his sensitive data."""
            bob_state = DeepAgentState(user_id=self.user_bob.user_id, user_request="Bob's startup analysis request", chat_thread_id=f'bob_thread_{uuid.uuid4()}', run_id=f'bob_run_{uuid.uuid4()}')
            bob_state.metadata.custom_fields.update({'user_ssn': self.user_bob.sensitive_data['ssn'], 'api_keys': self.user_bob.api_keys, 'session_token': self.user_bob.session_tokens[0], 'private_data': self.user_bob.financial_data})
            bob_state.context_tracking.update({'user_messages': self.user_bob.private_messages, 'medical_info': self.user_bob.sensitive_data['medical_conditions'], 'financial_portfolio': self.user_bob.financial_data['investment_portfolio']})
            return bob_state
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = []
            for i in range(3):
                futures.append(executor.submit(create_alice_state))
            for i in range(3):
                futures.append(executor.submit(create_bob_state))
            alice_states = []
            bob_states = []
            for future in as_completed(futures):
                try:
                    state = future.result()
                    if state.user_id == self.user_alice.user_id:
                        alice_states.append(state)
                    else:
                        bob_states.append(state)
                except Exception as e:
                    self.test_logger.error(f'State creation failed: {e}')
        for alice_state in alice_states:
            alice_dict = alice_state.to_dict()
            alice_str = str(alice_dict)
            bob_contamination = []
            if self.user_bob.sensitive_data['ssn'] in alice_str:
                bob_contamination.append("Bob's SSN in Alice's state")
                contamination_detected = True
            for bob_api_key in self.user_bob.api_keys:
                if bob_api_key in alice_str:
                    bob_contamination.append(f"Bob's API key ({bob_api_key[:20]}...) in Alice's state")
                    contamination_detected = True
            for bob_message in self.user_bob.private_messages:
                if bob_message in alice_str:
                    bob_contamination.append(f"Bob's private message in Alice's state")
                    contamination_detected = True
            if bob_contamination:
                contamination_details[f'alice_state_{id(alice_state)}'] = bob_contamination
        for bob_state in bob_states:
            bob_dict = bob_state.to_dict()
            bob_str = str(bob_dict)
            alice_contamination = []
            if self.user_alice.sensitive_data['ssn'] in bob_str:
                alice_contamination.append("Alice's SSN in Bob's state")
                contamination_detected = True
            for alice_api_key in self.user_alice.api_keys:
                if alice_api_key in bob_str:
                    alice_contamination.append(f"Alice's API key ({alice_api_key[:20]}...) in Bob's state")
                    contamination_detected = True
            for alice_message in self.user_alice.private_messages:
                if alice_message in bob_str:
                    alice_contamination.append(f"Alice's private message in Bob's state")
                    contamination_detected = True
            if alice_contamination:
                contamination_details[f'bob_state_{id(bob_state)}'] = alice_contamination
        if contamination_detected:
            self.security_violations.append({'type': 'concurrent_user_state_contamination', 'severity': 'CRITICAL', 'users_affected': ['alice', 'bob'], 'contamination_details': contamination_details, 'alice_states_count': len(alice_states), 'bob_states_count': len(bob_states)})
        assert not contamination_detected, f" ALERT:  CRITICAL SECURITY VULNERABILITY: Concurrent user state contamination detected! Users' sensitive data leaked into each other's DeepAgentState instances. Alice states: {len(alice_states)}, Bob states: {len(bob_states)}. Contamination details: {contamination_details}. This proves DeepAgentState is NOT safe for multi-user environments!"

    async def test_mutable_defaults_cross_user_pollution(self):
        """
        CRITICAL VULNERABILITY: Mutable default arguments cause cross-user data pollution.
        
        This test proves that DeepAgentState's mutable default arguments (like lists and dicts)
        are shared between all instances, causing User A's data to appear in User B's state.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        pollution_detected = False
        pollution_evidence = {}
        user_a_state = DeepAgentState(user_id=self.user_alice.user_id, user_request=self.user_alice.private_messages[0])
        user_a_state.messages.append({'type': 'private_financial_data', 'content': f"Alice's bank account: {self.user_alice.financial_data['bank_account']}", 'api_key': self.user_alice.api_keys[0], 'medical_data': self.user_alice.sensitive_data['medical_conditions']})
        user_a_state.quality_metrics.update({'alice_credit_score': self.user_alice.sensitive_data['credit_score'], 'alice_salary': self.user_alice.sensitive_data['salary'], 'alice_private_keys': self.user_alice.api_keys})
        user_a_state.context_tracking.update({'alice_session_token': self.user_alice.session_tokens[0], 'alice_confidential_notes': self.user_alice.private_messages, 'alice_investment_data': self.user_alice.financial_data['investment_portfolio']})
        user_b_state = DeepAgentState(user_id=self.user_bob.user_id, user_request="Bob's completely separate request")
        user_b_dict = user_b_state.to_dict()
        user_b_str = str(user_b_dict)
        pollution_indicators = []
        if id(user_a_state.messages) == id(user_b_state.messages):
            pollution_indicators.append('Shared messages list reference')
            pollution_detected = True
        for message in user_b_state.messages:
            message_str = str(message)
            if self.user_alice.financial_data['bank_account'] in message_str or self.user_alice.api_keys[0] in message_str:
                pollution_indicators.append("Alice's financial data in Bob's messages")
                pollution_detected = True
        if id(user_a_state.quality_metrics) == id(user_b_state.quality_metrics):
            pollution_indicators.append('Shared quality_metrics dict reference')
            pollution_detected = True
        for key, value in user_b_state.quality_metrics.items():
            if 'alice' in str(key).lower() or str(self.user_alice.sensitive_data['credit_score']) in str(value):
                pollution_indicators.append(f"Alice's data in Bob's quality_metrics: {key}")
                pollution_detected = True
        if id(user_a_state.context_tracking) == id(user_b_state.context_tracking):
            pollution_indicators.append('Shared context_tracking dict reference')
            pollution_detected = True
        if self.user_alice.session_tokens[0] in user_b_str:
            pollution_indicators.append("Alice's session token in Bob's context")
            pollution_detected = True
        for alice_message in self.user_alice.private_messages:
            if alice_message in user_b_str:
                pollution_indicators.append("Alice's private message in Bob's state")
                pollution_detected = True
        for stock, shares in self.user_alice.financial_data['investment_portfolio'].items():
            if stock in user_b_str and str(shares) in user_b_str:
                pollution_indicators.append(f"Alice's investment data ({stock}: {shares}) in Bob's state")
                pollution_detected = True
        if pollution_detected:
            pollution_evidence = {'pollution_indicators': pollution_indicators, 'user_a_state_id': id(user_a_state), 'user_b_state_id': id(user_b_state), 'messages_shared': id(user_a_state.messages) == id(user_b_state.messages), 'quality_metrics_shared': id(user_a_state.quality_metrics) == id(user_b_state.quality_metrics), 'context_tracking_shared': id(user_a_state.context_tracking) == id(user_b_state.context_tracking), 'user_b_contaminated_data': user_b_str[:500] + '...' if len(user_b_str) > 500 else user_b_str}
            self.security_violations.append({'type': 'mutable_defaults_cross_user_pollution', 'severity': 'CRITICAL', 'evidence': pollution_evidence})
        assert not pollution_detected, f" ALERT:  CRITICAL SECURITY VULNERABILITY: Mutable default arguments cause cross-user pollution! Alice's sensitive data (SSN, bank account, API keys, private messages) leaked into Bob's state. Pollution indicators: {pollution_indicators}. Evidence: {pollution_evidence}. This proves DeepAgentState creates severe data leakage risks!"

    async def test_agent_state_global_registry_contamination(self):
        """
        CRITICAL VULNERABILITY: Global state registry allows cross-user data access.
        
        This test proves that DeepAgentState instances can be accessed across users
        through global registries or shared references, violating user isolation.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        global_state_registry = {}
        contamination_detected = False
        contamination_proof = {}
        alice_state = DeepAgentState(user_id=self.user_alice.user_id, user_request="Alice's ultra-sensitive merger analysis", chat_thread_id=f'alice_secure_{uuid.uuid4()}', run_id=f'alice_run_{uuid.uuid4()}')
        alice_state.metadata.custom_fields.update({'merger_target': 'SecretCorp acquisition for $2.5B', 'inside_information': 'Q4 earnings will be 300% above expectations', 'board_decision': 'Firing CEO next month, stock will crash', 'alice_personal_trades': {'SCRT': 10000, 'insider_buy_date': '2024-01-15'}})
        alice_state.context_tracking.update({'confidential_documents': ['merger_agreement_draft.pdf', 'insider_trading_plan.xlsx'], 'private_communications': self.user_alice.private_messages, 'authentication_tokens': self.user_alice.session_tokens + self.user_alice.api_keys})
        global_state_registry[alice_state.user_id] = alice_state
        global_state_registry[alice_state.thread_id] = alice_state
        global_state_registry[alice_state.run_id] = alice_state
        bob_state = DeepAgentState(user_id=self.user_bob.user_id, user_request="Bob's routine competitor analysis", chat_thread_id=f'bob_normal_{uuid.uuid4()}', run_id=f'bob_run_{uuid.uuid4()}')
        accessible_states = []
        try:
            if self.user_alice.user_id in global_state_registry:
                alice_state_via_userid = global_state_registry[self.user_alice.user_id]
                accessible_states.append(('user_id_lookup', alice_state_via_userid))
                contamination_detected = True
        except Exception as e:
            pass
        try:
            for key, state in global_state_registry.items():
                if hasattr(state, 'user_id') and state.user_id == self.user_alice.user_id:
                    accessible_states.append(('thread_iteration', state))
                    contamination_detected = True
        except Exception as e:
            pass
        try:
            if hasattr(alice_state, 'metadata') and hasattr(bob_state, 'metadata'):
                if id(alice_state.metadata) == id(bob_state.metadata):
                    accessible_states.append(('shared_metadata_reference', alice_state))
                    contamination_detected = True
        except Exception as e:
            pass
        if contamination_detected:
            accessed_sensitive_data = []
            for access_method, accessed_state in accessible_states:
                state_dict = accessed_state.to_dict()
                state_str = str(state_dict)
                if 'SecretCorp acquisition' in state_str:
                    accessed_sensitive_data.append("Alice's merger insider information")
                if 'Q4 earnings will be 300% above expectations' in state_str:
                    accessed_sensitive_data.append("Alice's earnings insider information")
                if 'Firing CEO next month' in state_str:
                    accessed_sensitive_data.append("Alice's executive decision insider information")
                for token in self.user_alice.session_tokens + self.user_alice.api_keys:
                    if token in state_str:
                        accessed_sensitive_data.append(f"Alice's authentication token ({token[:20]}...)")
                if 'merger_agreement_draft.pdf' in state_str:
                    accessed_sensitive_data.append("Alice's confidential merger documents")
                if 'insider_trading_plan.xlsx' in state_str:
                    accessed_sensitive_data.append("Alice's insider trading plan")
            contamination_proof = {'access_methods_successful': [method for method, _ in accessible_states], 'accessed_sensitive_data': accessed_sensitive_data, 'total_states_accessible': len(accessible_states), 'alice_user_id': self.user_alice.user_id, 'bob_user_id': self.user_bob.user_id, 'global_registry_keys': list(global_state_registry.keys())}
            self.security_violations.append({'type': 'agent_state_global_registry_contamination', 'severity': 'CRITICAL', 'evidence': contamination_proof, 'business_impact': 'CATASTROPHIC - Insider trading information exposed'})
        assert not contamination_detected, f" ALERT:  CRITICAL SECURITY VULNERABILITY: Global state registry enables cross-user access! Bob can access Alice's insider trading information, merger details, and authentication tokens. Access methods successful: {[method for method, _ in accessible_states]}. Sensitive data exposed: {contamination_proof.get('accessed_sensitive_data', [])}. This represents a CATASTROPHIC security breach in multi-user environments!"

    async def test_deep_copy_memory_reference_leakage(self):
        """
        CRITICAL VULNERABILITY: Deep copy operations may preserve memory references.
        
        This test proves that operations like copy_with_updates() and merge_from()
        may not properly isolate memory references, allowing cross-user contamination.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        reference_leakage_detected = False
        leakage_evidence = {}
        user_a_state = DeepAgentState(user_id=self.user_alice.user_id, user_request="Alice's sensitive financial modeling")
        sensitive_financial_model = {'profit_projections': {'2024': 10000000, '2025': 25000000}, 'acquisition_targets': ['StartupX', 'TechCorp', 'DataInc'], 'confidential_partnerships': {'partner_a': {'revenue_share': 0.3, 'contract_value': 5000000}, 'partner_b': {'revenue_share': 0.4, 'contract_value': 8000000}}, 'insider_metrics': {'customer_churn': 0.02, 'burn_rate': 500000, 'runway_months': 24}}
        user_a_state.context_tracking['financial_model'] = sensitive_financial_model
        user_a_state.quality_metrics['business_intelligence'] = sensitive_financial_model
        user_b_state = user_a_state.copy_with_updates(user_id=self.user_bob.user_id, user_request="Bob's separate analysis")
        reference_checks = []
        if id(user_a_state.context_tracking.get('financial_model')) == id(user_b_state.context_tracking.get('financial_model')):
            reference_checks.append('financial_model context_tracking shared')
            reference_leakage_detected = True
        if id(user_a_state.quality_metrics.get('business_intelligence')) == id(user_b_state.quality_metrics.get('business_intelligence')):
            reference_checks.append('business_intelligence quality_metrics shared')
            reference_leakage_detected = True
        if reference_leakage_detected:
            user_a_state.context_tracking['financial_model']['profit_projections']['2024'] = 50000000
            user_a_state.context_tracking['financial_model']['acquisition_targets'].append('SecretTarget')
            bob_financial_model = user_b_state.context_tracking.get('financial_model', {})
            if bob_financial_model.get('profit_projections', {}).get('2024') == 50000000 or 'SecretTarget' in bob_financial_model.get('acquisition_targets', []):
                reference_checks.append("Alice's updates automatically appear in Bob's state")
                reference_leakage_detected = True
        if user_b_state.context_tracking.get('financial_model'):
            user_b_state.context_tracking['financial_model']['malicious_data'] = 'Bob_inserted_malware'
            alice_financial_model = user_a_state.context_tracking.get('financial_model', {})
            if 'Bob_inserted_malware' in str(alice_financial_model):
                reference_checks.append("Bob's malicious data appears in Alice's state")
                reference_leakage_detected = True
        if reference_leakage_detected:
            leakage_evidence = {'shared_references_detected': reference_checks, 'alice_state_id': id(user_a_state), 'bob_state_id': id(user_b_state), 'financial_model_alice_id': id(user_a_state.context_tracking.get('financial_model', {})), 'financial_model_bob_id': id(user_b_state.context_tracking.get('financial_model', {})), 'alice_contaminated_by_bob': 'Bob_inserted_malware' in str(user_a_state.context_tracking), 'bob_has_alice_updates': user_b_state.context_tracking.get('financial_model', {}).get('profit_projections', {}).get('2024') == 50000000}
            self.security_violations.append({'type': 'deep_copy_memory_reference_leakage', 'severity': 'CRITICAL', 'evidence': leakage_evidence, 'business_impact': 'Financial projections and acquisition targets exposed across users'})
        assert not reference_leakage_detected, f" ALERT:  CRITICAL SECURITY VULNERABILITY: Memory reference leakage in copy operations! Alice's financial projections, acquisition targets, and business intelligence share memory references with Bob's state, allowing bidirectional contamination. Reference checks failed: {reference_checks}. Evidence: {leakage_evidence}. This enables sophisticated attacks and data corruption!"

    async def test_agent_metadata_cross_contamination(self):
        """
        CRITICAL VULNERABILITY: Agent metadata objects contaminate across users.
        
        This test proves that AgentMetadata objects can be shared or cross-contaminate
        between different users' DeepAgentState instances.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        metadata_contamination_detected = False
        contamination_details = {}
        alice_state = DeepAgentState(user_id=self.user_alice.user_id, user_request="Alice's sensitive compliance analysis")
        alice_state.metadata.custom_fields.update({'compliance_violations': ['SOX_violation_2024_Q1', 'GDPR_breach_incident_47'], 'regulatory_fines': {'SEC': 2500000, 'GDPR': 500000}, 'internal_audit_findings': ['financial_misstatement', 'data_privacy_breach'], 'alice_personal_pii': {'home_address': '123 Confidential St, Private City, CA', 'phone': '+1-555-PRIVATE', 'emergency_contact': "Alice's Mother - 555-FAMILY"}})
        alice_state.metadata.execution_context.update({'alice_session_details': {'ip_address': '192.168.1.100', 'browser': 'Chrome/Private', 'location': "Alice's Home Office"}, 'authentication_details': {'login_time': '2024-01-15 09:30:00', 'mfa_token': 'alice_mfa_token_abc123', 'session_duration': '8 hours'}})
        bob_state = DeepAgentState(user_id=self.user_bob.user_id, user_request="Bob's routine business analysis")
        metadata_sharing_checks = []
        if id(alice_state.metadata) == id(bob_state.metadata):
            metadata_sharing_checks.append('Root metadata object shared')
            metadata_contamination_detected = True
        if id(alice_state.metadata.custom_fields) == id(bob_state.metadata.custom_fields):
            metadata_sharing_checks.append('custom_fields dict shared')
            metadata_contamination_detected = True
        if id(alice_state.metadata.execution_context) == id(bob_state.metadata.execution_context):
            metadata_sharing_checks.append('execution_context dict shared')
            metadata_contamination_detected = True
        bob_metadata_str = str(bob_state.metadata.model_dump())
        alice_contamination_found = []
        for violation in ['SOX_violation_2024_Q1', 'GDPR_breach_incident_47']:
            if violation in bob_metadata_str:
                alice_contamination_found.append(f"Alice's compliance violation: {violation}")
                metadata_contamination_detected = True
        if '2500000' in bob_metadata_str and 'SEC' in bob_metadata_str:
            alice_contamination_found.append("Alice's SEC fine amount")
            metadata_contamination_detected = True
        if '123 Confidential St' in bob_metadata_str:
            alice_contamination_found.append("Alice's home address")
            metadata_contamination_detected = True
        if '555-PRIVATE' in bob_metadata_str:
            alice_contamination_found.append("Alice's private phone number")
            metadata_contamination_detected = True
        if '192.168.1.100' in bob_metadata_str:
            alice_contamination_found.append("Alice's IP address")
            metadata_contamination_detected = True
        if 'alice_mfa_token_abc123' in bob_metadata_str:
            alice_contamination_found.append("Alice's MFA token")
            metadata_contamination_detected = True
        bob_state.metadata.custom_fields['bob_malicious_injection'] = "I can see Alice's data!"
        alice_metadata_str = str(alice_state.metadata.model_dump())
        if "I can see Alice's data!" in alice_metadata_str:
            alice_contamination_found.append("Bob's injection appears in Alice's metadata")
            metadata_contamination_detected = True
        if metadata_contamination_detected:
            contamination_details = {'metadata_sharing_checks': metadata_sharing_checks, 'alice_contamination_in_bob': alice_contamination_found, 'alice_metadata_id': id(alice_state.metadata), 'bob_metadata_id': id(bob_state.metadata), 'custom_fields_shared': id(alice_state.metadata.custom_fields) == id(bob_state.metadata.custom_fields), 'execution_context_shared': id(alice_state.metadata.execution_context) == id(bob_state.metadata.execution_context), 'bob_can_modify_alice_metadata': "I can see Alice's data!" in alice_metadata_str, 'contaminated_data_preview': bob_metadata_str[:300] + '...'}
            self.security_violations.append({'type': 'agent_metadata_cross_contamination', 'severity': 'CRITICAL', 'evidence': contamination_details, 'business_impact': 'Compliance violations, regulatory fines, and personal PII exposed'})
        assert not metadata_contamination_detected, f" ALERT:  CRITICAL SECURITY VULNERABILITY: AgentMetadata cross-contamination detected! Alice's compliance violations, regulatory fines, personal PII, and MFA tokens are accessible in Bob's metadata. Bob can also inject malicious data into Alice's metadata. Contamination found: {alice_contamination_found}. Sharing checks: {metadata_sharing_checks}. Details: {contamination_details}. This represents a severe breach of user data isolation!"

    def teardown_method(self, method=None):
        """Clean up and report security violations found."""
        super().teardown_method(method)
        if self.security_violations:
            self.test_logger.critical(f" ALERT:  SECURITY VULNERABILITY SUMMARY: {len(self.security_violations)} critical user isolation failures detected in DeepAgentState. Violations: {[v['type'] for v in self.security_violations]}. These tests prove that DeepAgentState creates severe multi-user data leakage risks affecting $500K+ ARR and enterprise compliance requirements.")
            vulnerability_report = {'test_class': 'TestDeepAgentStateUserIsolationVulnerability', 'total_violations': len(self.security_violations), 'violation_types': [v['type'] for v in self.security_violations], 'severity_breakdown': {'CRITICAL': len([v for v in self.security_violations if v['severity'] == 'CRITICAL']), 'HIGH': len([v for v in self.security_violations if v['severity'] == 'HIGH']), 'MEDIUM': len([v for v in self.security_violations if v['severity'] == 'MEDIUM'])}, 'business_impact_summary': {'financial_data_exposure': True, 'api_keys_compromised': True, 'session_tokens_leaked': True, 'private_messages_exposed': True, 'compliance_violations_visible': True, 'cross_user_contamination': True}, 'detailed_violations': self.security_violations, 'recommendation': 'IMMEDIATE MIGRATION REQUIRED: Replace DeepAgentState with UserExecutionContext to prevent catastrophic data breaches in multi-user environments.'}
            self.test_logger.critical(f'Detailed vulnerability report: {vulnerability_report}')
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')