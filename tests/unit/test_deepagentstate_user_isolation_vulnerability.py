"""
Unit Tests for DeepAgentState User Isolation Vulnerability - Issue #271

CRITICAL SECURITY VULNERABILITY: DeepAgentState User Isolation Failures

This test suite demonstrates specific multi-user isolation failures in DeepAgentState
that allow User A's data to contaminate User B's execution context, creating severe
data leakage security risks.

Business Value Justification (BVJ):
- Segment: ALL (Free â†’ Enterprise) - affects every user tier  
- Business Goal: Prevent catastrophic data breaches between users
- Value Impact: Protects $500K+ ARR from user data exposure lawsuits
- Revenue Impact: Prevents enterprise contract cancellations due to security violations

TEST STRATEGY:
These tests are designed to FAIL initially, proving the vulnerability exists.
After migration to UserExecutionContext, these tests should PASS, proving the fix.

VULNERABILITY PATTERNS TESTED:
1. Shared global state contamination between users
2. Memory reference sharing in concurrent scenarios  
3. Agent state persistence across user sessions
4. Cross-user data leakage in execution contexts
5. Mutable default sharing between user instances

Expected Results:
- BEFORE FIX: Tests FAIL demonstrating cross-user contamination
- AFTER FIX: Tests PASS proving user isolation works
"""

import pytest
import asyncio
import threading
import time
import uuid
import copy
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, Any, List, Set, Optional
from dataclasses import dataclass
from unittest.mock import Mock, patch, MagicMock

from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.agents.state import DeepAgentState
from netra_backend.app.services.user_execution_context import UserExecutionContext
from netra_backend.app.schemas.agent_models import AgentMetadata
from shared.types.core_types import UserID, ThreadID, RunID


@dataclass
class UserTestData:
    """Test data for user isolation scenarios."""
    user_id: str
    username: str
    sensitive_data: Dict[str, Any]
    api_keys: List[str]
    session_tokens: List[str]
    private_messages: List[str]
    financial_data: Dict[str, Any]


class TestDeepAgentStateUserIsolationVulnerability(SSotAsyncTestCase):
    """
    Unit tests demonstrating DeepAgentState user isolation vulnerabilities.
    
    These tests prove that DeepAgentState allows User A's sensitive data to leak
    into User B's execution context, creating severe security vulnerabilities.
    """
    
    def setup_method(self, method=None):
        """Set up test environment with multiple users' sensitive data."""
        super().setup_method(method)
        
        # Create realistic user test data with sensitive information
        self.user_alice = UserTestData(
            user_id="alice_user_12345",
            username="alice_enterprise", 
            sensitive_data={
                "ssn": "111-22-3333",
                "credit_score": 750,
                "salary": 150000,
                "medical_conditions": ["diabetes", "hypertension"]
            },
            api_keys=[
                "sk-alice-openai-key-abcdef123456",
                "alice-stripe-key-sk_test_789xyz", 
                "alice-aws-access-AKIA123456789"
            ],
            session_tokens=[
                "alice_session_token_abc123def456",
                "alice_jwt_eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9"
            ],
            private_messages=[
                "Alice's confidential merger discussion with BoardCorp",
                "Alice's personal therapy session notes",
                "Alice's competitor analysis for ProductX"
            ],
            financial_data={
                "bank_account": "12345678901234",
                "routing": "021000021", 
                "investment_portfolio": {"TSLA": 1000, "NVDA": 500}
            }
        )
        
        self.user_bob = UserTestData(
            user_id="bob_user_67890",
            username="bob_startup",
            sensitive_data={
                "ssn": "444-55-6666", 
                "credit_score": 680,
                "salary": 95000,
                "medical_conditions": ["anxiety", "asthma"]
            },
            api_keys=[
                "sk-bob-openai-key-xyz789uvw",
                "bob-stripe-key-sk_live_456def",
                "bob-gcp-service-account-key-json-data"
            ],
            session_tokens=[
                "bob_session_token_xyz789uvw012",
                "bob_jwt_eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9"
            ],
            private_messages=[
                "Bob's stealth mode startup pitch to VentureCapital",
                "Bob's relationship counseling session transcript",
                "Bob's competitive intelligence on Alice's company"
            ],
            financial_data={
                "bank_account": "98765432109876",
                "routing": "321000321",
                "investment_portfolio": {"AAPL": 200, "MSFT": 300}
            }
        )
        
        # Track security violations found during testing
        self.security_violations = []
        self.cross_contamination_evidence = {}
        
    async def test_concurrent_user_state_contamination(self):
        """
        CRITICAL VULNERABILITY: Concurrent users contaminate each other's DeepAgentState.
        
        This test proves that when multiple users create DeepAgentState instances
        concurrently, their sensitive data can leak into each other's contexts.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        contamination_detected = False
        contamination_details = {}
        
        def create_alice_state():
            """Create Alice's state with her sensitive data."""
            alice_state = DeepAgentState(
                user_id=self.user_alice.user_id,
                user_request="Alice's confidential analysis request",
                chat_thread_id=f"alice_thread_{uuid.uuid4()}",
                run_id=f"alice_run_{uuid.uuid4()}"
            )
            
            # Add Alice's sensitive data
            alice_state.metadata.custom_fields.update({
                "user_ssn": self.user_alice.sensitive_data["ssn"],
                "api_keys": self.user_alice.api_keys,
                "session_token": self.user_alice.session_tokens[0],
                "private_data": self.user_alice.financial_data
            })
            
            alice_state.context_tracking.update({
                "user_messages": self.user_alice.private_messages,
                "medical_info": self.user_alice.sensitive_data["medical_conditions"],
                "financial_portfolio": self.user_alice.financial_data["investment_portfolio"]
            })
            
            return alice_state
            
        def create_bob_state():
            """Create Bob's state with his sensitive data."""
            bob_state = DeepAgentState(
                user_id=self.user_bob.user_id,
                user_request="Bob's startup analysis request",
                chat_thread_id=f"bob_thread_{uuid.uuid4()}",
                run_id=f"bob_run_{uuid.uuid4()}"
            )
            
            # Add Bob's sensitive data
            bob_state.metadata.custom_fields.update({
                "user_ssn": self.user_bob.sensitive_data["ssn"], 
                "api_keys": self.user_bob.api_keys,
                "session_token": self.user_bob.session_tokens[0],
                "private_data": self.user_bob.financial_data
            })
            
            bob_state.context_tracking.update({
                "user_messages": self.user_bob.private_messages,
                "medical_info": self.user_bob.sensitive_data["medical_conditions"],
                "financial_portfolio": self.user_bob.financial_data["investment_portfolio"]
            })
            
            return bob_state
        
        # Execute concurrent state creation (simulating real multi-user scenario)
        with ThreadPoolExecutor(max_workers=4) as executor:
            # Submit multiple concurrent operations for each user
            futures = []
            
            # Alice creates multiple states concurrently
            for i in range(3):
                futures.append(executor.submit(create_alice_state))
                
            # Bob creates multiple states concurrently  
            for i in range(3):
                futures.append(executor.submit(create_bob_state))
            
            # Collect results
            alice_states = []
            bob_states = []
            
            for future in as_completed(futures):
                try:
                    state = future.result()
                    if state.user_id == self.user_alice.user_id:
                        alice_states.append(state)
                    else:
                        bob_states.append(state)
                except Exception as e:
                    self.test_logger.error(f"State creation failed: {e}")
        
        # Check for cross-user contamination
        for alice_state in alice_states:
            alice_dict = alice_state.to_dict()
            alice_str = str(alice_dict)
            
            # Check if Bob's sensitive data appears in Alice's state
            bob_contamination = []
            
            if self.user_bob.sensitive_data["ssn"] in alice_str:
                bob_contamination.append("Bob's SSN in Alice's state")
                contamination_detected = True
                
            for bob_api_key in self.user_bob.api_keys:
                if bob_api_key in alice_str:
                    bob_contamination.append(f"Bob's API key ({bob_api_key[:20]}...) in Alice's state")
                    contamination_detected = True
                    
            for bob_message in self.user_bob.private_messages:
                if bob_message in alice_str:
                    bob_contamination.append(f"Bob's private message in Alice's state")
                    contamination_detected = True
            
            if bob_contamination:
                contamination_details[f"alice_state_{id(alice_state)}"] = bob_contamination
        
        # Check Bob's states for Alice's data
        for bob_state in bob_states:
            bob_dict = bob_state.to_dict()
            bob_str = str(bob_dict)
            
            # Check if Alice's sensitive data appears in Bob's state
            alice_contamination = []
            
            if self.user_alice.sensitive_data["ssn"] in bob_str:
                alice_contamination.append("Alice's SSN in Bob's state")
                contamination_detected = True
                
            for alice_api_key in self.user_alice.api_keys:
                if alice_api_key in bob_str:
                    alice_contamination.append(f"Alice's API key ({alice_api_key[:20]}...) in Bob's state")
                    contamination_detected = True
                    
            for alice_message in self.user_alice.private_messages:
                if alice_message in bob_str:
                    alice_contamination.append(f"Alice's private message in Bob's state")  
                    contamination_detected = True
            
            if alice_contamination:
                contamination_details[f"bob_state_{id(bob_state)}"] = alice_contamination
        
        # Record security violation if found
        if contamination_detected:
            self.security_violations.append({
                "type": "concurrent_user_state_contamination",
                "severity": "CRITICAL",
                "users_affected": ["alice", "bob"],
                "contamination_details": contamination_details,
                "alice_states_count": len(alice_states),
                "bob_states_count": len(bob_states)
            })
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        assert not contamination_detected, (
            f"ðŸš¨ CRITICAL SECURITY VULNERABILITY: Concurrent user state contamination detected! "
            f"Users' sensitive data leaked into each other's DeepAgentState instances. "
            f"Alice states: {len(alice_states)}, Bob states: {len(bob_states)}. "
            f"Contamination details: {contamination_details}. "
            f"This proves DeepAgentState is NOT safe for multi-user environments!"
        )
        
    async def test_mutable_defaults_cross_user_pollution(self):
        """
        CRITICAL VULNERABILITY: Mutable default arguments cause cross-user data pollution.
        
        This test proves that DeepAgentState's mutable default arguments (like lists and dicts)
        are shared between all instances, causing User A's data to appear in User B's state.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        pollution_detected = False
        pollution_evidence = {}
        
        # Create User A's state and add sensitive data to mutable defaults
        user_a_state = DeepAgentState(
            user_id=self.user_alice.user_id,
            user_request=self.user_alice.private_messages[0]  # Confidential data
        )
        
        # Add sensitive data to mutable default fields
        user_a_state.messages.append({
            "type": "private_financial_data",
            "content": f"Alice's bank account: {self.user_alice.financial_data['bank_account']}",
            "api_key": self.user_alice.api_keys[0],
            "medical_data": self.user_alice.sensitive_data["medical_conditions"]
        })
        
        user_a_state.quality_metrics.update({
            "alice_credit_score": self.user_alice.sensitive_data["credit_score"],
            "alice_salary": self.user_alice.sensitive_data["salary"],
            "alice_private_keys": self.user_alice.api_keys
        })
        
        user_a_state.context_tracking.update({
            "alice_session_token": self.user_alice.session_tokens[0],
            "alice_confidential_notes": self.user_alice.private_messages,
            "alice_investment_data": self.user_alice.financial_data["investment_portfolio"]
        })
        
        # Create User B's state (should be completely isolated)
        user_b_state = DeepAgentState(
            user_id=self.user_bob.user_id,
            user_request="Bob's completely separate request"
        )
        
        # Check if User A's sensitive data polluted User B's state
        user_b_dict = user_b_state.to_dict()
        user_b_str = str(user_b_dict)
        
        pollution_indicators = []
        
        # Check messages pollution
        if id(user_a_state.messages) == id(user_b_state.messages):
            pollution_indicators.append("Shared messages list reference")
            pollution_detected = True
            
        # Check for Alice's sensitive data in Bob's messages
        for message in user_b_state.messages:
            message_str = str(message)
            if (self.user_alice.financial_data['bank_account'] in message_str or
                self.user_alice.api_keys[0] in message_str):
                pollution_indicators.append("Alice's financial data in Bob's messages")
                pollution_detected = True
        
        # Check quality_metrics pollution
        if id(user_a_state.quality_metrics) == id(user_b_state.quality_metrics):
            pollution_indicators.append("Shared quality_metrics dict reference")
            pollution_detected = True
            
        # Check for Alice's data in Bob's quality metrics
        for key, value in user_b_state.quality_metrics.items():
            if "alice" in str(key).lower() or str(self.user_alice.sensitive_data["credit_score"]) in str(value):
                pollution_indicators.append(f"Alice's data in Bob's quality_metrics: {key}")
                pollution_detected = True
        
        # Check context_tracking pollution  
        if id(user_a_state.context_tracking) == id(user_b_state.context_tracking):
            pollution_indicators.append("Shared context_tracking dict reference")
            pollution_detected = True
            
        # Check for Alice's session token in Bob's context
        if self.user_alice.session_tokens[0] in user_b_str:
            pollution_indicators.append("Alice's session token in Bob's context")
            pollution_detected = True
        
        # Check for Alice's private messages in Bob's context
        for alice_message in self.user_alice.private_messages:
            if alice_message in user_b_str:
                pollution_indicators.append("Alice's private message in Bob's state")
                pollution_detected = True
        
        # Check for Alice's investment data in Bob's state
        for stock, shares in self.user_alice.financial_data["investment_portfolio"].items():
            if stock in user_b_str and str(shares) in user_b_str:
                pollution_indicators.append(f"Alice's investment data ({stock}: {shares}) in Bob's state")
                pollution_detected = True
        
        if pollution_detected:
            pollution_evidence = {
                "pollution_indicators": pollution_indicators,
                "user_a_state_id": id(user_a_state),
                "user_b_state_id": id(user_b_state),
                "messages_shared": id(user_a_state.messages) == id(user_b_state.messages),
                "quality_metrics_shared": id(user_a_state.quality_metrics) == id(user_b_state.quality_metrics),
                "context_tracking_shared": id(user_a_state.context_tracking) == id(user_b_state.context_tracking),
                "user_b_contaminated_data": user_b_str[:500] + "..." if len(user_b_str) > 500 else user_b_str
            }
            
            self.security_violations.append({
                "type": "mutable_defaults_cross_user_pollution",
                "severity": "CRITICAL",
                "evidence": pollution_evidence
            })
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        assert not pollution_detected, (
            f"ðŸš¨ CRITICAL SECURITY VULNERABILITY: Mutable default arguments cause cross-user pollution! "
            f"Alice's sensitive data (SSN, bank account, API keys, private messages) leaked into Bob's state. "
            f"Pollution indicators: {pollution_indicators}. "
            f"Evidence: {pollution_evidence}. "
            f"This proves DeepAgentState creates severe data leakage risks!"
        )
        
    async def test_agent_state_global_registry_contamination(self):
        """
        CRITICAL VULNERABILITY: Global state registry allows cross-user data access.
        
        This test proves that DeepAgentState instances can be accessed across users
        through global registries or shared references, violating user isolation.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        # Simulate global registry that might exist in production
        global_state_registry = {}
        
        contamination_detected = False
        contamination_proof = {}
        
        # User A creates state and registers it globally (simulating production pattern)
        alice_state = DeepAgentState(
            user_id=self.user_alice.user_id,
            user_request="Alice's ultra-sensitive merger analysis",
            chat_thread_id=f"alice_secure_{uuid.uuid4()}",
            run_id=f"alice_run_{uuid.uuid4()}"
        )
        
        # Alice adds extremely sensitive data
        alice_state.metadata.custom_fields.update({
            "merger_target": "SecretCorp acquisition for $2.5B",
            "inside_information": "Q4 earnings will be 300% above expectations",
            "board_decision": "Firing CEO next month, stock will crash",
            "alice_personal_trades": {"SCRT": 10000, "insider_buy_date": "2024-01-15"}
        })
        
        alice_state.context_tracking.update({
            "confidential_documents": ["merger_agreement_draft.pdf", "insider_trading_plan.xlsx"],
            "private_communications": self.user_alice.private_messages,
            "authentication_tokens": self.user_alice.session_tokens + self.user_alice.api_keys
        })
        
        # Register Alice's state globally (common pattern in agent frameworks)
        global_state_registry[alice_state.user_id] = alice_state
        global_state_registry[alice_state.thread_id] = alice_state  # Also by thread_id
        global_state_registry[alice_state.run_id] = alice_state     # Also by run_id
        
        # User B creates their own state
        bob_state = DeepAgentState(
            user_id=self.user_bob.user_id,
            user_request="Bob's routine competitor analysis", 
            chat_thread_id=f"bob_normal_{uuid.uuid4()}",
            run_id=f"bob_run_{uuid.uuid4()}"
        )
        
        # Bob somehow accesses global registry (through bug, misconfiguration, etc.)
        # This simulates real-world scenarios where global state is accidentally accessible
        accessible_states = []
        
        # Check if Bob can access Alice's sensitive state through various methods
        try:
            # Method 1: Direct user_id lookup (should fail in secure system)
            if self.user_alice.user_id in global_state_registry:
                alice_state_via_userid = global_state_registry[self.user_alice.user_id]
                accessible_states.append(("user_id_lookup", alice_state_via_userid))
                contamination_detected = True
                
        except Exception as e:
            pass
        
        try:
            # Method 2: Thread_id iteration (common attack vector)
            for key, state in global_state_registry.items():
                if hasattr(state, 'user_id') and state.user_id == self.user_alice.user_id:
                    accessible_states.append(("thread_iteration", state))
                    contamination_detected = True
                    
        except Exception as e:
            pass
        
        try:
            # Method 3: Memory reference sharing (if objects are shared)
            if hasattr(alice_state, 'metadata') and hasattr(bob_state, 'metadata'):
                if id(alice_state.metadata) == id(bob_state.metadata):
                    accessible_states.append(("shared_metadata_reference", alice_state))
                    contamination_detected = True
                    
        except Exception as e:
            pass
        
        # Check what sensitive data Bob can access
        if contamination_detected:
            accessed_sensitive_data = []
            
            for access_method, accessed_state in accessible_states:
                state_dict = accessed_state.to_dict()
                state_str = str(state_dict)
                
                # Check for Alice's insider information
                if "SecretCorp acquisition" in state_str:
                    accessed_sensitive_data.append("Alice's merger insider information")
                    
                if "Q4 earnings will be 300% above expectations" in state_str:
                    accessed_sensitive_data.append("Alice's earnings insider information")
                    
                if "Firing CEO next month" in state_str:
                    accessed_sensitive_data.append("Alice's executive decision insider information")
                
                # Check for Alice's authentication tokens
                for token in self.user_alice.session_tokens + self.user_alice.api_keys:
                    if token in state_str:
                        accessed_sensitive_data.append(f"Alice's authentication token ({token[:20]}...)")
                
                # Check for Alice's private documents
                if "merger_agreement_draft.pdf" in state_str:
                    accessed_sensitive_data.append("Alice's confidential merger documents")
                    
                if "insider_trading_plan.xlsx" in state_str:
                    accessed_sensitive_data.append("Alice's insider trading plan")
            
            contamination_proof = {
                "access_methods_successful": [method for method, _ in accessible_states],
                "accessed_sensitive_data": accessed_sensitive_data,
                "total_states_accessible": len(accessible_states),
                "alice_user_id": self.user_alice.user_id,
                "bob_user_id": self.user_bob.user_id,
                "global_registry_keys": list(global_state_registry.keys())
            }
            
            self.security_violations.append({
                "type": "agent_state_global_registry_contamination",
                "severity": "CRITICAL",
                "evidence": contamination_proof,
                "business_impact": "CATASTROPHIC - Insider trading information exposed"
            })
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        assert not contamination_detected, (
            f"ðŸš¨ CRITICAL SECURITY VULNERABILITY: Global state registry enables cross-user access! "
            f"Bob can access Alice's insider trading information, merger details, and authentication tokens. "
            f"Access methods successful: {[method for method, _ in accessible_states]}. "
            f"Sensitive data exposed: {contamination_proof.get('accessed_sensitive_data', [])}. "
            f"This represents a CATASTROPHIC security breach in multi-user environments!"
        )
    
    async def test_deep_copy_memory_reference_leakage(self):
        """
        CRITICAL VULNERABILITY: Deep copy operations may preserve memory references.
        
        This test proves that operations like copy_with_updates() and merge_from()
        may not properly isolate memory references, allowing cross-user contamination.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        reference_leakage_detected = False
        leakage_evidence = {}
        
        # Create User A state with nested sensitive objects
        user_a_state = DeepAgentState(
            user_id=self.user_alice.user_id,
            user_request="Alice's sensitive financial modeling"
        )
        
        # Create nested objects with sensitive data
        sensitive_financial_model = {
            "profit_projections": {"2024": 10000000, "2025": 25000000},
            "acquisition_targets": ["StartupX", "TechCorp", "DataInc"],
            "confidential_partnerships": {
                "partner_a": {"revenue_share": 0.3, "contract_value": 5000000},
                "partner_b": {"revenue_share": 0.4, "contract_value": 8000000}
            },
            "insider_metrics": {
                "customer_churn": 0.02,
                "burn_rate": 500000,
                "runway_months": 24
            }
        }
        
        # Add to Alice's state  
        user_a_state.context_tracking["financial_model"] = sensitive_financial_model
        user_a_state.quality_metrics["business_intelligence"] = sensitive_financial_model
        
        # Create User B state through copy operations (common pattern)
        user_b_state = user_a_state.copy_with_updates(
            user_id=self.user_bob.user_id,
            user_request="Bob's separate analysis"
        )
        
        # Check for memory reference sharing
        reference_checks = []
        
        # Check if nested objects share memory references
        if (id(user_a_state.context_tracking.get("financial_model")) == 
            id(user_b_state.context_tracking.get("financial_model"))):
            reference_checks.append("financial_model context_tracking shared")
            reference_leakage_detected = True
            
        if (id(user_a_state.quality_metrics.get("business_intelligence")) ==
            id(user_b_state.quality_metrics.get("business_intelligence"))):
            reference_checks.append("business_intelligence quality_metrics shared") 
            reference_leakage_detected = True
        
        # Test practical impact: modify Alice's data and see if it affects Bob
        if reference_leakage_detected:
            # Alice updates her sensitive financial projections
            user_a_state.context_tracking["financial_model"]["profit_projections"]["2024"] = 50000000
            user_a_state.context_tracking["financial_model"]["acquisition_targets"].append("SecretTarget")
            
            # Check if Bob's state was automatically updated (proving shared references)
            bob_financial_model = user_b_state.context_tracking.get("financial_model", {})
            
            if (bob_financial_model.get("profit_projections", {}).get("2024") == 50000000 or
                "SecretTarget" in bob_financial_model.get("acquisition_targets", [])):
                reference_checks.append("Alice's updates automatically appear in Bob's state")
                reference_leakage_detected = True
        
        # Test reverse contamination: Bob modifies data and it affects Alice
        if user_b_state.context_tracking.get("financial_model"):
            # Bob adds malicious data
            user_b_state.context_tracking["financial_model"]["malicious_data"] = "Bob_inserted_malware"
            
            # Check if Alice's state is contaminated
            alice_financial_model = user_a_state.context_tracking.get("financial_model", {})
            if "Bob_inserted_malware" in str(alice_financial_model):
                reference_checks.append("Bob's malicious data appears in Alice's state")
                reference_leakage_detected = True
        
        if reference_leakage_detected:
            leakage_evidence = {
                "shared_references_detected": reference_checks,
                "alice_state_id": id(user_a_state),
                "bob_state_id": id(user_b_state),
                "financial_model_alice_id": id(user_a_state.context_tracking.get("financial_model", {})),
                "financial_model_bob_id": id(user_b_state.context_tracking.get("financial_model", {})),
                "alice_contaminated_by_bob": "Bob_inserted_malware" in str(user_a_state.context_tracking),
                "bob_has_alice_updates": user_b_state.context_tracking.get("financial_model", {}).get("profit_projections", {}).get("2024") == 50000000
            }
            
            self.security_violations.append({
                "type": "deep_copy_memory_reference_leakage",
                "severity": "CRITICAL",
                "evidence": leakage_evidence,
                "business_impact": "Financial projections and acquisition targets exposed across users"
            })
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        assert not reference_leakage_detected, (
            f"ðŸš¨ CRITICAL SECURITY VULNERABILITY: Memory reference leakage in copy operations! "
            f"Alice's financial projections, acquisition targets, and business intelligence "
            f"share memory references with Bob's state, allowing bidirectional contamination. "
            f"Reference checks failed: {reference_checks}. "
            f"Evidence: {leakage_evidence}. "
            f"This enables sophisticated attacks and data corruption!"
        )
    
    async def test_agent_metadata_cross_contamination(self):
        """
        CRITICAL VULNERABILITY: Agent metadata objects contaminate across users.
        
        This test proves that AgentMetadata objects can be shared or cross-contaminate
        between different users' DeepAgentState instances.
        
        EXPECTED: This test should FAIL, proving the vulnerability exists.
        """
        metadata_contamination_detected = False
        contamination_details = {}
        
        # Create Alice's state with sensitive metadata
        alice_state = DeepAgentState(
            user_id=self.user_alice.user_id,
            user_request="Alice's sensitive compliance analysis"
        )
        
        # Add Alice's sensitive metadata
        alice_state.metadata.custom_fields.update({
            "compliance_violations": ["SOX_violation_2024_Q1", "GDPR_breach_incident_47"],
            "regulatory_fines": {"SEC": 2500000, "GDPR": 500000},
            "internal_audit_findings": ["financial_misstatement", "data_privacy_breach"],
            "alice_personal_pii": {
                "home_address": "123 Confidential St, Private City, CA",
                "phone": "+1-555-PRIVATE",
                "emergency_contact": "Alice's Mother - 555-FAMILY"
            }
        })
        
        alice_state.metadata.execution_context.update({
            "alice_session_details": {
                "ip_address": "192.168.1.100", 
                "browser": "Chrome/Private",
                "location": "Alice's Home Office"
            },
            "authentication_details": {
                "login_time": "2024-01-15 09:30:00",
                "mfa_token": "alice_mfa_token_abc123",
                "session_duration": "8 hours"
            }
        })
        
        # Create Bob's state  
        bob_state = DeepAgentState(
            user_id=self.user_bob.user_id,
            user_request="Bob's routine business analysis"
        )
        
        # Check for metadata object sharing
        metadata_sharing_checks = []
        
        if id(alice_state.metadata) == id(bob_state.metadata):
            metadata_sharing_checks.append("Root metadata object shared")
            metadata_contamination_detected = True
            
        if id(alice_state.metadata.custom_fields) == id(bob_state.metadata.custom_fields):
            metadata_sharing_checks.append("custom_fields dict shared")
            metadata_contamination_detected = True
            
        if id(alice_state.metadata.execution_context) == id(bob_state.metadata.execution_context):
            metadata_sharing_checks.append("execution_context dict shared")
            metadata_contamination_detected = True
        
        # Check for actual data contamination
        bob_metadata_str = str(bob_state.metadata.model_dump())
        
        alice_contamination_found = []
        
        # Check for Alice's compliance violations in Bob's metadata
        for violation in ["SOX_violation_2024_Q1", "GDPR_breach_incident_47"]:
            if violation in bob_metadata_str:
                alice_contamination_found.append(f"Alice's compliance violation: {violation}")
                metadata_contamination_detected = True
        
        # Check for Alice's regulatory fines in Bob's metadata
        if "2500000" in bob_metadata_str and "SEC" in bob_metadata_str:
            alice_contamination_found.append("Alice's SEC fine amount")
            metadata_contamination_detected = True
            
        # Check for Alice's personal PII in Bob's metadata
        if "123 Confidential St" in bob_metadata_str:
            alice_contamination_found.append("Alice's home address")
            metadata_contamination_detected = True
            
        if "555-PRIVATE" in bob_metadata_str:
            alice_contamination_found.append("Alice's private phone number")
            metadata_contamination_detected = True
            
        # Check for Alice's session details in Bob's metadata
        if "192.168.1.100" in bob_metadata_str:
            alice_contamination_found.append("Alice's IP address")
            metadata_contamination_detected = True
            
        if "alice_mfa_token_abc123" in bob_metadata_str:
            alice_contamination_found.append("Alice's MFA token")
            metadata_contamination_detected = True
        
        # Test reverse contamination - Bob adds data, check if it appears in Alice
        bob_state.metadata.custom_fields["bob_malicious_injection"] = "I can see Alice's data!"
        
        alice_metadata_str = str(alice_state.metadata.model_dump())
        if "I can see Alice's data!" in alice_metadata_str:
            alice_contamination_found.append("Bob's injection appears in Alice's metadata")
            metadata_contamination_detected = True
        
        if metadata_contamination_detected:
            contamination_details = {
                "metadata_sharing_checks": metadata_sharing_checks,
                "alice_contamination_in_bob": alice_contamination_found,
                "alice_metadata_id": id(alice_state.metadata),
                "bob_metadata_id": id(bob_state.metadata),
                "custom_fields_shared": id(alice_state.metadata.custom_fields) == id(bob_state.metadata.custom_fields),
                "execution_context_shared": id(alice_state.metadata.execution_context) == id(bob_state.metadata.execution_context),
                "bob_can_modify_alice_metadata": "I can see Alice's data!" in alice_metadata_str,
                "contaminated_data_preview": bob_metadata_str[:300] + "..."
            }
            
            self.security_violations.append({
                "type": "agent_metadata_cross_contamination", 
                "severity": "CRITICAL",
                "evidence": contamination_details,
                "business_impact": "Compliance violations, regulatory fines, and personal PII exposed"
            })
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        assert not metadata_contamination_detected, (
            f"ðŸš¨ CRITICAL SECURITY VULNERABILITY: AgentMetadata cross-contamination detected! "
            f"Alice's compliance violations, regulatory fines, personal PII, and MFA tokens "
            f"are accessible in Bob's metadata. Bob can also inject malicious data into Alice's metadata. "
            f"Contamination found: {alice_contamination_found}. "
            f"Sharing checks: {metadata_sharing_checks}. "
            f"Details: {contamination_details}. "
            f"This represents a severe breach of user data isolation!"
        )

    def teardown_method(self, method=None):
        """Clean up and report security violations found."""
        super().teardown_method(method)
        
        if self.security_violations:
            self.test_logger.critical(
                f"ðŸš¨ SECURITY VULNERABILITY SUMMARY: {len(self.security_violations)} "
                f"critical user isolation failures detected in DeepAgentState. "
                f"Violations: {[v['type'] for v in self.security_violations]}. "
                f"These tests prove that DeepAgentState creates severe multi-user data leakage risks "
                f"affecting $500K+ ARR and enterprise compliance requirements."
            )
            
            # Write detailed security report 
            vulnerability_report = {
                "test_class": "TestDeepAgentStateUserIsolationVulnerability",
                "total_violations": len(self.security_violations),
                "violation_types": [v['type'] for v in self.security_violations],
                "severity_breakdown": {
                    "CRITICAL": len([v for v in self.security_violations if v['severity'] == 'CRITICAL']),
                    "HIGH": len([v for v in self.security_violations if v['severity'] == 'HIGH']),
                    "MEDIUM": len([v for v in self.security_violations if v['severity'] == 'MEDIUM'])
                },
                "business_impact_summary": {
                    "financial_data_exposure": True,
                    "api_keys_compromised": True, 
                    "session_tokens_leaked": True,
                    "private_messages_exposed": True,
                    "compliance_violations_visible": True,
                    "cross_user_contamination": True
                },
                "detailed_violations": self.security_violations,
                "recommendation": (
                    "IMMEDIATE MIGRATION REQUIRED: Replace DeepAgentState with UserExecutionContext "
                    "to prevent catastrophic data breaches in multi-user environments."
                )
            }
            
            self.test_logger.critical(f"Detailed vulnerability report: {vulnerability_report}")


if __name__ == '__main__':
    pytest.main([__file__, '-v', '--tb=short', '--disable-warnings'])