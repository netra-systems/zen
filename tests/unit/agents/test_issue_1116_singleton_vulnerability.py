"""
Test Suite: Issue #1116 Singleton Vulnerability - Unit Test Suite
================================================================

PURPOSE: Create FAILING unit tests that prove singleton factory patterns create security vulnerabilities
ISSUE: #1116 - AgentInstanceFactory singleton pattern enables cross-user context contamination
CRITICALITY: $500K+ ARR security risk - enterprise compliance violations

MISSION: These tests MUST FAIL initially to demonstrate the vulnerability exists.
After factory pattern migration, these tests should PASS proving security is fixed.

Business Value: Enterprise/Platform - Complete user isolation for HIPAA/SOC2/SEC compliance
Security Impact: Prevents data leakage between concurrent users in multi-tenant environment

CRITICAL VULNERABILITY SCENARIOS:
1. Singleton factory shares state between different user sessions
2. User context contamination through shared singleton instances  
3. Memory references leak between concurrent user executions
4. WebSocket event routing contamination via singleton state
5. Agent state persistence creates cross-user data exposure

EXPECTED BEHAVIOR:
- BEFORE REMEDIATION: Tests FAIL (proving vulnerabilities exist) 
- AFTER REMEDIATION: Tests PASS (proving user isolation achieved)

These tests target the root cause of enterprise security violations in our multi-tenant system.
"""

import asyncio
import gc
import sys
import threading
import time
import uuid
import weakref
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Any, Dict, List, Optional, Set, Tuple
from unittest.mock import AsyncMock, Mock, patch
from datetime import datetime, timezone

import pytest

from test_framework.ssot.base_test_case import SSotAsyncTestCase
from test_framework.ssot.mock_factory import SSotMockFactory


@pytest.mark.unit
class TestIssue1116SingletonVulnerability(SSotAsyncTestCase):
    """
    Unit test suite proving singleton pattern creates critical security vulnerabilities.
    
    These tests demonstrate Issue #1116 by proving:
    1. Singleton factory creates shared state between users (VIOLATION)
    2. Concurrent sessions contaminate each other via singleton (DATA LEAK)
    3. WebSocket events route to wrong users via shared state (ROUTING ERROR)
    4. Agent context persists between users (PRIVACY VIOLATION)
    5. Memory references create cross-user contamination (SECURITY BREACH)
    
    CRITICAL: These tests are DESIGNED TO FAIL until singleton migration is complete.
    """
    
    def setup_method(self, method):
        """Set up test environment for singleton vulnerability testing."""
        super().setup_method(method)
        self.mock_factory = SSotMockFactory()
        self.user_contexts = {}
        self.shared_state_evidence = {}
        self.contamination_events = []
        
        # Generate test user identities
        self.user_a_id = f"user_a_{uuid.uuid4().hex[:8]}"
        self.user_b_id = f"user_b_{uuid.uuid4().hex[:8]}"
        self.user_c_id = f"user_c_{uuid.uuid4().hex[:8]}"
        
        # Track singleton instances for contamination analysis
        self.singleton_instances = {}
        self.factory_references = set()
        
    def test_singleton_factory_shares_state_between_users_VULNERABILITY(self):
        """
        CRITICAL SECURITY TEST: Prove singleton factory creates shared state vulnerabilities.
        
        This test MUST FAIL initially, proving that:
        1. AgentInstanceFactory uses singleton pattern
        2. Multiple users get the SAME factory instance
        3. Shared factory state contaminates user sessions
        4. User isolation is BROKEN at the factory level
        
        EXPECTED: FAIL (before remediation) - Same factory instance shared
        EXPECTED: PASS (after remediation) - Each user gets isolated factory
        """
        print("\nðŸš¨ TESTING SINGLETON FACTORY STATE SHARING VULNERABILITY...")
        
        # Simulate concurrent user requests to factory
        user_a_factory = None
        user_b_factory = None
        user_c_factory = None
        
        try:
            # Import and create factory instances for different users
            # This should reveal singleton pattern if it exists
            with patch('sys.modules', {}):
                # Force fresh imports to detect singleton sharing
                from netra_backend.app.agents.supervisor.agent_instance_factory import AgentInstanceFactory
                
                # User A gets factory instance
                user_a_factory = AgentInstanceFactory()
                user_a_instance_id = id(user_a_factory)
                
                # User B gets factory instance 
                user_b_factory = AgentInstanceFactory()
                user_b_instance_id = id(user_b_factory)
                
                # User C gets factory instance
                user_c_factory = AgentInstanceFactory()
                user_c_instance_id = id(user_c_factory)
                
                self.singleton_instances['user_a'] = user_a_instance_id
                self.singleton_instances['user_b'] = user_b_instance_id  
                self.singleton_instances['user_c'] = user_c_instance_id
                
        except ImportError as e:
            # If import fails, this may indicate path issues - document for debugging
            self.shared_state_evidence['import_error'] = str(e)
            pytest.fail(f"Cannot import AgentInstanceFactory for testing: {e}")
            
        # VULNERABILITY CHECK: Same instance means singleton pattern
        if user_a_instance_id == user_b_instance_id:
            self.contamination_events.append({
                'type': 'singleton_sharing',
                'users': ['user_a', 'user_b'],
                'shared_instance_id': user_a_instance_id,
                'timestamp': datetime.now(timezone.utc).isoformat()
            })
            
        if user_b_instance_id == user_c_instance_id:
            self.contamination_events.append({
                'type': 'singleton_sharing', 
                'users': ['user_b', 'user_c'],
                'shared_instance_id': user_b_instance_id,
                'timestamp': datetime.now(timezone.utc).isoformat()
            })
            
        # Record evidence of shared state
        self.shared_state_evidence.update({
            'user_a_factory_id': user_a_instance_id,
            'user_b_factory_id': user_b_instance_id,
            'user_c_factory_id': user_c_instance_id,
            'instances_are_identical': user_a_instance_id == user_b_instance_id,
            'contamination_events_count': len(self.contamination_events)
        })
        
        print(f"   User A Factory ID: {user_a_instance_id}")
        print(f"   User B Factory ID: {user_b_instance_id}")  
        print(f"   User C Factory ID: {user_c_instance_id}")
        print(f"   Contamination Events: {len(self.contamination_events)}")
        
        # ASSERTION: This MUST FAIL if singleton pattern exists
        # After remediation, each user should get unique factory instance
        assert user_a_instance_id != user_b_instance_id, \
            f"ðŸš¨ SECURITY VULNERABILITY: Factory singleton detected! " \
            f"User A and User B share same factory instance {user_a_instance_id}. " \
            f"This creates cross-user contamination risk for $500K+ ARR enterprise customers."
            
        assert user_b_instance_id != user_c_instance_id, \
            f"ðŸš¨ SECURITY VULNERABILITY: Factory singleton detected! " \
            f"User B and User C share same factory instance {user_b_instance_id}. " \
            f"This violates user isolation requirements for enterprise compliance."
        
        print("âœ… PASS: Each user gets isolated factory instance (vulnerability fixed)")
    
    def test_concurrent_user_context_contamination_VULNERABILITY(self):
        """
        CRITICAL SECURITY TEST: Prove singleton creates user context contamination.
        
        This test MUST FAIL initially, proving that:
        1. User contexts leak between concurrent sessions via singleton
        2. User A's data appears in User B's execution context  
        3. Shared state creates enterprise compliance violations
        4. Memory references persist between user sessions
        
        EXPECTED: FAIL (before remediation) - Context contamination detected
        EXPECTED: PASS (after remediation) - Perfect user isolation achieved
        """
        print("\nðŸš¨ TESTING CONCURRENT USER CONTEXT CONTAMINATION...")
        
        contamination_detected = False
        context_leak_evidence = {}
        
        def simulate_user_execution(user_id: str, sensitive_data: Dict[str, Any]) -> Dict[str, Any]:
            """Simulate user execution that may contaminate other users via singleton."""
            try:
                # Import factory and create user-specific context
                from netra_backend.app.agents.supervisor.agent_instance_factory import AgentInstanceFactory
                
                factory = AgentInstanceFactory()
                
                # Store user-specific sensitive data in factory/context
                # This simulates how singleton state can leak between users
                if hasattr(factory, '_user_contexts'):
                    factory._user_contexts[user_id] = sensitive_data
                else:
                    # Set attribute to track user context in factory
                    setattr(factory, '_user_contexts', {user_id: sensitive_data})
                
                # Return evidence of what user context contains
                return {
                    'user_id': user_id,
                    'factory_id': id(factory),
                    'sensitive_data': sensitive_data,
                    'other_user_data': getattr(factory, '_user_contexts', {}),
                    'memory_references': [id(v) for v in getattr(factory, '_user_contexts', {}).values()]
                }
                
            except Exception as e:
                return {'user_id': user_id, 'error': str(e), 'factory_id': None}
        
        # Concurrent user executions with sensitive data
        user_a_data = {
            'session_id': f"session_{self.user_a_id}",
            'enterprise_client': 'ACME_HEALTHCARE_HIPAA',
            'patient_data': 'CONFIDENTIAL_PATIENT_123',
            'compliance_level': 'HIPAA_PROTECTED'
        }
        
        user_b_data = {
            'session_id': f"session_{self.user_b_id}",
            'enterprise_client': 'GLOBAL_FINANCE_SOC2', 
            'trading_data': 'CONFIDENTIAL_TRADES_456',
            'compliance_level': 'SOC2_SECURED'
        }
        
        user_c_data = {
            'session_id': f"session_{self.user_c_id}",
            'enterprise_client': 'GOV_AGENCY_SEC',
            'classified_data': 'SECRET_INTELLIGENCE_789',
            'compliance_level': 'SEC_CLASSIFIED'
        }
        
        # Execute concurrent user sessions
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = [
                executor.submit(simulate_user_execution, self.user_a_id, user_a_data),
                executor.submit(simulate_user_execution, self.user_b_id, user_b_data),  
                executor.submit(simulate_user_execution, self.user_c_id, user_c_data)
            ]
            
            results = [future.result() for future in as_completed(futures)]
        
        # Analyze results for contamination evidence
        for result in results:
            user_id = result.get('user_id')
            other_user_data = result.get('other_user_data', {})
            
            # Check if this user can see other users' data
            for other_user_id, other_data in other_user_data.items():
                if other_user_id != user_id:
                    contamination_detected = True
                    self.contamination_events.append({
                        'type': 'context_contamination',
                        'contaminated_user': user_id,
                        'leaked_from_user': other_user_id,
                        'leaked_data_keys': list(other_data.keys()),
                        'severity': 'CRITICAL',
                        'compliance_violation': other_data.get('compliance_level', 'UNKNOWN'),
                        'timestamp': datetime.now(timezone.utc).isoformat()
                    })
            
            context_leak_evidence[user_id] = {
                'can_access_other_users': len([uid for uid in other_user_data.keys() if uid != user_id]),
                'factory_id': result.get('factory_id'),
                'total_contexts_visible': len(other_user_data),
                'contamination_detected': len(other_user_data) > 1
            }
        
        print(f"   Contamination Events: {len(self.contamination_events)}")
        print(f"   Users With Context Leaks: {sum(1 for evidence in context_leak_evidence.values() if evidence['contamination_detected'])}")
        
        # Store evidence for debugging
        self.shared_state_evidence['context_contamination'] = {
            'contamination_detected': contamination_detected,
            'leak_evidence': context_leak_evidence,
            'total_violations': len(self.contamination_events)
        }
        
        # ASSERTION: This MUST FAIL if singleton creates contamination
        # After remediation, users should be perfectly isolated
        assert not contamination_detected, \
            f"ðŸš¨ CRITICAL SECURITY VIOLATION: User context contamination detected! " \
            f"Singleton factory allows users to access other users' sensitive data. " \
            f"Contamination events: {len(self.contamination_events)}. " \
            f"This violates enterprise compliance requirements and creates liability risk."
        
        print("âœ… PASS: Perfect user isolation achieved (no context contamination)")
        
    def test_websocket_event_routing_contamination_VULNERABILITY(self):
        """
        CRITICAL SECURITY TEST: Prove singleton creates WebSocket event routing contamination.
        
        This test MUST FAIL initially, proving that:
        1. Singleton factory causes WebSocket events to route to wrong users
        2. User A's chat responses appear in User B's WebSocket connection
        3. Real-time event contamination violates user privacy
        4. Enterprise customers receive other customers' sensitive chat data
        
        EXPECTED: FAIL (before remediation) - Event routing contamination
        EXPECTED: PASS (after remediation) - Perfect event isolation
        """
        print("\nðŸš¨ TESTING WEBSOCKET EVENT ROUTING CONTAMINATION...")
        
        routing_contamination_detected = False
        websocket_evidence = {}
        
        # Mock WebSocket connections for multiple users
        user_connections = {
            self.user_a_id: self.mock_factory.create_mock_websocket(f"ws_user_a_{uuid.uuid4().hex[:6]}"),
            self.user_b_id: self.mock_factory.create_mock_websocket(f"ws_user_b_{uuid.uuid4().hex[:6]}"),
            self.user_c_id: self.mock_factory.create_mock_websocket(f"ws_user_c_{uuid.uuid4().hex[:6]}")
        }
        
        def simulate_websocket_event_delivery(user_id: str, event_data: Dict[str, Any]) -> Dict[str, Any]:
            """Simulate WebSocket event delivery that may route to wrong user via singleton."""
            try:
                # Import factory and simulate event routing
                from netra_backend.app.agents.supervisor.agent_instance_factory import AgentInstanceFactory
                
                factory = AgentInstanceFactory() 
                
                # Simulate event routing through singleton factory
                # In singleton pattern, factory may have shared WebSocket routing state
                if hasattr(factory, '_websocket_routing'):
                    # Add current user's event to shared routing state
                    factory._websocket_routing[event_data['event_id']] = {
                        'target_user': user_id,
                        'websocket_connection': user_connections[user_id],
                        'event_data': event_data
                    }
                else:
                    # Initialize shared routing state in singleton
                    setattr(factory, '_websocket_routing', {
                        event_data['event_id']: {
                            'target_user': user_id, 
                            'websocket_connection': user_connections[user_id],
                            'event_data': event_data
                        }
                    })
                
                # Get all routed events (may include other users' events due to singleton)
                all_routed_events = getattr(factory, '_websocket_routing', {})
                
                return {
                    'user_id': user_id,
                    'factory_id': id(factory),
                    'event_id': event_data['event_id'],
                    'all_routed_events': {eid: {'target_user': route['target_user']} 
                                        for eid, route in all_routed_events.items()},
                    'can_see_other_events': len(all_routed_events) > 1,
                    'routing_contamination': [eid for eid, route in all_routed_events.items() 
                                            if route['target_user'] != user_id]
                }
                
            except Exception as e:
                return {'user_id': user_id, 'error': str(e), 'routing_contamination': []}
        
        # Concurrent WebSocket events for different users
        user_events = {
            self.user_a_id: {
                'event_id': f"event_a_{uuid.uuid4().hex[:8]}",
                'type': 'agent_completed',
                'message': 'HIPAA patient analysis complete - CONFIDENTIAL',
                'sensitive_data': 'Patient diagnosis for John Doe'
            },
            self.user_b_id: {
                'event_id': f"event_b_{uuid.uuid4().hex[:8]}",
                'type': 'tool_completed', 
                'message': 'SOC2 financial analysis complete - RESTRICTED',
                'sensitive_data': 'Trading algorithm results for ACME Corp'
            },
            self.user_c_id: {
                'event_id': f"event_c_{uuid.uuid4().hex[:8]}",
                'type': 'agent_started',
                'message': 'Government intelligence analysis started - CLASSIFIED',
                'sensitive_data': 'National security assessment data'
            }
        }
        
        # Execute concurrent WebSocket event delivery
        with ThreadPoolExecutor(max_workers=3) as executor:
            futures = [
                executor.submit(simulate_websocket_event_delivery, user_id, event_data)
                for user_id, event_data in user_events.items()
            ]
            
            results = [future.result() for future in as_completed(futures)]
        
        # Analyze results for routing contamination
        for result in results:
            user_id = result.get('user_id')
            routing_contamination = result.get('routing_contamination', [])
            
            if routing_contamination:
                routing_contamination_detected = True
                self.contamination_events.append({
                    'type': 'websocket_routing_contamination',
                    'affected_user': user_id,
                    'contaminated_events': routing_contamination,
                    'severity': 'CRITICAL',
                    'privacy_violation': True,
                    'timestamp': datetime.now(timezone.utc).isoformat()
                })
            
            websocket_evidence[user_id] = {
                'can_see_other_events': result.get('can_see_other_events', False),
                'routing_contamination_count': len(routing_contamination),
                'factory_id': result.get('factory_id'),
                'contamination_event_ids': routing_contamination
            }
        
        print(f"   WebSocket Routing Contamination Events: {sum(len(ev.get('contaminated_events', [])) for ev in self.contamination_events if ev.get('type') == 'websocket_routing_contamination')}")
        print(f"   Users With Event Contamination: {sum(1 for evidence in websocket_evidence.values() if evidence['can_see_other_events'])}")
        
        # Store evidence for debugging
        self.shared_state_evidence['websocket_contamination'] = {
            'routing_contamination_detected': routing_contamination_detected,
            'websocket_evidence': websocket_evidence,
            'contaminated_events_total': sum(len(ev.get('contaminated_events', [])) for ev in self.contamination_events if ev.get('type') == 'websocket_routing_contamination')
        }
        
        # ASSERTION: This MUST FAIL if singleton causes event contamination
        # After remediation, WebSocket events should route only to correct users
        assert not routing_contamination_detected, \
            f"ðŸš¨ CRITICAL PRIVACY VIOLATION: WebSocket event routing contamination detected! " \
            f"Singleton factory causes user events to be visible to other users. " \
            f"Users can see each other's chat responses and sensitive data. " \
            f"This creates massive privacy violations and enterprise liability risk."
        
        print("âœ… PASS: Perfect WebSocket event isolation achieved")
    
    def test_memory_reference_persistence_VULNERABILITY(self):
        """
        CRITICAL SECURITY TEST: Prove singleton creates persistent memory reference contamination.
        
        This test MUST FAIL initially, proving that:
        1. Singleton factory retains memory references between user sessions
        2. User A's execution context persists after session ends  
        3. User B can access User A's leftover memory references
        4. Garbage collection cannot clean up shared singleton state
        
        EXPECTED: FAIL (before remediation) - Memory persistence contamination
        EXPECTED: PASS (after remediation) - Clean memory isolation per user
        """
        print("\nðŸš¨ TESTING MEMORY REFERENCE PERSISTENCE CONTAMINATION...")
        
        memory_contamination_detected = False
        memory_evidence = {}
        persistent_references = set()
        
        def execute_user_session_with_cleanup(user_id: str, session_data: Dict[str, Any]) -> Tuple[Dict[str, Any], Set[int]]:
            """Execute user session and return memory reference evidence."""
            try:
                # Import factory and execute user session
                from netra_backend.app.agents.supervisor.agent_instance_factory import AgentInstanceFactory
                
                factory = AgentInstanceFactory()
                factory_id = id(factory)
                
                # Store user session data that should be cleaned up after session
                sensitive_session_data = {
                    'user_id': user_id,
                    'session_start': datetime.now(timezone.utc),
                    'sensitive_payload': session_data,
                    'memory_id': id(session_data)
                }
                
                # Store in factory (simulating session state)
                if hasattr(factory, '_active_sessions'):
                    factory._active_sessions[user_id] = sensitive_session_data
                else:
                    setattr(factory, '_active_sessions', {user_id: sensitive_session_data})
                
                # Get memory references before cleanup
                session_memory_refs = {id(v) for v in getattr(factory, '_active_sessions', {}).values()}
                
                # Simulate session end - should clean up this user's data
                # In proper factory pattern, this user's data should be isolated and cleanable
                active_sessions = getattr(factory, '_active_sessions', {})
                
                return {
                    'user_id': user_id,
                    'factory_id': factory_id,  
                    'session_memory_refs': session_memory_refs,
                    'active_sessions_count': len(active_sessions),
                    'other_user_sessions': [uid for uid in active_sessions.keys() if uid != user_id],
                    'memory_contamination': len(active_sessions) > 1,
                    'persistent_data': {uid: data.get('memory_id') for uid, data in active_sessions.items()}
                }, session_memory_refs
                
            except Exception as e:
                return {'user_id': user_id, 'error': str(e)}, set()
        
        # User session data with sensitive information
        user_sessions_data = {
            self.user_a_id: {
                'enterprise_client': 'HEALTHCARE_PARTNERS',
                'patient_records': ['confidential_record_001', 'confidential_record_002'],
                'hipaa_data': 'Protected health information'
            },
            self.user_b_id: {
                'enterprise_client': 'FINANCIAL_SERVICES_CORP',
                'trading_positions': ['position_001', 'position_002'],  
                'soc2_data': 'Confidential financial analysis'
            },
            self.user_c_id: {
                'enterprise_client': 'GOVERNMENT_AGENCY',
                'classified_intel': ['intel_001', 'intel_002'],
                'sec_data': 'Classified security information'
            }
        }
        
        # Execute sessions sequentially to test persistence
        session_results = []
        all_memory_refs = set()
        
        for user_id, session_data in user_sessions_data.items():
            print(f"   Executing session for {user_id}...")
            result, memory_refs = execute_user_session_with_cleanup(user_id, session_data)
            session_results.append(result)
            all_memory_refs.update(memory_refs)
            
            # Small delay to ensure session separation
            time.sleep(0.1)
        
        # Analyze memory persistence contamination
        for result in session_results:
            user_id = result.get('user_id')
            other_user_sessions = result.get('other_user_sessions', [])
            
            if other_user_sessions:
                memory_contamination_detected = True
                self.contamination_events.append({
                    'type': 'memory_persistence_contamination',
                    'affected_user': user_id,
                    'persistent_other_users': other_user_sessions,
                    'severity': 'CRITICAL',
                    'memory_leak': True,
                    'timestamp': datetime.now(timezone.utc).isoformat()
                })
            
            memory_evidence[user_id] = {
                'can_see_other_sessions': len(other_user_sessions) > 0,
                'persistent_users': other_user_sessions,
                'factory_id': result.get('factory_id'),
                'memory_contamination': result.get('memory_contamination', False),
                'active_sessions_count': result.get('active_sessions_count', 0)
            }
        
        print(f"   Memory Contamination Events: {len([ev for ev in self.contamination_events if ev.get('type') == 'memory_persistence_contamination'])}")
        print(f"   Users With Persistent Memory: {sum(1 for evidence in memory_evidence.values() if evidence['can_see_other_sessions'])}")
        
        # Store evidence for debugging
        self.shared_state_evidence['memory_contamination'] = {
            'memory_contamination_detected': memory_contamination_detected,
            'memory_evidence': memory_evidence,
            'total_memory_refs': len(all_memory_refs),
            'contamination_events': len([ev for ev in self.contamination_events if ev.get('type') == 'memory_persistence_contamination'])
        }
        
        # ASSERTION: This MUST FAIL if singleton creates memory persistence contamination
        # After remediation, each user session should be completely isolated in memory
        assert not memory_contamination_detected, \
            f"ðŸš¨ CRITICAL MEMORY LEAK: Singleton factory creates persistent memory contamination! " \
            f"User sessions remain in memory after completion, allowing other users to access sensitive data. " \
            f"Memory contamination events: {len([ev for ev in self.contamination_events if ev.get('type') == 'memory_persistence_contamination'])}. " \
            f"This creates severe privacy violations and prevents proper garbage collection."
        
        print("âœ… PASS: Clean memory isolation achieved (no persistent contamination)")
        
    def test_enterprise_compliance_violation_aggregation_VULNERABILITY(self):
        """
        CRITICAL BUSINESS TEST: Aggregate all vulnerability evidence for enterprise impact assessment.
        
        This test MUST FAIL initially, providing comprehensive evidence that:
        1. Singleton pattern creates multiple enterprise security violations
        2. HIPAA, SOC2, SEC compliance requirements are violated
        3. $500K+ ARR customer data is at risk of cross-contamination
        4. System cannot meet enterprise security standards in current state
        
        EXPECTED: FAIL (before remediation) - Multiple compliance violations detected
        EXPECTED: PASS (after remediation) - Full enterprise compliance achieved
        """
        print("\nðŸš¨ ENTERPRISE COMPLIANCE VIOLATION ASSESSMENT...")
        
        # Run all vulnerability tests to collect comprehensive evidence
        try:
            self.test_singleton_factory_shares_state_between_users_VULNERABILITY()
        except AssertionError:
            pass  # Expected to fail - record evidence
            
        try:
            self.test_concurrent_user_context_contamination_VULNERABILITY()
        except AssertionError:
            pass  # Expected to fail - record evidence
            
        try:
            self.test_websocket_event_routing_contamination_VULNERABILITY()
        except AssertionError:
            pass  # Expected to fail - record evidence
            
        try:
            self.test_memory_reference_persistence_VULNERABILITY()
        except AssertionError:
            pass  # Expected to fail - record evidence
        
        # Aggregate compliance violation evidence
        compliance_violations = {
            'HIPAA': [],
            'SOC2': [],  
            'SEC': [],
            'PCI_DSS': [],
            'GDPR': []
        }
        
        total_violations = len(self.contamination_events)
        critical_violations = len([ev for ev in self.contamination_events if ev.get('severity') == 'CRITICAL'])
        
        # Categorize violations by compliance framework
        for event in self.contamination_events:
            violation_type = event.get('type', 'unknown')
            
            # HIPAA violations (patient data contamination)
            if 'HIPAA' in str(event.get('compliance_violation', '')) or 'patient' in str(event).lower():
                compliance_violations['HIPAA'].append(violation_type)
                
            # SOC2 violations (financial data contamination)  
            if 'SOC2' in str(event.get('compliance_violation', '')) or 'financial' in str(event).lower():
                compliance_violations['SOC2'].append(violation_type)
                
            # SEC violations (classified data contamination)
            if 'SEC' in str(event.get('compliance_violation', '')) or 'classified' in str(event).lower():
                compliance_violations['SEC'].append(violation_type)
                
            # Privacy violations (general user data contamination)
            if event.get('privacy_violation'):
                compliance_violations['GDPR'].append(violation_type)
        
        # Calculate enterprise risk assessment
        enterprise_risk_score = (
            len(compliance_violations['HIPAA']) * 10 +  # HIPAA violations are severe
            len(compliance_violations['SOC2']) * 8 +    # Financial violations are critical
            len(compliance_violations['SEC']) * 12 +     # Government violations are extreme
            len(compliance_violations['GDPR']) * 6       # Privacy violations are significant
        )
        
        compliance_summary = {
            'total_violations': total_violations,
            'critical_violations': critical_violations, 
            'compliance_frameworks_violated': len([k for k, v in compliance_violations.items() if v]),
            'enterprise_risk_score': enterprise_risk_score,
            'hipaa_violations': len(compliance_violations['HIPAA']),
            'soc2_violations': len(compliance_violations['SOC2']),
            'sec_violations': len(compliance_violations['SEC']),
            'gdpr_violations': len(compliance_violations['GDPR']),
            'revenue_at_risk': "$500K+ ARR" if total_violations > 0 else "$0",
            'compliance_status': 'FAILED' if total_violations > 0 else 'PASSED'
        }
        
        print(f"   Total Violations: {total_violations}")
        print(f"   Critical Violations: {critical_violations}")
        print(f"   HIPAA Violations: {len(compliance_violations['HIPAA'])}")
        print(f"   SOC2 Violations: {len(compliance_violations['SOC2'])}")
        print(f"   SEC Violations: {len(compliance_violations['SEC'])}")
        print(f"   Enterprise Risk Score: {enterprise_risk_score}")
        print(f"   Revenue at Risk: {compliance_summary['revenue_at_risk']}")
        
        # Store comprehensive evidence
        self.shared_state_evidence['compliance_assessment'] = {
            'compliance_summary': compliance_summary,
            'violation_details': compliance_violations,
            'all_contamination_events': self.contamination_events,
            'assessment_timestamp': datetime.now(timezone.utc).isoformat()
        }
        
        # FINAL ASSERTION: Enterprise compliance must be achieved
        assert total_violations == 0, \
            f"ðŸš¨ ENTERPRISE COMPLIANCE FAILURE: {total_violations} security violations detected! " \
            f"System violates {len([k for k, v in compliance_violations.items() if v])} compliance frameworks. " \
            f"HIPAA: {len(compliance_violations['HIPAA'])} violations, " \
            f"SOC2: {len(compliance_violations['SOC2'])} violations, " \
            f"SEC: {len(compliance_violations['SEC'])} violations. " \
            f"Enterprise Risk Score: {enterprise_risk_score}. " \
            f"Revenue at Risk: $500K+ ARR. " \
            f"IMMEDIATE REMEDIATION REQUIRED: Migrate from singleton to factory pattern for user isolation."
        
        print("âœ… PASS: Full enterprise compliance achieved (zero security violations)")
        
    def teardown_method(self, method):
        """Clean up test environment and log vulnerability evidence."""
        # Log comprehensive evidence for debugging
        if self.contamination_events:
            print(f"\nðŸ“Š VULNERABILITY EVIDENCE SUMMARY:")
            print(f"   Contamination Events: {len(self.contamination_events)}")
            print(f"   Singleton Instances: {self.singleton_instances}")
            print(f"   Shared State Evidence: {len(self.shared_state_evidence)}")
            
            # Write evidence to test metadata for debugging
            self.record_custom('vulnerability_evidence', {
                'contamination_events': self.contamination_events,
                'singleton_instances': self.singleton_instances, 
                'shared_state_evidence': self.shared_state_evidence,
                'test_timestamp': datetime.now(timezone.utc).isoformat()
            })
        
        super().teardown_method(method)