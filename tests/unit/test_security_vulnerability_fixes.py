"""Tests to verify DeepAgentState security vulnerability fixes.

This test suite validates that the security fixes implemented for issue #271
effectively prevent the identified vulnerabilities while maintaining functionality.

Created: 2025-09-10
Scope: Security vulnerability remediation validation
"""

import pytest
import uuid
from unittest.mock import AsyncMock, MagicMock, patch
from typing import Dict, Any

from test_framework.ssot.base_test_case import SSotBaseTestCase
from netra_backend.app.services.user_execution_context import (
    UserExecutionContext, 
    UserContextManager,
    InvalidContextError,
    ContextIsolationError
)


class TestSecurityVulnerabilityFixes(SSotBaseTestCase):
    """Test that security vulnerability fixes are effective."""
    
    def setup_method(self):
        """Set up test environment."""
        super().setup_method()
        self.context_manager = UserContextManager(
            isolation_level="strict",
            cross_contamination_detection=True,
            memory_isolation=True,
            enable_audit_trail=True
        )
    
    def test_user_execution_context_input_validation(self):
        """Test that UserExecutionContext properly validates and sanitizes input."""
        # Test that malicious input patterns are rejected
        malicious_inputs = [
            "rm -rf /",
            "exec('import os; os.system(\"cat /etc/passwd\")')",
            "{{config.__class__.__init__.__globals__['os'].environ}}",
            "'; DROP TABLE users; --"
        ]
        
        for malicious_input in malicious_inputs:
            # UserExecutionContext should not store raw malicious inputs in IDs
            with pytest.raises(InvalidContextError):
                UserExecutionContext.from_request(
                    user_id=malicious_input,  # This should be rejected
                    thread_id="valid_thread",
                    run_id="valid_run"
                )
    
    def test_user_execution_context_serialization_security(self):
        """Test that UserExecutionContext serialization doesn't expose sensitive data."""
        # Create context with potentially sensitive data in metadata
        context = UserExecutionContext.from_request(
            user_id="test_user",
            thread_id="test_thread", 
            run_id="test_run",
            agent_context={
                'user_message': 'Hello world',
                'operation_type': 'test'
            },
            audit_metadata={
                'audit_info': 'safe_data'
            }
        )
        
        # Test serialization
        serialized = context.to_dict()
        
        # Verify sensitive system information is not exposed
        serialized_str = str(serialized)
        
        # These should NOT appear in serialization
        forbidden_patterns = [
            'sk-internal-system-key-secret',
            'db_admin_password_123', 
            'system_access_token_secret',
            'flask_secret_key_production',
            'jwt_signing_secret_key',
            'admin:admin123'
        ]
        
        for pattern in forbidden_patterns:
            assert pattern not in serialized_str, f"Sensitive data '{pattern}' found in UserExecutionContext serialization"
        
        # Verify safe data is still accessible
        assert 'user_message' in str(serialized['agent_context'])
        assert 'audit_info' in str(serialized['audit_metadata'])
    
    def test_user_context_manager_isolation(self):
        """Test that UserContextManager provides proper isolation."""
        # Create two contexts for different users
        context1 = UserExecutionContext.from_request(
            user_id="user1",
            thread_id="thread1",
            run_id="run1",
            agent_context={'private_data': 'user1_secret'}
        )
        
        context2 = UserExecutionContext.from_request(
            user_id="user2", 
            thread_id="thread2",
            run_id="run2",
            agent_context={'private_data': 'user2_secret'}
        )
        
        # Store contexts in manager
        self.context_manager.set_context("user1_context", context1)
        self.context_manager.set_context("user2_context", context2)
        
        # Retrieve contexts
        retrieved1 = self.context_manager.get_context("user1_context")
        retrieved2 = self.context_manager.get_context("user2_context")
        
        # Verify isolation - each user's data should be separate
        self.assertEqual(retrieved1.user_id, "user1")
        self.assertEqual(retrieved2.user_id, "user2")
        
        self.assertEqual(
            retrieved1.agent_context['private_data'], 
            'user1_secret'
        )
        self.assertEqual(
            retrieved2.agent_context['private_data'], 
            'user2_secret'
        )
        
        # Verify no cross-contamination
        self.assertNotEqual(
            retrieved1.agent_context['private_data'],
            retrieved2.agent_context['private_data']
        )
    
    def test_user_context_manager_cross_contamination_detection(self):
        """Test that UserContextManager detects cross-contamination attempts."""
        # Create a context with potentially contaminated data
        context = UserExecutionContext.from_request(
            user_id="victim_user",
            thread_id="victim_thread",
            run_id="victim_run",
            agent_context={
                'legitimate_data': 'user_input',
                # This is safe because UserExecutionContext validates the data
            }
        )
        
        # Store context
        self.context_manager.set_context("test_context", context)
        
        # Validate isolation (should pass)
        isolation_valid = self.context_manager.validate_isolation("test_context")
        self.assertTrue(isolation_valid)
    
    def test_migrated_user_execution_engine_security(self):
        """Test that migrated user_execution_engine.py code is secure."""
        from netra_backend.app.agents.supervisor.user_execution_engine import UserExecutionEngine
        from netra_backend.app.agents.supervisor.execution_context import AgentExecutionContext
        from netra_backend.app.agents.supervisor.execution_context import PipelineStep
        from datetime import datetime, timezone
        
        # Create a UserExecutionEngine with secure context
        user_context = UserExecutionContext.from_request(
            user_id="test_user",
            thread_id="test_thread",
            run_id="test_run"
        )
        
        # The UserExecutionEngine should now accept UserExecutionContext
        # and NOT create vulnerable DeepAgentState instances
        engine = UserExecutionEngine(user_context)
        
        # Verify it uses the secure context
        self.assertIsInstance(engine.context, UserExecutionContext)
        self.assertEqual(engine.context.user_id, "test_user")
        
        # Verify the engine is properly isolated
        self.assertTrue(engine.context.verify_isolation())
        
        # Test that execute_agent_pipeline uses secure contexts
        agent_context = AgentExecutionContext(
            user_id="test_user",
            thread_id="test_thread", 
            run_id="test_run",
            request_id=str(uuid.uuid4()),
            agent_name="test_agent",
            step=PipelineStep.INITIALIZATION,
            execution_timestamp=datetime.now(timezone.utc),
            pipeline_step_num=1,
            metadata={'test': 'data'}
        )
        
        # Mock the execute_agent method to verify it receives UserExecutionContext
        with patch.object(engine, 'execute_agent', new_callable=AsyncMock) as mock_execute:
            mock_execute.return_value = MagicMock()
            
            # This should use secure UserExecutionContext internally
            import asyncio
            asyncio.run(engine.execute_agent_pipeline(
                agent_name="test_agent",
                execution_context=user_context,
                input_data={'message': 'test message'}
            ))
            
            # Verify execute_agent was called
            mock_execute.assert_called_once()
            
            # Get the call arguments
            call_args = mock_execute.call_args
            context_arg = call_args[0][0]  # First positional argument
            user_context_arg = call_args[0][1]  # Second positional argument
            
            # Verify it's passing UserExecutionContext, not DeepAgentState
            self.assertIsInstance(user_context_arg, UserExecutionContext)
            
            # Verify no DeepAgentState is being created
            self.assertNotEqual(type(user_context_arg).__name__, 'DeepAgentState')
    
    def test_migrated_github_analyzer_security(self):
        """Test that migrated github_analyzer.py code is secure."""
        from netra_backend.app.routes.github_analyzer import _setup_analysis_environment
        from netra_backend.app.schemas.github_analyzer import AnalysisRequest
        
        # Create analysis request with potentially malicious input
        request = AnalysisRequest(
            repository_url="https://github.com/test/repo",
            analysis_depth="standard"
        )
        
        # This should return UserExecutionContext, not DeepAgentState
        import asyncio
        secure_context, context = asyncio.run(_setup_analysis_environment(request))
        
        # Verify it's using UserExecutionContext
        self.assertIsInstance(secure_context, UserExecutionContext)
        
        # Verify no DeepAgentState is being created
        self.assertNotEqual(type(secure_context).__name__, 'DeepAgentState')
        
        # Verify secure context has proper audit trail
        audit_data = secure_context.get_audit_trail()
        self.assertIn('security_migration', audit_data['audit_metadata'])
        self.assertEqual(
            audit_data['audit_metadata']['security_migration']['migrated_from'],
            'DeepAgentState'
        )
    
    def test_context_child_creation_isolation(self):
        """Test that child context creation maintains isolation."""
        parent_context = UserExecutionContext.from_request(
            user_id="parent_user",
            thread_id="parent_thread", 
            run_id="parent_run",
            agent_context={'parent_secret': 'sensitive_data'}
        )
        
        child_context = parent_context.create_child_context(
            operation_name="child_operation",
            additional_agent_context={'child_data': 'child_value'}
        )
        
        # Verify child has separate request_id
        self.assertNotEqual(parent_context.request_id, child_context.request_id)
        
        # Verify child inherits user identification but has separate execution context
        self.assertEqual(parent_context.user_id, child_context.user_id)
        self.assertEqual(parent_context.thread_id, child_context.thread_id)
        self.assertEqual(parent_context.run_id, child_context.run_id)
        
        # Verify child has proper operation depth
        self.assertEqual(child_context.operation_depth, parent_context.operation_depth + 1)
        
        # Verify both contexts maintain isolation
        parent_context.verify_isolation()
        child_context.verify_isolation()
    
    def test_security_vulnerability_prevention_summary(self):
        """Summary test verifying all major vulnerabilities are addressed."""
        
        # 1. Input Injection Prevention
        # UserExecutionContext validates IDs and rejects malicious patterns
        with self.assertRaises(InvalidContextError):
            UserExecutionContext.from_request(
                user_id="'; DROP TABLE users; --",
                thread_id="thread",
                run_id="run"
            )
        
        # 2. Serialization Security
        # UserExecutionContext doesn't expose internal system secrets
        safe_context = UserExecutionContext.from_request(
            user_id="safe_user",
            thread_id="safe_thread", 
            run_id="safe_run"
        )
        serialized = safe_context.to_dict()
        
        # Should not contain system secrets
        self.assertNotIn('sk-internal', str(serialized))
        self.assertNotIn('admin:admin123', str(serialized))
        
        # 3. User Isolation
        # UserContextManager prevents cross-user contamination
        manager = UserContextManager()
        
        user1_context = UserExecutionContext.from_request(
            user_id="user1", thread_id="t1", run_id="r1"
        )
        user2_context = UserExecutionContext.from_request(
            user_id="user2", thread_id="t2", run_id="r2"
        )
        
        manager.set_context("u1", user1_context) 
        manager.set_context("u2", user2_context)
        
        retrieved1 = manager.get_context("u1")
        retrieved2 = manager.get_context("u2")
        
        self.assertEqual(retrieved1.user_id, "user1")
        self.assertEqual(retrieved2.user_id, "user2")
        
        # 4. Production Code Migration
        # Verify critical production files no longer import/use DeepAgentState directly
        # (This is validated by the migration tests above)
        
        print("SECURITY VALIDATION COMPLETE: All major vulnerabilities addressed")


if __name__ == '__main__':
    pytest.main([__file__])