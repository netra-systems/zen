"""Tests to verify DeepAgentState security vulnerability fixes.

This test suite validates that the security fixes implemented for issue #271
effectively prevent the identified vulnerabilities while maintaining functionality.

Created: 2025-09-10
Scope: Security vulnerability remediation validation
"""
import pytest
import uuid
from unittest.mock import AsyncMock, MagicMock, patch
from typing import Dict, Any
from test_framework.ssot.base_test_case import SSotBaseTestCase
from netra_backend.app.services.user_execution_context import UserExecutionContext, UserContextManager, InvalidContextError, ContextIsolationError

@pytest.mark.unit
class SecurityVulnerabilityFixesTests(SSotBaseTestCase):
    """Test that security vulnerability fixes are effective."""

    def setup_method(self):
        """Set up test environment."""
        super().setup_method()
        self.context_manager = UserContextManager(isolation_level='strict', cross_contamination_detection=True, memory_isolation=True, enable_audit_trail=True)

    def test_user_execution_context_input_validation(self):
        """Test that UserExecutionContext properly validates and sanitizes input."""
        malicious_inputs = ['rm -rf /', 'exec(\'import os; os.system("cat /etc/passwd")\')', "{{config.__class__.__init__.__globals__['os'].environ}}", "'; DROP TABLE users; --"]
        for malicious_input in malicious_inputs:
            with pytest.raises(InvalidContextError):
                UserExecutionContext.from_request(user_id=malicious_input, thread_id='valid_thread', run_id='valid_run')

    def test_user_execution_context_serialization_security(self):
        """Test that UserExecutionContext serialization doesn't expose sensitive data."""
        context = UserExecutionContext.from_request(user_id='test_user', thread_id='test_thread', run_id='test_run', agent_context={'user_message': 'Hello world', 'operation_type': 'test'}, audit_metadata={'audit_info': 'safe_data'})
        serialized = context.to_dict()
        serialized_str = str(serialized)
        forbidden_patterns = ['sk-internal-system-key-secret', 'db_admin_password_123', 'system_access_token_secret', 'flask_secret_key_production', 'jwt_signing_secret_key', 'admin:admin123']
        for pattern in forbidden_patterns:
            assert pattern not in serialized_str, f"Sensitive data '{pattern}' found in UserExecutionContext serialization"
        assert 'user_message' in str(serialized['agent_context'])
        assert 'audit_info' in str(serialized['audit_metadata'])

    def test_user_context_manager_isolation(self):
        """Test that UserContextManager provides proper isolation."""
        context1 = UserExecutionContext.from_request(user_id='user1', thread_id='thread1', run_id='run1', agent_context={'private_data': 'user1_secret'})
        context2 = UserExecutionContext.from_request(user_id='user2', thread_id='thread2', run_id='run2', agent_context={'private_data': 'user2_secret'})
        self.context_manager.set_context('user1_context', context1)
        self.context_manager.set_context('user2_context', context2)
        retrieved1 = self.context_manager.get_context('user1_context')
        retrieved2 = self.context_manager.get_context('user2_context')
        self.assertEqual(retrieved1.user_id, 'user1')
        self.assertEqual(retrieved2.user_id, 'user2')
        self.assertEqual(retrieved1.agent_context['private_data'], 'user1_secret')
        self.assertEqual(retrieved2.agent_context['private_data'], 'user2_secret')
        self.assertNotEqual(retrieved1.agent_context['private_data'], retrieved2.agent_context['private_data'])

    def test_user_context_manager_cross_contamination_detection(self):
        """Test that UserContextManager detects cross-contamination attempts."""
        context = UserExecutionContext.from_request(user_id='victim_user', thread_id='victim_thread', run_id='victim_run', agent_context={'legitimate_data': 'user_input'})
        self.context_manager.set_context('test_context', context)
        isolation_valid = self.context_manager.validate_isolation('test_context')
        self.assertTrue(isolation_valid)

    def test_migrated_user_execution_engine_security(self):
        """Test that migrated user_execution_engine.py code is secure."""
        from netra_backend.app.agents.supervisor.user_execution_engine import UserExecutionEngine
        from netra_backend.app.agents.supervisor.execution_context import AgentExecutionContext
        from netra_backend.app.agents.supervisor.execution_context import PipelineStep
        from datetime import datetime, timezone
        user_context = UserExecutionContext.from_request(user_id='test_user', thread_id='test_thread', run_id='test_run')
        engine = UserExecutionEngine(user_context)
        self.assertIsInstance(engine.context, UserExecutionContext)
        self.assertEqual(engine.context.user_id, 'test_user')
        self.assertTrue(engine.context.verify_isolation())
        agent_context = AgentExecutionContext(user_id='test_user', thread_id='test_thread', run_id='test_run', request_id=str(uuid.uuid4()), agent_name='test_agent', step=PipelineStep.INITIALIZATION, execution_timestamp=datetime.now(timezone.utc), pipeline_step_num=1, metadata={'test': 'data'})
        with patch.object(engine, 'execute_agent', new_callable=AsyncMock) as mock_execute:
            mock_execute.return_value = MagicMock()
            import asyncio
            asyncio.run(engine.execute_agent_pipeline(agent_name='test_agent', execution_context=user_context, input_data={'message': 'test message'}))
            mock_execute.assert_called_once()
            call_args = mock_execute.call_args
            context_arg = call_args[0][0]
            user_context_arg = call_args[0][1]
            self.assertIsInstance(user_context_arg, UserExecutionContext)
            self.assertNotEqual(type(user_context_arg).__name__, 'DeepAgentState')

    def test_migrated_github_analyzer_security(self):
        """Test that migrated github_analyzer.py code is secure."""
        from netra_backend.app.routes.github_analyzer import _setup_analysis_environment
        from netra_backend.app.schemas.github_analyzer import AnalysisRequest
        request = AnalysisRequest(repository_url='https://github.com/test/repo', analysis_depth='standard')
        import asyncio
        secure_context, context = asyncio.run(_setup_analysis_environment(request))
        self.assertIsInstance(secure_context, UserExecutionContext)
        self.assertNotEqual(type(secure_context).__name__, 'DeepAgentState')
        audit_data = secure_context.get_audit_trail()
        self.assertIn('security_migration', audit_data['audit_metadata'])
        self.assertEqual(audit_data['audit_metadata']['security_migration']['migrated_from'], 'DeepAgentState')

    def test_context_child_creation_isolation(self):
        """Test that child context creation maintains isolation."""
        parent_context = UserExecutionContext.from_request(user_id='parent_user', thread_id='parent_thread', run_id='parent_run', agent_context={'parent_secret': 'sensitive_data'})
        child_context = parent_context.create_child_context(operation_name='child_operation', additional_agent_context={'child_data': 'child_value'})
        self.assertNotEqual(parent_context.request_id, child_context.request_id)
        self.assertEqual(parent_context.user_id, child_context.user_id)
        self.assertEqual(parent_context.thread_id, child_context.thread_id)
        self.assertEqual(parent_context.run_id, child_context.run_id)
        self.assertEqual(child_context.operation_depth, parent_context.operation_depth + 1)
        parent_context.verify_isolation()
        child_context.verify_isolation()

    def test_security_vulnerability_prevention_summary(self):
        """Summary test verifying all major vulnerabilities are addressed."""
        with self.assertRaises(InvalidContextError):
            UserExecutionContext.from_request(user_id="'; DROP TABLE users; --", thread_id='thread', run_id='run')
        safe_context = UserExecutionContext.from_request(user_id='safe_user', thread_id='safe_thread', run_id='safe_run')
        serialized = safe_context.to_dict()
        self.assertNotIn('sk-internal', str(serialized))
        self.assertNotIn('admin:admin123', str(serialized))
        manager = UserContextManager()
        user1_context = UserExecutionContext.from_request(user_id='user1', thread_id='t1', run_id='r1')
        user2_context = UserExecutionContext.from_request(user_id='user2', thread_id='t2', run_id='r2')
        manager.set_context('u1', user1_context)
        manager.set_context('u2', user2_context)
        retrieved1 = manager.get_context('u1')
        retrieved2 = manager.get_context('u2')
        self.assertEqual(retrieved1.user_id, 'user1')
        self.assertEqual(retrieved2.user_id, 'user2')
        print('SECURITY VALIDATION COMPLETE: All major vulnerabilities addressed')
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')