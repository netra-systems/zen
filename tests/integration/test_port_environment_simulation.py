"""

Integration tests for simulating Cloud Run PORT environment variable behavior.



CRITICAL: These tests simulate Cloud Run's dynamic PORT assignment without requiring Docker.

They are designed to FAIL until Alpine Dockerfiles properly support dynamic PORT configuration.



Issue #146: Cloud Run PORT Configuration Error - Alpine Dockerfiles ignore

the PORT environment variable that Cloud Run sets dynamically.

"""



import os

import subprocess

import tempfile

import pytest

from pathlib import Path

from typing import Dict, List

from unittest.mock import patch, MagicMock



# Test utilities  

from test_framework.ssot.base_test_case import BaseTestCase





class TestPortEnvironmentSimulation(BaseTestCase):

    """Test suite to simulate Cloud Run PORT environment behavior.

    

    These tests simulate the Cloud Run environment without requiring actual Docker deployment.

    """

    

    def setup_method(self, method=None):

        """Set up test environment."""

        super().setup_method(method)

        self.project_root = Path(__file__).parent.parent.parent

        self.test_ports = [8080, 8090, 9000, 9090]  # Typical Cloud Run ports

    

    def test_cloud_run_port_assignment_simulation(self):

        """

        FAILING TEST: Simulate Cloud Run's dynamic PORT assignment behavior.

        

        Expected to FAIL: Alpine Dockerfiles don't respect the PORT environment variable.

        """

        backend_alpine_dockerfile = self.project_root / "dockerfiles" / "backend.alpine.Dockerfile"

        backend_gcp_dockerfile = self.project_root / "deployment" / "docker" / "backend.gcp.Dockerfile"

        

        for test_port in self.test_ports:

            # Test with different ports to simulate Cloud Run behavior

                # Simulate Cloud Run setting PORT environment variable

                with patch.dict(os.environ, {'PORT': str(test_port)}):

                    

                    # Test GCP Dockerfile behavior (should work)

                    gcp_command = self._extract_command_from_dockerfile(backend_gcp_dockerfile)

                    gcp_effective_port = self._simulate_command_execution(gcp_command, test_port)

                    

                    self.assertEqual(

                        gcp_effective_port, test_port,

                        f"GCP Dockerfile should use PORT={test_port} from environment"

                    )

                    

                    # Test Alpine Dockerfile behavior (should fail)

                    alpine_command = self._extract_command_from_dockerfile(backend_alpine_dockerfile)

                    alpine_effective_port = self._simulate_command_execution(alpine_command, test_port)

                    

                    # This should FAIL until Alpine is fixed

                    self.assertEqual(

                        alpine_effective_port, test_port,

                        f"Alpine Dockerfile should use PORT={test_port} from environment, "

                        f"but currently ignores it and uses hardcoded port 8000"

                    )

    

    def test_health_check_port_environment_simulation(self):

        """

        FAILING TEST: Health check should adapt to dynamic PORT environment variable.

        

        Expected to FAIL: Alpine health check uses hardcoded localhost:8000.

        """

        backend_alpine_dockerfile = self.project_root / "dockerfiles" / "backend.alpine.Dockerfile"

        

        for test_port in self.test_ports:

            # Test with different ports to simulate Cloud Run behavior

                with patch.dict(os.environ, {'PORT': str(test_port)}):

                    

                    health_check_config = self._extract_health_check_from_dockerfile(backend_alpine_dockerfile)

                    

                    if health_check_config:

                        effective_health_port = self._simulate_health_check_execution(

                            health_check_config, test_port

                        )

                        

                        # This should FAIL until Alpine health check is fixed

                        self.assertEqual(

                            effective_health_port, test_port,

                            f"Health check should use PORT={test_port} from environment, "

                            f"but currently uses hardcoded localhost:8000"

                        )

    

    def test_multiple_container_port_conflict_simulation(self):

        """

        FAILING TEST: Simulate multiple containers with different PORT assignments.

        

        Expected to FAIL: Alpine containers would all try to bind to port 8000,

        causing conflicts in multi-container environments.

        """

        backend_alpine_dockerfile = self.project_root / "dockerfiles" / "backend.alpine.Dockerfile"

        

        # Simulate multiple Cloud Run instances with different ports

        container_configs = [

            {'instance': 'backend-1', 'port': 8080},

            {'instance': 'backend-2', 'port': 8090}, 

            {'instance': 'backend-3', 'port': 9000}

        ]

        

        used_ports = set()

        conflicts = []

        

        for config in container_configs:

            with patch.dict(os.environ, {'PORT': str(config['port'])}):

                

                command = self._extract_command_from_dockerfile(backend_alpine_dockerfile)

                effective_port = self._simulate_command_execution(command, config['port'])

                

                if effective_port in used_ports:

                    conflicts.append(

                        f"Port conflict: {config['instance']} tried to use port {effective_port} "

                        f"(already used by another instance)"

                    )

                

                used_ports.add(effective_port)

        

        # This should FAIL due to all Alpine containers trying to use port 8000

        self.assertEqual(

            len(conflicts), 0,

            f"Alpine Dockerfiles cause port conflicts in multi-container environments:\n" +

            "\n".join(conflicts)

        )

    

    def test_environment_variable_precedence_simulation(self):

        """

        FAILING TEST: PORT environment variable should take precedence over defaults.

        

        Expected to FAIL: Alpine Dockerfiles ignore PORT environment variable completely.

        """

        backend_alpine_dockerfile = self.project_root / "dockerfiles" / "backend.alpine.Dockerfile"

        backend_gcp_dockerfile = self.project_root / "deployment" / "docker" / "backend.gcp.Dockerfile"

        

        test_scenarios = [

            {'PORT': '8080', 'expected': 8080},

            {'PORT': '9000', 'expected': 9000},

            # Missing PORT should use default

            {None: None, 'expected': 8000}

        ]

        

        for scenario in test_scenarios:

            # Test each scenario

                env_patch = {}

                if list(scenario.keys())[0] is not None:

                    env_patch['PORT'] = list(scenario.values())[0]

                

                with patch.dict(os.environ, env_patch, clear=False):

                    

                    # GCP should handle this correctly

                    gcp_command = self._extract_command_from_dockerfile(backend_gcp_dockerfile)

                    gcp_port = self._simulate_command_execution(gcp_command, scenario['expected'])

                    

                    self.assertEqual(

                        gcp_port, scenario['expected'],

                        f"GCP Dockerfile should respect PORT environment variable precedence"

                    )

                    

                    # Alpine should fail this test

                    alpine_command = self._extract_command_from_dockerfile(backend_alpine_dockerfile)

                    alpine_port = self._simulate_command_execution(alpine_command, scenario['expected'])

                    

                    self.assertEqual(

                        alpine_port, scenario['expected'],

                        f"Alpine Dockerfile should respect PORT environment variable precedence. "

                        f"Expected {scenario['expected']}, but Alpine ignores PORT and uses hardcoded 8000"

                    )

    

    def _extract_command_from_dockerfile(self, dockerfile_path: Path) -> str:

        """Extract the CMD instruction from a Dockerfile."""

        with open(dockerfile_path, 'r', encoding='utf-8') as f:

            content = f.read()

        

        # Find CMD instruction

        import re

        cmd_match = re.search(r'CMD\s*\[(.*?)\]', content, re.DOTALL)

        if cmd_match:

            # JSON array format

            return cmd_match.group(1)

        

        cmd_match = re.search(r'CMD\s+(.+)', content, re.MULTILINE)

        if cmd_match:

            # Shell format

            return cmd_match.group(1)

        

        return ""

    

    def _extract_health_check_from_dockerfile(self, dockerfile_path: Path) -> str:

        """Extract the HEALTHCHECK instruction from a Dockerfile."""

        with open(dockerfile_path, 'r', encoding='utf-8') as f:

            content = f.read()

        

        import re

        health_match = re.search(r'HEALTHCHECK.*CMD\s+(.+)', content, re.MULTILINE)

        if health_match:

            return health_match.group(1)

        

        return ""

    

    def _simulate_command_execution(self, command: str, expected_port: int) -> int:

        """

        Simulate command execution to determine what port would actually be used.

        

        This doesn't actually execute the command, but parses it to determine

        the effective port configuration.

        """

        if not command:

            return 8000  # Default fallback

        

        # Check for ${PORT} usage in command

        if '${PORT' in command:

            # Command uses environment variable - return the expected port

            return expected_port

        

        # Check for hardcoded port in gunicorn --bind

        import re

        bind_match = re.search(r'--bind\s+[^:]+:(\d+)', command)

        if bind_match:

            return int(bind_match.group(1))

        

        # Check for hardcoded port in uvicorn --port

        port_match = re.search(r'--port\s+(\d+)', command)

        if port_match:

            return int(port_match.group(1))

        

        # Default port

        return 8000

    

    def _simulate_health_check_execution(self, health_check: str, expected_port: int) -> int:

        """

        Simulate health check execution to determine what port would be checked.

        """

        if not health_check:

            return expected_port

        

        # Check for ${PORT} usage in health check

        if '${PORT' in health_check:

            return expected_port

        

        # Check for hardcoded port

        import re

        port_match = re.search(r'localhost:(\d+)', health_check)

        if port_match:

            return int(port_match.group(1))

        

        return expected_port





if __name__ == '__main__':

    pytest.main([__file__, '-v'])

