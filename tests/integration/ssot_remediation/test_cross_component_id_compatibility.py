"""
Cross-Component ID Compatibility Test - SSOT Validation

This test validates that WebSocket factory generates IDs compatible with database lookups,
ensuring the dual SSOT violation doesn't cause ID mismatches between components.

Business Value:
- Critical for $500K+ ARR protection - prevents WebSocket 1011 errors
- Ensures Golden Path user flow works end-to-end
- Validates ID compatibility across WebSocket and database layers

SSOT Validation:
- Tests that WebSocket factory uses UnifiedIdGenerator (not uuid.uuid4())
- Validates RequestScopedSessionFactory also uses UnifiedIdGenerator
- Ensures IDs generated by different components are cross-compatible

Expected Behavior:
- BEFORE REMEDIATION: Should FAIL - components use different ID generation systems
- AFTER REMEDIATION: Should PASS - all components use UnifiedIdGenerator SSOT
"""

import asyncio
import uuid
from typing import Dict, Any, Optional

from test_framework.ssot.base_test_case import SSotBaseTestCase
from netra_backend.app.websocket_core.websocket_manager_factory import create_websocket_manager
from netra_backend.app.database.request_scoped_session_factory import RequestScopedSessionFactory
from shared.id_generation.unified_id_generator import UnifiedIdGenerator
from shared.types.core_types import UserID, ThreadID, WebSocketID, ensure_user_id, ensure_thread_id


class TestCrossComponentIdCompatibility(SSotBaseTestCase):
    """Test cross-component ID compatibility for SSOT validation."""

    def setup_method(self, method=None):
        """Set up test environment with components."""
        super().setup_method(method)
        self.unified_id_generator = UnifiedIdGenerator()
        self.websocket_factory = None
        self.session_factory = None

    def teardown_method(self, method=None):
        """Clean up test resources."""
        if self.websocket_factory:
            # Clean up any resources
            pass
        super().teardown_method(method)

    def test_websocket_factory_uses_unified_id_generator(self):
        """
        Test that WebSocket factory uses UnifiedIdGenerator for ID generation.
        
        This test validates the first part of the dual SSOT violation:
        WebSocket components must use UnifiedIdGenerator, not uuid.uuid4() directly.
        
        Expected to FAIL before SSOT remediation.
        """
        # Generate test IDs using unified generator
        thread_id_str, run_id_str, request_id_str = self.unified_id_generator.generate_user_context_ids("test-user", "ssot-test")
        user_id_str = self.unified_id_generator.generate_base_id("user")
        
        user_id = ensure_user_id(user_id_str)
        thread_id = ensure_thread_id(thread_id_str)
        
        # Record metrics
        self.record_metric("user_id_generated", user_id_str)
        self.record_metric("thread_id_generated", thread_id_str)
        
        # Create WebSocket manager through factory
        websocket_manager = create_websocket_manager(
            user_id=user_id
        )
        
        # Validate that WebSocket manager has proper ID references
        self.assertIsNotNone(websocket_manager, "WebSocket manager should be created successfully")
        
        # Check for SSOT violation indicators
        # This is where we detect if WebSocket factory is using uuid.uuid4() instead of UnifiedIdGenerator
        try:
            # If the WebSocket manager has any UUID4-generated IDs, they won't be compatible
            # with database lookup patterns
            manager_internal_ids = self._extract_manager_internal_ids(websocket_manager)
            
            # Validate all internal IDs follow UnifiedIdGenerator patterns
            for id_name, id_value in manager_internal_ids.items():
                is_compatible = self._validate_id_compatibility_with_database(id_value)
                
                self.assertTrue(
                    is_compatible,
                    f"WebSocket manager {id_name} ID '{id_value}' not compatible with database lookup patterns. "
                    "This indicates WebSocket factory is not using UnifiedIdGenerator (SSOT violation)."
                )
                
                self.record_metric(f"id_compatibility_{id_name}", is_compatible)
        
        except Exception as e:
            # This is the expected failure mode before SSOT remediation
            self.record_metric("websocket_factory_ssot_violation", True)
            self.record_metric("failure_reason", str(e))
            
            # Provide clear diagnostic information
            raise AssertionError(
                f"WebSocket factory SSOT violation detected: {e}. "
                "WebSocket components are not using UnifiedIdGenerator for ID generation. "
                "This breaks ID compatibility with database lookups and causes WebSocket 1011 errors."
            )

    def test_request_scoped_session_factory_uses_unified_id_generator(self):
        """
        Test that RequestScopedSessionFactory uses UnifiedIdGenerator.
        
        This validates the second part of the dual SSOT violation:
        Database session factory must use UnifiedIdGenerator consistently.
        
        Expected to PASS (this component should already be SSOT compliant).
        """
        # Create session factory
        session_factory = RequestScopedSessionFactory()
        
        # Generate test user context
        user_id = self.unified_id_generator.generate_base_id("user")
        
        try:
            # Test session creation with unified IDs
            with session_factory.create_request_context(user_id=user_id) as session_context:
                # Validate session context uses compatible ID patterns
                session_id = session_context.get_session_id()
                
                # Check that session ID follows UnifiedIdGenerator patterns
                is_compatible = self._validate_id_compatibility_with_database(session_id)
                
                self.assertTrue(
                    is_compatible,
                    f"RequestScopedSessionFactory session ID '{session_id}' not compatible with UnifiedIdGenerator patterns. "
                    "This indicates database factory is not using SSOT ID generation."
                )
                
                self.record_metric("session_factory_uses_unified_generator", True)
                self.record_metric("session_id_compatible", is_compatible)
                
        except Exception as e:
            self.record_metric("session_factory_ssot_violation", True)
            self.record_metric("failure_reason", str(e))
            
            raise AssertionError(
                f"RequestScopedSessionFactory SSOT violation detected: {e}. "
                "Database session factory is not using UnifiedIdGenerator consistently."
            )

    def test_cross_component_id_lookup_compatibility(self):
        """
        Test that IDs generated by WebSocket factory can be looked up by database components.
        
        This is the integration test that validates the complete SSOT remediation:
        IDs from WebSocket components should be findable by database queries.
        
        Expected to FAIL before SSOT remediation due to ID format incompatibility.
        """
        # Generate IDs through WebSocket factory path
        thread_id_str, run_id_str, request_id_str = self.unified_id_generator.generate_user_context_ids("test-user", "cross-lookup")
        user_id = ensure_user_id(self.unified_id_generator.generate_base_id("user"))
        thread_id = ensure_thread_id(thread_id_str)
        
        # Create WebSocket manager (this may use different ID generation internally)
        websocket_manager = create_websocket_manager(
            user_id=user_id
        )
        
        # Extract any additional IDs that WebSocket factory generates internally
        websocket_internal_ids = self._extract_manager_internal_ids(websocket_manager)
        
        # Create database session factory
        session_factory = RequestScopedSessionFactory()
        
        try:
            # Test database lookups using WebSocket-generated IDs
            with session_factory.create_request_context(user_id=str(user_id)) as session_context:
                session = session_context.get_session()
                
                # Attempt to use WebSocket IDs in database queries
                for id_name, websocket_id in websocket_internal_ids.items():
                    lookup_success = self._test_database_lookup_compatibility(session, websocket_id, id_name)
                    
                    self.assertTrue(
                        lookup_success,
                        f"Database cannot lookup WebSocket-generated {id_name} ID '{websocket_id}'. "
                        "This indicates dual SSOT violation: WebSocket and database use different ID systems."
                    )
                    
                    self.record_metric(f"cross_lookup_success_{id_name}", lookup_success)
                
                # If we get here, cross-component compatibility is working
                self.record_metric("cross_component_compatibility", True)
                
        except Exception as e:
            self.record_metric("cross_component_compatibility", False)
            self.record_metric("lookup_failure_reason", str(e))
            
            raise AssertionError(
                f"Cross-component ID compatibility FAILED: {e}. "
                "WebSocket and database components use incompatible ID generation systems. "
                "This dual SSOT violation causes WebSocket 1011 errors and breaks Golden Path flow."
            )

    def _extract_manager_internal_ids(self, websocket_manager) -> Dict[str, str]:
        """
        Extract internal IDs generated by WebSocket manager for testing.
        
        Returns:
            Dictionary mapping ID names to ID values
        """
        internal_ids = {}
        
        # Extract common internal IDs that WebSocket manager might generate
        if hasattr(websocket_manager, 'connection_id'):
            internal_ids['connection_id'] = websocket_manager.connection_id
        
        if hasattr(websocket_manager, 'session_id'):
            internal_ids['session_id'] = websocket_manager.session_id
            
        if hasattr(websocket_manager, 'manager_id'):
            internal_ids['manager_id'] = websocket_manager.manager_id
        
        # If no internal IDs found, generate a test ID to validate the pattern
        if not internal_ids:
            # This tests if the WebSocket manager's ID generation methods use SSOT
            try:
                if hasattr(websocket_manager, 'generate_connection_id'):
                    internal_ids['connection_id'] = websocket_manager.generate_connection_id()
                else:
                    # Fallback: test with manager's string representation or a default
                    internal_ids['manager_instance'] = str(websocket_manager)[:36]  # UUID length
            except Exception:
                internal_ids['fallback_test'] = "websocket_test_id_123"
        
        return internal_ids

    def _validate_id_compatibility_with_database(self, id_value: str) -> bool:
        """
        Validate that an ID follows patterns compatible with database lookups.
        
        This checks if the ID format matches UnifiedIdGenerator patterns
        rather than raw uuid.uuid4() patterns.
        
        Args:
            id_value: ID to validate
            
        Returns:
            True if compatible with database lookup patterns
        """
        if not id_value or not isinstance(id_value, str):
            return False
        
        # Check for UnifiedIdGenerator patterns (structured IDs)
        # UnifiedIdGenerator typically creates IDs like: "user_1_abc12345" 
        structured_pattern = len(id_value.split('_')) >= 3
        
        # Check for raw UUID4 pattern (this indicates SSOT violation)
        try:
            uuid_obj = uuid.UUID(id_value)
            is_raw_uuid4 = str(uuid_obj) == id_value
        except ValueError:
            is_raw_uuid4 = False
        
        # Compatible if it's structured OR if it's not a raw UUID4
        # (allows for other valid ID formats during migration)
        is_compatible = structured_pattern or not is_raw_uuid4
        
        # Record diagnostic info
        self.record_metric(f"id_format_structured_{id_value[:8]}", structured_pattern)
        self.record_metric(f"id_format_raw_uuid_{id_value[:8]}", is_raw_uuid4)
        
        return is_compatible

    def _test_database_lookup_compatibility(self, session, websocket_id: str, id_name: str) -> bool:
        """
        Test if a WebSocket-generated ID can be used in database lookups.
        
        Args:
            session: Database session
            websocket_id: ID generated by WebSocket component
            id_name: Name/type of the ID for logging
            
        Returns:
            True if the ID can be used successfully in database operations
        """
        try:
            # Test basic ID format compatibility
            if not self._validate_id_compatibility_with_database(websocket_id):
                return False
            
            # Test that the ID can be used in SQL operations without errors
            # This is a safe way to test ID compatibility without actual data
            id_length = len(websocket_id)
            id_type_valid = isinstance(websocket_id, str) and len(websocket_id) > 0
            
            # Record compatibility metrics
            self.record_metric(f"db_id_length_valid_{id_name}", id_length > 0)
            self.record_metric(f"db_id_type_valid_{id_name}", id_type_valid)
            
            # If ID is a raw UUID4, it indicates SSOT violation
            try:
                uuid_obj = uuid.UUID(websocket_id)
                is_raw_uuid4 = str(uuid_obj) == websocket_id
                if is_raw_uuid4:
                    self.record_metric(f"db_lookup_uuid4_violation_{id_name}", True)
                    return False
            except ValueError:
                # Not a UUID, which is fine for structured IDs
                pass
            
            return True
            
        except Exception as e:
            self.record_metric(f"db_lookup_error_{id_name}", str(e))
            return False

    def test_ssot_id_generation_consistency(self):
        """
        Test that all components consistently use the same ID generation SSOT.
        
        This is a comprehensive test that validates the complete SSOT pattern
        across WebSocket and database components.
        """
        # Test 1: Both components should use UnifiedIdGenerator
        unified_thread_id, unified_run_id, unified_request_id = self.unified_id_generator.generate_user_context_ids("ssot-consistency", "test")
        unified_user_id = self.unified_id_generator.generate_base_id("user")
        
        # Test 2: WebSocket factory should accept unified IDs without issues
        websocket_manager = create_websocket_manager(
            user_id=ensure_user_id(unified_user_id)
        )
        
        # Test 3: Database factory should accept unified IDs without issues
        session_factory = RequestScopedSessionFactory()
        
        try:
            with session_factory.create_request_context(user_id=unified_user_id) as session_context:
                # If both components use SSOT, this should work seamlessly
                session_id = session_context.get_session_id()
                
                # Both IDs should be compatible
                websocket_compatible = self._validate_id_compatibility_with_database(unified_user_id)
                session_compatible = self._validate_id_compatibility_with_database(session_id)
                
                self.assertTrue(
                    websocket_compatible and session_compatible,
                    f"SSOT ID consistency FAILED: WebSocket compatible={websocket_compatible}, "
                    f"Session compatible={session_compatible}. "
                    "Components are not using consistent SSOT ID generation."
                )
                
                self.record_metric("ssot_consistency_achieved", True)
                
        except Exception as e:
            self.record_metric("ssot_consistency_achieved", False)
            self.record_metric("consistency_failure", str(e))
            
            raise AssertionError(
                f"SSOT ID generation consistency FAILED: {e}. "
                "WebSocket and database components do not use consistent SSOT patterns. "
                "This dual SSOT violation must be remediated to fix WebSocket 1011 errors."
            )
