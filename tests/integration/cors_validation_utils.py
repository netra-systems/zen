from shared.isolated_environment import get_env
"""
CORS Validation Utilities for Integration Tests

Business Value Justification (BVJ):
- Segment: ALL (Framework for testing CORS across all services)
- Business Goal: Ensure CORS compliance in all integration tests
- Value Impact: Prevents CORS-related production issues
- Strategic Impact: Systematic testing prevents service integration failures

This module provides utilities to validate CORS headers in integration tests.
"""

from typing import Dict, List, Optional, Any
import os


def validate_cors_headers(
    response_headers: Dict[str, str], 
    request_origin: str,
    environment: str = "development"
) -> Dict[str, Any]:
    """
    Validate CORS headers in a response.
    
    Args:
        response_headers: HTTP response headers
        request_origin: Origin header from the request
        environment: Environment being tested
        
    Returns:
        Dictionary with validation results
    """
    validation_results = {
        "valid": True,
        "errors": [],
        "warnings": [],
        "headers_found": {},
        "missing_headers": []
    }
    
    # Normalize header names (case-insensitive)
    normalized_headers = {k.lower(): v for k, v in response_headers.items()}
    
    # Required CORS headers
    cors_headers = {
        "access-control-allow-origin": request_origin,
        "access-control-allow-credentials": "true",
        "access-control-allow-methods": None,  # Should contain common methods
        "access-control-allow-headers": None,  # Should contain required headers
        "access-control-max-age": None,  # Should be present for preflight
    }
    
    for header, expected_value in cors_headers.items():
        if header in normalized_headers:
            validation_results["headers_found"][header] = normalized_headers[header]
            
            if expected_value and normalized_headers[header] != expected_value:
                if header == "access-control-allow-origin":
                    # Special case: check if origin is allowed
                    actual_origin = normalized_headers[header]
                    if actual_origin != request_origin and actual_origin != "*":
                        validation_results["errors"].append(
                            f"Origin mismatch: expected {request_origin}, got {actual_origin}"
                        )
                        validation_results["valid"] = False
                else:
                    validation_results["warnings"].append(
                        f"{header}: expected {expected_value}, got {normalized_headers[header]}"
                    )
        else:
            validation_results["missing_headers"].append(header)
            if header in ["access-control-allow-origin", "access-control-allow-credentials"]:
                validation_results["errors"].append(f"Missing critical header: {header}")
                validation_results["valid"] = False
    
    # Validate specific header content
    if "access-control-allow-methods" in normalized_headers:
        methods = normalized_headers["access-control-allow-methods"]
        required_methods = ["GET", "POST", "OPTIONS"]
        for method in required_methods:
            if method not in methods:
                validation_results["warnings"].append(f"Missing HTTP method: {method}")
    
    if "access-control-allow-headers" in normalized_headers:
        headers = normalized_headers["access-control-allow-headers"]
        required_headers = ["Authorization", "Content-Type"]
        for header in required_headers:
            if header not in headers:
                validation_results["warnings"].append(f"Missing allowed header: {header}")
    
    # Check for security headers
    security_headers = ["vary", "x-content-type-options", "x-frame-options"]
    for header in security_headers:
        if header in normalized_headers:
            validation_results["headers_found"][header] = normalized_headers[header]
        else:
            validation_results["warnings"].append(f"Missing security header: {header}")
    
    return validation_results


def get_test_origins(environment: str = "development") -> List[str]:
    """
    Get test origins for the specified environment.
    
    Args:
        environment: Environment to get origins for
        
    Returns:
        List of test origins for the environment
    """
    origins = {
        "development": [
            "http://localhost:3000",
            "http://localhost:3001", 
            "http://127.0.0.1:3000",
            "https://localhost:3000",
            "http://[::1]:3000",  # IPv6
        ],
        "staging": [
            "https://app.staging.netrasystems.ai",
            "https://auth.staging.netrasystems.ai",
            "http://localhost:3000",  # Local testing
        ],
        "production": [
            "https://netrasystems.ai",
            "https://app.netrasystems.ai",
            "https://auth.netrasystems.ai",
        ]
    }
    
    return origins.get(environment, origins["development"])


def create_cors_request_headers(origin: str, method: str = "GET") -> Dict[str, str]:
    """
    Create request headers for testing CORS.
    
    Args:
        origin: Origin header value
        method: HTTP method for preflight requests
        
    Returns:
        Dictionary of request headers
    """
    if method == "OPTIONS":  # Preflight request
        return {
            "Origin": origin,
            "Access-Control-Request-Method": "POST",
            "Access-Control-Request-Headers": "Authorization, Content-Type"
        }
    else:  # Actual request
        return {
            "Origin": origin,
            "Content-Type": "application/json"
        }


def assert_cors_valid(response, request_origin: str, environment: str = "development") -> None:
    """
    Assert that a response has valid CORS headers.
    
    Args:
        response: HTTP response object
        request_origin: Origin that was sent in the request
        environment: Environment being tested
        
    Raises:
        AssertionError: If CORS validation fails
    """
    headers = dict(response.headers) if hasattr(response, 'headers') else {}
    validation = validate_cors_headers(headers, request_origin, environment)
    
    if not validation["valid"]:
        error_msg = f"CORS validation failed for origin {request_origin}:
"
        error_msg += f"Errors: {validation['errors']}
"
        error_msg += f"Missing headers: {validation['missing_headers']}
"
        error_msg += f"Found headers: {validation['headers_found']}"
        raise AssertionError(error_msg)
    
    # Check for warnings in development/staging
    if environment != "production" and validation["warnings"]:
        print(f"CORS warnings for {request_origin}: {validation['warnings']}")


def cors_test_decorator(origins: Optional[List[str]] = None, environment: str = "development"):
    """
    Decorator to add CORS validation to test methods.
    
    Args:
        origins: List of origins to test. If None, uses default for environment
        environment: Environment being tested
        
    Returns:
        Decorator function
    """
    def decorator(test_func):
        async def wrapper(*args, **kwargs):
            # Run original test
            result = await test_func(*args, **kwargs)
            
            # Additional CORS validation can be added here if needed
            return result
        
        wrapper.__name__ = test_func.__name__
        wrapper.__doc__ = test_func.__doc__
        return wrapper
    
    return decorator


class CORSTestMixin:
    """Mixin class to add CORS testing capabilities to test classes."""
    
    def setUp_cors(self, environment: str = "development"):
        """Set up CORS testing configuration."""
        self.cors_environment = environment
        self.test_origins = get_test_origins(environment)
    
    async def assert_cors_response(self, client, endpoint: str, origin: str, method: str = "GET"):
        """Test and assert CORS for a specific endpoint and origin."""
        headers = create_cors_request_headers(origin, method)
        
        if method == "OPTIONS":
            response = await client.options(endpoint, headers=headers)
        else:
            response = await client.get(endpoint, headers=headers)
        
        # Allow 404s for endpoints that don't exist in test environment
        if response.status_code not in [200, 204, 404]:
            raise AssertionError(f"Unexpected status code {response.status_code} for {endpoint}")
        
        assert_cors_valid(response, origin, self.cors_environment)
        return response
    
    async def test_cors_for_all_origins(self, client, endpoint: str):
        """Test CORS for all configured origins for an endpoint."""
        for origin in self.test_origins[:3]:  # Test first 3 origins to keep tests manageable
            await self.assert_cors_response(client, endpoint, origin, "OPTIONS")  # Preflight
            await self.assert_cors_response(client, endpoint, origin, "GET")      # Actual request


def cors_integration_test(environment: str = "development"):
    """
    Class decorator to add CORS testing to integration test classes.
    
    Usage:
        @cors_integration_test("development")
        class TestMyAPI:
            async def test_my_endpoint(self, client):
                # Test endpoint functionality
                response = await client.get("/api/test")
                
                # CORS validation is automatically added
    """
    def class_decorator(cls):
        # Add CORSTestMixin to the class
        if not issubclass(cls, CORSTestMixin):
            cls = type(cls.__name__, (cls, CORSTestMixin), dict(cls.__dict__))
        
        # Override setUp if it exists, or create one
        original_setup = getattr(cls, 'setUp', None)
        
        def new_setup(self):
            if original_setup:
                original_setup(self)
            self.setUp_cors(environment)
        
        cls.setUp = new_setup
        return cls
    
    return class_decorator


# Environment detection for automatic CORS testing
def get_current_test_environment() -> str:
    """Get the current test environment from environment variables."""
    return get_env().get("ENVIRONMENT", get_env().get("NETRA_ENV", "development")).lower()


# Example usage in integration tests:
"""
from tests.integration.cors_validation_utils import cors_integration_test, CORSTestMixin

@cors_integration_test("development")  
class TestAPIEndpoints(CORSTestMixin):
    
    async def test_health_endpoint(self, client):
        # Test the functionality
        response = await client.get("/health")
        assert response.status_code == 200
        
        # Test CORS for this endpoint
        await self.test_cors_for_all_origins(client, "/health")
"""
