"""Integration test demonstrating DeepAgentState user isolation vulnerability.

CRITICAL SECURITY VULNERABILITY: Issue #271 - DeepAgentState User Isolation Failure

This test reproduces the real security vulnerability where DeepAgentState instances
can leak data between users due to shared state and mutable objects.

Business Value Justification:
- Segment: ALL (Free â†’ Enterprise) 
- Business Goal: Critical Security & User Data Protection
- Value Impact: Prevents $500K+ ARR loss from data breaches and user trust loss
- Revenue Impact: Protects enterprise customers ($15K+ MRR) from data exposure

VULNERABILITY AREAS TESTED:
1. Cross-user data leakage (User A's data appearing in User B's results)
2. Shared state pollution (concurrent modifications affecting other users)
3. Memory reference sharing (same object references between users)
4. Session boundary violations (context bleeding between user sessions)

EXPECTED OUTCOME: These tests should FAIL initially, proving the vulnerability exists.
"""

import asyncio
import pytest
import time
import uuid
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, Any, List, Set, Optional
from unittest.mock import MagicMock, AsyncMock, patch

from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.agents.state import DeepAgentState
from netra_backend.app.agents.base_agent import BaseAgent
from netra_backend.app.services.user_execution_context import UserExecutionContext
from shared.types.core_types import UserID, ThreadID, RunID


class TestDeepAgentStateUserIsolationVulnerability(SSotAsyncTestCase):
    """Test demonstrating the critical user isolation vulnerability in DeepAgentState.
    
    SECURITY WARNING: These tests prove that DeepAgentState allows user data
    to leak between concurrent executions, violating user privacy and security.
    """
    
    def setUp(self):
        """Set up test with clean state isolation."""
        super().setUp()
        self.user_a_id = "user_a_12345"
        self.user_b_id = "user_b_67890"
        self.user_c_id = "user_c_abcde"
        
        # Track shared state pollution
        self.shared_pollution_tracker = {}
        self.memory_reference_tracker = {}
        
    async def test_concurrent_user_deepagentstate_data_leakage(self):
        """
        CRITICAL VULNERABILITY TEST: Demonstrates cross-user data leakage.
        
        This test proves that when multiple users execute agents concurrently,
        DeepAgentState allows User A's sensitive data to appear in User B's results.
        
        EXPECTED: This test should FAIL - proving the vulnerability exists.
        """
        
        # Simulate sensitive user data
        user_a_sensitive_data = {
            "user_request": "Find my personal financial optimization opportunities",
            "triage_result": {"classification": "PRIVATE_FINANCE", "confidence": 0.95},
            "optimizations_result": {
                "optimization_type": "personal_finance",
                "recommendations": ["Reduce spending on luxury items", "Invest in retirement accounts"],
                "cost_savings": 15000.0,
                "confidence_score": 0.9
            },
            "private_api_keys": "sk-user-a-secret-12345",
            "personal_data": "Social Security: 123-45-6789"
        }
        
        user_b_sensitive_data = {
            "user_request": "Analyze my corporate supply chain optimization", 
            "triage_result": {"classification": "CORPORATE_SUPPLY", "confidence": 0.88},
            "optimizations_result": {
                "optimization_type": "supply_chain",
                "recommendations": ["Optimize vendor contracts", "Reduce logistics costs"],
                "cost_savings": 250000.0,
                "confidence_score": 0.85
            },
            "private_api_keys": "sk-user-b-corporate-67890",
            "corporate_data": "Employee Count: 500, Revenue: $50M"
        }
        
        # Track results for cross-contamination
        execution_results = {}
        contamination_found = False
        
        async def execute_user_workflow(user_id: str, sensitive_data: Dict[str, Any]) -> Dict[str, Any]:
            """Simulate user workflow with DeepAgentState - VULNERABLE pattern."""
            
            # Create DeepAgentState with user-specific data (VULNERABLE)
            state = DeepAgentState(
                user_id=user_id,
                user_request=sensitive_data["user_request"],
                chat_thread_id=f"thread_{user_id}_{uuid.uuid4()}",
                run_id=str(uuid.uuid4()),
                agent_input={"sensitive_data": sensitive_data}
            )
            
            # Simulate agent processing that modifies state (VULNERABLE)
            if "triage_result" in sensitive_data:
                state.triage_result = sensitive_data["triage_result"]
            
            if "optimizations_result" in sensitive_data:
                from netra_backend.app.agents.state import OptimizationsResult
                state.optimizations_result = OptimizationsResult(**sensitive_data["optimizations_result"])
            
            # Simulate additional processing that might cause pollution
            state.context_tracking = {
                "api_keys": sensitive_data.get("private_api_keys"),
                "personal_info": sensitive_data.get("personal_data", sensitive_data.get("corporate_data"))
            }
            
            # Add to global tracking (simulating shared memory vulnerability)
            state.metadata.custom_fields["execution_timestamp"] = time.time()
            state.metadata.custom_fields["user_sensitive_marker"] = f"PRIVATE_DATA_{user_id}"
            
            # Small delay to simulate processing and increase race condition likelihood
            await asyncio.sleep(0.1)
            
            # Return state data for analysis
            return {
                "user_id": user_id,
                "state_dict": state.to_dict(),
                "triage_result": state.triage_result,
                "optimizations_result": state.optimizations_result,
                "context_tracking": state.context_tracking,
                "metadata": state.metadata.model_dump(),
                "memory_id": id(state),  # Track object identity
                "private_markers": [
                    sensitive_data.get("private_api_keys"),
                    sensitive_data.get("personal_data"),
                    sensitive_data.get("corporate_data")
                ]
            }
        
        # Execute concurrent workflows (simulating real production scenario)
        tasks = [
            execute_user_workflow(self.user_a_id, user_a_sensitive_data),
            execute_user_workflow(self.user_b_id, user_b_sensitive_data),
            # Add a third user to increase complexity
            execute_user_workflow(self.user_c_id, {
                "user_request": "Standard analytics request",
                "private_api_keys": "sk-user-c-standard-abcde",
                "personal_data": "Phone: 555-123-4567"
            })
        ]
        
        # Run concurrently to trigger race conditions
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Analyze results for cross-user contamination
        for result in results:
            if isinstance(result, Exception):
                self.fail(f"Execution failed with exception: {result}")
            
            user_id = result["user_id"]
            execution_results[user_id] = result
            
            # Check for contamination from other users
            for other_user_id, other_result in execution_results.items():
                if other_user_id != user_id:
                    # Check if current user's data contains other user's private data
                    contamination_found = self._check_cross_user_contamination(
                        result, other_result, user_id, other_user_id
                    )
                    if contamination_found:
                        break
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        self.assertFalse(
            contamination_found,
            f"ðŸš¨ CRITICAL VULNERABILITY DETECTED: Cross-user data contamination found! "
            f"User data is leaking between DeepAgentState instances. "
            f"This proves Issue #271 vulnerability exists. "
            f"Results: {execution_results}"
        )
    
    def _check_cross_user_contamination(
        self,
        user_result: Dict[str, Any],
        other_user_result: Dict[str, Any],
        user_id: str,
        other_user_id: str
    ) -> bool:
        """Check if user's result contains data from another user."""
        
        user_state_str = str(user_result["state_dict"])
        other_private_markers = other_user_result["private_markers"]
        
        # Check for direct private data leakage
        for private_marker in other_private_markers:
            if private_marker and private_marker in user_state_str:
                self.test_logger.error(
                    f"ðŸš¨ VULNERABILITY: User {user_id} data contains private marker "
                    f"'{private_marker}' from User {other_user_id}"
                )
                return True
        
        # Check for API key contamination
        if (other_user_result.get("context_tracking", {}).get("api_keys") and
            other_user_result["context_tracking"]["api_keys"] in user_state_str):
            self.test_logger.error(
                f"ðŸš¨ VULNERABILITY: User {user_id} has access to User {other_user_id}'s API keys"
            )
            return True
        
        # Check for personal info contamination
        other_personal = other_user_result.get("context_tracking", {}).get("personal_info")
        if other_personal and other_personal in user_state_str:
            self.test_logger.error(
                f"ðŸš¨ VULNERABILITY: User {user_id} has access to User {other_user_id}'s personal data"
            )
            return True
        
        return False
    
    async def test_deepagentstate_shared_object_reference_vulnerability(self):
        """
        CRITICAL VULNERABILITY TEST: Demonstrates shared object reference pollution.
        
        This test proves that DeepAgentState instances can share object references,
        allowing modifications by one user to affect another user's data.
        
        EXPECTED: This test should FAIL - proving the vulnerability exists.
        """
        
        # Create base shared data that could be referenced
        shared_metadata_template = {
            "execution_context": {"environment": "production"},
            "custom_fields": {"shared_resource": "database_pool_1"}
        }
        
        user_states = []
        object_ids = set()
        
        # Create multiple user states and track object identities
        for i, user_id in enumerate([self.user_a_id, self.user_b_id, self.user_c_id]):
            state = DeepAgentState(
                user_id=user_id,
                user_request=f"Request from {user_id}",
                chat_thread_id=f"thread_{user_id}_{i}",
                run_id=str(uuid.uuid4())
            )
            
            # Simulate metadata sharing (VULNERABLE pattern)
            state.metadata.execution_context.update(shared_metadata_template["execution_context"])
            state.metadata.custom_fields.update(shared_metadata_template["custom_fields"])
            
            user_states.append(state)
            
            # Track object identities
            object_ids.add(id(state.metadata))
            object_ids.add(id(state.metadata.execution_context))
            object_ids.add(id(state.metadata.custom_fields))
        
        # Modify one user's data and check if it affects others (VULNERABILITY TEST)
        user_a_state = user_states[0]
        user_a_state.metadata.custom_fields["user_a_secret"] = "CONFIDENTIAL_A_12345"
        user_a_state.metadata.execution_context["user_a_session"] = "session_a_secret"
        
        contamination_detected = False
        
        # Check if User A's modifications appear in other users' states
        for i, state in enumerate(user_states[1:], 1):
            user_id = [self.user_b_id, self.user_c_id][i-1]
            
            # Check for secret contamination
            if ("user_a_secret" in state.metadata.custom_fields or
                "user_a_session" in state.metadata.execution_context):
                
                contamination_detected = True
                self.test_logger.error(
                    f"ðŸš¨ VULNERABILITY: User A's secret data found in User {user_id}'s state! "
                    f"custom_fields: {state.metadata.custom_fields}, "
                    f"execution_context: {state.metadata.execution_context}"
                )
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        self.assertFalse(
            contamination_detected,
            f"ðŸš¨ CRITICAL VULNERABILITY: Shared object reference pollution detected! "
            f"User A's modifications are visible to other users. "
            f"Object IDs: {object_ids}, States: {[s.to_dict() for s in user_states]}"
        )
        
        # Additional check: Ensure object identities are unique (proper isolation)
        unique_object_count = len(object_ids)
        expected_unique_objects = len(user_states) * 3  # state.metadata, execution_context, custom_fields
        
        self.assertEqual(
            unique_object_count,
            expected_unique_objects,
            f"ðŸš¨ VULNERABILITY: Object sharing detected! Expected {expected_unique_objects} "
            f"unique objects, but found only {unique_object_count}. "
            f"This indicates memory reference sharing between users."
        )
    
    async def test_deepagentstate_mutable_state_race_condition(self):
        """
        CRITICAL VULNERABILITY TEST: Demonstrates mutable state race conditions.
        
        This test proves that concurrent modifications to DeepAgentState can
        create race conditions where user data gets mixed or corrupted.
        
        EXPECTED: This test should FAIL - proving the vulnerability exists.
        """
        
        # Shared state that could be modified by multiple users
        base_state = DeepAgentState(
            user_id="initial_user",
            user_request="Base request",
            chat_thread_id="base_thread",
            run_id=str(uuid.uuid4())
        )
        
        modification_results = []
        race_condition_detected = False
        
        async def concurrent_state_modifier(user_id: str, modification_data: Dict[str, Any]) -> Dict[str, Any]:
            """Simulate concurrent state modifications that could cause races."""
            
            # Simulate the VULNERABLE pattern where states might be shared
            working_state = base_state  # VULNERABILITY: Direct reference sharing
            
            # Perform user-specific modifications
            working_state.user_id = user_id
            working_state.user_request = modification_data["request"]
            
            # Simulate processing delay
            await asyncio.sleep(0.05)
            
            # Add user-specific results
            working_state.metadata.custom_fields[f"{user_id}_data"] = modification_data["sensitive_data"]
            working_state.context_tracking[f"{user_id}_context"] = modification_data["context"]
            
            # Another delay to increase race likelihood
            await asyncio.sleep(0.05)
            
            # Final state capture
            final_state = {
                "user_id": working_state.user_id,
                "user_request": working_state.user_request,
                "custom_fields": working_state.metadata.custom_fields.copy(),
                "context_tracking": working_state.context_tracking.copy(),
                "memory_id": id(working_state)
            }
            
            return final_state
        
        # Define user modification data
        user_modifications = {
            self.user_a_id: {
                "request": "User A financial analysis",
                "sensitive_data": "A_FINANCIAL_SECRET_123",
                "context": "A_PRIVATE_CONTEXT"
            },
            self.user_b_id: {
                "request": "User B supply chain optimization", 
                "sensitive_data": "B_SUPPLY_SECRET_456",
                "context": "B_CORPORATE_CONTEXT"
            },
            self.user_c_id: {
                "request": "User C market research",
                "sensitive_data": "C_MARKET_SECRET_789", 
                "context": "C_RESEARCH_CONTEXT"
            }
        }
        
        # Execute concurrent modifications
        tasks = [
            concurrent_state_modifier(user_id, data)
            for user_id, data in user_modifications.items()
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Analyze results for race condition artifacts
        for result in results:
            if isinstance(result, Exception):
                self.fail(f"State modification failed: {result}")
            modification_results.append(result)
        
        # Check for race condition indicators
        memory_ids = [r["memory_id"] for r in modification_results]
        unique_memory_ids = set(memory_ids)
        
        # VULNERABILITY: If same object used, memory IDs will be identical
        if len(unique_memory_ids) < len(modification_results):
            race_condition_detected = True
            self.test_logger.error(
                f"ðŸš¨ VULNERABILITY: Shared memory object detected! "
                f"Memory IDs: {memory_ids}, Results: {modification_results}"
            )
        
        # Check for cross-user data contamination in final states
        for i, result_a in enumerate(modification_results):
            for j, result_b in enumerate(modification_results):
                if i != j:
                    user_a_id = list(user_modifications.keys())[i]
                    user_b_id = list(user_modifications.keys())[j]
                    
                    # Check if User A's data appears in User B's state
                    user_a_sensitive = user_modifications[user_a_id]["sensitive_data"]
                    user_b_fields = str(result_b["custom_fields"]) + str(result_b["context_tracking"])
                    
                    if user_a_sensitive in user_b_fields:
                        race_condition_detected = True
                        self.test_logger.error(
                            f"ðŸš¨ VULNERABILITY: User {user_a_id}'s data found in User {user_b_id}'s state! "
                            f"Sensitive data '{user_a_sensitive}' contaminated User {user_b_id}"
                        )
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        self.assertFalse(
            race_condition_detected,
            f"ðŸš¨ CRITICAL VULNERABILITY: Race condition and shared state pollution detected! "
            f"DeepAgentState is not safe for concurrent multi-user execution. "
            f"Results: {modification_results}"
        )
    
    async def test_deepagentstate_session_boundary_violation(self):
        """
        CRITICAL VULNERABILITY TEST: Demonstrates session boundary violations.
        
        This test proves that DeepAgentState can violate session boundaries,
        allowing data from one user session to persist into another.
        
        EXPECTED: This test should FAIL - proving the vulnerability exists.
        """
        
        session_data_leakage = []
        boundary_violation_detected = False
        
        # Simulate session 1 with User A
        session_1_state = DeepAgentState(
            user_id=self.user_a_id,
            user_request="Session 1 - Private financial data request",
            chat_thread_id="session_1_thread",
            run_id=str(uuid.uuid4())
        )
        
        # Add sensitive session 1 data
        session_1_state.metadata.custom_fields["session_1_secret"] = "USER_A_BANK_ACCOUNT_12345"
        session_1_state.context_tracking["session_1_auth"] = "bearer_token_session_1_secret"
        session_1_state.quality_metrics["session_1_private"] = {"financial_score": 850}
        
        # Simulate session processing
        await asyncio.sleep(0.1)
        
        # Capture session 1 final state
        session_1_final = session_1_state.to_dict()
        
        # Simulate session cleanup (VULNERABLE - insufficient cleanup)
        # In real vulnerability, cleanup is incomplete
        session_1_state.user_id = None  # Partial cleanup
        session_1_state.user_request = "cleaned"  # Partial cleanup
        # NOTE: metadata, context_tracking, quality_metrics not cleaned (VULNERABILITY)
        
        await asyncio.sleep(0.1)
        
        # Simulate session 2 with User B (should be completely isolated)
        session_2_state = DeepAgentState(
            user_id=self.user_b_id,
            user_request="Session 2 - Corporate supply chain analysis",
            chat_thread_id="session_2_thread", 
            run_id=str(uuid.uuid4())
        )
        
        # VULNERABILITY CHECK: If session 1 data persists, it will contaminate session 2
        # Check if any session 1 secrets appear in session 2 state
        session_2_initial = session_2_state.to_dict()
        
        session_1_secrets = [
            "USER_A_BANK_ACCOUNT_12345",
            "bearer_token_session_1_secret",
            "session_1_secret",
            "session_1_auth",
            "session_1_private"
        ]
        
        for secret in session_1_secrets:
            session_2_str = str(session_2_initial)
            if secret in session_2_str:
                boundary_violation_detected = True
                session_data_leakage.append({
                    "leaked_secret": secret,
                    "from_session": "session_1",
                    "to_session": "session_2",
                    "victim_user": self.user_b_id,
                    "source_user": self.user_a_id
                })
                
                self.test_logger.error(
                    f"ðŸš¨ VULNERABILITY: Session boundary violation! "
                    f"Session 1 secret '{secret}' found in Session 2 for User {self.user_b_id}"
                )
        
        # Additional check: Ensure session 2 operations don't modify session 1 residual data
        session_2_state.metadata.custom_fields["session_2_data"] = "USER_B_CORPORATE_DATA"
        session_2_state.context_tracking["session_2_context"] = "corporate_context_b"
        
        # Check if session 1 state was modified by session 2 operations
        session_1_modified = session_1_state.to_dict()
        session_1_modified_str = str(session_1_modified)
        
        if ("USER_B_CORPORATE_DATA" in session_1_modified_str or
            "corporate_context_b" in session_1_modified_str):
            
            boundary_violation_detected = True
            session_data_leakage.append({
                "contamination_type": "reverse_contamination",
                "description": "Session 2 data contaminated Session 1 residuals"
            })
            
            self.test_logger.error(
                f"ðŸš¨ VULNERABILITY: Reverse session contamination detected! "
                f"Session 2 operations modified Session 1 residual data"
            )
        
        # VULNERABILITY ASSERTION: This should FAIL if vulnerability exists
        self.assertFalse(
            boundary_violation_detected,
            f"ðŸš¨ CRITICAL VULNERABILITY: Session boundary violation detected! "
            f"User session data is leaking between sessions. "
            f"Data leakage details: {session_data_leakage}"
        )
        
        # Ensure complete session isolation
        self.assertEqual(
            len(session_data_leakage),
            0,
            f"Session isolation must be complete. Found {len(session_data_leakage)} "
            f"boundary violations: {session_data_leakage}"
        )


if __name__ == '__main__':
    pytest.main([__file__, '-v', '--tb=short'])