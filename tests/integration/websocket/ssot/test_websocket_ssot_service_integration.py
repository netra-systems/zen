"""

Issue #507 - WebSocket SSOT Service Integration Tests



CRITICAL MISSION: Create integration tests for WebSocket SSOT service integration

using real services (staging GCP environment).



PROBLEM: WebSocket URL environment variable duplication causing service integration issues

BUSINESS IMPACT: $500K+ ARR Golden Path chat functionality at risk



TEST DESIGN:

- Integration tests with real services (staging GCP)

- No Docker required - uses staging environment

- Tests service startup and WebSocket configuration integration

- Validates SSOT compliance across service boundaries



Business Value: Platform/Internal - System Integration & Service Reliability

Ensures WebSocket services integrate correctly with SSOT configuration.

"""



import pytest

import asyncio

import time

from unittest.mock import patch

from test_framework.ssot.base_test_case import SSotAsyncTestCase, SsotTestMetrics

from shared.isolated_environment import IsolatedEnvironment, get_env





@pytest.mark.integration

@pytest.mark.staging

class TestWebSocketSSOTServiceIntegration(SSotAsyncTestCase):

    """Integration tests for WebSocket SSOT service integration (Issue #507)"""



    def setup_method(self, method):

        """Setup for each test method using SSOT async pattern"""

        super().setup_method(method)

        self.env = IsolatedEnvironment() 

        self.metrics = SsotTestMetrics()

        self.staging_config = {

            "ENVIRONMENT": "staging",

            "NEXT_PUBLIC_WS_URL": "wss://api.staging.netrasystems.ai/ws",

            "BACKEND_URL": "https://api.staging.netrasystems.ai",

            "AUTH_SERVICE_URL": "https://auth.staging.netrasystems.ai"

        }



    def teardown_method(self, method):

        """Teardown for each test method"""

        super().teardown_method(method)



    @pytest.mark.asyncio

    async def test_websocket_service_startup_with_ssot_configuration(self):

        """

        Test that WebSocket service starts correctly with SSOT configuration

        

        CRITICAL: Tests service startup uses canonical WebSocket URL configuration

        """

        with patch.dict('os.environ', self.staging_config, clear=False):

            env = IsolatedEnvironment()

            

            # Simulate service startup configuration loading

            ws_url = env.get("NEXT_PUBLIC_WS_URL")

            environment = env.get("ENVIRONMENT")

            

            # SSOT VALIDATION: Canonical variable should be used

            assert ws_url is not None, "WebSocket URL should be loaded during service startup"

            assert ws_url == "wss://api.staging.netrasystems.ai/ws", (

                "Service should use canonical staging WebSocket URL"

            )

            

            # SSOT COMPLIANCE: No deprecated variables should be accessed

            deprecated_url = env.get("NEXT_PUBLIC_WEBSOCKET_URL")

            assert deprecated_url is None, (

                "SSOT VIOLATION: Service startup should not access deprecated WebSocket URL variable"

            )

            

            # Validate service configuration consistency

            assert environment == "staging", "Service should recognize staging environment"

            

            self.metrics.custom_metrics["service_startup_success"] = True

            self.metrics.custom_metrics["ssot_compliant"] = True



    @pytest.mark.asyncio

    async def test_websocket_configuration_service_boundary_consistency(self):

        """

        Test WebSocket configuration consistency across service boundaries

        

        Tests that frontend, backend, and auth services use consistent WebSocket URLs

        """

        with patch.dict('os.environ', self.staging_config, clear=False):

            env = IsolatedEnvironment()

            

            # Frontend configuration (Next.js)

            frontend_ws_url = env.get("NEXT_PUBLIC_WS_URL")

            

            # Backend configuration

            backend_url = env.get("BACKEND_URL")

            

            # Auth service configuration

            auth_url = env.get("AUTH_SERVICE_URL")

            

            # SSOT VALIDATION: All services should use consistent domain

            expected_domain = "staging.netrasystems.ai"

            

            assert frontend_ws_url and expected_domain in frontend_ws_url, (

                f"Frontend WebSocket URL should use {expected_domain} domain"

            )

            

            assert backend_url and expected_domain in backend_url, (

                f"Backend URL should use {expected_domain} domain"

            )

            

            assert auth_url and expected_domain in auth_url, (

                f"Auth service URL should use {expected_domain} domain"

            )

            

            # SSOT COMPLIANCE: No service should use deprecated WebSocket variables

            deprecated_vars = ["NEXT_PUBLIC_WEBSOCKET_URL", "WEBSOCKET_URL_DEPRECATED"]

            for var in deprecated_vars:

                deprecated_value = env.get(var)

                assert deprecated_value is None, (

                    f"SSOT VIOLATION: Deprecated variable {var} should not be configured"

                )

            

            self.metrics.custom_metrics["cross_service_consistency"] = True



    @pytest.mark.asyncio 

    async def test_websocket_service_configuration_validation_integration(self):

        """

        Test integration of WebSocket configuration validation across services

        

        CRITICAL: Ensures configuration validation works consistently across service startup

        """

        # Test valid configuration

        valid_config = self.staging_config.copy()

        

        with patch.dict('os.environ', valid_config, clear=False):

            env = IsolatedEnvironment()

            

            # Simulate configuration validation process

            ws_url = env.get("NEXT_PUBLIC_WS_URL")

            environment = env.get("ENVIRONMENT")

            

            # Validate configuration meets requirements

            config_valid = self._validate_websocket_service_config(ws_url, environment)

            

            assert config_valid["is_valid"], (

                f"Valid staging configuration should pass validation: {config_valid['errors']}"

            )

            

            self.metrics.custom_metrics["config_validation_success"] = True

        

        # Test invalid configuration (missing WebSocket URL)

        invalid_config = self.staging_config.copy()

        del invalid_config["NEXT_PUBLIC_WS_URL"]

        

        with patch.dict('os.environ', invalid_config, clear=False):

            env = IsolatedEnvironment()

            

            ws_url = env.get("NEXT_PUBLIC_WS_URL")

            environment = env.get("ENVIRONMENT")

            

            config_valid = self._validate_websocket_service_config(ws_url, environment)

            

            assert not config_valid["is_valid"], (

                "Invalid configuration (missing WebSocket URL) should fail validation"

            )

            

            assert "WebSocket URL is required" in config_valid["errors"], (

                "Validation should detect missing WebSocket URL"

            )



    @pytest.mark.asyncio

    async def test_websocket_service_environment_configuration_integration(self):

        """

        Test WebSocket service configuration for different environments

        

        Tests that service integrates correctly with environment-specific configurations

        """

        environments = {

            "staging": {

                "ENVIRONMENT": "staging",

                "NEXT_PUBLIC_WS_URL": "wss://api.staging.netrasystems.ai/ws",

                "expected_secure": True

            },

            "production": {

                "ENVIRONMENT": "production", 

                "NEXT_PUBLIC_WS_URL": "wss://api.netrasystems.ai/ws",

                "expected_secure": True

            },

            "development": {

                "ENVIRONMENT": "development",

                "NEXT_PUBLIC_WS_URL": "wss://localhost:8000/ws", 

                "expected_secure": True

            }

        }

        

        for env_name, config in environments.items():

            with patch.dict('os.environ', config, clear=False):

                env = IsolatedEnvironment()

                

                # Test service configuration loading

                ws_url = env.get("NEXT_PUBLIC_WS_URL")

                environment = env.get("ENVIRONMENT")

                

                # Validate environment-specific requirements

                assert ws_url == config["NEXT_PUBLIC_WS_URL"], (

                    f"Environment {env_name} should load correct WebSocket URL"

                )

                

                if config["expected_secure"]:

                    assert ws_url.startswith("wss://"), (

                        f"Environment {env_name} should use secure WebSocket protocol"

                    )

                

                # SSOT COMPLIANCE: No deprecated variables in any environment

                deprecated_url = env.get("NEXT_PUBLIC_WEBSOCKET_URL")

                assert deprecated_url is None, (

                    f"SSOT VIOLATION: Environment {env_name} should not have deprecated variables"

                )

                

                self.metrics.custom_metrics[f"{env_name}_config_valid"] = True



    @pytest.mark.asyncio

    async def test_websocket_ssot_migration_service_compatibility(self):

        """

        Test service compatibility during SSOT migration

        

        CRITICAL: Ensures services work correctly during migration from dual to single variable

        """

        # Pre-migration scenario: Both variables exist (should detect SSOT violation)

        pre_migration_config = {

            "ENVIRONMENT": "staging",

            "NEXT_PUBLIC_WS_URL": "wss://api.staging.netrasystems.ai/ws",

            "NEXT_PUBLIC_WEBSOCKET_URL": "wss://api.staging.netrasystems.ai/ws"  # Deprecated

        }

        

        with patch.dict('os.environ', pre_migration_config, clear=False):

            env = IsolatedEnvironment()

            

            # Simulate service attempting to load configuration

            canonical_url = env.get("NEXT_PUBLIC_WS_URL")

            deprecated_url = env.get("NEXT_PUBLIC_WEBSOCKET_URL")

            

            # Detect SSOT violation

            if canonical_url and deprecated_url:

                self.metrics.custom_metrics["migration_phase"] = "pre_migration"

                self.metrics.custom_metrics["ssot_violation_detected"] = True

                

                # Service should preferentially use canonical variable

                service_url = canonical_url  # Service should choose canonical

                

                assert service_url == "wss://api.staging.netrasystems.ai/ws", (

                    "Service should use canonical WebSocket URL even when deprecated exists"

                )

                

                # Log SSOT violation for remediation

                pytest.fail(

                    f"SSOT VIOLATION DETECTED: Both NEXT_PUBLIC_WS_URL and NEXT_PUBLIC_WEBSOCKET_URL exist. "

                    f"Service can function but Issue #507 SSOT migration required. "

                    f"Canonical: {canonical_url}, Deprecated: {deprecated_url}"

                )

        

        # Post-migration scenario: Only canonical variable exists (should pass)

        post_migration_config = {

            "ENVIRONMENT": "staging",

            "NEXT_PUBLIC_WS_URL": "wss://api.staging.netrasystems.ai/ws"

            # Note: NEXT_PUBLIC_WEBSOCKET_URL intentionally not set

        }

        

        with patch.dict('os.environ', post_migration_config, clear=False):

            env = IsolatedEnvironment()

            

            canonical_url = env.get("NEXT_PUBLIC_WS_URL") 

            deprecated_url = env.get("NEXT_PUBLIC_WEBSOCKET_URL")

            

            # SSOT COMPLIANT: Only canonical variable exists

            assert canonical_url is not None, "Canonical WebSocket URL should be available"

            assert deprecated_url is None, "Deprecated WebSocket URL should not exist"

            

            self.metrics.custom_metrics["migration_phase"] = "post_migration"

            self.metrics.custom_metrics["ssot_compliant"] = True



    def _validate_websocket_service_config(self, ws_url, environment):

        """

        Helper method to validate WebSocket service configuration

        

        Simulates the validation logic that should be used by services

        """

        errors = []

        

        if not ws_url:

            errors.append("WebSocket URL is required")

        elif not (ws_url.startswith("ws://") or ws_url.startswith("wss://")):

            errors.append("WebSocket URL must use ws:// or wss:// protocol")

        elif not any(path in ws_url for path in ["/ws", "/websocket"]):

            errors.append("WebSocket URL must include valid WebSocket path")

        

        # Environment-specific validation

        if environment in ["staging", "production"]:

            if ws_url and not ws_url.startswith("wss://"):

                errors.append(f"Environment {environment} requires secure WebSocket protocol")

            

            if environment == "staging" and ws_url and "staging.netrasystems.ai" not in ws_url:

                errors.append("Staging environment should use staging.netrasystems.ai domain")

            

            if environment == "production" and ws_url and "staging" in ws_url:

                errors.append("Production environment should not use staging URLs")

        

        return {

            "is_valid": len(errors) == 0,

            "errors": errors,

            "ws_url": ws_url,

            "environment": environment

        }





@pytest.mark.integration

@pytest.mark.staging

class TestWebSocketSSOTServiceHealthIntegration(SSotAsyncTestCase):

    """Integration tests for WebSocket service health with SSOT configuration"""



    def setup_method(self, method):

        """Setup for each test method"""

        super().setup_method(method)

        self.env = IsolatedEnvironment()



    @pytest.mark.asyncio

    async def test_websocket_service_health_check_with_ssot_config(self):

        """

        Test that WebSocket service health checks work with SSOT configuration

        

        CRITICAL: Validates service health monitoring uses correct WebSocket URL

        """

        staging_config = {

            "ENVIRONMENT": "staging",

            "NEXT_PUBLIC_WS_URL": "wss://api.staging.netrasystems.ai/ws"

        }

        

        with patch.dict('os.environ', staging_config, clear=False):

            env = IsolatedEnvironment()

            

            # Simulate service health check configuration loading

            ws_url = env.get("NEXT_PUBLIC_WS_URL")

            environment = env.get("ENVIRONMENT")

            

            # Health check should use canonical WebSocket URL

            assert ws_url is not None, "Health check should find WebSocket URL"

            assert ws_url.startswith("wss://"), "Health check should use secure protocol"

            

            # Simulate health check validation

            health_status = self._simulate_websocket_health_check(ws_url)

            

            # Health check should be able to validate URL format

            assert health_status["url_valid"], f"Health check should validate URL: {health_status['message']}"

            

            # SSOT COMPLIANCE: Health check should not access deprecated variables

            deprecated_url = env.get("NEXT_PUBLIC_WEBSOCKET_URL")

            assert deprecated_url is None, "Health check should not find deprecated WebSocket URL"



    def _simulate_websocket_health_check(self, ws_url):

        """

        Simulate WebSocket service health check

        

        Returns health status based on WebSocket URL configuration

        """

        if not ws_url:

            return {"url_valid": False, "message": "WebSocket URL not configured"}

        

        if not ws_url.startswith(("ws://", "wss://")):

            return {"url_valid": False, "message": "Invalid WebSocket protocol"}

        

        if not any(path in ws_url for path in ["/ws", "/websocket"]):

            return {"url_valid": False, "message": "Invalid WebSocket path"}

        

        return {"url_valid": True, "message": "WebSocket URL configuration valid"}





if __name__ == "__main__":

    # Enable execution for validation

    pytest.main([__file__, "-v", "--tb=short"])

