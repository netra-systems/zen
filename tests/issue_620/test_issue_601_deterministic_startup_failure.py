#!/usr/bin/env python3

"""

Issue #601 Phase 1 Reproduction Tests: Deterministic Startup Memory Leak and Timeout Issues



CRITICAL: These tests are DESIGNED TO FAIL initially to prove the problems exist.



Test Categories:

1. Import Loop Deadlock Detection Tests (should TIMEOUT/FAIL)

2. Memory Monitoring System Failures (should show MEMORY LEAKS)

3. Startup Sequencing Race Conditions (should show RACE CONDITIONS)



Expected Behavior: ALL TESTS SHOULD FAIL - proving the deterministic startup issues exist.



Author: Claude Code Agent

Created: 2025-09-12

Issue: #601 - Deterministic Startup Memory Leak Timeout Issue

"""



import asyncio

import gc

import inspect

import logging

import os

import psutil

import pytest

import sys

import threading

import time

import tracemalloc

from collections import defaultdict

from dataclasses import dataclass, field

from threading import Event, Lock, Thread

from typing import Dict, List, Optional, Set, Tuple, Any

from unittest.mock import Mock, patch, MagicMock



# Test framework imports

try:

    from test_framework.ssot.base_test_case import SSotBaseTestCase, SSotAsyncTestCase

    from test_framework.ssot.mock_factory import SSotMockFactory

    from test_framework.ssot.orchestration import OrchestrationConfig

    from test_framework.ssot.orchestration_enums import ServiceAvailability

except ImportError as e:

    print(f"WARNING: Test framework SSOT imports failed: {e}")

    # Fallback for development

    import unittest

    SSotBaseTestCase = unittest.TestCase

    SSotAsyncTestCase = unittest.IsolatedAsyncioTestCase



# Attempt imports that may cause deadlocks - this is intentional for testing

try:

    from netra_backend.app.core.deterministic_startup import DeterministicStartup

    from netra_backend.app.core.memory_monitoring import MemoryMonitor  

    from netra_backend.app.core.app_state_contracts import AppStateContracts

    from netra_backend.app.core.startup_phase_validation import StartupPhaseValidator

    from netra_backend.app.core.websocket_cors import WebSocketCORS

    from netra_backend.app.websocket_core.manager import WebSocketManager

    from netra_backend.app.agents.registry import AgentRegistry

    IMPORTS_AVAILABLE = True

except ImportError as e:

    print(f"WARNING: Backend imports failed (expected for deadlock testing): {e}")

    IMPORTS_AVAILABLE = False

    # Create mock classes for testing import behavior

    class DeterministicStartup:

        @classmethod

        def create_app(cls): return Mock()

    class MemoryMonitor:

        def __init__(self): pass

        def start_monitoring(self): pass

        def get_memory_usage(self): return {"memory": "1GB"}

    class AppStateContracts:

        @staticmethod

        def validate_app_state_contracts(state): return True

    class StartupPhaseValidator:

        @staticmethod

        def validate_complete_startup_sequence(state): return True

    class WebSocketCORS:

        def __init__(self): pass

    class WebSocketManager:

        def __init__(self): pass

    class AgentRegistry:

        def __init__(self): pass





@dataclass

class ImportDeadlockTestResult:

    """Results from import deadlock testing"""

    import_success: bool = False

    timeout_occurred: bool = False

    deadlock_detected: bool = False

    circular_imports: List[str] = field(default_factory=list)

    import_duration: float = 0.0

    memory_before: int = 0

    memory_after: int = 0

    memory_leaked: int = 0

    error_details: Optional[str] = None

    thread_count_before: int = 0

    thread_count_after: int = 0





@dataclass

class MemoryLeakTestResult:

    """Results from memory leak testing"""

    startup_successful: bool = False

    memory_growth: int = 0

    monitoring_failed: bool = False

    timeout_occurred: bool = False

    max_memory_reached: int = 0

    monitoring_duration: float = 0.0

    error_details: Optional[str] = None

    leaked_objects: List[str] = field(default_factory=list)





@dataclass

class StartupRaceConditionResult:

    """Results from startup race condition testing"""

    race_condition_detected: bool = False

    initialization_failed: bool = False

    websocket_startup_failed: bool = False

    agent_registry_failed: bool = False

    timeout_occurred: bool = False

    startup_duration: float = 0.0

    error_details: Optional[str] = None

    failed_phases: List[str] = field(default_factory=list)





class Issue601ReproductionTestSuite(SSotBaseTestCase):

    """

    Phase 1 Reproduction Tests for Issue #601

    

    CRITICAL: These tests are DESIGNED TO FAIL to prove the deterministic startup issues exist.

    They should demonstrate:

    1. Import loop deadlocks causing timeouts

    2. Memory monitoring system failures

    3. Startup sequencing race conditions

    """

    

    def setUp(self):

        """Set up test environment with memory tracking"""

        super().setUp()

        

        # Start memory tracking

        tracemalloc.start()

        

        # Get initial system state

        self.initial_memory = psutil.Process().memory_info().rss

        self.initial_thread_count = threading.active_count()

        

        # Setup test timeout (shorter than system timeout to prove deadlock)

        self.test_timeout = 15.0  # Should timeout before system timeout

        

        # Test result storage

        self.test_results = {

            'import_deadlock': None,

            'memory_leak': None,

            'race_condition': None

        }

        

        # Setup logging to capture deadlock evidence

        self.setup_deadlock_logging()

    

    def tearDown(self):

        """Clean up test environment"""

        # Stop memory tracking

        tracemalloc.stop()

        

        # Force garbage collection

        gc.collect()

        

        super().tearDown()

    

    def setup_deadlock_logging(self):

        """Setup logging to capture deadlock evidence"""

        self.logger = logging.getLogger('issue_601_reproduction')

        self.logger.setLevel(logging.DEBUG)

        

        # Create handler if not exists

        if not self.logger.handlers:

            handler = logging.StreamHandler()

            formatter = logging.Formatter(

                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'

            )

            handler.setFormatter(formatter)

            self.logger.addHandler(handler)

    

    def test_import_loop_deadlock_detection(self):

        """

        Test #1: Import Loop Deadlock Detection

        

        EXPECTED RESULT: FAIL/TIMEOUT

        This test should demonstrate that circular imports cause deadlocks

        during deterministic startup initialization.

        """

        self.logger.info("=== STARTING IMPORT DEADLOCK TEST ===")

        

        result = ImportDeadlockTestResult()

        

        try:

            # Record starting state

            result.memory_before = psutil.Process().memory_info().rss

            result.thread_count_before = threading.active_count()

            start_time = time.time()

            

            # Create import deadlock detection

            import_event = Event()

            deadlock_detected = Event()

            timeout_event = Event()

            

            def attempt_imports():

                """Attempt imports that may cause deadlocks"""

                try:

                    self.logger.info("Attempting problematic imports...")

                    

                    # These imports may cause circular dependency deadlocks

                    import netra_backend.app.core.deterministic_startup

                    import netra_backend.app.core.memory_monitoring

                    import netra_backend.app.websocket_core.manager

                    import netra_backend.app.agents.registry

                    import netra_backend.app.core.app_state_contracts

                    

                    # If we get here, imports succeeded (unexpected)

                    result.import_success = True

                    import_event.set()

                    

                except ImportError as e:

                    self.logger.error(f"Import failed (may indicate deadlock): {e}")

                    result.error_details = str(e)

                    result.circular_imports.append(str(e))

                    import_event.set()

                

                except Exception as e:

                    self.logger.error(f"Unexpected error during import: {e}")

                    result.error_details = str(e)

                    import_event.set()

            

            def deadlock_monitor():

                """Monitor for deadlock indicators"""

                monitor_start = time.time()

                while not import_event.is_set() and not timeout_event.is_set():

                    time.sleep(0.1)

                    

                    # Check if we've been waiting too long

                    if time.time() - monitor_start > self.test_timeout:

                        self.logger.error("DEADLOCK DETECTED: Import timeout exceeded")

                        result.deadlock_detected = True

                        result.timeout_occurred = True

                        timeout_event.set()

                        break

                

                deadlock_detected.set()

            

            # Start import and monitoring threads

            import_thread = Thread(target=attempt_imports, daemon=True)

            monitor_thread = Thread(target=deadlock_monitor, daemon=True)

            

            import_thread.start()

            monitor_thread.start()

            

            # Wait for completion or timeout

            import_thread.join(timeout=self.test_timeout)

            monitor_thread.join(timeout=1.0)

            

            # Calculate results

            result.import_duration = time.time() - start_time

            result.memory_after = psutil.Process().memory_info().rss

            result.memory_leaked = result.memory_after - result.memory_before

            result.thread_count_after = threading.active_count()

            

            # Check if import thread is still alive (deadlock indicator)

            if import_thread.is_alive():

                result.deadlock_detected = True

                result.timeout_occurred = True

                self.logger.error("Import thread still alive - DEADLOCK CONFIRMED")

            

        except Exception as e:

            result.error_details = str(e)

            self.logger.error(f"Test execution error: {e}")

        

        finally:

            self.test_results['import_deadlock'] = result

        

        # Log detailed results

        self.log_import_deadlock_results(result)

        

        # ASSERTION: This should FAIL to prove the deadlock exists

        if result.deadlock_detected or result.timeout_occurred:

            self.fail(

                f"EXPECTED FAILURE: Import deadlock detected! "

                f"Timeout: {result.timeout_occurred}, "

                f"Duration: {result.import_duration:.2f}s, "

                f"Memory leaked: {result.memory_leaked} bytes"

            )

        elif result.import_success:

            self.logger.warning("Imports succeeded - deadlock may not be present")

        

        # Always fail to prove the test is working

        self.fail("REPRODUCTION TEST: This test should fail to prove import deadlock issues exist")

    

    def test_memory_monitoring_system_failure(self):

        """

        Test #2: Memory Monitoring System Failure

        

        EXPECTED RESULT: FAIL

        This test should demonstrate that memory monitoring fails

        during deterministic startup, leading to uncontrolled memory growth.

        """

        self.logger.info("=== STARTING MEMORY MONITORING FAILURE TEST ===")

        

        result = MemoryLeakTestResult()

        

        try:

            start_time = time.time()

            initial_memory = psutil.Process().memory_info().rss

            

            # Attempt to initialize memory monitoring

            if IMPORTS_AVAILABLE:

                try:

                    memory_monitor = MemoryMonitor()

                    memory_monitor.start_monitoring()

                    

                    # Simulate startup memory operations

                    for i in range(100):

                        # Create objects that should be monitored

                        large_object = [0] * 10000  # 10K integers

                        time.sleep(0.01)  # Small delay

                        

                        current_memory = psutil.Process().memory_info().rss

                        memory_growth = current_memory - initial_memory

                        

                        # Check if memory monitoring is working

                        monitor_data = memory_monitor.get_memory_usage()

                        if not monitor_data or 'memory' not in monitor_data:

                            result.monitoring_failed = True

                            break

                        

                        # Check for excessive growth

                        if memory_growth > 100 * 1024 * 1024:  # 100MB

                            result.max_memory_reached = current_memory

                            self.logger.error(f"Excessive memory growth: {memory_growth} bytes")

                            break

                    

                    result.startup_successful = True

                    

                except Exception as e:

                    result.error_details = str(e)

                    result.monitoring_failed = True

                    self.logger.error(f"Memory monitoring initialization failed: {e}")

            

            else:

                # Test with mock memory monitor

                self.logger.info("Testing with mock memory monitor (imports not available)")

                result.monitoring_failed = True

                result.error_details = "Backend imports not available for testing"

            

            # Calculate final results

            result.monitoring_duration = time.time() - start_time

            final_memory = psutil.Process().memory_info().rss

            result.memory_growth = final_memory - initial_memory

            

            # Check for timeout

            if result.monitoring_duration > self.test_timeout:

                result.timeout_occurred = True

        

        except Exception as e:

            result.error_details = str(e)

            self.logger.error(f"Memory monitoring test error: {e}")

        

        finally:

            self.test_results['memory_leak'] = result

        

        # Log detailed results

        self.log_memory_monitoring_results(result)

        

        # ASSERTION: This should FAIL to prove memory monitoring issues exist

        if result.monitoring_failed or result.timeout_occurred:

            self.fail(

                f"EXPECTED FAILURE: Memory monitoring system failed! "

                f"Monitoring failed: {result.monitoring_failed}, "

                f"Timeout: {result.timeout_occurred}, "

                f"Memory growth: {result.memory_growth} bytes"

            )

        

        # Always fail to prove the test is working

        self.fail("REPRODUCTION TEST: This test should fail to prove memory monitoring issues exist")

    

    def test_startup_sequencing_race_conditions(self):

        """

        Test #3: Startup Sequencing Race Conditions

        

        EXPECTED RESULT: FAIL

        This test should demonstrate race conditions in deterministic startup

        that cause initialization failures and timeouts.

        """

        self.logger.info("=== STARTING STARTUP RACE CONDITION TEST ===")

        

        result = StartupRaceConditionResult()

        

        try:

            start_time = time.time()

            

            if IMPORTS_AVAILABLE:

                try:

                    # Attempt deterministic startup with race condition detection

                    startup_phases = []

                    failed_phases = []

                    

                    # Phase 1: App state initialization

                    try:

                        app_state = Mock()  # Simulate app state

                        if not AppStateContracts.validate_app_state_contracts(app_state):

                            failed_phases.append("app_state_validation")

                        startup_phases.append("app_state_initialized")

                    except Exception as e:

                        failed_phases.append("app_state_initialization")

                        self.logger.error(f"App state initialization failed: {e}")

                    

                    # Phase 2: WebSocket initialization

                    try:

                        websocket_manager = WebSocketManager()

                        startup_phases.append("websocket_initialized")

                    except Exception as e:

                        failed_phases.append("websocket_initialization")

                        result.websocket_startup_failed = True

                        self.logger.error(f"WebSocket initialization failed: {e}")

                    

                    # Phase 3: Agent registry initialization

                    try:

                        agent_registry = AgentRegistry()

                        startup_phases.append("agent_registry_initialized")

                    except Exception as e:

                        failed_phases.append("agent_registry_initialization")

                        result.agent_registry_failed = True

                        self.logger.error(f"Agent registry initialization failed: {e}")

                    

                    # Phase 4: Startup sequence validation

                    try:

                        if not StartupPhaseValidator.validate_complete_startup_sequence(app_state):

                            failed_phases.append("startup_sequence_validation")

                        startup_phases.append("startup_validated")

                    except Exception as e:

                        failed_phases.append("startup_sequence_validation")

                        self.logger.error(f"Startup validation failed: {e}")

                    

                    result.failed_phases = failed_phases

                    

                    # Check for race conditions

                    if len(failed_phases) > 0:

                        result.race_condition_detected = True

                        result.initialization_failed = True

                

                except Exception as e:

                    result.error_details = str(e)

                    result.initialization_failed = True

                    self.logger.error(f"Startup sequence failed: {e}")

            

            else:

                # Test with mocks

                self.logger.info("Testing startup sequence with mocks (imports not available)")

                result.initialization_failed = True

                result.error_details = "Backend imports not available for testing"

            

            # Calculate timing

            result.startup_duration = time.time() - start_time

            

            # Check for timeout

            if result.startup_duration > self.test_timeout:

                result.timeout_occurred = True

        

        except Exception as e:

            result.error_details = str(e)

            self.logger.error(f"Startup race condition test error: {e}")

        

        finally:

            self.test_results['race_condition'] = result

        

        # Log detailed results

        self.log_startup_race_condition_results(result)

        

        # ASSERTION: This should FAIL to prove race conditions exist

        if result.race_condition_detected or result.initialization_failed or result.timeout_occurred:

            self.fail(

                f"EXPECTED FAILURE: Startup race conditions detected! "

                f"Race condition: {result.race_condition_detected}, "

                f"Init failed: {result.initialization_failed}, "

                f"Timeout: {result.timeout_occurred}, "

                f"Failed phases: {result.failed_phases}"

            )

        

        # Always fail to prove the test is working

        self.fail("REPRODUCTION TEST: This test should fail to prove startup race condition issues exist")

    

    def log_import_deadlock_results(self, result: ImportDeadlockTestResult):

        """Log detailed import deadlock test results"""

        self.logger.info("=== IMPORT DEADLOCK TEST RESULTS ===")

        self.logger.info(f"Import success: {result.import_success}")

        self.logger.info(f"Timeout occurred: {result.timeout_occurred}")

        self.logger.info(f"Deadlock detected: {result.deadlock_detected}")

        self.logger.info(f"Import duration: {result.import_duration:.2f}s")

        self.logger.info(f"Memory before: {result.memory_before} bytes")

        self.logger.info(f"Memory after: {result.memory_after} bytes")

        self.logger.info(f"Memory leaked: {result.memory_leaked} bytes")

        self.logger.info(f"Thread count before: {result.thread_count_before}")

        self.logger.info(f"Thread count after: {result.thread_count_after}")

        if result.circular_imports:

            self.logger.info(f"Circular imports detected: {result.circular_imports}")

        if result.error_details:

            self.logger.info(f"Error details: {result.error_details}")

    

    def log_memory_monitoring_results(self, result: MemoryLeakTestResult):

        """Log detailed memory monitoring test results"""

        self.logger.info("=== MEMORY MONITORING TEST RESULTS ===")

        self.logger.info(f"Startup successful: {result.startup_successful}")

        self.logger.info(f"Memory growth: {result.memory_growth} bytes")

        self.logger.info(f"Monitoring failed: {result.monitoring_failed}")

        self.logger.info(f"Timeout occurred: {result.timeout_occurred}")

        self.logger.info(f"Max memory reached: {result.max_memory_reached} bytes")

        self.logger.info(f"Monitoring duration: {result.monitoring_duration:.2f}s")

        if result.leaked_objects:

            self.logger.info(f"Leaked objects: {result.leaked_objects}")

        if result.error_details:

            self.logger.info(f"Error details: {result.error_details}")

    

    def log_startup_race_condition_results(self, result: StartupRaceConditionResult):

        """Log detailed startup race condition test results"""

        self.logger.info("=== STARTUP RACE CONDITION TEST RESULTS ===")

        self.logger.info(f"Race condition detected: {result.race_condition_detected}")

        self.logger.info(f"Initialization failed: {result.initialization_failed}")

        self.logger.info(f"WebSocket startup failed: {result.websocket_startup_failed}")

        self.logger.info(f"Agent registry failed: {result.agent_registry_failed}")

        self.logger.info(f"Timeout occurred: {result.timeout_occurred}")

        self.logger.info(f"Startup duration: {result.startup_duration:.2f}s")

        if result.failed_phases:

            self.logger.info(f"Failed phases: {result.failed_phases}")

        if result.error_details:

            self.logger.info(f"Error details: {result.error_details}")





class Issue601AsyncReproductionTests(SSotAsyncTestCase):

    """

    Async reproduction tests for Issue #601

    

    These tests specifically target async-related deadlocks and race conditions

    in the deterministic startup process.

    """

    

    async def test_async_startup_deadlock_reproduction(self):

        """

        Test async startup deadlock reproduction

        

        EXPECTED RESULT: FAIL/TIMEOUT

        This should demonstrate async deadlocks in startup sequence.

        """

        start_time = time.time()

        timeout_seconds = 10.0

        

        try:

            # Create multiple async tasks that may deadlock

            async def startup_task_1():

                # Simulate WebSocket manager initialization

                await asyncio.sleep(0.1)

                return "websocket_manager_initialized"

            

            async def startup_task_2():

                # Simulate agent registry initialization  

                await asyncio.sleep(0.1)

                return "agent_registry_initialized"

            

            async def startup_task_3():

                # Simulate memory monitor initialization

                await asyncio.sleep(0.1)

                return "memory_monitor_initialized"

            

            # Attempt concurrent initialization (may deadlock)

            tasks = [

                asyncio.create_task(startup_task_1()),

                asyncio.create_task(startup_task_2()),

                asyncio.create_task(startup_task_3())

            ]

            

            # This should timeout if deadlock occurs

            results = await asyncio.wait_for(

                asyncio.gather(*tasks, return_exceptions=True),

                timeout=timeout_seconds

            )

            

            duration = time.time() - start_time

            

            # If we get here without timeout, that's unexpected

            self.fail(f"UNEXPECTED SUCCESS: Async startup completed in {duration:.2f}s - deadlock not reproduced")

            

        except asyncio.TimeoutError:

            duration = time.time() - start_time

            # This is expected - proves async deadlock

            self.fail(f"EXPECTED FAILURE: Async startup deadlock detected after {duration:.2f}s timeout")

        

        except Exception as e:

            duration = time.time() - start_time

            self.fail(f"EXPECTED FAILURE: Async startup error after {duration:.2f}s: {e}")





if __name__ == "__main__":

    """

    Run Issue #601 reproduction tests

    

    Expected Results: ALL TESTS SHOULD FAIL

    This proves the deterministic startup issues exist and need to be fixed.

    """

    

    print("="*80)

    print("ISSUE #601 PHASE 1 REPRODUCTION TESTS")

    print("="*80)

    print("CRITICAL: These tests are DESIGNED TO FAIL to prove the problems exist!")

    print("Expected Results:")

    print("- Import deadlock tests should TIMEOUT")

    print("- Memory monitoring tests should show FAILURES")

    print("- Startup sequencing tests should show RACE CONDITIONS")

    print("="*80)

    

    # Configure logging

    logging.basicConfig(

        level=logging.INFO,

        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'

    )

    

    # Run the tests

    import unittest

    

    # Create test suite

    suite = unittest.TestSuite()

    

    # Add sync tests

    suite.addTest(Issue601ReproductionTestSuite('test_import_loop_deadlock_detection'))

    suite.addTest(Issue601ReproductionTestSuite('test_memory_monitoring_system_failure'))

    suite.addTest(Issue601ReproductionTestSuite('test_startup_sequencing_race_conditions'))

    

    # Add async tests

    suite.addTest(Issue601AsyncReproductionTests('test_async_startup_deadlock_reproduction'))

    

    # Run with verbose output

    runner = unittest.TextTestRunner(verbosity=2, stream=sys.stdout)

    result = runner.run(suite)

    

    print("\n" + "="*80)

    print("ISSUE #601 REPRODUCTION TEST SUMMARY")

    print("="*80)

    print(f"Tests run: {result.testsRun}")

    print(f"Failures: {len(result.failures)}")

    print(f"Errors: {len(result.errors)}")

    print()

    

    if result.failures:

        print("EXPECTED FAILURES (proving issues exist):")

        for test, traceback in result.failures:

            print(f"- {test}: FAILED (expected)")

    

    if result.errors:

        print("ERRORS (may indicate test setup issues):")

        for test, traceback in result.errors:

            print(f"- {test}: ERROR")

    

    print("="*80)

    print("Next Steps:")

    print("1. Review failed tests to confirm they demonstrate the reported issues")

    print("2. If tests fail as expected, proceed to Phase 2 (fix implementation)")

    print("3. If tests pass unexpectedly, investigate and refine reproduction tests")

    print("="*80)

