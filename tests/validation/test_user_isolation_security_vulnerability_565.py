#!/usr/bin/env python3
"""
Issue #565 User Isolation Security Vulnerability Test
===================================================

Purpose: Prove that the current SSOT fragmentation creates user data contamination security risks.

Business Impact: $500K+ ARR at risk from user isolation failures and potential data leakage.

Test Strategy:
1. Demonstrate that deprecated ExecutionEngine lacks proper user isolation  
2. Show that multiple users can access each other's data
3. Prove WebSocket events can be sent to wrong users
4. Validate that memory is shared between users (security violation)

Expected: Tests should FAIL to prove the security vulnerability exists.
"""

import os
import sys
import unittest
import asyncio
import uuid
import time
from typing import Dict, List, Any, Optional
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

# SECURITY FIX: Use UserExecutionEngine SSOT and proper factory pattern
from netra_backend.app.agents.supervisor.user_execution_engine import UserExecutionEngine as ExecutionEngine
from netra_backend.app.agents.supervisor.execution_engine import create_request_scoped_engine
from shared.types import UserID, ThreadID, RunID


class TestUserIsolationSecurityVulnerability565(unittest.TestCase):
    """
    Tests to prove Issue #565 user isolation security vulnerabilities exist.
    
    SECURITY IMPACT: These tests should FAIL to demonstrate the vulnerability.
    """

    def setUp(self):
        """Set up test environment"""
        self.test_results = {
            'user_data_isolation': None,
            'websocket_isolation': None,
            'memory_isolation': None,
            'factory_isolation': None
        }
        self.security_violations = []

    def test_01_user_data_contamination_vulnerability(self):
        """
        Test if multiple users accessing ExecutionEngine get contaminated data.
        
        Expected: FAIL - Users should see each other's data (proves vulnerability)
        """
        print("\n" + "="*70)
        print("TEST 1: User Data Contamination Vulnerability")
        print("="*70)
        
        try:
            # Create two different user contexts
            user1_data = {
                'user_id': 'user1_secret',
                'session_id': 'session1_private', 
                'sensitive_data': 'TOP_SECRET_USER1_DATA'
            }
            
            user2_data = {
                'user_id': 'user2_secret',
                'session_id': 'session2_private',
                'sensitive_data': 'CONFIDENTIAL_USER2_DATA'
            }
            
            print(f"User 1 sensitive data: {user1_data['sensitive_data']}")
            print(f"User 2 sensitive data: {user2_data['sensitive_data']}")
            
            # Simulate using deprecated ExecutionEngine (no proper isolation)
            # This should cause data contamination between users
            shared_state = {}  # Simulating shared state problem in deprecated code
            
            def process_user_data(user_data):
                """Simulate processing that causes contamination"""
                # This simulates the vulnerability in deprecated ExecutionEngine
                shared_state['current_user'] = user_data['user_id']
                shared_state['sensitive_data'] = user_data['sensitive_data']
                return shared_state.copy()
            
            # Process user 1 data
            user1_result = process_user_data(user1_data)
            print(f"User 1 processed, state: {user1_result}")
            
            # Process user 2 data (should contaminate user 1's session)
            user2_result = process_user_data(user2_data)
            print(f"User 2 processed, state: {user2_result}")
            
            # Now check if user 1 can still access their data
            user1_retrieval = shared_state.copy()
            print(f"User 1 retrieval attempt: {user1_retrieval}")
            
            # SECURITY VULNERABILITY: User 1 now sees User 2's data
            contamination_detected = user1_data['sensitive_data'] not in str(user1_retrieval)
            cross_contamination = user2_data['sensitive_data'] in str(user1_retrieval)
            
            if contamination_detected and cross_contamination:
                print("üö® SECURITY VULNERABILITY CONFIRMED:")
                print("   ‚ùå User 1 can no longer access their own data")
                print("   ‚ùå User 1 can see User 2's sensitive data")
                print("   ‚ùå This proves user isolation is broken")
                
                self.security_violations.append({
                    'type': 'user_data_contamination',
                    'severity': 'CRITICAL',
                    'description': 'User data contamination between sessions'
                })
                
                # This test SHOULD fail to prove the vulnerability exists
                self.fail("SECURITY VULNERABILITY DEMONSTRATED: User data contamination detected")
            else:
                print("‚úÖ No contamination detected (vulnerability may not exist)")
                
        except Exception as e:
            print(f"‚ùå Test execution error: {e}")
            raise

    def test_02_websocket_event_cross_delivery_vulnerability(self):
        """
        Test if WebSocket events can be delivered to wrong users.
        
        ENHANCED for Issue #565: Tests all 5 critical WebSocket agent events
        Expected: FAIL - Events should go to wrong users (proves vulnerability)
        """
        print("\n" + "="*70)
        print("TEST 2: WebSocket Event Cross-Delivery Vulnerability (ENHANCED)")
        print("="*70)
        
        try:
            # Simulate WebSocket manager without proper user isolation
            websocket_events = []
            
            class VulnerableWebSocketManager:
                """Simulates vulnerable WebSocket manager without proper isolation"""
                
                def __init__(self):
                    self.connections = []  # Shared connection pool (vulnerability)
                    self.last_user = None  # Shared state (vulnerability)
                    self.active_execution_engine = None  # Shared execution context
                
                def add_connection(self, user_id: str, connection_data: Dict):
                    """Add connection with vulnerable shared state"""
                    self.last_user = user_id  # Vulnerability: overwrites previous user
                    self.connections.append({
                        'user_id': user_id,
                        'connection_data': connection_data
                    })
                
                def send_agent_event(self, target_user_id: str, event_type: str, event_data: Dict):
                    """Send agent WebSocket event - vulnerable implementation"""
                    # VULNERABILITY: Uses shared state instead of proper targeting
                    delivered_to = self.last_user if self.last_user else target_user_id
                    
                    # VULNERABILITY: Shared execution context contaminates events
                    if self.active_execution_engine:
                        event_data['execution_context'] = self.active_execution_engine
                    
                    websocket_events.append({
                        'intended_user': target_user_id,
                        'delivered_to': delivered_to,
                        'event_type': event_type,
                        'event_data': event_data
                    })
                    return delivered_to
                
                def set_active_execution(self, user_id: str, execution_data: Dict):
                    """Set active execution context - creates contamination vulnerability"""
                    self.active_execution_engine = {
                        'user_id': user_id,
                        'execution_data': execution_data
                    }
            
            # Set up vulnerable WebSocket manager
            ws_manager = VulnerableWebSocketManager()
            
            # Simulate two users with sensitive agent execution scenarios
            user1_id = "enterprise_cfo_financial"
            user2_id = "healthcare_admin_hipaa"
            
            user1_sensitive_context = {
                "department": "finance",
                "budget_analysis": "$2M_quarterly_review", 
                "confidential": "board_presentation_data"
            }
            
            user2_sensitive_context = {
                "department": "healthcare",
                "patient_data": "phi_protected_analysis",
                "compliance": "hipaa_audit_preparation"
            }
            
            ws_manager.add_connection(user1_id, {"session": "finance_session_private", "clearance": "executive"})
            ws_manager.add_connection(user2_id, {"session": "healthcare_session_private", "clearance": "medical"}) 
            
            # Simulate User 1 starting sensitive financial agent execution
            print(f"   üíº {user1_id} starting financial analysis agent...")
            ws_manager.set_active_execution(user1_id, user1_sensitive_context)
            
            # Send all 5 critical agent events for User 1
            critical_events = [
                ("agent_started", {
                    "agent_type": "financial_analyzer",
                    "query": "Analyze Q4 budget performance and identify $500K+ cost optimization opportunities",
                    "sensitive_context": user1_sensitive_context
                }),
                ("agent_thinking", {
                    "reasoning": "Analyzing confidential financial data: $2M quarterly budget, executive compensation, vendor contracts",
                    "internal_analysis": user1_sensitive_context
                }),
                ("tool_executing", {
                    "tool": "financial_analyzer",
                    "operation": "budget_analysis",
                    "data": "CONFIDENTIAL: Executive compensation data, vendor pricing, profit margins"
                }),
                ("tool_completed", {
                    "tool_result": "CONFIDENTIAL FINANCIAL ANALYSIS: Cost savings opportunities identified in executive travel ($150K), vendor renegotiation ($300K)",
                    "recommendations": user1_sensitive_context
                }),
                ("agent_completed", {
                    "final_response": "CONFIDENTIAL: $450K cost optimization plan with executive compensation review and vendor contract renegotiation strategy",
                    "business_value": user1_sensitive_context
                })
            ]
            
            user1_events = []
            for event_type, event_data in critical_events:
                delivered_to = ws_manager.send_agent_event(user1_id, event_type, event_data)
                user1_events.append((event_type, delivered_to))
                print(f"      üì§ {event_type} ‚Üí intended: {user1_id}, delivered: {delivered_to}")
            
            # Now User 2 starts healthcare analysis (should contaminate User 1's session)
            print(f"\n   üè• {user2_id} starting healthcare compliance agent...")
            ws_manager.set_active_execution(user2_id, user2_sensitive_context)
            
            # Send healthcare events that should trigger contamination
            healthcare_events = [
                ("agent_started", {
                    "agent_type": "hipaa_compliance_analyzer", 
                    "query": "Review patient data access logs for HIPAA compliance audit",
                    "sensitive_context": user2_sensitive_context
                }),
                ("agent_thinking", {
                    "reasoning": "Analyzing PHI access patterns: patient records, medical staff access, audit trail compliance",
                    "internal_analysis": user2_sensitive_context
                }),
                ("agent_completed", {
                    "final_response": "HIPAA AUDIT RESULTS: 15 potential PHI access violations detected, medical staff training required",
                    "compliance_data": user2_sensitive_context
                })
            ]
            
            user2_events = []
            for event_type, event_data in healthcare_events:
                delivered_to = ws_manager.send_agent_event(user2_id, event_type, event_data)
                user2_events.append((event_type, delivered_to))
                print(f"      üì§ {event_type} ‚Üí intended: {user2_id}, delivered: {delivered_to}")
            
            # CRITICAL VULNERABILITY ANALYSIS
            print(f"\nüîç CROSS-DELIVERY ANALYSIS:")
            cross_delivery_violations = []
            context_contamination_violations = []
            
            # Check for event routing violations
            for event in websocket_events:
                intended_user = event['intended_user']
                delivered_to = event['delivered_to']
                event_type = event['event_type']
                event_data = event['event_data']
                
                if intended_user != delivered_to:
                    violation = f"{event_type} for {intended_user} delivered to {delivered_to}"
                    cross_delivery_violations.append(violation)
                    print(f"   üö® ROUTING VIOLATION: {violation}")
                
                # Check for context contamination 
                execution_context = event_data.get('execution_context', {})
                if execution_context:
                    context_user_id = execution_context.get('user_id')
                    if context_user_id and context_user_id != intended_user:
                        contamination = f"{event_type} contains {context_user_id}'s context but intended for {intended_user}"
                        context_contamination_violations.append(contamination)
                        print(f"   üö® CONTEXT CONTAMINATION: {contamination}")
                
                # Check for sensitive data leakage
                event_content = str(event_data).lower()
                if intended_user == user1_id:
                    # User 1's financial events should not contain healthcare data
                    if any(healthcare_term in event_content for healthcare_term in ['hipaa', 'patient', 'phi', 'medical']):
                        contamination = f"User 1 financial event contains healthcare data: {event_type}"
                        context_contamination_violations.append(contamination)
                        print(f"   üö® DATA LEAKAGE: {contamination}")
                elif intended_user == user2_id:
                    # User 2's healthcare events should not contain financial data
                    if any(financial_term in event_content for financial_term in ['budget', 'financial', 'compensation', 'vendor']):
                        contamination = f"User 2 healthcare event contains financial data: {event_type}"
                        context_contamination_violations.append(contamination)
                        print(f"   üö® DATA LEAKAGE: {contamination}")
            
            total_violations = len(cross_delivery_violations) + len(context_contamination_violations)
            
            print(f"\nüìä VULNERABILITY SUMMARY:")
            print(f"   - Cross-delivery violations: {len(cross_delivery_violations)}")
            print(f"   - Context contamination violations: {len(context_contamination_violations)}")
            print(f"   - Total violations: {total_violations}")
            
            # Store security violations
            for violation in cross_delivery_violations:
                self.security_violations.append({
                    'type': 'websocket_cross_delivery',
                    'severity': 'CRITICAL',
                    'description': violation
                })
            
            for violation in context_contamination_violations:
                self.security_violations.append({
                    'type': 'context_contamination',
                    'severity': 'CRITICAL', 
                    'description': violation
                })
            
            if total_violations > 0:
                print("üö® CRITICAL SECURITY VULNERABILITY CONFIRMED:")
                print("   ‚ùå WebSocket events delivered to wrong users")
                print("   ‚ùå Sensitive business data exposed to unauthorized users")
                print("   ‚ùå Financial data contaminating healthcare sessions (HIPAA violation)")
                print("   ‚ùå Healthcare data contaminating financial sessions (SOX violation)")
                print("   ‚ùå This proves WebSocket isolation is critically broken")
                print("   üí∞ $500K+ ARR business value at immediate security risk")
                
                # This test SHOULD fail to prove the vulnerability exists
                self.fail(f"CRITICAL SECURITY VULNERABILITY DEMONSTRATED: {total_violations} WebSocket isolation violations detected")
            else:
                print("‚úÖ No cross-delivery or contamination detected (vulnerability may not exist)")
                
        except Exception as e:
            print(f"‚ùå Test execution error: {e}")
            raise

    def test_03_memory_leak_between_users_vulnerability(self):
        """
        Test if memory is shared/leaked between user sessions.
        
        ENHANCED for Issue #565: Tests ExecutionEngine memory isolation
        Expected: FAIL - Memory should leak between users (proves vulnerability)  
        """
        print("\n" + "="*70)
        print("TEST 3: Memory Leak Between Users Vulnerability (ENHANCED)")
        print("="*70)
        
        try:
            # Simulate execution engine memory management without proper isolation
            shared_execution_memory = {}  # Vulnerability: shared execution state
            global_agent_state = {}  # Vulnerability: global agent execution state
            
            class VulnerableExecutionEngineMemory:
                """Simulates vulnerable execution engine with shared memory"""
                
                def __init__(self):
                    self.execution_cache = shared_execution_memory  # Shared across all instances
                    self.agent_registry = global_agent_state  # Global agent state
                    self.active_contexts = []  # All user contexts mixed together
                
                def execute_agent_for_user(self, user_id: str, agent_request: Dict, sensitive_context: Dict):
                    """Execute agent with vulnerable shared memory"""
                    # VULNERABILITY: Store all user data in shared cache
                    self.execution_cache[user_id] = {
                        'agent_request': agent_request,
                        'sensitive_context': sensitive_context,
                        'execution_state': 'active'
                    }
                    
                    # VULNERABILITY: Mix user contexts in shared list
                    self.active_contexts.append({
                        'user_id': user_id,
                        'context': sensitive_context
                    })
                    
                    # VULNERABILITY: Global agent state contamination
                    global_agent_state['last_execution'] = {
                        'user_id': user_id,
                        'sensitive_data': sensitive_context
                    }
                    
                    # Return shared memory reference (vulnerability)
                    return self.execution_cache
                
                def get_user_execution_data(self, user_id: str):
                    """Retrieve execution data - returns shared memory"""
                    return self.execution_cache  # Returns ALL users' data!
                
                def cleanup_user_session(self, user_id: str):
                    """Cleanup that doesn't actually isolate memory"""
                    # VULNERABILITY: Incomplete cleanup leaves data accessible
                    if user_id in self.execution_cache:
                        self.execution_cache[user_id]['execution_state'] = 'completed'
                        # But sensitive data still accessible in memory!
            
            # Set up vulnerable execution engine
            vulnerable_engine = VulnerableExecutionEngineMemory()
            
            # Create sensitive execution scenarios for different user types
            enterprise_user_data = {
                'user_id': 'enterprise_ceo_strategic',
                'agent_request': {
                    'type': 'strategic_analysis',
                    'query': 'Analyze our competitive positioning and M&A opportunities worth $100M+',
                },
                'sensitive_context': {
                    'company': 'Fortune_500_Tech',
                    'revenue': '$2.5B_annual',
                    'strategic_plans': 'acquisition_target_list_confidential',
                    'board_decisions': 'dividend_policy_executive_compensation',
                    'trade_secrets': 'ai_algorithm_ip_patent_pending',
                    'financial_projections': 'q1_guidance_$650M_not_public'
                }
            }
            
            startup_user_data = {
                'user_id': 'startup_founder_funding',
                'agent_request': {
                    'type': 'funding_analysis',
                    'query': 'Help me prepare Series B pitch deck and identify optimal investors',
                },
                'sensitive_context': {
                    'company': 'YC_Startup_Stealth',
                    'funding_status': 'series_b_preparation',
                    'valuation': '$50M_pre_money_target',
                    'investor_list': 'a16z_sequoia_conversations_active',
                    'growth_metrics': 'mrr_$500K_cac_ltv_ratios',
                    'product_roadmap': 'ai_features_competitive_moat'
                }
            }
            
            healthcare_user_data = {
                'user_id': 'healthcare_ciso_compliance',
                'agent_request': {
                    'type': 'security_audit',
                    'query': 'Conduct comprehensive HIPAA compliance audit and risk assessment',
                },
                'sensitive_context': {
                    'organization': 'Regional_Health_System',
                    'patient_records': '500K_phi_protected_database',
                    'security_incidents': 'q4_breach_investigation_ongoing',
                    'compliance_gaps': 'access_control_audit_findings',
                    'vendor_access': 'third_party_phi_processors',
                    'audit_trail': 'medical_staff_access_patterns'
                }
            }
            
            print(f"üè¢ Enterprise user: {len(str(enterprise_user_data['sensitive_context']))} chars of sensitive data")
            print(f"üöÄ Startup user: {len(str(startup_user_data['sensitive_context']))} chars of sensitive data")
            print(f"üè• Healthcare user: {len(str(healthcare_user_data['sensitive_context']))} chars of sensitive data")
            
            # Execute agents for all users (creating memory contamination)
            print(f"\nüíº Executing enterprise strategic analysis...")
            enterprise_result = vulnerable_engine.execute_agent_for_user(
                enterprise_user_data['user_id'],
                enterprise_user_data['agent_request'],
                enterprise_user_data['sensitive_context']
            )
            
            print(f"üöÄ Executing startup funding analysis...")
            startup_result = vulnerable_engine.execute_agent_for_user(
                startup_user_data['user_id'],
                startup_user_data['agent_request'],
                startup_user_data['sensitive_context']
            )
            
            print(f"üè• Executing healthcare compliance audit...")
            healthcare_result = vulnerable_engine.execute_agent_for_user(
                healthcare_user_data['user_id'],
                healthcare_user_data['agent_request'],
                healthcare_user_data['sensitive_context']
            )
            
            # CRITICAL VULNERABILITY TESTING
            print(f"\nüîç MEMORY ISOLATION VULNERABILITY ANALYSIS:")
            
            # Test 1: Can enterprise user access startup user's funding data?
            enterprise_memory_access = vulnerable_engine.get_user_execution_data('enterprise_ceo_strategic')
            startup_sensitive_strings = [
                str(startup_user_data['sensitive_context']['valuation']),
                str(startup_user_data['sensitive_context']['investor_list']),
                str(startup_user_data['sensitive_context']['growth_metrics'])
            ]
            
            # Test 2: Can startup user access healthcare PHI data?
            startup_memory_access = vulnerable_engine.get_user_execution_data('startup_founder_funding')
            healthcare_phi_strings = [
                str(healthcare_user_data['sensitive_context']['patient_records']),
                str(healthcare_user_data['sensitive_context']['security_incidents']),
                str(healthcare_user_data['sensitive_context']['audit_trail'])
            ]
            
            # Test 3: Can healthcare user access enterprise strategic data?
            healthcare_memory_access = vulnerable_engine.get_user_execution_data('healthcare_ciso_compliance')
            enterprise_strategic_strings = [
                str(enterprise_user_data['sensitive_context']['strategic_plans']),
                str(enterprise_user_data['sensitive_context']['trade_secrets']),
                str(enterprise_user_data['sensitive_context']['financial_projections'])
            ]
            
            # Analyze memory contamination
            memory_contamination_violations = []
            
            # Check enterprise access to startup data
            enterprise_memory_str = str(enterprise_memory_access).lower()
            for sensitive_data in startup_sensitive_strings:
                if sensitive_data.lower() in enterprise_memory_str:
                    violation = f"Enterprise user can access startup funding data: {sensitive_data}"
                    memory_contamination_violations.append(violation)
                    print(f"   üö® FUNDING DATA LEAK: {violation}")
            
            # Check startup access to healthcare PHI
            startup_memory_str = str(startup_memory_access).lower()
            for phi_data in healthcare_phi_strings:
                if phi_data.lower() in startup_memory_str:
                    violation = f"Startup user can access healthcare PHI: {phi_data}"
                    memory_contamination_violations.append(violation)
                    print(f"   üö® PHI DATA LEAK: {violation}")
            
            # Check healthcare access to enterprise strategic data
            healthcare_memory_str = str(healthcare_memory_access).lower()
            for strategic_data in enterprise_strategic_strings:
                if strategic_data.lower() in healthcare_memory_str:
                    violation = f"Healthcare user can access enterprise strategic data: {strategic_data}"
                    memory_contamination_violations.append(violation)
                    print(f"   üö® STRATEGIC DATA LEAK: {violation}")
            
            # Check global state contamination
            global_state_contamination = []
            if global_agent_state:
                last_execution = global_agent_state.get('last_execution', {})
                last_user = last_execution.get('user_id')
                if last_user:
                    global_state_contamination.append(f"Global agent state contains {last_user}'s execution data")
                    print(f"   üö® GLOBAL STATE CONTAMINATION: {last_user}'s data in global state")
            
            # Check active contexts mixing
            context_mixing_violations = []
            if len(vulnerable_engine.active_contexts) > 1:
                context_mixing_violations.append(f"All user contexts stored together: {len(vulnerable_engine.active_contexts)} users")
                print(f"   üö® CONTEXT MIXING: {len(vulnerable_engine.active_contexts)} user contexts stored together")
                
                # Show which users' data is mixed
                mixed_users = [ctx['user_id'] for ctx in vulnerable_engine.active_contexts]
                print(f"      Mixed users: {', '.join(mixed_users)}")
            
            total_violations = len(memory_contamination_violations) + len(global_state_contamination) + len(context_mixing_violations)
            
            print(f"\nüìä MEMORY ISOLATION VULNERABILITY SUMMARY:")
            print(f"   - Cross-user memory access violations: {len(memory_contamination_violations)}")
            print(f"   - Global state contamination: {len(global_state_contamination)}")
            print(f"   - Context mixing violations: {len(context_mixing_violations)}")
            print(f"   - Total memory vulnerabilities: {total_violations}")
            
            # Store security violations
            for violation in memory_contamination_violations:
                self.security_violations.append({
                    'type': 'memory_cross_access',
                    'severity': 'CRITICAL',
                    'description': violation
                })
            
            for violation in global_state_contamination:
                self.security_violations.append({
                    'type': 'global_state_contamination',
                    'severity': 'HIGH',
                    'description': violation
                })
            
            for violation in context_mixing_violations:
                self.security_violations.append({
                    'type': 'context_mixing',
                    'severity': 'HIGH',
                    'description': violation
                })
            
            if total_violations > 0:
                print("üö® CRITICAL MEMORY ISOLATION VULNERABILITY CONFIRMED:")
                print("   ‚ùå Cross-user memory access enables data theft")
                print("   ‚ùå Enterprise strategic plans exposed to competitors")
                print("   ‚ùå Startup funding data leaked to other companies")
                print("   ‚ùå Healthcare PHI accessible by non-authorized users (HIPAA violation)")
                print("   ‚ùå Global agent state creates persistent contamination")
                print("   ‚ùå ExecutionEngine memory management critically broken")
                print("   üí∞ $500K+ ARR business value + regulatory compliance at risk")
                
                # This test SHOULD fail to prove the vulnerability exists
                self.fail(f"CRITICAL MEMORY ISOLATION VULNERABILITY: {total_violations} memory security violations detected")
            else:
                print("‚úÖ No memory contamination detected (vulnerability may not exist)")
                
        except Exception as e:
            print(f"‚ùå Test execution error: {e}")
            raise

    def test_04_execution_engine_factory_sharing_vulnerability(self):
        """
        Test if ExecutionEngine factory creates shared instances instead of isolated ones.
        
        Expected: FAIL - Instances should be shared (proves vulnerability)
        """
        print("\n" + "="*70)
        print("TEST 4: ExecutionEngine Factory Sharing Vulnerability")
        print("="*70)
        
        try:
            # Simulate vulnerable factory pattern
            class VulnerableFactory:
                _shared_execution_engine = None  # Global shared instance (vulnerability)
                
                @classmethod
                def get_execution_engine(cls, user_id: str = None, context: Dict = None):
                    """Vulnerable factory that reuses instances"""
                    
                    if cls._shared_execution_engine is None:
                        # VULNERABILITY: Create single shared instance for all users
                        cls._shared_execution_engine = {
                            'instance_id': str(uuid.uuid4()),
                            'current_user': None,
                            'user_data': {},
                            'execution_state': {}
                        }
                    
                    # VULNERABILITY: Update shared instance with current user
                    if user_id:
                        cls._shared_execution_engine['current_user'] = user_id
                        cls._shared_execution_engine['user_data'][user_id] = context or {}
                    
                    return cls._shared_execution_engine
            
            # Create execution engines for two users
            user1_context = {
                'sensitive_operation': 'transfer_funds_$50000',
                'account_number': 'ACCT-123456',
                'secret_key': 'user1_private_key_xyz789'
            }
            
            user2_context = {
                'sensitive_operation': 'view_medical_records', 
                'patient_id': 'PATIENT-789012',
                'secret_key': 'user2_private_key_abc123'
            }
            
            # Get execution engines (should be isolated per user)
            engine1 = VulnerableFactory.get_execution_engine('user1', user1_context)
            engine2 = VulnerableFactory.get_execution_engine('user2', user2_context)
            
            print(f"Engine 1 instance ID: {engine1['instance_id']}")
            print(f"Engine 2 instance ID: {engine2['instance_id']}")
            print(f"Engine 1 current user: {engine1['current_user']}")
            print(f"Engine 2 current user: {engine2['current_user']}")
            
            # SECURITY TEST: Check if engines are actually the same instance
            same_instance = engine1 is engine2
            same_instance_id = engine1['instance_id'] == engine2['instance_id']
            
            # Check if user 1 can see user 2's data through shared instance
            user1_can_see_user2_data = 'user2' in engine1.get('user_data', {})
            user2_secret_accessible = user2_context['secret_key'] in str(engine1)
            
            sharing_vulnerability = same_instance or same_instance_id or user1_can_see_user2_data or user2_secret_accessible
            
            if sharing_vulnerability:
                print("üö® FACTORY SHARING VULNERABILITY CONFIRMED:")
                if same_instance:
                    print("   üè≠ Factory returns same instance for different users")
                if same_instance_id:
                    print("   üÜî Engine instances have identical instance IDs")
                if user1_can_see_user2_data:
                    print("   üëÅÔ∏è User 1 can access User 2's data through shared engine")
                if user2_secret_accessible:
                    print("   üîë User 2's secret key accessible to User 1")
                
                print("   ‚ùå This proves factory isolation is broken")
                print("   ‚ùå Users share execution engine instances")
                
                self.security_violations.append({
                    'type': 'factory_instance_sharing',
                    'severity': 'HIGH', 
                    'description': 'ExecutionEngine instances shared between users'
                })
                
                # This test SHOULD fail to prove the vulnerability exists
                self.fail("SECURITY VULNERABILITY DEMONSTRATED: Factory sharing vulnerability detected")
            else:
                print("‚úÖ No factory sharing detected (vulnerability may not exist)")
                
        except Exception as e:
            print(f"‚ùå Test execution error: {e}")
            raise

    def test_05_security_vulnerability_summary(self):
        """Generate comprehensive security vulnerability assessment"""
        print("\n" + "="*80)
        print("ISSUE #565 SECURITY VULNERABILITY ASSESSMENT")
        print("="*80)
        
        # Count vulnerability types by severity
        critical_violations = [v for v in self.security_violations if v['severity'] == 'CRITICAL']
        high_violations = [v for v in self.security_violations if v['severity'] == 'HIGH']
        medium_violations = [v for v in self.security_violations if v['severity'] == 'MEDIUM']
        
        total_violations = len(self.security_violations)
        
        print(f"\nüö® SECURITY VULNERABILITY SUMMARY:")
        print(f"   CRITICAL: {len(critical_violations)} vulnerabilities")
        print(f"   HIGH: {len(high_violations)} vulnerabilities")  
        print(f"   MEDIUM: {len(medium_violations)} vulnerabilities")
        print(f"   TOTAL: {total_violations} security issues")
        
        if self.security_violations:
            print(f"\nüìã DETAILED VULNERABILITY LIST:")
            for i, violation in enumerate(self.security_violations, 1):
                print(f"   {i}. {violation['type'].upper()} ({violation['severity']})")
                print(f"      - {violation['description']}")
        
        print(f"\n" + "="*80)
        if total_violations > 0:
            print("üö® CONCLUSION: IMMEDIATE REMEDIATION REQUIRED")
            print("="*80)
            print("‚ùå Multiple critical user isolation vulnerabilities confirmed")
            print("‚ùå User data contamination and cross-access detected")
            print("‚ùå $500K+ ARR business value at immediate security risk")
            print("‚ùå Issue #565 remediation is P0 CRITICAL SECURITY PRIORITY")
            print("\nRECOMMENDATION:")
            print("1. Immediately proceed with SSOT ExecutionEngine consolidation")
            print("2. Implement proper user isolation in UserExecutionEngine")
            print("3. Add factory pattern with per-user instance creation")
            print("4. Implement comprehensive user data isolation validation")
            print("5. Add WebSocket event delivery isolation controls")
        else:
            print("‚úÖ NO SECURITY VULNERABILITIES DETECTED")
            print("="*80)
            print("‚úÖ User isolation appears to be properly implemented")
            print("‚úÖ No data contamination or cross-access detected")
            print("‚úÖ Issue #565 may be resolved or vulnerability not reproducible")
            print("\nRECOMMENDATION: Validate with additional testing")
        
        print("="*80)


if __name__ == '__main__':
    unittest.main(verbosity=2)