"""
Tests to verify no circular imports exist in critical modules.

These tests ensure that the circular import fixes prevent pytest collection crashes
and Docker container startup failures.
"""
import pytest
import sys
import importlib
from pathlib import Path
from typing import List

# Set up Python path for imports
def _setup_test_paths():
    """Set up Python path for test execution."""
    project_root = Path(__file__).parent.parent
    if str(project_root) not in sys.path:
        sys.path.insert(0, str(project_root))

_setup_test_paths()


class TestCircularImports:
    """Test suite for circular import detection and validation."""
    
    CRITICAL_MODULES = [
        'shared.isolated_environment',
        'netra_backend.app.startup_module', 
        'netra_backend.app.dependencies',
        'netra_backend.app.services.memory_optimization_service',
        'netra_backend.app.services.session_memory_manager',
        'netra_backend.app.database.session_manager'
    ]
    
    def test_all_critical_modules_import_successfully(self):
        """Test that all critical modules can be imported without circular import errors."""
        failed_imports = []
        circular_import_errors = []
        
        for module in self.CRITICAL_MODULES:
            try:
                # Clear module from sys.modules to force fresh import
                if module in sys.modules:
                    del sys.modules[module]
                
                # Import the module
                importlib.import_module(module)
                
            except ImportError as e:
                error_msg = str(e)
                if "circular import" in error_msg.lower() or "partially initialized module" in error_msg:
                    circular_import_errors.append(f"{module}: {error_msg}")
                else:
                    failed_imports.append(f"{module}: {error_msg}")
            except Exception as e:
                failed_imports.append(f"{module}: {type(e).__name__}: {e}")
        
        # Assert no circular imports detected
        if circular_import_errors:
            pytest.fail(
                f"Circular imports detected:\n" + 
                "\n".join(f"  - {error}" for error in circular_import_errors)
            )
        
        # Assert no other import failures
        if failed_imports:
            pytest.fail(
                f"Module import failures:\n" + 
                "\n".join(f"  - {error}" for error in failed_imports)
            )
    
    def test_startup_module_import_order(self):
        """Test that startup_module imports in correct order."""
        # Clear startup module if already imported
        module_name = 'netra_backend.app.startup_module'
        if module_name in sys.modules:
            del sys.modules[module_name]
        
        try:
            import netra_backend.app.startup_module
            
            # Verify that shared.isolated_environment is accessible
            assert hasattr(netra_backend.app.startup_module, 'get_env'), \
                "startup_module should have get_env accessible after import"
                
        except ImportError as e:
            if "circular import" in str(e).lower():
                pytest.fail(f"Circular import in startup_module: {e}")
            raise
    
    def test_dependencies_module_lazy_imports(self):
        """Test that dependencies module properly uses lazy imports."""
        # Clear dependencies module if already imported
        module_name = 'netra_backend.app.dependencies'
        if module_name in sys.modules:
            del sys.modules[module_name]
        
        try:
            import netra_backend.app.dependencies as deps_module
            
            # Verify lazy import functions exist
            assert hasattr(deps_module, '_get_session_scope_validator'), \
                "dependencies module should have lazy import function _get_session_scope_validator"
            
            assert hasattr(deps_module, '_get_session_isolation_error'), \
                "dependencies module should have lazy import function _get_session_isolation_error"
            
            assert hasattr(deps_module, '_get_managed_session'), \
                "dependencies module should have lazy import function _get_managed_session"
            
            # Test that lazy imports work
            validator_class = deps_module._get_session_scope_validator()
            assert validator_class is not None, "Lazy import should return valid class"
            
        except ImportError as e:
            if "circular import" in str(e).lower():
                pytest.fail(f"Circular import in dependencies: {e}")
            raise
    
    def test_session_manager_type_checking_imports(self):
        """Test that session_manager uses TYPE_CHECKING pattern correctly."""
        # Clear session_manager module if already imported
        module_name = 'netra_backend.app.database.session_manager'
        if module_name in sys.modules:
            del sys.modules[module_name]
        
        try:
            import netra_backend.app.database.session_manager as sm_module
            
            # Verify lazy import function exists
            assert hasattr(sm_module, '_get_user_execution_context_type'), \
                "session_manager should have lazy import function _get_user_execution_context_type"
            
            # Test that lazy import works
            context_class = sm_module._get_user_execution_context_type()
            assert context_class is not None, "Lazy import should return valid class"
            
        except ImportError as e:
            if "circular import" in str(e).lower():
                pytest.fail(f"Circular import in session_manager: {e}")
            raise
    
    def test_import_order_isolation(self):
        """Test that modules can be imported in any order without issues."""
        # Test different import orders to ensure robustness
        import_orders = [
            # Standard order
            ['shared.isolated_environment', 'netra_backend.app.database.session_manager', 'netra_backend.app.dependencies'],
            
            # Reverse order 
            ['netra_backend.app.dependencies', 'netra_backend.app.database.session_manager', 'shared.isolated_environment'],
            
            # Mixed order
            ['netra_backend.app.database.session_manager', 'shared.isolated_environment', 'netra_backend.app.dependencies'],
        ]
        
        for i, order in enumerate(import_orders):
            # Clear modules
            for module in order:
                if module in sys.modules:
                    del sys.modules[module]
            
            try:
                # Import in this order
                for module in order:
                    importlib.import_module(module)
                    
            except ImportError as e:
                if "circular import" in str(e).lower():
                    pytest.fail(f"Circular import detected in order #{i+1} {order}: {e}")
                raise
    
    def test_pytest_collection_compatibility(self):
        """Test that modules work properly during pytest collection."""
        # Simulate pytest collection scenario
        original_modules = dict(sys.modules)
        
        try:
            # Clear modules that might be problematic
            modules_to_clear = [m for m in sys.modules.keys() 
                              if m.startswith('netra_backend.app') or m.startswith('shared.')]
            
            for module in modules_to_clear:
                if module in sys.modules:
                    del sys.modules[module]
            
            # Import modules as pytest would during collection
            for module in self.CRITICAL_MODULES:
                try:
                    importlib.import_module(module)
                except ImportError as e:
                    if "circular import" in str(e).lower():
                        pytest.fail(f"Pytest collection would fail due to circular import in {module}: {e}")
                    raise
        finally:
            # Restore original module state
            sys.modules.clear()
            sys.modules.update(original_modules)
    
    def test_import_guards_effectiveness(self):
        """Test that import guards prevent runtime circular import issues."""
        # Test that TYPE_CHECKING imports don't affect runtime
        try:
            from netra_backend.app.database.session_manager import DatabaseSessionManager
            from netra_backend.app.dependencies import get_db_dependency
            
            # These should work without triggering circular imports
            assert DatabaseSessionManager is not None
            assert get_db_dependency is not None
            
        except ImportError as e:
            if "circular import" in str(e).lower():
                pytest.fail(f"Import guards failed to prevent circular import: {e}")
            raise
    
    @pytest.mark.parametrize("module_name", CRITICAL_MODULES)
    def test_individual_module_import(self, module_name: str):
        """Test each critical module can be imported individually."""
        # Clear the specific module
        if module_name in sys.modules:
            del sys.modules[module_name]
        
        try:
            importlib.import_module(module_name)
        except ImportError as e:
            if "circular import" in str(e).lower():
                pytest.fail(f"Circular import in {module_name}: {e}")
            raise
    
    def test_memory_service_integration(self):
        """Test memory services work without circular imports."""
        try:
            from netra_backend.app.services.memory_optimization_service import get_memory_service
            from netra_backend.app.services.session_memory_manager import get_session_manager
            
            # These should be importable and callable
            memory_service = get_memory_service()
            session_manager = get_session_manager()
            
            assert memory_service is not None
            assert session_manager is not None
            
        except ImportError as e:
            if "circular import" in str(e).lower():
                pytest.fail(f"Circular import in memory services: {e}")
            raise


class TestImportHierarchy:
    """Test the overall import hierarchy for correctness."""
    
    def test_shared_isolated_environment_is_foundation(self):
        """Test that shared.isolated_environment can be imported first."""
        # This should always work as it's the foundation
        import shared.isolated_environment
        assert hasattr(shared.isolated_environment, 'get_env')
    
    def test_startup_module_path_setup(self):
        """Test that startup_module sets up paths correctly."""
        import netra_backend.app.startup_module as startup
        
        # Verify the _setup_paths function exists
        assert hasattr(startup, '_setup_paths'), \
            "startup_module should have _setup_paths function"
    
    def test_lazy_import_functions_work(self):
        """Test that all lazy import functions work correctly."""
        from netra_backend.app.dependencies import (
            _get_session_scope_validator,
            _get_session_isolation_error,
            _get_managed_session
        )
        
        # Test lazy imports work
        validator = _get_session_scope_validator()
        error_class = _get_session_isolation_error()
        managed_fn = _get_managed_session()
        
        assert validator is not None
        assert error_class is not None  
        assert managed_fn is not None
    
    def test_type_checking_imports_isolation(self):
        """Test that TYPE_CHECKING imports don't cause runtime issues."""
        # Import modules that use TYPE_CHECKING
        import netra_backend.app.database.session_manager
        import netra_backend.app.dependencies
        
        # Should not have runtime errors from TYPE_CHECKING imports
        assert netra_backend.app.database.session_manager is not None
        assert netra_backend.app.dependencies is not None


if __name__ == "__main__":
    # Run tests directly for verification
    print("Testing circular imports...")
    
    test_instance = TestCircularImports()
    
    try:
        test_instance.test_all_critical_modules_import_successfully()
        print("PASS: All critical modules import successfully")
    except Exception as e:
        print(f"FAIL: Critical modules test failed: {e}")
        
    try:
        test_instance.test_import_order_isolation()
        print("PASS: Import order isolation test passed")
    except Exception as e:
        print(f"FAIL: Import order test failed: {e}")
        
    try:
        test_instance.test_import_guards_effectiveness()
        print("PASS: Import guards effectiveness test passed")  
    except Exception as e:
        print(f"FAIL: Import guards test failed: {e}")
    
    print("\\nTesting import hierarchy...")
    
    hierarchy_test = TestImportHierarchy()
    
    try:
        hierarchy_test.test_shared_isolated_environment_is_foundation()
        print("PASS: shared.isolated_environment foundation test passed")
    except Exception as e:
        print(f"FAIL: Foundation test failed: {e}")
        
    try:
        hierarchy_test.test_startup_module_path_setup()
        print("PASS: startup_module path setup test passed")
    except Exception as e:
        print(f"FAIL: Path setup test failed: {e}")
        
    print("\\nCircular import testing complete!")