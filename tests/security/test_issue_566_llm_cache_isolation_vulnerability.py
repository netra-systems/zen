#!/usr/bin/env python3
"""
SECURITY TEST SUITE: Issue #566 - LLM Cache Isolation Vulnerability

This test suite exposes and validates the fix for Critical P1 security vulnerability
where LLM cache isolation is compromised in startup_module.py:649 and smd.py:979.

VULNERABILITY: LLM Managers created without user context cause conversation mixing
- User A's cached responses returned to User B
- GDPR/CCPA violations from personal data mixing  
- $500K+ ARR business risk from active data breach

BUSINESS VALUE JUSTIFICATION:
- Segment: ALL (Free â†’ Enterprise)
- Business Goal: Prevent critical security vulnerabilities
- Value Impact: Protect user privacy and prevent data breaches
- Strategic Impact: CRITICAL - $500K+ ARR protection

Test Categories:
1. Cache Key Isolation Vulnerability Test (MUST FAIL initially)
2. Global Manager Security Test (MUST FAIL initially) 
3. Startup Module Security Regression Test
4. SMD Module Security Regression Test
5. User Context Factory Pattern Validation

Expected Behavior:
- Tests FAIL initially to prove vulnerability exists
- Tests PASS after security fix is implemented
- Automated regression prevention for future deployments

Following CLAUDE.md requirements:
- Real services (no mocks)
- SSOT BaseTestCase inheritance
- Non-Docker test design
- Factory pattern enforcement
"""

import pytest
import asyncio
import uuid
from typing import Dict, Any, List
from datetime import datetime, timezone

# SSOT Test Infrastructure 
from test_framework.ssot.base_test_case import SSotAsyncTestCase
from shared.isolated_environment import IsolatedEnvironment

# Production modules under test
from netra_backend.app.llm.llm_manager import LLMManager, create_llm_manager
from netra_backend.app.services.user_execution_context import UserExecutionContext
from netra_backend.app.core.configuration.base import get_unified_config


class TestIssue566LLMCacheIsolationVulnerability(SSotAsyncTestCase):
    """
    Critical security tests for Issue #566 LLM cache isolation vulnerability.
    
    These tests MUST FAIL initially to prove the vulnerability exists.
    After the security fix, the same tests MUST PASS.
    """
    
    async def setup_method(self, method):
        """Set up test environment with isolated configuration."""
        await super().setup_method(method)
        
        # Initialize test users with distinct contexts
        self.user_a_context = UserExecutionContext.from_request(
            user_id="user_a_12345",
            thread_id="thread_a_67890", 
            run_id="run_a_11111",
            request_id="req_a_22222"
        )
        
        self.user_b_context = UserExecutionContext.from_request(
            user_id="user_b_54321",
            thread_id="thread_b_09876",
            run_id="run_b_99999", 
            request_id="req_b_88888"
        )
        
        # Test prompt that should be isolated per user
        self.test_prompt = "What are my optimization recommendations?"
        self.test_config = "default"
        
        # Expected responses that should be user-specific
        self.user_a_response = "User A specific optimization data: reduce compute costs by 25%"
        self.user_b_response = "User B specific optimization data: optimize storage by 40%"
    
    async def test_cache_key_isolation_vulnerability_reproduction(self):
        """
        CRITICAL TEST: Reproduce cache key isolation vulnerability.
        
        This test MUST FAIL initially to prove vulnerability exists.
        It demonstrates how global LLM managers mix cache keys between users.
        
        Expected Initial Behavior: FAIL - Users get each other's cached responses
        Expected After Fix: PASS - Users get only their own responses
        """
        
        # Create user-contexted managers (proper pattern)
        user_a_manager = create_llm_manager(user_context=self.user_a_context)
        user_b_manager = create_llm_manager(user_context=self.user_b_context)
        
        await user_a_manager.initialize()
        await user_b_manager.initialize()
        
        # Generate different cache keys for same prompt
        user_a_cache_key = user_a_manager._get_cache_key(self.test_prompt, self.test_config)
        user_b_cache_key = user_b_manager._get_cache_key(self.test_prompt, self.test_config)
        
        # SECURITY ASSERTION: Cache keys MUST be different for different users
        # This MUST FAIL if global managers are used (no user context)
        assert user_a_cache_key != user_b_cache_key, (
            f"SECURITY VULNERABILITY: Cache keys are identical for different users!\n"
            f"User A key: {user_a_cache_key}\n"
            f"User B key: {user_b_cache_key}\n"
            f"This causes conversation mixing between users."
        )
        
        # Verify user isolation in cache keys
        assert "user_a_12345:" in user_a_cache_key, f"User A cache key missing user prefix: {user_a_cache_key}"
        assert "user_b_54321:" in user_b_cache_key, f"User B cache key missing user prefix: {user_b_cache_key}"
        
        # Test cache isolation by simulating cached responses
        user_a_manager._cache[user_a_cache_key] = self.user_a_response
        user_b_manager._cache[user_b_cache_key] = self.user_b_response
        
        # Verify each user gets only their own cached data
        assert user_a_manager._is_cached(self.test_prompt, self.test_config), "User A cache lookup failed"
        assert user_b_manager._is_cached(self.test_prompt, self.test_config), "User B cache lookup failed"
        
        # Critical security check: Users cannot access each other's cache
        assert user_a_cache_key not in user_b_manager._cache, "User B can access User A's cache!"
        assert user_b_cache_key not in user_a_manager._cache, "User A can access User B's cache!"
    
    async def test_global_manager_vulnerability_demonstration(self):
        """
        CRITICAL TEST: Demonstrate global manager vulnerability.
        
        This recreates the exact vulnerability in startup_module.py:649 and smd.py:979
        where LLM managers are created without user context.
        
        Expected Initial Behavior: FAIL - Global managers mix cache data
        Expected After Fix: PASS - Global managers eliminated
        """
        
        # Recreate the vulnerable pattern from startup files
        global_manager_vulnerable = create_llm_manager()  # NO user_context - VULNERABLE!
        await global_manager_vulnerable.initialize()
        
        # Create proper user-contexted manager
        user_manager_secure = create_llm_manager(user_context=self.user_a_context)
        await user_manager_secure.initialize()
        
        # Generate cache keys with same prompt
        global_cache_key = global_manager_vulnerable._get_cache_key(self.test_prompt, self.test_config)
        user_cache_key = user_manager_secure._get_cache_key(self.test_prompt, self.test_config)
        
        # VULNERABILITY PROOF: Global manager creates unscoped cache keys
        # This test MUST FAIL initially because global managers have no user prefix
        assert global_cache_key.startswith("user_"), (
            f"SECURITY VULNERABILITY: Global manager creates unscoped cache key!\n"
            f"Global key: {global_cache_key}\n"
            f"Expected: user_prefixed cache key\n"
            f"This is the exact vulnerability in startup_module.py:649 and smd.py:979"
        )
        
        # Security warning check
        user_manager_secure._logger.info("Testing security warning detection")
        # Global manager should log security warning about missing user context
        assert hasattr(global_manager_vulnerable, '_user_context'), "Global manager missing user context tracking"
        assert global_manager_vulnerable._user_context is None, "Global manager has unexpected user context"
    
    async def test_startup_module_security_regression_prevention(self):
        """
        Regression test to prevent reintroduction of startup_module.py:649 vulnerability.
        
        This test validates that startup initialization creates properly isolated
        LLM managers instead of global instances.
        """
        
        # Import the actual startup module function that contains the vulnerability
        from netra_backend.app.startup_module import setup_security_services
        from netra_backend.app.services.key_manager import KeyManager
        from fastapi import FastAPI
        
        # Create test FastAPI app
        test_app = FastAPI()
        
        # Create test key manager
        from shared.isolated_environment import IsolatedEnvironment
        env = IsolatedEnvironment()
        key_manager = KeyManager(
            openai_api_key=env.get("OPENAI_API_KEY", "test_key"),
            jwt_secret_key=env.get("JWT_SECRET_KEY", "test_jwt_secret")
        )
        
        # Call the vulnerable function
        setup_security_services(test_app, key_manager)
        
        # SECURITY ASSERTION: Startup should NOT create global LLM manager
        # This test MUST FAIL initially due to line 649 vulnerability
        assert not hasattr(test_app.state, 'llm_manager'), (
            f"SECURITY REGRESSION: startup_module.py creates global LLM manager!\n"
            f"Line 649: app.state.llm_manager = create_llm_manager()\n"
            f"This creates a global manager without user context, causing cache mixing.\n"
            f"FIX: Remove global LLM manager creation from startup."
        )
        
        # If global manager exists, verify it logs security warnings
        if hasattr(test_app.state, 'llm_manager'):
            global_manager = test_app.state.llm_manager
            assert global_manager._user_context is None, "Global manager has unexpected user context"
    
    async def test_smd_module_security_regression_prevention(self):
        """
        Regression test to prevent reintroduction of smd.py:1007 vulnerability.
        
        This test validates that SMD initialization doesn't create global
        LLM managers that mix user conversations.
        """
        
        # Import SMD module with the vulnerability
        from netra_backend.app.smd import StartupModuleDeterministic
        from netra_backend.app.core.configuration.base import UnifiedConfiguration
        from fastapi import FastAPI
        
        # Create test app and SMD instance
        test_app = FastAPI()
        
        # Create minimal config for testing
        test_config = UnifiedConfiguration(
            environment="test",
            database_config=None,
            redis_config=None,
            service_configs={}
        )
        
        smd = StartupModuleDeterministic(test_app, test_config)
        
        # Call the vulnerable initialization method
        smd._initialize_llm_manager()
        
        # SECURITY ASSERTION: SMD should NOT create global LLM manager  
        # This test MUST FAIL initially due to line 1007 vulnerability
        assert not hasattr(test_app.state, 'llm_manager'), (
            f"SECURITY REGRESSION: smd.py creates global LLM manager!\n"
            f"Line 1007: self.app.state.llm_manager = create_llm_manager()\n"
            f"This creates a global manager without user context, causing cache mixing.\n"
            f"FIX: Remove global LLM manager creation from SMD initialization."
        )
        
        # If global manager exists, verify it logs security warnings  
        if hasattr(test_app.state, 'llm_manager'):
            global_manager = test_app.state.llm_manager
            assert global_manager._user_context is None, "Global manager has unexpected user context"
    
    async def test_user_context_factory_pattern_validation(self):
        """
        Positive test to validate proper user context factory pattern.
        
        This test demonstrates the CORRECT way to create LLM managers
        with proper user isolation.
        """
        
        # Test multiple users with concurrent LLM operations
        users = []
        managers = []
        
        for i in range(3):
            user_context = UserExecutionContext.from_request(
                user_id=f"test_user_{i}",
                thread_id=f"thread_{i}",
                run_id=f"run_{i}",
                request_id=f"req_{i}"
            )
            users.append(user_context)
            
            manager = create_llm_manager(user_context=user_context)
            await manager.initialize()
            managers.append(manager)
        
        # Verify each manager has distinct user context
        for i, manager in enumerate(managers):
            assert manager._user_context is not None, f"Manager {i} missing user context"
            assert manager._user_context.user_id == f"test_user_{i}", f"Manager {i} wrong user ID"
            
            # Verify cache isolation
            cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
            assert f"test_user_{i}:" in cache_key, f"Manager {i} cache key missing user prefix"
            
            # Verify each manager has isolated cache
            assert len(manager._cache) == 0, f"Manager {i} has unexpected cache data"
        
        # Test concurrent cache operations don't interfere
        test_responses = [f"Response for user {i}" for i in range(3)]
        
        for i, (manager, response) in enumerate(zip(managers, test_responses)):
            cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
            manager._cache[cache_key] = response
        
        # Verify cache isolation maintained
        for i, manager in enumerate(managers):
            assert manager._is_cached(self.test_prompt, self.test_config), f"User {i} cache lookup failed"
            
            cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
            cached_response = manager._cache[cache_key]
            assert cached_response == test_responses[i], f"User {i} got wrong cached response"
            
            # Verify user cannot access other users' cache keys
            for j, other_manager in enumerate(managers):
                if i != j:
                    other_cache_key = other_manager._get_cache_key(self.test_prompt, self.test_config)
                    assert other_cache_key not in manager._cache, f"User {i} can access User {j}'s cache!"
    
    async def test_security_compliance_audit_trail(self):
        """
        Test security compliance and audit trail for LLM operations.
        
        Ensures proper logging and monitoring for security investigations.
        """
        
        # Create manager with user context
        manager = create_llm_manager(user_context=self.user_a_context)
        await manager.initialize()
        
        # Verify security logging components
        assert hasattr(manager, '_logger'), "Manager missing logger for security audit"
        assert hasattr(manager, '_user_context'), "Manager missing user context for audit"
        
        # Test cache operation logging
        cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
        manager._cache[cache_key] = "test response"
        
        # Verify audit trail information is available
        assert manager._user_context.user_id == "user_a_12345", "Audit trail missing user ID"
        assert manager._user_context.request_id == "req_a_22222", "Audit trail missing request ID"
        
        # Test security warning for missing user context
        global_manager = create_llm_manager()  # No user context
        await global_manager.initialize()
        
        # Verify security warning logged (implementation should log this)
        assert global_manager._user_context is None, "Global manager should have None user context"
        
        # Test cache key generation with security implications
        global_cache_key = global_manager._get_cache_key(self.test_prompt, self.test_config)
        user_cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
        
        # Security audit: Verify different cache namespaces
        assert global_cache_key != user_cache_key, "Cache keys should be different for security"
        assert not global_cache_key.startswith("user_"), "Global manager should not have user prefix"
        assert user_cache_key.startswith("user_a_12345:"), "User manager must have user prefix"


if __name__ == "__main__":
    # Allow direct execution for debugging
    pytest.main([__file__, "-v", "-s"])