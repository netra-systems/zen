"""
CRITICAL FAILING TEST SUITE: Service Secret Configuration Vulnerability
Purpose: Expose security weaknesses in service_secret fallback to jwt_secret_key
Expected: ALL tests should FAIL to demonstrate the vulnerability

WARNING: This test suite reproduces the critical warning:
"service_secret not configured, using jwt_secret_key fallback"

Business Value Justification (BVJ):
- Segment: All (Enterprise, Mid, Early, Free) - Security is foundational
- Business Goal: Risk Reduction - Prevent authentication bypasses
- Value Impact: Protects customer AI workloads and data integrity
- Strategic Impact: Critical - Authentication breaches destroy platform trust
"""

import pytest
import asyncio
import logging
import os
import sys
import time
import datetime
import hmac
import hashlib
import json
from typing import Dict, Optional, Any
from unittest.mock import Mock, patch, AsyncMock, MagicMock

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from netra_backend.app.services.user_auth_service import UserAuthService
from netra_backend.app.core.configuration import unified_config_manager
from netra_backend.app.schemas.Config import AppConfig
from netra_backend.app.core.auth_constants import AuthConstants


@pytest.fixture
def vulnerable_config():
    """Configuration with missing service_secret (vulnerable state)"""
    config = Mock(spec=AppConfig)
    config.service_secret = None  # CRITICAL: No service_secret configured
    config.jwt_secret_key = "weak-jwt-secret-12345"  # Fallback secret
    config.environment = "development"
    config.auth_service_url = "http://localhost:8001"
    return config


@pytest.fixture
def secure_config():
    """Configuration with proper service_secret"""
    config = Mock(spec=AppConfig)
    config.service_secret = "strong-service-secret-" + os.urandom(32).hex()
    config.jwt_secret_key = "different-jwt-secret-" + os.urandom(32).hex()
    config.environment = "production"
    config.auth_service_url = "http://localhost:8001"
    return config


@pytest.fixture
def mock_auth_client():
    """Mock auth client for testing"""
    client = AsyncMock()
    client.validate_token = AsyncMock()
    return client


@pytest.fixture
def capture_logs():
    """Fixture to capture log output"""
    logs = []
    handler = logging.Handler()
    handler.emit = lambda record: logs.append(record)
    
    logger = logging.getLogger("netra_backend.app.services.user_auth_service")
    logger.addHandler(handler)
    logger.setLevel(logging.WARNING)
    
    yield logs
    
    logger.removeHandler(handler)


class TestServiceSecretFallbackVulnerability:
    """
    CRITICAL: These tests MUST FAIL to expose the vulnerability
    Each test demonstrates a security weakness in the fallback mechanism
    """
    
    @pytest.mark.asyncio
    async def test_missing_service_secret_generates_warning(self, vulnerable_config, capture_logs):
        """
        TEST 1: Missing service_secret should trigger security alert
        EXPECTED FAILURE: System logs warning but continues with weak fallback
        ATTACK VECTOR: Configuration weakness detection
        """
        # Arrange
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config', 
                   return_value=vulnerable_config):
            auth_service = UserAuthService()
        
        # Act - Initialize service with missing service_secret
        secret = auth_service._get_shared_secret()
        
        # Assert - This should FAIL because warning is logged
        warning_found = any(
            "service_secret not configured" in str(log.getMessage())
            for log in capture_logs
        )
        
        # FAILING ASSERTION: System should not just warn, it should reject
        assert not warning_found, (
            "VULNERABILITY: System logs warning about missing service_secret "
            "but continues operation with weak fallback. Should reject initialization."
        )
        
        # Additional check: Fallback should not be allowed
        assert secret != vulnerable_config.jwt_secret_key, (
            "VULNERABILITY: System falls back to jwt_secret_key when service_secret missing"
        )
    
    @pytest.mark.asyncio
    async def test_service_secret_none_falls_back_to_jwt(self, vulnerable_config, mock_auth_client):
        """
        TEST 2: None service_secret should be rejected
        EXPECTED FAILURE: System accepts None and falls back to JWT secret
        ATTACK VECTOR: Exploit None value to force fallback
        """
        # Arrange
        vulnerable_config.service_secret = None
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                auth_service = UserAuthService()
        
        # Act
        secret = auth_service._shared_secret
        
        # Assert - This should FAIL because None is accepted
        assert secret != vulnerable_config.jwt_secret_key, (
            "VULNERABILITY: Service accepts None service_secret and falls back to JWT secret. "
            "None should trigger initialization failure."
        )
        
        # Verify service is not operational with None secret
        with pytest.raises(ValueError, match="service_secret is required"):
            await auth_service.validate_user_token("test-token")
    
    @pytest.mark.asyncio
    async def test_empty_service_secret_falls_back_to_jwt(self, vulnerable_config):
        """
        TEST 3: Empty string service_secret should be rejected
        EXPECTED FAILURE: System accepts empty string and falls back
        ATTACK VECTOR: Exploit empty string to force fallback
        """
        # Arrange
        vulnerable_config.service_secret = ""  # Empty string attack
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            auth_service = UserAuthService()
        
        # Act
        secret = auth_service._shared_secret
        
        # Assert - This should FAIL because empty string is accepted
        assert secret != vulnerable_config.jwt_secret_key, (
            "VULNERABILITY: Service accepts empty service_secret and falls back to JWT secret. "
            "Empty string should be rejected as invalid configuration."
        )
        
        # Verify empty string is validated
        assert len(secret) > 0 and secret != "dev-secret", (
            "VULNERABILITY: Empty service_secret results in weak default secret"
        )
    
    @pytest.mark.asyncio
    async def test_service_secret_fallback_same_as_jwt_secret(self, vulnerable_config):
        """
        TEST 4: Identical secrets across services should be detected
        EXPECTED FAILURE: System allows same secret for different purposes
        ATTACK VECTOR: Shared secrets enable cross-domain attacks
        """
        # Arrange
        vulnerable_config.service_secret = None
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            auth_service = UserAuthService()
        
        # Act
        service_secret = auth_service._shared_secret
        jwt_secret = vulnerable_config.jwt_secret_key
        
        # Assert - This should FAIL because secrets are the same
        assert service_secret != jwt_secret, (
            "VULNERABILITY: Service secret and JWT secret are identical when fallback occurs. "
            "This enables cross-domain signature attacks and service impersonation."
        )
        
        # Verify cryptographic separation
        service_sig = hmac.new(
            service_secret.encode(),
            b"test-payload",
            hashlib.sha256
        ).hexdigest()
        
        jwt_sig = hmac.new(
            jwt_secret.encode(),
            b"test-payload",
            hashlib.sha256
        ).hexdigest()
        
        assert service_sig != jwt_sig, (
            "VULNERABILITY: Identical signatures generated for different security domains"
        )
    
    @pytest.mark.asyncio
    async def test_service_secret_weak_entropy(self, vulnerable_config):
        """
        TEST 5: Weak service secrets should be rejected
        EXPECTED FAILURE: System accepts low-entropy secrets
        ATTACK VECTOR: Weak secret brute-force/dictionary attacks
        """
        # Arrange - Test various weak secrets
        weak_secrets = [
            "password",
            "12345678",
            "secret",
            "dev-secret",
            "test-secret",
            "a" * 8,  # Repeated characters
            "abcd1234",  # Simple pattern
        ]
        
        for weak_secret in weak_secrets:
            vulnerable_config.service_secret = weak_secret
            
            with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                       return_value=vulnerable_config):
                
                # Act & Assert - Should reject weak secrets
                with pytest.raises(ValueError, match="insufficient entropy|weak secret"):
                    auth_service = UserAuthService()
                    
                # If initialization doesn't fail, check runtime validation
                try:
                    auth_service = UserAuthService()
                    secret = auth_service._shared_secret
                    
                    # Calculate entropy (simplified)
                    unique_chars = len(set(secret))
                    entropy_bits = len(secret) * (unique_chars.bit_length())
                    
                    # Assert minimum entropy (e.g., 128 bits)
                    assert entropy_bits >= 128, (
                        f"VULNERABILITY: Weak secret '{weak_secret}' accepted with only "
                        f"{entropy_bits} bits of entropy. Minimum 128 bits required."
                    )
                except Exception:
                    pass  # Expected to fail


class TestCrossServiceAuthenticationBypass:
    """
    Tests that exploit the service_secret fallback to bypass authentication
    ALL tests should FAIL to demonstrate cross-service vulnerabilities
    """
    
    @pytest.mark.asyncio
    async def test_cross_service_token_signature_bypass(self, vulnerable_config, mock_auth_client):
        """
        TEST 6: Exploit shared secret to bypass service validation
        EXPECTED FAILURE: Attacker can forge service signatures using JWT secret
        ATTACK VECTOR: Use jwt_secret_key to forge service signatures
        """
        # Arrange - Setup vulnerable service with fallback
        vulnerable_config.service_secret = None
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                auth_service = UserAuthService()
        
        # Act - Attacker knows JWT secret and creates forged service signature
        jwt_secret = vulnerable_config.jwt_secret_key
        
        # Create malicious token data
        malicious_data = {
            "user_id": "attacker-id",
            "email": "attacker@evil.com",
            "verified_at": datetime.datetime.now(datetime.timezone.utc).isoformat(),
            "valid": True
        }
        
        # Forge service signature using known JWT secret
        forged_signature = hmac.new(
            jwt_secret.encode(),
            json.dumps(malicious_data, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        
        malicious_data["service_signature"] = forged_signature
        
        # Mock auth client to return our forged data
        mock_auth_client.validate_token.return_value = malicious_data
        
        # Attempt validation with forged signature
        result = await auth_service.validate_user_token("forged-token")
        
        # Assert - This should FAIL (result should be None for forged signatures)
        assert result is None, (
            "VULNERABILITY: Forged service signature accepted! "
            "Attacker successfully bypassed authentication using JWT secret to forge service signature."
        )
        
        # Verify signature validation actually occurred
        assert not auth_service._validate_cross_service_token(malicious_data, "forged-token"), (
            "VULNERABILITY: Cross-service validation accepts forged signatures"
        )
    
    @pytest.mark.asyncio
    async def test_service_impersonation_attack(self, vulnerable_config, mock_auth_client):
        """
        TEST 7: Impersonate auth service using fallback secret
        EXPECTED FAILURE: Attacker can impersonate legitimate auth service
        ATTACK VECTOR: Create malicious service that passes validation
        """
        # Arrange
        vulnerable_config.service_secret = None
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                auth_service = UserAuthService()
        
        # Act - Create fake auth service response
        fake_auth_response = {
            "user_id": "legitimate-user",
            "email": "user@company.com",
            "verified_at": datetime.datetime.now(datetime.timezone.utc).isoformat(),
            "valid": True,
            "service_id": "fake-auth-service"  # Impersonation marker
        }
        
        # Sign with fallback secret (which attacker knows)
        fallback_secret = vulnerable_config.jwt_secret_key
        fake_signature = hmac.new(
            fallback_secret.encode(),
            json.dumps(fake_auth_response, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        
        fake_auth_response["service_signature"] = fake_signature
        
        # Configure mock to return fake response
        mock_auth_client.validate_token.return_value = fake_auth_response
        
        # Attempt validation
        result = await auth_service.validate_user_token("impersonation-token")
        
        # Assert - Should detect service impersonation
        assert result is None or result.get("service_id") != "fake-auth-service", (
            "VULNERABILITY: Service impersonation successful! "
            "Fake auth service response accepted as legitimate."
        )
        
        # Verify service identity validation
        assert "service_id" in fake_auth_response and fake_auth_response["service_id"] == "auth_service", (
            "VULNERABILITY: No service identity validation - any service can impersonate auth service"
        )
    
    @pytest.mark.asyncio
    async def test_replay_attack_cross_service(self, vulnerable_config, mock_auth_client):
        """
        TEST 8: Replay service tokens across different services
        EXPECTED FAILURE: Old tokens can be replayed indefinitely
        ATTACK VECTOR: Token replay between services
        """
        # Arrange
        vulnerable_config.service_secret = None
        replay_tracker = set()  # Track used tokens
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                auth_service = UserAuthService()
        
        # Create valid token response
        valid_response = {
            "user_id": "user-123",
            "email": "user@example.com",
            "verified_at": (datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(minutes=2)).isoformat(),
            "valid": True,
            "nonce": "unique-nonce-12345"  # Should prevent replay
        }
        
        # Sign with fallback secret
        secret = vulnerable_config.jwt_secret_key
        signature = hmac.new(
            secret.encode(),
            json.dumps(valid_response, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        
        valid_response["service_signature"] = signature
        mock_auth_client.validate_token.return_value = valid_response
        
        # Act - First validation (should succeed)
        result1 = await auth_service.validate_user_token("token-to-replay")
        if result1:
            replay_tracker.add(valid_response.get("nonce"))
        
        # Replay the same token
        result2 = await auth_service.validate_user_token("token-to-replay")
        
        # Assert - Second validation should fail (replay detection)
        assert result2 is None or result2.get("nonce") not in replay_tracker, (
            "VULNERABILITY: Token replay attack successful! "
            "Same token accepted multiple times - no replay protection."
        )
        
        # Verify nonce tracking
        assert hasattr(auth_service, '_used_nonces') or hasattr(auth_service, '_nonce_cache'), (
            "VULNERABILITY: No nonce/replay tracking mechanism implemented"
        )
    
    @pytest.mark.asyncio
    async def test_service_downgrade_attack(self, secure_config, vulnerable_config):
        """
        TEST 9: Force service to use weaker authentication
        EXPECTED FAILURE: Attacker can downgrade security by manipulating config
        ATTACK VECTOR: Configuration manipulation to force fallback
        """
        # Arrange - Start with secure config
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=secure_config):
            auth_service = UserAuthService()
            initial_secret = auth_service._shared_secret
        
        # Act - Attacker manipulates configuration (e.g., via environment variable)
        with patch.dict(os.environ, {"SERVICE_SECRET": "", "FORCE_FALLBACK": "true"}):
            # Simulate config reload/refresh
            with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                       return_value=vulnerable_config):
                # Re-initialize or refresh configuration
                auth_service = UserAuthService()
                downgraded_secret = auth_service._shared_secret
        
        # Assert - Security level should not be downgradeable
        assert initial_secret == downgraded_secret, (
            "VULNERABILITY: Security downgrade successful! "
            "Service switched from strong service_secret to weak JWT fallback."
        )
        
        # Verify security level persistence
        assert len(downgraded_secret) >= len(initial_secret), (
            "VULNERABILITY: Downgraded secret is weaker than initial secret"
        )
    
    @pytest.mark.asyncio
    async def test_man_in_the_middle_service_communication(self, vulnerable_config, mock_auth_client):
        """
        TEST 10: Intercept and modify service-to-service communication
        EXPECTED FAILURE: MITM can tamper with service messages
        ATTACK VECTOR: MITM using known fallback secret
        """
        # Arrange
        vulnerable_config.service_secret = None
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                auth_service = UserAuthService()
        
        # Original legitimate response
        original_response = {
            "user_id": "user-456",
            "email": "legitimate@example.com",
            "verified_at": datetime.datetime.now(datetime.timezone.utc).isoformat(),
            "valid": True,
            "role": "user"
        }
        
        # MITM intercepts and modifies response
        tampered_response = original_response.copy()
        tampered_response["role"] = "admin"  # Privilege escalation
        tampered_response["additional_permissions"] = ["delete_all", "access_all"]
        
        # Re-sign with known fallback secret
        fallback_secret = vulnerable_config.jwt_secret_key
        tampered_signature = hmac.new(
            fallback_secret.encode(),
            json.dumps(tampered_response, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        
        tampered_response["service_signature"] = tampered_signature
        
        # Mock returns tampered response
        mock_auth_client.validate_token.return_value = tampered_response
        
        # Act
        result = await auth_service.validate_user_token("mitm-token")
        
        # Assert - Tampered response should be rejected
        assert result is None or result.get("role") != "admin", (
            "VULNERABILITY: MITM attack successful! "
            "Tampered response with privilege escalation accepted."
        )
        
        # Verify message integrity
        assert "additional_permissions" not in result if result else True, (
            "VULNERABILITY: Unauthorized fields injected via MITM attack"
        )


class TestTimestampManipulationAttacks:
    """
    Tests that exploit timestamp validation weaknesses
    ALL tests should FAIL to demonstrate timing vulnerabilities
    """
    
    @pytest.mark.asyncio
    async def test_timestamp_replay_attack(self, vulnerable_config, mock_auth_client):
        """
        TEST 11: Replay old valid timestamps
        EXPECTED FAILURE: Old timestamps accepted beyond security window
        ATTACK VECTOR: Use old but technically valid verification timestamps
        """
        # Arrange
        vulnerable_config.service_secret = None
        vulnerable_config.environment = "development"  # 1 hour window
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                auth_service = UserAuthService()
        
        # Create response with old timestamp (45 minutes ago - within dev window)
        old_timestamp = (
            datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(minutes=45)
        ).isoformat()
        
        old_response = {
            "user_id": "user-789",
            "email": "old@example.com",
            "verified_at": old_timestamp,
            "valid": True
        }
        
        mock_auth_client.validate_token.return_value = old_response
        
        # Act
        result = await auth_service.validate_user_token("old-token")
        
        # Assert - Old timestamps should be rejected regardless of environment
        assert result is None, (
            "VULNERABILITY: Old timestamp accepted! "
            f"Timestamp from 45 minutes ago accepted in {vulnerable_config.environment} environment. "
            "Should enforce strict 5-minute window for all environments."
        )
    
    @pytest.mark.asyncio
    async def test_environment_timestamp_confusion(self, vulnerable_config, secure_config, mock_auth_client):
        """
        TEST 12: Exploit dev vs prod timestamp differences
        EXPECTED FAILURE: Dev timestamps accepted in production
        ATTACK VECTOR: Use dev environment timestamps in prod validation
        """
        # Arrange - Create token in dev environment
        vulnerable_config.environment = "development"
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                dev_auth_service = UserAuthService()
        
        # Create token with dev-acceptable timestamp (30 minutes old)
        dev_timestamp = (
            datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(minutes=30)
        ).isoformat()
        
        dev_response = {
            "user_id": "user-999",
            "email": "confusion@example.com",
            "verified_at": dev_timestamp,
            "valid": True,
            "environment": "development"  # Tagged with environment
        }
        
        # Switch to production environment
        secure_config.environment = "production"
        secure_config.service_secret = None  # Force vulnerability
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=secure_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                prod_auth_service = UserAuthService()
        
        mock_auth_client.validate_token.return_value = dev_response
        
        # Act - Try to use dev token in production
        result = await prod_auth_service.validate_user_token("cross-env-token")
        
        # Assert - Cross-environment tokens should be rejected
        assert result is None or result.get("environment") == "production", (
            "VULNERABILITY: Cross-environment token accepted! "
            "Development token with relaxed timestamp accepted in production."
        )
    
    @pytest.mark.asyncio
    async def test_future_timestamp_acceptance(self, vulnerable_config, mock_auth_client):
        """
        TEST 13: Accept future timestamps
        EXPECTED FAILURE: Future timestamps extend token validity
        ATTACK VECTOR: Use future timestamps to extend token lifetime
        """
        # Arrange
        vulnerable_config.service_secret = None
        
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=vulnerable_config):
            with patch('netra_backend.app.clients.auth_client.auth_client', mock_auth_client):
                auth_service = UserAuthService()
        
        # Create response with future timestamp (5 minutes in future)
        future_timestamp = (
            datetime.datetime.now(datetime.timezone.utc) + datetime.timedelta(minutes=5)
        ).isoformat()
        
        future_response = {
            "user_id": "future-user",
            "email": "future@example.com",
            "verified_at": future_timestamp,
            "valid": True
        }
        
        mock_auth_client.validate_token.return_value = future_response
        
        # Act
        result = await auth_service.validate_user_token("future-token")
        
        # Assert - Future timestamps should be rejected
        assert result is None, (
            "VULNERABILITY: Future timestamp accepted! "
            "Token with timestamp 5 minutes in the future was validated. "
            "This allows attackers to pre-generate long-lived tokens."
        )


class TestConfigurationSecurityAudit:
    """
    Tests that audit configuration security issues
    ALL tests should FAIL to enforce proper security standards
    """
    
    @pytest.mark.asyncio
    async def test_production_requires_service_secret(self):
        """
        TEST 14: Production should never use JWT fallback
        EXPECTED FAILURE: Production starts without service_secret
        ATTACK VECTOR: Production deployment without proper secrets
        """
        # Arrange
        prod_config = Mock(spec=AppConfig)
        prod_config.service_secret = None
        prod_config.jwt_secret_key = "jwt-secret"
        prod_config.environment = "production"
        
        # Act & Assert - Production initialization should fail
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=prod_config):
            
            with pytest.raises(ValueError, match="service_secret is required in production"):
                auth_service = UserAuthService()
            
            # If initialization doesn't fail, check runtime
            try:
                auth_service = UserAuthService()
                # This should not be reachable in production
                assert False, (
                    "VULNERABILITY: Production service started without service_secret! "
                    "This is a critical security violation."
                )
            except:
                pass  # Expected to fail
    
    @pytest.mark.asyncio
    async def test_service_secret_environment_isolation(self):
        """
        TEST 15: Secrets should be environment-specific
        EXPECTED FAILURE: Same secret used across environments
        ATTACK VECTOR: Cross-environment secret reuse
        """
        # Arrange - Create configs for different environments
        environments = ["development", "staging", "production"]
        secrets_used = {}
        
        for env in environments:
            config = Mock(spec=AppConfig)
            config.service_secret = "shared-secret-12345"  # Same secret
            config.jwt_secret_key = "jwt-secret"
            config.environment = env
            
            with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                       return_value=config):
                auth_service = UserAuthService()
                secrets_used[env] = auth_service._shared_secret
        
        # Assert - Each environment should have unique secrets
        unique_secrets = len(set(secrets_used.values()))
        assert unique_secrets == len(environments), (
            f"VULNERABILITY: Secret reuse across environments detected! "
            f"Only {unique_secrets} unique secrets for {len(environments)} environments. "
            f"Secrets: {secrets_used}"
        )


# Test execution marker
if __name__ == "__main__":
    print("=" * 80)
    print("EXECUTING FAILING TEST SUITE: Service Secret Configuration Vulnerability")
    print("Expected: ALL tests should FAIL to demonstrate security weaknesses")
    print("=" * 80)
    
    # Run with maximum verbosity to see all failures
    pytest.main([__file__, "-vvv", "-s", "--tb=short", "--color=yes"])