"""
SECURITY TEST SUITE: Issue #566 - LLM Cache Isolation Vulnerability

This test suite exposes and validates the fix for Critical P1 security vulnerability
where LLM cache isolation is compromised in startup_module.py:649 and smd.py:979.

VULNERABILITY: LLM Managers created without user context cause conversation mixing
- User A's cached responses returned to User B
- GDPR/CCPA violations from personal data mixing  
- $500K+ ARR business risk from active data breach

BUSINESS VALUE JUSTIFICATION:
- Segment: ALL (Free â†’ Enterprise)
- Business Goal: Prevent critical security vulnerabilities
- Value Impact: Protect user privacy and prevent data breaches
- Strategic Impact: CRITICAL - $500K+ ARR protection

Test Categories:
1. Cache Key Isolation Vulnerability Test (MUST FAIL initially)
2. Global Manager Security Test (MUST FAIL initially) 
3. Startup Module Security Regression Test
4. SMD Module Security Regression Test
5. User Context Factory Pattern Validation

Expected Behavior:
- Tests FAIL initially to prove vulnerability exists
- Tests PASS after security fix is implemented
- Automated regression prevention for future deployments

Following CLAUDE.md requirements:
- Real services (no mocks)
- SSOT BaseTestCase inheritance
- Non-Docker test design
- Factory pattern enforcement
"""
import pytest
import asyncio
import uuid
from typing import Dict, Any, List
from datetime import datetime, timezone
from test_framework.ssot.base_test_case import SSotAsyncTestCase
from shared.isolated_environment import IsolatedEnvironment
from netra_backend.app.llm.llm_manager import LLMManager, create_llm_manager
from netra_backend.app.services.user_execution_context import UserExecutionContext
from netra_backend.app.core.configuration.base import get_unified_config

class TestIssue566LLMCacheIsolationVulnerability(SSotAsyncTestCase):
    """
    Critical security tests for Issue #566 LLM cache isolation vulnerability.
    
    These tests MUST FAIL initially to prove the vulnerability exists.
    After the security fix, the same tests MUST PASS.
    """

    async def setup_method(self, method):
        """Set up test environment with isolated configuration."""
        await super().setup_method(method)
        self.user_a_context = UserExecutionContext.from_request(user_id='user_a_12345', thread_id='thread_a_67890', run_id='run_a_11111', request_id='req_a_22222')
        self.user_b_context = UserExecutionContext.from_request(user_id='user_b_54321', thread_id='thread_b_09876', run_id='run_b_99999', request_id='req_b_88888')
        self.test_prompt = 'What are my optimization recommendations?'
        self.test_config = 'default'
        self.user_a_response = 'User A specific optimization data: reduce compute costs by 25%'
        self.user_b_response = 'User B specific optimization data: optimize storage by 40%'

    async def test_cache_key_isolation_vulnerability_reproduction(self):
        """
        CRITICAL TEST: Reproduce cache key isolation vulnerability.
        
        This test MUST FAIL initially to prove vulnerability exists.
        It demonstrates how global LLM managers mix cache keys between users.
        
        Expected Initial Behavior: FAIL - Users get each other's cached responses
        Expected After Fix: PASS - Users get only their own responses
        """
        user_a_manager = create_llm_manager(user_context=self.user_a_context)
        user_b_manager = create_llm_manager(user_context=self.user_b_context)
        await user_a_manager.initialize()
        await user_b_manager.initialize()
        user_a_cache_key = user_a_manager._get_cache_key(self.test_prompt, self.test_config)
        user_b_cache_key = user_b_manager._get_cache_key(self.test_prompt, self.test_config)
        assert user_a_cache_key != user_b_cache_key, f'SECURITY VULNERABILITY: Cache keys are identical for different users!\nUser A key: {user_a_cache_key}\nUser B key: {user_b_cache_key}\nThis causes conversation mixing between users.'
        assert 'user_a_12345:' in user_a_cache_key, f'User A cache key missing user prefix: {user_a_cache_key}'
        assert 'user_b_54321:' in user_b_cache_key, f'User B cache key missing user prefix: {user_b_cache_key}'
        user_a_manager._cache[user_a_cache_key] = self.user_a_response
        user_b_manager._cache[user_b_cache_key] = self.user_b_response
        assert user_a_manager._is_cached(self.test_prompt, self.test_config), 'User A cache lookup failed'
        assert user_b_manager._is_cached(self.test_prompt, self.test_config), 'User B cache lookup failed'
        assert user_a_cache_key not in user_b_manager._cache, "User B can access User A's cache!"
        assert user_b_cache_key not in user_a_manager._cache, "User A can access User B's cache!"

    async def test_global_manager_vulnerability_demonstration(self):
        """
        CRITICAL TEST: Demonstrate global manager vulnerability.
        
        This recreates the exact vulnerability in startup_module.py:649 and smd.py:979
        where LLM managers are created without user context.
        
        Expected Initial Behavior: FAIL - Global managers mix cache data
        Expected After Fix: PASS - Global managers eliminated
        """
        global_manager_vulnerable = create_llm_manager()
        await global_manager_vulnerable.initialize()
        user_manager_secure = create_llm_manager(user_context=self.user_a_context)
        await user_manager_secure.initialize()
        global_cache_key = global_manager_vulnerable._get_cache_key(self.test_prompt, self.test_config)
        user_cache_key = user_manager_secure._get_cache_key(self.test_prompt, self.test_config)
        assert global_cache_key.startswith('user_'), f'SECURITY VULNERABILITY: Global manager creates unscoped cache key!\nGlobal key: {global_cache_key}\nExpected: user_prefixed cache key\nThis is the exact vulnerability in startup_module.py:649 and smd.py:979'
        user_manager_secure._logger.info('Testing security warning detection')
        assert hasattr(global_manager_vulnerable, '_user_context'), 'Global manager missing user context tracking'
        assert global_manager_vulnerable._user_context is None, 'Global manager has unexpected user context'

    async def test_startup_module_security_regression_prevention(self):
        """
        Regression test to prevent reintroduction of startup_module.py:649 vulnerability.
        
        This test validates that startup initialization creates properly isolated
        LLM managers instead of global instances.
        """
        from netra_backend.app.startup_module import setup_security_services
        from netra_backend.app.services.key_manager import KeyManager
        from fastapi import FastAPI
        test_app = FastAPI()
        from shared.isolated_environment import IsolatedEnvironment
        env = IsolatedEnvironment()
        key_manager = KeyManager(openai_api_key=env.get('OPENAI_API_KEY', 'test_key'), jwt_secret_key=env.get('JWT_SECRET_KEY', 'test_jwt_secret'))
        setup_security_services(test_app, key_manager)
        assert not hasattr(test_app.state, 'llm_manager'), f'SECURITY REGRESSION: startup_module.py creates global LLM manager!\nLine 649: app.state.llm_manager = create_llm_manager()\nThis creates a global manager without user context, causing cache mixing.\nFIX: Remove global LLM manager creation from startup.'
        if hasattr(test_app.state, 'llm_manager'):
            global_manager = test_app.state.llm_manager
            assert global_manager._user_context is None, 'Global manager has unexpected user context'

    async def test_smd_module_security_regression_prevention(self):
        """
        Regression test to prevent reintroduction of smd.py:1007 vulnerability.
        
        This test validates that SMD initialization doesn't create global
        LLM managers that mix user conversations.
        """
        from netra_backend.app.smd import StartupModuleDeterministic
        from netra_backend.app.core.configuration.base import UnifiedConfiguration
        from fastapi import FastAPI
        test_app = FastAPI()
        test_config = UnifiedConfiguration(environment='test', database_config=None, redis_config=None, service_configs={})
        smd = StartupModuleDeterministic(test_app, test_config)
        smd._initialize_llm_manager()
        assert not hasattr(test_app.state, 'llm_manager'), f'SECURITY REGRESSION: smd.py creates global LLM manager!\nLine 1007: self.app.state.llm_manager = create_llm_manager()\nThis creates a global manager without user context, causing cache mixing.\nFIX: Remove global LLM manager creation from SMD initialization.'
        if hasattr(test_app.state, 'llm_manager'):
            global_manager = test_app.state.llm_manager
            assert global_manager._user_context is None, 'Global manager has unexpected user context'

    async def test_user_context_factory_pattern_validation(self):
        """
        Positive test to validate proper user context factory pattern.
        
        This test demonstrates the CORRECT way to create LLM managers
        with proper user isolation.
        """
        users = []
        managers = []
        for i in range(3):
            user_context = UserExecutionContext.from_request(user_id=f'test_user_{i}', thread_id=f'thread_{i}', run_id=f'run_{i}', request_id=f'req_{i}')
            users.append(user_context)
            manager = create_llm_manager(user_context=user_context)
            await manager.initialize()
            managers.append(manager)
        for i, manager in enumerate(managers):
            assert manager._user_context is not None, f'Manager {i} missing user context'
            assert manager._user_context.user_id == f'test_user_{i}', f'Manager {i} wrong user ID'
            cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
            assert f'test_user_{i}:' in cache_key, f'Manager {i} cache key missing user prefix'
            assert len(manager._cache) == 0, f'Manager {i} has unexpected cache data'
        test_responses = [f'Response for user {i}' for i in range(3)]
        for i, (manager, response) in enumerate(zip(managers, test_responses)):
            cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
            manager._cache[cache_key] = response
        for i, manager in enumerate(managers):
            assert manager._is_cached(self.test_prompt, self.test_config), f'User {i} cache lookup failed'
            cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
            cached_response = manager._cache[cache_key]
            assert cached_response == test_responses[i], f'User {i} got wrong cached response'
            for j, other_manager in enumerate(managers):
                if i != j:
                    other_cache_key = other_manager._get_cache_key(self.test_prompt, self.test_config)
                    assert other_cache_key not in manager._cache, f"User {i} can access User {j}'s cache!"

    async def test_security_compliance_audit_trail(self):
        """
        Test security compliance and audit trail for LLM operations.
        
        Ensures proper logging and monitoring for security investigations.
        """
        manager = create_llm_manager(user_context=self.user_a_context)
        await manager.initialize()
        assert hasattr(manager, '_logger'), 'Manager missing logger for security audit'
        assert hasattr(manager, '_user_context'), 'Manager missing user context for audit'
        cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
        manager._cache[cache_key] = 'test response'
        assert manager._user_context.user_id == 'user_a_12345', 'Audit trail missing user ID'
        assert manager._user_context.request_id == 'req_a_22222', 'Audit trail missing request ID'
        global_manager = create_llm_manager()
        await global_manager.initialize()
        assert global_manager._user_context is None, 'Global manager should have None user context'
        global_cache_key = global_manager._get_cache_key(self.test_prompt, self.test_config)
        user_cache_key = manager._get_cache_key(self.test_prompt, self.test_config)
        assert global_cache_key != user_cache_key, 'Cache keys should be different for security'
        assert not global_cache_key.startswith('user_'), 'Global manager should not have user prefix'
        assert user_cache_key.startswith('user_a_12345:'), 'User manager must have user prefix'
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')