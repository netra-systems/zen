"""
CRITICAL FAILING TEST SUITE: JWT Signature Exploitation
Purpose: Expose vulnerabilities in JWT/service signature collision when using fallback
Expected: ALL tests should FAIL to demonstrate signature exploitation risks

This suite specifically tests the cryptographic weaknesses that arise when
service_secret falls back to jwt_secret_key, creating signature collisions.

Business Value Justification (BVJ):
- Segment: All - Critical security foundation
- Business Goal: Prevent signature forgery and token manipulation
- Value Impact: Protects authentication integrity across all services
- Strategic Impact: Signature vulnerabilities enable complete auth bypass
"""

import pytest
import asyncio
import jwt
import hmac
import hashlib
import json
import base64
import time
import os
import sys
from typing import Dict, Any, Optional
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime, timedelta, timezone


from netra_backend.app.services.user_auth_service import UserAuthService
from netra_backend.app.core.configuration import unified_config_manager
from netra_backend.app.schemas.Config import AppConfig


class TestJWTSignatureExploitation:
    """
    Tests that exploit JWT and service signature weaknesses
    when service_secret falls back to jwt_secret_key
    """
    
    @pytest.fixture
    def shared_secret_config(self):
        """Config where service_secret falls back to jwt_secret_key"""
        # Mock: Component isolation for controlled unit testing
        config = Mock(spec=AppConfig)
        config.service_secret = None  # Forces fallback
        config.jwt_secret_key = "shared-vulnerable-secret-123"
        config.environment = "development"
        config.auth_service_url = "http://localhost:8001"
        return config
    
    @pytest.fixture
    def distinct_secret_config(self):
        """Config with properly separated secrets"""
        # Mock: Component isolation for controlled unit testing
        config = Mock(spec=AppConfig)
        config.service_secret = "unique-service-secret-" + os.urandom(16).hex()
        config.jwt_secret_key = "unique-jwt-secret-" + os.urandom(16).hex()
        config.environment = "production"
        config.auth_service_url = "http://localhost:8001"
        return config
    
    @pytest.mark.asyncio
    async def test_jwt_secret_key_service_signature_collision(self, shared_secret_config):
        """
        TEST 1: Detect when JWT and service signatures use same secret
        EXPECTED FAILURE: Signatures collide enabling cross-domain attacks
        ATTACK VECTOR: Cross-domain signature validation bypass
        """
        # Arrange
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            auth_service = UserAuthService()
        
        # Create JWT token
        jwt_payload = {
            "user_id": "user-123",
            "email": "user@example.com",
            "exp": time.time() + 3600
        }
        
        jwt_token = jwt.encode(
            jwt_payload,
            shared_secret_config.jwt_secret_key,
            algorithm="HS256"
        )
        
        # Create service signature for same payload
        service_payload = json.dumps(jwt_payload, sort_keys=True)
        service_signature = hmac.new(
            shared_secret_config.jwt_secret_key.encode(),
            service_payload.encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Act - Try to use JWT signature as service signature
        jwt_signature = jwt_token.split('.')[-1]
        
        # Decode JWT signature (base64url)
        jwt_sig_bytes = base64.urlsafe_b64decode(jwt_signature + '==')
        
        # Assert - Signatures should be cryptographically separated
        assert service_signature != jwt_sig_bytes.hex(), (
            "VULNERABILITY: JWT and service signatures can be interchanged! "
            "Same secret used for different cryptographic purposes enables signature confusion attacks."
        )
        
        # Verify domain separation
        with pytest.raises(ValueError, match="signature domain mismatch"):
            # Attempt to validate JWT signature as service signature
            auth_service._verify_service_signature(jwt_payload, jwt_signature)
    
    @pytest.mark.asyncio
    async def test_token_signature_algorithm_confusion(self, shared_secret_config):
        """
        TEST 2: Exploit algorithm confusion between JWT and service signatures
        EXPECTED FAILURE: Different algorithms can be mixed
        ATTACK VECTOR: Algorithm downgrade attack
        """
        # Arrange
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            auth_service = UserAuthService()
        
        secret = shared_secret_config.jwt_secret_key
        payload = {"user_id": "victim", "role": "user"}
        
        # Create signatures with different algorithms
        algorithms = [
            ("HS256", hashlib.sha256),
            ("HS384", hashlib.sha384),
            ("HS512", hashlib.sha512),
            ("none", None),  # Algorithm confusion attack
        ]
        
        signatures = {}
        for alg_name, hash_func in algorithms:
            if alg_name == "none":
                # Attempt to bypass with no signature
                signatures[alg_name] = ""
            elif hash_func:
                signatures[alg_name] = hmac.new(
                    secret.encode(),
                    json.dumps(payload).encode(),
                    hash_func
                ).hexdigest()
        
        # Act - Try to mix algorithms
        for alg1 in signatures:
            for alg2 in signatures:
                if alg1 != alg2:
                    # Attempt algorithm confusion
                    mixed_token = {
                        "payload": payload,
                        "signature": signatures[alg1],
                        "algorithm": alg2
                    }
                    
                    # Assert - Mixed algorithms should be rejected
                    with pytest.raises(ValueError, match="algorithm mismatch|invalid algorithm"):
                        auth_service._validate_signature_algorithm(mixed_token)
        
        # Specifically test "none" algorithm bypass
        assert signatures["none"] != "", (
            "VULNERABILITY: 'none' algorithm accepted for signatures! "
            "This allows complete signature bypass."
        )
    
    @pytest.mark.asyncio
    async def test_service_signature_tampering(self, shared_secret_config):
        """
        TEST 3: Tamper with service signature using known secret
        EXPECTED FAILURE: Tampered signatures accepted
        ATTACK VECTOR: Signature forgery
        """
        # Arrange
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            auth_service = UserAuthService()
        
        # Original legitimate data
        original_data = {
            "user_id": "legitimate-user",
            "role": "viewer",
            "permissions": ["read"]
        }
        
        # Create legitimate signature
        secret = shared_secret_config.jwt_secret_key
        original_sig = hmac.new(
            secret.encode(),
            json.dumps(original_data, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Act - Tamper with data and create new signature
        tampered_data = original_data.copy()
        tampered_data["role"] = "admin"  # Privilege escalation
        tampered_data["permissions"] = ["read", "write", "delete"]
        
        # Forge new signature with known secret
        tampered_sig = hmac.new(
            secret.encode(),
            json.dumps(tampered_data, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Create mock validation context
        # Mock: Authentication service isolation for testing without real auth flows
        mock_auth_client = AsyncMock()
        mock_auth_client.validate_token.return_value = {
            **tampered_data,
            "service_signature": tampered_sig,
            "valid": True,
            "verified_at": datetime.now(timezone.utc).isoformat()
        }
        
        # Mock: Authentication service isolation for testing without real auth flows
        with patch('netra_backend.app.clients.auth_client_core.auth_client', mock_auth_client):
            result = await auth_service.validate_user_token("tampered-token")
        
        # Assert - Tampered data should be rejected
        assert result is None or result.get("role") != "admin", (
            "VULNERABILITY: Signature tampering successful! "
            "Attacker escalated privileges by forging new signature with known secret."
        )
        
        # Verify original data integrity
        assert original_data["role"] == "viewer", "Original data should not be modified"
    
    @pytest.mark.asyncio
    async def test_hmac_timing_attack_service_validation(self, shared_secret_config):
        """
        TEST 4: Time-based attack on HMAC comparison
        EXPECTED FAILURE: Timing differences reveal signature information
        ATTACK VECTOR: Side-channel timing analysis
        """
        # Arrange
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            auth_service = UserAuthService()
        
        secret = shared_secret_config.jwt_secret_key
        payload = {"user_id": "timing-victim"}
        
        # Create correct signature
        correct_sig = hmac.new(
            secret.encode(),
            json.dumps(payload).encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Act - Measure timing for different signatures
        timing_results = []
        
        # Test signatures with increasing similarity to correct one
        test_sigs = [
            "0" * len(correct_sig),  # Completely wrong
            correct_sig[:1] + "0" * (len(correct_sig) - 1),  # First char correct
            correct_sig[:len(correct_sig)//2] + "0" * (len(correct_sig)//2),  # Half correct
            correct_sig[:-1] + "0",  # All but last char correct
            correct_sig  # Completely correct
        ]
        
        for test_sig in test_sigs:
            start_time = time.perf_counter_ns()
            
            # Simulate signature comparison
            try:
                # This should use constant-time comparison
                is_valid = hmac.compare_digest(test_sig, correct_sig)
            except:
                is_valid = test_sig == correct_sig  # Vulnerable comparison
            
            end_time = time.perf_counter_ns()
            timing_results.append((test_sig[:8], end_time - start_time, is_valid))
        
        # Assert - Timing should be constant regardless of similarity
        timings = [t[1] for t in timing_results[:-1]]  # Exclude correct sig
        avg_timing = sum(timings) / len(timings)
        max_deviation = max(abs(t - avg_timing) for t in timings)
        
        # Check for timing attack vulnerability
        timing_variance_threshold = avg_timing * 0.1  # 10% variance threshold
        
        assert max_deviation < timing_variance_threshold, (
            f"VULNERABILITY: Timing attack possible! "
            f"Signature comparison timing varies by up to {max_deviation}ns. "
            f"This reveals information about correct signature through timing side-channel. "
            f"Results: {timing_results}"
        )
    
    @pytest.mark.asyncio
    async def test_service_signature_length_extension(self, shared_secret_config):
        """
        TEST 5: Hash length extension attack
        EXPECTED FAILURE: Can extend signed messages without knowing secret
        ATTACK VECTOR: Extend service signature payload
        """
        # Arrange
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            auth_service = UserAuthService()
        
        secret = shared_secret_config.jwt_secret_key
        
        # Original message and signature
        original_message = json.dumps({"user_id": "user-1", "role": "user"})
        original_sig = hmac.new(
            secret.encode(),
            original_message.encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Act - Attempt length extension attack
        # Note: HMAC should prevent this, but test for vulnerability
        extension = ', "admin": true}'
        extended_message = original_message[:-1] + extension
        
        # Try to forge extended signature without knowing secret
        # This simulates what an attacker would attempt
        
        # Calculate what signature would be if vulnerable to length extension
        # (This would work with plain hash, not HMAC)
        forged_data = {
            "message": extended_message,
            "signature": original_sig,  # Reuse original
            "valid": True
        }
        
        # Assert - Length extension should fail with HMAC
        extended_sig = hmac.new(
            secret.encode(),
            extended_message.encode(),
            hashlib.sha256
        ).hexdigest()
        
        assert extended_sig != original_sig, (
            "VULNERABILITY: Length extension attack possible! "
            "Original signature valid for extended message. "
            "This indicates improper use of hash function instead of HMAC."
        )
        
        # Verify HMAC is actually being used
        assert hasattr(auth_service, '_generate_service_signature'), (
            "VULNERABILITY: No service signature generation method found"
        )
    
    @pytest.mark.asyncio
    async def test_signature_malleability_attack(self, shared_secret_config):
        """
        TEST 6: Test for signature malleability
        EXPECTED FAILURE: Modified signatures still validate
        ATTACK VECTOR: Signature format manipulation
        """
        # Arrange
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            auth_service = UserAuthService()
        
        secret = shared_secret_config.jwt_secret_key
        payload = {"user_id": "malleable-user", "timestamp": time.time()}
        
        # Create signature
        signature = hmac.new(
            secret.encode(),
            json.dumps(payload, sort_keys=True).encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Act - Test various signature malleability attacks
        malleable_sigs = [
            signature.upper(),  # Case variation
            signature.lower(),
            " " + signature + " ",  # Whitespace
            signature + "\x00",  # Null byte injection
            signature[::-1],  # Reversed
            signature + signature,  # Duplicated
        ]
        
        validation_results = []
        for mal_sig in malleable_sigs:
            try:
                # Attempt validation with malleable signature
                is_valid = mal_sig.strip().lower() == signature.lower()
                validation_results.append((mal_sig[:20], is_valid))
            except:
                validation_results.append((mal_sig[:20], False))
        
        # Assert - Only exact signature should validate
        valid_count = sum(1 for _, valid in validation_results if valid)
        assert valid_count == 0, (
            f"VULNERABILITY: Signature malleability detected! "
            f"{valid_count} malleable signatures accepted. "
            f"Signatures should be validated with exact byte comparison. "
            f"Results: {validation_results}"
        )
    
    @pytest.mark.asyncio
    async def test_key_confusion_attack(self, shared_secret_config, distinct_secret_config):
        """
        TEST 7: Test for key confusion between services
        EXPECTED FAILURE: Wrong keys accepted for validation
        ATTACK VECTOR: Use keys from different contexts
        """
        # Arrange - Create auth services with different configs
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            vulnerable_service = UserAuthService()
        
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=distinct_secret_config):
            secure_service = UserAuthService()
        
        # Create token signed with one secret
        payload = {"user_id": "confused-user", "service": "auth"}
        
        vulnerable_sig = hmac.new(
            shared_secret_config.jwt_secret_key.encode(),
            json.dumps(payload).encode(),
            hashlib.sha256
        ).hexdigest()
        
        secure_sig = hmac.new(
            distinct_secret_config.service_secret.encode(),
            json.dumps(payload).encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Act - Try to validate with wrong service
        # Mock: Authentication service isolation for testing without real auth flows
        mock_auth_client = AsyncMock()
        mock_auth_client.validate_token.return_value = {
            **payload,
            "service_signature": vulnerable_sig,
            "valid": True,
            "verified_at": datetime.now(timezone.utc).isoformat()
        }
        
        # Try to validate vulnerable signature with secure service
        # Mock: Authentication service isolation for testing without real auth flows
        with patch('netra_backend.app.clients.auth_client_core.auth_client', mock_auth_client):
            # Mock: Component isolation for testing without external dependencies
            with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                       return_value=distinct_secret_config):
                result = await secure_service.validate_user_token("confused-token")
        
        # Assert - Cross-service signatures should fail
        assert result is None, (
            "VULNERABILITY: Key confusion attack successful! "
            "Signature from one service accepted by another service. "
            "Services must use cryptographically isolated keys."
        )
    
    @pytest.mark.asyncio
    async def test_signature_stripping_attack(self, shared_secret_config):
        """
        TEST 8: Test signature stripping vulnerability
        EXPECTED FAILURE: Tokens accepted without signatures
        ATTACK VECTOR: Remove signature from token
        """
        # Arrange
        # Mock: Component isolation for testing without external dependencies
        with patch('netra_backend.app.core.configuration.unified_config_manager.get_config',
                   return_value=shared_secret_config):
            auth_service = UserAuthService()
        
        # Create valid token data without signature
        unsigned_data = {
            "user_id": "unsigned-user",
            "email": "attacker@example.com",
            "role": "admin",
            "valid": True,
            "verified_at": datetime.now(timezone.utc).isoformat()
        }
        
        # Act - Try validation without signature
        mock_auth_client = AsyncMock()
        mock_auth_client.validate_token.return_value = unsigned_data
        
        # Mock: Authentication service isolation for testing without real auth flows
        with patch('netra_backend.app.clients.auth_client_core.auth_client', mock_auth_client):
            result = await auth_service.validate_user_token("unsigned-token")
        
        # Assert - Unsigned tokens should be rejected
        assert result is None, (
            "VULNERABILITY: Signature stripping attack successful! "
            "Token accepted without service_signature field. "
            "All tokens must have valid signatures."
        )
        
        # Test with empty signature
        unsigned_data["service_signature"] = ""
        mock_auth_client.validate_token.return_value = unsigned_data
        
        # Mock: Authentication service isolation for testing without real auth flows
        with patch('netra_backend.app.clients.auth_client_core.auth_client', mock_auth_client):
            result = await auth_service.validate_user_token("empty-sig-token")
        
        assert result is None, (
            "VULNERABILITY: Empty signature accepted! "
            "Tokens with empty service_signature field should be rejected."
        )


# Standalone execution
if __name__ == "__main__":
    print("=" * 80)
    print("EXECUTING FAILING TEST SUITE: JWT Signature Exploitation")
    print("Testing cryptographic vulnerabilities in signature handling")
    print("Expected: ALL tests should FAIL")
    print("=" * 80)
    
    pytest.main([__file__, "-vvv", "-s", "--tb=short", "--color=yes"])