"""
Test module split from original file
Generated by auto_fix_test_violations.py
"""

import pytest
import asyncio
import threading
import time
import gc
import psutil
import uuid
import json
import logging
import random
import hashlib
import secrets
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime, timedelta, timezone
from typing import Dict, List, Optional, Any, Tuple
from unittest.mock import AsyncMock, MagicMock, patch
from collections import defaultdict
import sys
import os
from auth_core.services.auth_service import AuthService
from auth_core.core.jwt_handler import JWTHandler
from auth_core.core.session_manager import SessionManager
from auth_core.models.auth_models import (
    LoginRequest, LoginResponse, AuthProvider, TokenResponse
)
from tests.factories.user_factory import UserFactory
import jwt as jwt_lib

class TestDatabaseTransactionIsolation:
    """Test Case 5: Database Transaction Isolation Verification"""
    
    @pytest.mark.asyncio
    async def test_database_transaction_isolation(self, isolated_auth_environment,
                                                 concurrent_executor, race_detector):
        """
        Scenario: Concurrent user creation, login attempts, and updates
        Expected: Database maintains consistency, no partial state updates
        
        This test verifies that database operations maintain ACID properties
        under concurrency, particularly for authentication operations.
        """
        auth_service = isolated_auth_environment["auth_service"]
        
        race_detector.take_memory_snapshot("before_db_isolation_test")
        
        # Mock database operations for testing
        created_users = []
        login_results = []
        operation_lock = threading.Lock()
        
        async def create_and_login_user(user_index):
            """Simulate concurrent user creation and immediate login"""
            start_time = time.perf_counter()
            
            try:
                # Create unique user data
                email = f"isolationtest-{user_index}-{uuid.uuid4().hex[:8]}@example.com"
                password = f"Password{user_index}!"
                
                # Simulate user creation (would be database operation)
                user_data = UserFactory.create_local_user_data(
                    email=email,
                    password=password,
                    full_name=f"Isolation Test User {user_index}"
                )
                
                # Simulate atomic user creation
                with operation_lock:
                    created_users.append(user_data)
                
                # Immediate login attempt
                login_request = LoginRequest(
                    email=email,
                    password=password,
                    provider=AuthProvider.LOCAL
                )
                
                client_info = {
                    "ip": f"127.0.0.{user_index % 255}",
                    "user_agent": f"TestAgent-{user_index}-{uuid.uuid4().hex[:8]}"
                }
                
                # Mock the login process since we don't have real database
                # In real implementation, this would test actual database transactions
                login_result = {
                    "user_id": user_data["id"],
                    "email": email,
                    "success": True,
                    "timestamp": datetime.now(timezone.utc).isoformat()
                }
                
                with operation_lock:
                    login_results.append(login_result)
                
                end_time = time.perf_counter()
                race_detector.log_operation("create_and_login", start_time, end_time, True)
                
                return user_data, login_result
                
            except Exception as e:
                end_time = time.perf_counter()
                race_detector.log_operation("create_and_login", start_time, end_time, 
                                          False, str(e))
                return None, e
        
        # Execute concurrent user creation and login operations
        num_concurrent_users = 20
        operations = [create_and_login_user(i) for i in range(num_concurrent_users)]
        results = await concurrent_executor.execute_simultaneously(operations)
        
        # Validation: All operations should succeed
        successful_results = [r for r in results if r[0] is not None and not isinstance(r[1], Exception)]
        failed_results = [r for r in results if r[0] is None or isinstance(r[1], Exception)]
        
        assert len(successful_results) == num_concurrent_users, \
            f"Some operations failed: {len(successful_results)} successful, " \
            f"{len(failed_results)} failed"
        
        # Verify data consistency
        assert len(created_users) == num_concurrent_users, \
            f"User creation count mismatch: {len(created_users)} != {num_concurrent_users}"
        
        assert len(login_results) == num_concurrent_users, \
            f"Login result count mismatch: {len(login_results)} != {num_concurrent_users}"
        
        # Verify email uniqueness (critical for race condition detection)
        created_emails = [user["email"] for user in created_users]
        unique_emails = set(created_emails)
        assert len(unique_emails) == len(created_emails), \
            f"Duplicate emails detected: {len(created_emails)} created, " \
            f"{len(unique_emails)} unique"
        
        # Verify user ID uniqueness
        created_user_ids = [user["id"] for user in created_users]
        unique_user_ids = set(created_user_ids)
        assert len(unique_user_ids) == len(created_user_ids), \
            f"Duplicate user IDs detected: {len(created_user_ids)} created, " \
            f"{len(unique_user_ids)} unique"
        
        # Verify login result consistency
        login_emails = [result["email"] for result in login_results]
        assert set(login_emails) == set(created_emails), \
            "Login emails don't match created user emails"
        
        # Check for timing anomalies that might indicate race conditions
        timestamps = [datetime.fromisoformat(r["timestamp"]) for r in login_results]
        if len(timestamps) > 1:
            time_span = max(timestamps) - min(timestamps)
            # All operations should complete within reasonable time
            assert time_span.total_seconds() < 5.0, \
                f"Operations took too long: {time_span.total_seconds()}s span"
        
        race_detector.take_memory_snapshot("after_db_isolation_test")
