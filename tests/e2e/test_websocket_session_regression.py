# REMOVED_SYNTAX_ERROR: class TestWebSocketConnection:

    # REMOVED_SYNTAX_ERROR: """Real WebSocket connection for testing instead of mocks."""



# REMOVED_SYNTAX_ERROR: def __init__(self):

    # REMOVED_SYNTAX_ERROR: pass

    # REMOVED_SYNTAX_ERROR: self.messages_sent = []

    # REMOVED_SYNTAX_ERROR: self.is_connected = True

    # REMOVED_SYNTAX_ERROR: self._closed = False



# REMOVED_SYNTAX_ERROR: async def send_json(self, message: dict):

    # REMOVED_SYNTAX_ERROR: """Send JSON message."""

    # REMOVED_SYNTAX_ERROR: if self._closed:

        # REMOVED_SYNTAX_ERROR: raise RuntimeError("WebSocket is closed")

        # REMOVED_SYNTAX_ERROR: self.messages_sent.append(message)



# REMOVED_SYNTAX_ERROR: async def close(self, code: int = 1000, reason: str = "Normal closure"):

    # REMOVED_SYNTAX_ERROR: """Close WebSocket connection."""

    # REMOVED_SYNTAX_ERROR: pass

    # REMOVED_SYNTAX_ERROR: self._closed = True

    # REMOVED_SYNTAX_ERROR: self.is_connected = False



# REMOVED_SYNTAX_ERROR: def get_messages(self) -> list:

    # REMOVED_SYNTAX_ERROR: """Get all sent messages."""

    # REMOVED_SYNTAX_ERROR: await asyncio.sleep(0)

    # REMOVED_SYNTAX_ERROR: return self.messages_sent.copy()



    # REMOVED_SYNTAX_ERROR: '''

    # REMOVED_SYNTAX_ERROR: Regression Test Suite: WebSocket Session Management and Agent Execution



    # REMOVED_SYNTAX_ERROR: Tests to prevent regression of SQLAlchemy session management issues that cause

    # REMOVED_SYNTAX_ERROR: agents to hang in Docker environments.



    # REMOVED_SYNTAX_ERROR: Business Value Justification (BVJ):

        # REMOVED_SYNTAX_ERROR: 1. Segment: Platform/Internal

        # REMOVED_SYNTAX_ERROR: 2. Business Goal: Stability - Prevent agent execution failures

        # REMOVED_SYNTAX_ERROR: 3. Value Impact: Ensures reliable agent execution in production

        # REMOVED_SYNTAX_ERROR: 4. Strategic Impact: Prevents customer-facing failures and support tickets



        # REMOVED_SYNTAX_ERROR: CRITICAL: Tests MUST use real database sessions, not mocks

        # REMOVED_SYNTAX_ERROR: '''



        # REMOVED_SYNTAX_ERROR: import asyncio

        # REMOVED_SYNTAX_ERROR: import time

        # REMOVED_SYNTAX_ERROR: from typing import AsyncGenerator, Dict, Any

        # REMOVED_SYNTAX_ERROR: import pytest

        # REMOVED_SYNTAX_ERROR: from sqlalchemy.ext.asyncio import AsyncSession

        # REMOVED_SYNTAX_ERROR: from sqlalchemy.exc import IllegalStateChangeError

        # REMOVED_SYNTAX_ERROR: from shared.isolated_environment import IsolatedEnvironment



        # REMOVED_SYNTAX_ERROR: from netra_backend.app.database import get_db

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.websocket_core.agent_handler import AgentMessageHandler

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.websocket_core.types import WebSocketMessage, MessageType

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.services.message_handlers import MessageHandlerService

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.services.message_handler_base import MessageHandlerBase

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.agents.supervisor_ssot import SupervisorAgent

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.core.unified_error_handler import UnifiedErrorHandler

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.db.database_manager import DatabaseManager

        # REMOVED_SYNTAX_ERROR: from netra_backend.app.clients.auth_client_core import AuthServiceClient

        # REMOVED_SYNTAX_ERROR: from shared.isolated_environment import get_env

        # Decorator to enforce real services

# REMOVED_SYNTAX_ERROR: def use_real_services_enforced(func):

    # REMOVED_SYNTAX_ERROR: """Decorator that enforces use of real services in tests."""

    # REMOVED_SYNTAX_ERROR: return func





    # Removed problematic line: @pytest.mark.asyncio

# REMOVED_SYNTAX_ERROR: class TestWebSocketSessionRegression:

    # REMOVED_SYNTAX_ERROR: """Test suite to prevent regression of session management issues."""



    # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

    # Removed problematic line: async def test_session_not_passed_to_supervisor(self):

        # REMOVED_SYNTAX_ERROR: '''Verify database session is NOT passed to supervisor agent.



        # REMOVED_SYNTAX_ERROR: CRITICAL: This test prevents the root cause of agents hanging in Docker.

        # REMOVED_SYNTAX_ERROR: The supervisor must NOT hold a reference to the handler"s session.

        # REMOVED_SYNTAX_ERROR: '''

        # REMOVED_SYNTAX_ERROR: pass

        # Setup

        # REMOVED_SYNTAX_ERROR: handler = AgentMessageHandler()

        # REMOVED_SYNTAX_ERROR: test_message = WebSocketMessage( )

        # REMOVED_SYNTAX_ERROR: type=MessageType.START_AGENT,

        # REMOVED_SYNTAX_ERROR: payload={"user_request": "Test request"},

        # REMOVED_SYNTAX_ERROR: user_id="test_user",

        # REMOVED_SYNTAX_ERROR: thread_id="test_thread"

        



        # Track what gets passed to configure_supervisor

        # REMOVED_SYNTAX_ERROR: captured_session = None

        # REMOVED_SYNTAX_ERROR: original_configure = MessageHandlerBase.configure_supervisor



# REMOVED_SYNTAX_ERROR: def mock_configure(supervisor, user_id, thread, db_session):

    # REMOVED_SYNTAX_ERROR: pass

    # REMOVED_SYNTAX_ERROR: nonlocal captured_session

    # REMOVED_SYNTAX_ERROR: captured_session = supervisor.db_session

    # REMOVED_SYNTAX_ERROR: await asyncio.sleep(0)

    # REMOVED_SYNTAX_ERROR: return original_configure(supervisor, user_id, thread, db_session)



    # REMOVED_SYNTAX_ERROR: with patch.object(MessageHandlerBase, 'configure_supervisor', side_effect=mock_configure):

        # Execute - this should configure supervisor WITHOUT session

        # REMOVED_SYNTAX_ERROR: async with get_db() as session:

            # Simulate handler processing

            # REMOVED_SYNTAX_ERROR: await handler.handle_message("test_user", None, test_message)



            # Verify supervisor.db_session is None (not the actual session)

            # REMOVED_SYNTAX_ERROR: assert captured_session is None, "CRITICAL: Supervisor should NOT have db_session reference"



            # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

            # Removed problematic line: async def test_concurrent_agent_execution_no_session_conflict(self):

                # REMOVED_SYNTAX_ERROR: '''Test multiple concurrent agents don't cause session conflicts.



                # REMOVED_SYNTAX_ERROR: Simulates the Docker environment issue where multiple agents

                # REMOVED_SYNTAX_ERROR: running concurrently caused IllegalStateChangeError.

                # REMOVED_SYNTAX_ERROR: '''

                # REMOVED_SYNTAX_ERROR: pass

                # REMOVED_SYNTAX_ERROR: handler = AgentMessageHandler()



# REMOVED_SYNTAX_ERROR: async def simulate_agent_request(user_id: str, request: str):

    # REMOVED_SYNTAX_ERROR: """Simulate a single agent request."""

    # REMOVED_SYNTAX_ERROR: message = WebSocketMessage( )

    # REMOVED_SYNTAX_ERROR: type=MessageType.START_AGENT,

    # REMOVED_SYNTAX_ERROR: payload={"user_request": request},

    # REMOVED_SYNTAX_ERROR: user_id=user_id,

    # REMOVED_SYNTAX_ERROR: thread_id="formatted_string"

    



    # REMOVED_SYNTAX_ERROR: try:

        # REMOVED_SYNTAX_ERROR: result = await handler.handle_message(user_id, None, message)

        # REMOVED_SYNTAX_ERROR: await asyncio.sleep(0)

        # REMOVED_SYNTAX_ERROR: return {"success": True, "user_id": user_id}

        # REMOVED_SYNTAX_ERROR: except IllegalStateChangeError as e:

            # REMOVED_SYNTAX_ERROR: return {"success": False, "error": str(e), "user_id": user_id}



            # Launch multiple concurrent agent requests

            # REMOVED_SYNTAX_ERROR: tasks = [ )

            # REMOVED_SYNTAX_ERROR: simulate_agent_request("formatted_string", "formatted_string")

            # REMOVED_SYNTAX_ERROR: for i in range(5)

            



            # REMOVED_SYNTAX_ERROR: results = await asyncio.gather(*tasks, return_exceptions=True)



            # Verify no session conflicts occurred

            # REMOVED_SYNTAX_ERROR: for result in results:

                # REMOVED_SYNTAX_ERROR: if isinstance(result, dict):

                    # REMOVED_SYNTAX_ERROR: assert result["success"], "formatted_string"

                    # REMOVED_SYNTAX_ERROR: else:

                        # REMOVED_SYNTAX_ERROR: pytest.fail("formatted_string")



                        # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

                        # Removed problematic line: async def test_session_lifecycle_with_long_running_agent(self):

                            # REMOVED_SYNTAX_ERROR: '''Test session is properly managed during long-running agent operations.



                            # REMOVED_SYNTAX_ERROR: This test verifies that the session is closed after handler completes,

                            # REMOVED_SYNTAX_ERROR: even when the agent operation continues running asynchronously.

                            # REMOVED_SYNTAX_ERROR: '''

                            # REMOVED_SYNTAX_ERROR: pass

                            # REMOVED_SYNTAX_ERROR: handler = AgentMessageHandler()

                            # REMOVED_SYNTAX_ERROR: session_closed = False

                            # REMOVED_SYNTAX_ERROR: original_close = None



# REMOVED_SYNTAX_ERROR: async def track_session_close(self):

    # REMOVED_SYNTAX_ERROR: """Track when session.close() is called."""

    # REMOVED_SYNTAX_ERROR: nonlocal session_closed, original_close

    # REMOVED_SYNTAX_ERROR: session_closed = True

    # REMOVED_SYNTAX_ERROR: if original_close:

        # REMOVED_SYNTAX_ERROR: await asyncio.sleep(0)

        # REMOVED_SYNTAX_ERROR: return await original_close()



        # REMOVED_SYNTAX_ERROR: message = WebSocketMessage( )

        # REMOVED_SYNTAX_ERROR: type=MessageType.START_AGENT,

        # REMOVED_SYNTAX_ERROR: payload={"user_request": "Long running task"},

        # REMOVED_SYNTAX_ERROR: user_id="test_user",

        # REMOVED_SYNTAX_ERROR: thread_id="test_thread"

        



        # Get a real session and track its closure

        # REMOVED_SYNTAX_ERROR: async with get_db() as session:

            # REMOVED_SYNTAX_ERROR: original_close = session.close

            # REMOVED_SYNTAX_ERROR: session.close = lambda x: None track_session_close(session)



            # Simulate handler with session

            # REMOVED_SYNTAX_ERROR: with patch.object(handler, '_get_database_session', return_value=session):

                # REMOVED_SYNTAX_ERROR: await handler.handle_message("test_user", None, message)



                # Verify session was closed properly

                # REMOVED_SYNTAX_ERROR: assert session_closed, "Session should be closed after handler completes"



                # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

                # Removed problematic line: async def test_no_session_in_async_supervisor_execution(self):

                    # REMOVED_SYNTAX_ERROR: '''Verify supervisor doesn't access session during async execution.



                    # REMOVED_SYNTAX_ERROR: This test ensures the supervisor creates its own sessions as needed

                    # REMOVED_SYNTAX_ERROR: rather than using a passed reference that may be closed.

                    # REMOVED_SYNTAX_ERROR: '''

                    # REMOVED_SYNTAX_ERROR: pass

                    # REMOVED_SYNTAX_ERROR: from netra_backend.app.config import get_config

                    # REMOVED_SYNTAX_ERROR: from netra_backend.app.llm.llm_manager import LLMManager



                    # REMOVED_SYNTAX_ERROR: config = get_config()

                    # REMOVED_SYNTAX_ERROR: llm_manager = LLMManager(config)



                    # Create supervisor without session

                    # REMOVED_SYNTAX_ERROR: supervisor = SupervisorAgent( )

                    # REMOVED_SYNTAX_ERROR: llm_manager=llm_manager,

                    # REMOVED_SYNTAX_ERROR: db_session=None,  # CRITICAL: Must be None

                    # REMOVED_SYNTAX_ERROR: websocket_manager=None,

                    # REMOVED_SYNTAX_ERROR: tool_dispatcher=None

                    



                    # Verify supervisor has no session reference

                    # REMOVED_SYNTAX_ERROR: assert supervisor.db_session is None, "Supervisor should not have session reference"



                    # Simulate supervisor execution (would fail if it tries to use db_session)

                    # REMOVED_SYNTAX_ERROR: supervisor.user_id = "test_user"

                    # REMOVED_SYNTAX_ERROR: supervisor.thread_id = "test_thread"



                    # This should not raise any session-related errors

                    # REMOVED_SYNTAX_ERROR: try:

                        # Note: We're not actually running the full supervisor here,

                        # just verifying it's configured correctly without session

                        # REMOVED_SYNTAX_ERROR: assert supervisor.db_session is None

                        # REMOVED_SYNTAX_ERROR: except AttributeError as e:

                            # REMOVED_SYNTAX_ERROR: if "db_session" in str(e):

                                # REMOVED_SYNTAX_ERROR: pytest.fail("formatted_string")



                                # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

                                # Removed problematic line: async def test_session_error_detection(self):

                                    # REMOVED_SYNTAX_ERROR: '''Test that IllegalStateChangeError is properly detected and handled.



                                    # REMOVED_SYNTAX_ERROR: This test verifies our error detection works to catch future regressions.

                                    # REMOVED_SYNTAX_ERROR: '''

                                    # REMOVED_SYNTAX_ERROR: pass

                                    # Simulate the error condition

# REMOVED_SYNTAX_ERROR: async def problematic_handler():

    # REMOVED_SYNTAX_ERROR: """Simulate the problematic pattern that causes errors."""

    # REMOVED_SYNTAX_ERROR: async with get_db() as session:

        # Simulate concurrent access pattern that causes issues

        # REMOVED_SYNTAX_ERROR: agent = Magic                agent.db_session = session  # WRONG: This is the pattern to avoid



        # Start async operation

        # REMOVED_SYNTAX_ERROR: async_task = asyncio.create_task( )

        # REMOVED_SYNTAX_ERROR: asyncio.sleep(0.1)  # Simulate agent work

        



        # Try to close session while "agent" might still use it

        # REMOVED_SYNTAX_ERROR: await session.close()



        # Wait for async task

        # REMOVED_SYNTAX_ERROR: await async_task



        # This pattern would cause IllegalStateChangeError

        # REMOVED_SYNTAX_ERROR: await asyncio.sleep(0)

        # REMOVED_SYNTAX_ERROR: return agent



        # The problematic pattern should be avoided

        # REMOVED_SYNTAX_ERROR: try:

            # REMOVED_SYNTAX_ERROR: agent = await problematic_handler()

            # Verify agent doesn't have active session reference

            # REMOVED_SYNTAX_ERROR: if hasattr(agent, 'db_session'):

                # In the fix, db_session should be None

                # REMOVED_SYNTAX_ERROR: assert agent.db_session is None or agent.db_session.is_active is False

                # REMOVED_SYNTAX_ERROR: except IllegalStateChangeError:

                    # If error occurs, it means the pattern is still problematic

                    # REMOVED_SYNTAX_ERROR: pytest.fail("IllegalStateChangeError detected - session management issue present")





                    # Removed problematic line: @pytest.mark.asyncio

# REMOVED_SYNTAX_ERROR: class TestAgentPerformanceRegression:

    # REMOVED_SYNTAX_ERROR: """Test suite to ensure agent performance doesn't regress."""



    # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

    # Removed problematic line: async def test_agent_response_time_under_threshold(self):

        # REMOVED_SYNTAX_ERROR: '''Verify agents complete within reasonable time in Docker-like environment.



        # REMOVED_SYNTAX_ERROR: This test ensures agents don"t hang for 20+ seconds as they did

        # REMOVED_SYNTAX_ERROR: before the fix.

        # REMOVED_SYNTAX_ERROR: '''

        # REMOVED_SYNTAX_ERROR: pass

        # REMOVED_SYNTAX_ERROR: handler = AgentMessageHandler()



        # REMOVED_SYNTAX_ERROR: message = WebSocketMessage( )

        # REMOVED_SYNTAX_ERROR: type=MessageType.START_AGENT,

        # REMOVED_SYNTAX_ERROR: payload={"user_request": "Performance test request"},

        # REMOVED_SYNTAX_ERROR: user_id="perf_user",

        # REMOVED_SYNTAX_ERROR: thread_id="perf_thread"

        



        # REMOVED_SYNTAX_ERROR: start_time = time.time()



        # Execute with timeout to prevent hanging

        # REMOVED_SYNTAX_ERROR: try:

            # REMOVED_SYNTAX_ERROR: result = await asyncio.wait_for( )

            # REMOVED_SYNTAX_ERROR: handler.handle_message("perf_user", None, message),

            # REMOVED_SYNTAX_ERROR: timeout=5.0  # Should complete much faster than 20s

            

            # REMOVED_SYNTAX_ERROR: elapsed = time.time() - start_time



            # Verify reasonable response time

            # REMOVED_SYNTAX_ERROR: assert elapsed < 5.0, "formatted_string"

            # REMOVED_SYNTAX_ERROR: assert result is not False, "Agent execution should succeed"



            # REMOVED_SYNTAX_ERROR: except asyncio.TimeoutError:

                # REMOVED_SYNTAX_ERROR: pytest.fail("Agent execution timed out - possible hanging issue")



                # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

                # Removed problematic line: async def test_multiple_sequential_agents_no_degradation(self):

                    # REMOVED_SYNTAX_ERROR: '''Test multiple sequential agent requests don't cause performance degradation.



                    # REMOVED_SYNTAX_ERROR: This verifies that session management doesn"t cause cumulative issues.

                    # REMOVED_SYNTAX_ERROR: '''

                    # REMOVED_SYNTAX_ERROR: pass

                    # REMOVED_SYNTAX_ERROR: handler = AgentMessageHandler()

                    # REMOVED_SYNTAX_ERROR: response_times = []



                    # REMOVED_SYNTAX_ERROR: for i in range(3):

                        # REMOVED_SYNTAX_ERROR: message = WebSocketMessage( )

                        # REMOVED_SYNTAX_ERROR: type=MessageType.START_AGENT,

                        # REMOVED_SYNTAX_ERROR: payload={"user_request": "formatted_string"},

                        # REMOVED_SYNTAX_ERROR: user_id="formatted_string",

                        # REMOVED_SYNTAX_ERROR: thread_id="formatted_string"

                        



                        # REMOVED_SYNTAX_ERROR: start_time = time.time()

                        # REMOVED_SYNTAX_ERROR: try:

                            # REMOVED_SYNTAX_ERROR: await asyncio.wait_for( )

                            # REMOVED_SYNTAX_ERROR: handler.handle_message("formatted_string", None, message),

                            # REMOVED_SYNTAX_ERROR: timeout=5.0

                            

                            # REMOVED_SYNTAX_ERROR: elapsed = time.time() - start_time

                            # REMOVED_SYNTAX_ERROR: response_times.append(elapsed)

                            # REMOVED_SYNTAX_ERROR: except asyncio.TimeoutError:

                                # REMOVED_SYNTAX_ERROR: pytest.fail("formatted_string")



                                # Verify no significant degradation

                                # REMOVED_SYNTAX_ERROR: if len(response_times) >= 2:

                                    # Last request shouldn't be significantly slower than first

                                    # REMOVED_SYNTAX_ERROR: degradation = response_times[-1] - response_times[0]

                                    # REMOVED_SYNTAX_ERROR: assert degradation < 2.0, "formatted_string"





                                    # Removed problematic line: @pytest.mark.asyncio

# REMOVED_SYNTAX_ERROR: class TestSessionCleanup:

    # REMOVED_SYNTAX_ERROR: """Test suite for proper session cleanup and resource management."""



    # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

    # Removed problematic line: async def test_no_session_leaks_after_agent_execution(self):

        # REMOVED_SYNTAX_ERROR: '''Verify no database sessions are leaked after agent execution.



        # REMOVED_SYNTAX_ERROR: This test ensures proper cleanup even when agents fail or timeout.

        # REMOVED_SYNTAX_ERROR: '''

        # REMOVED_SYNTAX_ERROR: pass

        # REMOVED_SYNTAX_ERROR: handler = AgentMessageHandler()



        # Track active sessions

        # REMOVED_SYNTAX_ERROR: active_sessions = []

        # REMOVED_SYNTAX_ERROR: original_get_db = handler._get_database_session



# REMOVED_SYNTAX_ERROR: async def track_sessions():

    # REMOVED_SYNTAX_ERROR: """Track session creation."""

    # REMOVED_SYNTAX_ERROR: session = await original_get_db()

    # REMOVED_SYNTAX_ERROR: if session:

        # REMOVED_SYNTAX_ERROR: active_sessions.append(session)

        # REMOVED_SYNTAX_ERROR: await asyncio.sleep(0)

        # REMOVED_SYNTAX_ERROR: return session



        # REMOVED_SYNTAX_ERROR: handler._get_database_session = track_sessions



        # Execute multiple agent requests

        # REMOVED_SYNTAX_ERROR: for i in range(3):

            # REMOVED_SYNTAX_ERROR: message = WebSocketMessage( )

            # REMOVED_SYNTAX_ERROR: type=MessageType.START_AGENT,

            # REMOVED_SYNTAX_ERROR: payload={"user_request": "formatted_string"},

            # REMOVED_SYNTAX_ERROR: user_id="formatted_string",

            # REMOVED_SYNTAX_ERROR: thread_id="formatted_string"

            

            # REMOVED_SYNTAX_ERROR: await handler.handle_message("formatted_string", None, message)



            # Verify all sessions were closed

            # REMOVED_SYNTAX_ERROR: for session in active_sessions:

                # REMOVED_SYNTAX_ERROR: assert not session.is_active, "Session should be closed after use"



                # REMOVED_SYNTAX_ERROR: @use_real_services_enforced

                # Removed problematic line: async def test_session_cleanup_on_handler_error(self):

                    # REMOVED_SYNTAX_ERROR: '''Verify session is cleaned up even when handler encounters an error.



                    # REMOVED_SYNTAX_ERROR: This prevents session leaks when exceptions occur.

                    # REMOVED_SYNTAX_ERROR: '''

                    # REMOVED_SYNTAX_ERROR: pass

                    # REMOVED_SYNTAX_ERROR: handler = AgentMessageHandler()

                    # REMOVED_SYNTAX_ERROR: session_closed = False



                    # Force an error in message routing

                    # REMOVED_SYNTAX_ERROR: with patch.object(handler, '_route_agent_message', side_effect=Exception("Test error")):

                        # REMOVED_SYNTAX_ERROR: message = WebSocketMessage( )

                        # REMOVED_SYNTAX_ERROR: type=MessageType.START_AGENT,

                        # REMOVED_SYNTAX_ERROR: payload={"user_request": "Error test"},

                        # REMOVED_SYNTAX_ERROR: user_id="error_user",

                        # REMOVED_SYNTAX_ERROR: thread_id="error_thread"

                        



                        # Track session closure

                        # REMOVED_SYNTAX_ERROR: original_get_db = handler._get_database_session



# REMOVED_SYNTAX_ERROR: async def track_closure():

    # REMOVED_SYNTAX_ERROR: pass

    # REMOVED_SYNTAX_ERROR: session = await original_get_db()

    # REMOVED_SYNTAX_ERROR: if session:

        # REMOVED_SYNTAX_ERROR: original_close = session.close

# REMOVED_SYNTAX_ERROR: async def tracked_close():

    # REMOVED_SYNTAX_ERROR: pass

    # REMOVED_SYNTAX_ERROR: nonlocal session_closed

    # REMOVED_SYNTAX_ERROR: session_closed = True

    # REMOVED_SYNTAX_ERROR: await asyncio.sleep(0)

    # REMOVED_SYNTAX_ERROR: return await original_close()

    # REMOVED_SYNTAX_ERROR: session.close = tracked_close

    # REMOVED_SYNTAX_ERROR: return session



    # REMOVED_SYNTAX_ERROR: handler._get_database_session = track_closure



    # Execute (should fail but still clean up)

    # REMOVED_SYNTAX_ERROR: result = await handler.handle_message("error_user", None, message)

    # REMOVED_SYNTAX_ERROR: assert result is False  # Should return False on error



    # Verify session was still closed despite error

    # REMOVED_SYNTAX_ERROR: assert session_closed, "Session should be closed even after error"

