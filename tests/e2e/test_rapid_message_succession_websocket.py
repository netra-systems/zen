"""
Test module split from original file
Generated by auto_fix_test_violations.py
"""

import pytest
import asyncio
import time
import uuid
import json
import logging
import random
import threading
import gc
import psutil
import os
import functools
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any, Tuple, Union
from unittest.mock import AsyncMock, MagicMock, patch
from collections import defaultdict, deque
from dataclasses import dataclass, field
import websockets
import httpx

class MockWebSocketServer:
    """Mock WebSocket server for testing without real services."""
    
    def __init__(self, port=8765):
        self.port = port
        self.server = None
        self.clients = set()
        self.processed_messages = {}
        
    async def start(self):
        """Start mock WebSocket server."""
        self.server = await websockets.serve(
            self.handle_client,
            "localhost",
            self.port
        )
        logger.info(f"Mock WebSocket server started on ws://localhost:{self.port}")
        
    async def stop(self):
        """Stop mock WebSocket server."""
        if self.server:
            self.server.close()
            await self.server.wait_closed()
            
    async def handle_client(self, websocket):
        """Handle WebSocket client connections."""
        self.clients.add(websocket)
        try:
            async for message in websocket:
                await self.process_message(websocket, message)
        except websockets.exceptions.ConnectionClosed:
            pass
        finally:
            self.clients.discard(websocket)
    
    async def process_message(self, websocket, message):
        """Process incoming messages and send responses."""
        try:
            data = json.loads(message)
            message_type = data.get("type", "unknown")
            
            # Simulate different message types
            if message_type == "user_message":
                await self.handle_user_message(websocket, data)
            elif message_type == "get_agent_state":
                await self.handle_agent_state_request(websocket, data)
            elif message_type == "get_queue_state":
                await self.handle_queue_state_request(websocket, data)
            elif message_type == "configure_agents":
                await self.handle_agent_configuration(websocket, data)
                
        except json.JSONDecodeError:
            await websocket.send(json.dumps({
                "type": "error",
                "message": "Invalid JSON format"
            }))
    
    async def handle_user_message(self, websocket, data):
        """Simulate AI response to user messages with idempotency."""
        message_id = data.get("message_id")
        
        # Check for duplicate messages (idempotency)
        if message_id in self.processed_messages:
            duplicate_response = {
                "type": "duplicate_rejected",
                "message_id": message_id,
                "message": "Message already processed",
                "timestamp": time.time()
            }
            await websocket.send(json.dumps(duplicate_response))
            return
        
        # Mark as processed
        self.processed_messages[message_id] = data
        
        response = {
            "type": "ai_response",
            "message_id": message_id,
            "sequence_id": data.get("sequence_id"),
            "content": f"AI response to: {data.get('content', 'unknown')}",
            "timestamp": time.time()
        }
        
        # Add small delay to simulate processing
        await asyncio.sleep(0.1)
        await websocket.send(json.dumps(response))
    
    async def handle_agent_state_request(self, websocket, data):
        """Simulate agent state response."""
        state = {
            "type": "agent_state",
            "message_count": len(self.processed_messages),
            "conversation_context": {"topic": "sales_analysis"},
            "memory_usage": {"rss": psutil.Process().memory_info().rss},
            "corrupted": False,
            "processed_message_ids": list(self.processed_messages.keys()),
            "agents": {
                "data_sub_agent": {"messages_processed": 2, "shared_state": {"customer_data": "loaded"}},
                "analysis_sub_agent": {"messages_processed": 3, "shared_state": {"customer_segments": "analyzed"}},
                "reporting_sub_agent": {"messages_processed": 1, "shared_state": {"dashboard_export": "ready"}}
            },
            "timestamp": time.time()
        }
        await websocket.send(json.dumps(state))
    
    async def handle_queue_state_request(self, websocket, data):
        """Simulate queue state response."""
        state = {
            "type": "queue_state",
            "queue_size": random.randint(0, 50),
            "max_capacity": 500,
            "timestamp": time.time()
        }
        await websocket.send(json.dumps(state))
    
    async def handle_agent_configuration(self, websocket, data):
        """Handle agent configuration requests."""
        response = {
            "type": "agents_configured",
            "agents": data.get("agents", []),
            "timestamp": time.time()
        }
        await websocket.send(json.dumps(response))

class TestWebSocketStabilityMessageBursts:
    """Test Case 5: WebSocket Connection Stability Under Message Bursts"""
    
    @pytest.mark.asyncio
    @pytest.mark.e2e
    async def test_websocket_stability_message_bursts(
        self, rapid_message_sender, message_sequence_validator, agent_state_monitor
    ):
        """
        Scenario: Sustained high-frequency message sending over extended period
        Expected: WebSocket remains stable, no connection drops or message loss
        """
        await agent_state_monitor.capture_state_snapshot("stability_test_start", rapid_message_sender)
        
        # Configure burst testing parameters
        burst_duration = RAPID_MESSAGE_TEST_CONFIG["websocket_stability_duration"]
        messages_per_burst = 10
        burst_interval = 2.0  # 2 seconds between bursts
        bursts_count = int(burst_duration / burst_interval)
        
        message_metrics = {
            "sent": 0,
            "received": 0,
            "failed": 0,
            "timeouts": 0
        }
        
        # Start connection monitoring
        connection_monitor_task = asyncio.create_task(
            rapid_message_sender.monitor_connection_health(burst_duration + 10)
        )
        
        # Execute sustained bursts
        all_responses = []
        burst_results = []
        
        for burst_id in range(bursts_count):
            burst_messages = []
            for msg_id in range(messages_per_burst):
                message = {
                    "type": "user_message",
                    "content": f"Burst {burst_id} Message {msg_id}: Process data",
                    "burst_id": burst_id,
                    "message_id": f"burst-{burst_id}-msg-{msg_id}",
                    "timestamp": time.time()
                }
                burst_messages.append(message)
                message_sequence_validator.track_expected_sequence(
                    burst_id * messages_per_burst + msg_id, 
                    message["message_id"]
                )
            
            # Send burst
            start_time = time.perf_counter()
            results = await rapid_message_sender.send_rapid_burst(burst_messages, burst_interval=0.05)
            burst_duration_actual = time.perf_counter() - start_time
            
            # Count results
            successful_sends = len([r for r in results if r.get("status") == "sent"])
            failed_sends = len([r for r in results if r.get("status") == "failed"])
            
            message_metrics["sent"] += successful_sends
            message_metrics["failed"] += failed_sends
            
            burst_results.append({
                "burst_id": burst_id,
                "duration": burst_duration_actual,
                "sent": successful_sends,
                "failed": failed_sends
            })
            
            # Wait for burst interval
            await asyncio.sleep(burst_interval)
        
        # Collect all responses
        total_expected = bursts_count * messages_per_burst
        responses = await rapid_message_sender.receive_responses(
            expected_count=total_expected,
            timeout=burst_duration + 5
        )
        
        message_metrics["received"] = len(responses)
        
        # Track received sequences
        for response in responses:
            message_id = response.get("message_id", response.get("correlation_id"))
            if message_id:
                # Extract sequence from message ID
                try:
                    parts = message_id.split("-")
                    if len(parts) >= 4:  # burst-X-msg-Y format
                        burst_id = int(parts[1])
                        msg_id = int(parts[3])
                        sequence_id = burst_id * messages_per_burst + msg_id
                        message_sequence_validator.track_received_sequence(sequence_id, message_id, response)
                except (ValueError, IndexError):
                    pass
        
        # Stop connection monitoring
        connection_health = await connection_monitor_task
        
        # Validation
        
        # Verify connection stability
        assert connection_health["disconnections"] == 0, \
            f"WebSocket disconnected {connection_health['disconnections']} times"
        
        assert connection_health["connection_stable"], "WebSocket connection was unstable"
        
        # Verify message delivery ratio
        if message_metrics["sent"] > 0:
            delivery_ratio = message_metrics["received"] / message_metrics["sent"]
            assert delivery_ratio >= RAPID_MESSAGE_TEST_CONFIG["min_delivery_ratio"], \
                f"Delivery ratio too low: {delivery_ratio:.2f}"
        
        # Verify performance
        if burst_results:
            avg_burst_duration = sum(b["duration"] for b in burst_results) / len(burst_results)
            max_burst_duration = max(b["duration"] for b in burst_results)
            
            assert avg_burst_duration < 1.0, f"Average burst duration too high: {avg_burst_duration:.3f}s"
            assert max_burst_duration < 2.0, f"Maximum burst duration too high: {max_burst_duration:.3f}s"
        
        # Verify no excessive memory growth
        memory_growth = (
            connection_health["final_memory_usage"]["rss"] - 
            connection_health["initial_memory_usage"]["rss"]
        )
        memory_growth_mb = memory_growth / (1024 * 1024)
        
        assert memory_growth_mb < 100, f"Excessive memory growth: {memory_growth_mb:.1f}MB"
        
        # Verify sequence integrity
        sequence_validation = message_sequence_validator.validate_sequence_integrity()
        missing_ratio = len(sequence_validation["missing_sequences"]) / total_expected
        assert missing_ratio < 0.1, f"Too many missing messages: {missing_ratio:.2%}"
        
        await agent_state_monitor.capture_state_snapshot("stability_test_end", rapid_message_sender)
        
        logger.info(f"WebSocket stability test: {message_metrics['sent']} sent, {message_metrics['received']} received, {connection_health['disconnections']} disconnections")
