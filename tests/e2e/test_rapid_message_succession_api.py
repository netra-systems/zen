"""
Test module split from original file
Generated by auto_fix_test_violations.py
"""

import asyncio
import json
import time
from typing import Dict, List

import psutil
import pytest
import websockets


class RapidMessageSender:
    """Utility for controlled rapid message sending."""

    def __init__(
        self, websocket_uri: str, auth_token: str, max_rate_per_second: int = 50
    ):
        self.websocket_uri = websocket_uri
        self.auth_token = auth_token
        self.max_rate_per_second = max_rate_per_second
        self.sent_messages = []
        self.connection = None

    async def connect(self):
        """Establish WebSocket connection."""
        try:
            # For mock server, don't use auth headers
            if "localhost:8765" in self.websocket_uri:
                self.connection = await websockets.connect(
                    self.websocket_uri,
                    ping_interval=20,
                    ping_timeout=10,
                    close_timeout=10,
                )
            else:
                headers = {"Authorization": f"Bearer {self.auth_token}"}
                self.connection = await websockets.connect(
                    self.websocket_uri,
                    extra_headers=headers,
                    ping_interval=20,
                    ping_timeout=10,
                    close_timeout=10,
                )
            return self.connection
        except Exception as e:
            logger.error(f"Failed to connect to WebSocket: {e}")
            raise

    async def disconnect(self):
        """Close WebSocket connection."""
        if self.connection:
            await self.connection.close()

    async def send_rapid_burst(
        self, messages: List[Dict], burst_interval: float = 0.1
    ) -> List[Dict]:
        """Send messages in rapid succession with controlled timing."""
        if not self.connection:
            await self.connect()

        tasks = []
        for i, message in enumerate(messages):
            delay = i * burst_interval
            task = asyncio.create_task(self._send_with_delay(message, delay))
            tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results

    async def _send_with_delay(self, message: Dict, delay: float) -> Dict:
        """Send message after specified delay."""
        await asyncio.sleep(delay)
        start_time = time.perf_counter()

        try:
            message_json = json.dumps(message)
            await self.connection.send(message_json)
            send_time = time.perf_counter() - start_time

            result = {
                "message": message,
                "send_time": send_time,
                "timestamp": time.time(),
                "status": "sent",
            }
            self.sent_messages.append(result)
            return result

        except Exception as e:
            result = {
                "message": message,
                "error": str(e),
                "timestamp": time.time(),
                "status": "failed",
            }
            self.sent_messages.append(result)
            return result

    async def receive_responses(
        self, expected_count: int, timeout: float = 30.0
    ) -> List[Dict]:
        """Receive responses with timeout."""
        responses = []
        start_time = time.time()

        try:
            while (
                len(responses) < expected_count and (time.time() - start_time) < timeout
            ):
                try:
                    response = await asyncio.wait_for(
                        self.connection.recv(),
                        timeout=min(5.0, timeout - (time.time() - start_time)),
                    )
                    response_data = json.loads(response)
                    response_data["received_time"] = time.time()
                    responses.append(response_data)
                except asyncio.TimeoutError:
                    continue
                except Exception as e:
                    logger.warning(f"Error receiving response: {e}")
                    break
        except Exception as e:
            logger.error(f"Error in receive_responses: {e}")

        return responses

    async def get_agent_state(self) -> Dict:
        """Get current agent state via WebSocket."""
        state_request = {"type": "get_agent_state", "timestamp": time.time()}

        await self.connection.send(json.dumps(state_request))

        # Wait for state response
        try:
            response = await asyncio.wait_for(self.connection.recv(), timeout=5.0)
            return json.loads(response)
        except asyncio.TimeoutError:
            return {"error": "Agent state request timeout"}

    async def monitor_connection_health(self, duration: float) -> Dict:
        """Monitor WebSocket connection health over time."""
        health_data = {
            "start_time": time.time(),
            "disconnections": 0,
            "reconnections": 0,
            "ping_failures": 0,
            "initial_memory_usage": {"rss": psutil.Process().memory_info().rss},
            "final_memory_usage": {},
            "connection_stable": True,
        }

        end_time = time.time() + duration

        while time.time() < end_time:
            try:
                # Check connection state
                if self.connection.closed:
                    health_data["disconnections"] += 1
                    health_data["connection_stable"] = False
                    break

                # Test ping
                try:
                    pong = await self.connection.ping()
                    await asyncio.wait_for(pong, timeout=5.0)
                except asyncio.TimeoutError:
                    health_data["ping_failures"] += 1

                await asyncio.sleep(1.0)  # Check every second

            except Exception as e:
                logger.warning(f"Connection health check error: {e}")
                health_data["connection_stable"] = False
                break

        health_data["final_memory_usage"] = {"rss": psutil.Process().memory_info().rss}
        return health_data


class TestSequentialMessageProcessingRapidSuccession:
    """Test Case 1: Sequential Message Processing Under Rapid Succession"""

    @pytest.mark.asyncio
    @pytest.mark.e2e
    async def test_sequential_message_processing_rapid_succession(
        self, rapid_message_sender, message_sequence_validator, agent_state_monitor
    ):
        """
        Scenario: Single user sends 20 messages within 2 seconds
        Expected: All messages processed in exact order, no duplicates or loss
        """
        await agent_state_monitor.capture_state_snapshot(
            "test_start", rapid_message_sender
        )

        # Generate sequence of numbered messages
        message_count = 20
        messages = []

        for i in range(message_count):
            message = {
                "type": "user_message",
                "content": f"Message sequence {i:03d}: What is 2+2?",
                "sequence_id": i,
                "message_id": f"seq-msg-{i}",
                "timestamp": time.time(),
                "requires_processing": True,
            }
            messages.append(message)
            message_sequence_validator.track_expected_sequence(
                i, message["message_id"], message["content"]
            )

        # Send messages in rapid succession (100ms intervals)
        start_time = time.perf_counter()
        results = await rapid_message_sender.send_rapid_burst(
            messages, burst_interval=0.1
        )
        send_duration = time.perf_counter() - start_time

        # Collect responses
        responses = await rapid_message_sender.receive_responses(
            expected_count=message_count, timeout=30.0
        )

        # Track received sequences
        for response in responses:
            sequence_id = response.get("sequence_id")
            message_id = response.get("message_id", response.get("correlation_id"))
            if sequence_id is not None and message_id:
                message_sequence_validator.track_received_sequence(
                    sequence_id, message_id, response
                )

        # Validation
        assert (
            len(responses) == message_count
        ), f"Expected {message_count} responses, got {len(responses)}"

        # Validate sequence integrity
        sequence_validation = message_sequence_validator.validate_sequence_integrity()
        assert (
            len(sequence_validation["violations"]) == 0
        ), f"Sequence violations detected: {
            sequence_validation['violations']}"

        # Verify no duplicates
        message_ids = [
            r.get("message_id", r.get("correlation_id"))
            for r in responses
            if r.get("message_id") or r.get("correlation_id")
        ]
        unique_message_ids = set(message_ids)
        assert len(message_ids) == len(
            unique_message_ids
        ), f"Duplicate messages detected: {
            len(message_ids)} total, {
            len(unique_message_ids)} unique"

        # Verify timing performance
        assert (
            send_duration < 5.0
        ), f"Message sending took too long: {
            send_duration:.2f}s"

        await agent_state_monitor.capture_state_snapshot(
            "test_end", rapid_message_sender
        )

        logger.info(
            f"Sequential processing test completed: {
                len(responses)} messages in {
                send_duration:.2f}s"
        )
