"""
Test module split from original file
Generated by auto_fix_test_violations.py
"""

import asyncio
import json
import time
from typing import Dict, List

import psutil
import pytest
import websockets

class RapidMessageSender:
    # """Utility for controlled rapid message sending."""

    def __init__(
        self, websocket_uri: str, auth_token: str, max_rate_per_second: int = 50
    ):
        self.websocket_uri = websocket_uri
        self.auth_token = auth_token
        self.max_rate_per_second = max_rate_per_second
        self.sent_messages = []
        self.connection = None

    async def connect(self):
        """Establish WebSocket connection."""
        try:
            # For mock server, don't use auth headers
            if "localhost:8765" in self.websocket_uri:
                self.connection = await websockets.connect(
                    self.websocket_uri,
                    ping_interval=20,
                    ping_timeout=10,
                    close_timeout=10,
                )
            else:
                headers = {"Authorization": f"Bearer {self.auth_token}"}
                self.connection = await websockets.connect(
                    self.websocket_uri,
                    extra_headers=headers,
                    ping_interval=20,
                    ping_timeout=10,
                    close_timeout=10,
            return self.connection
        except Exception as e:
            logger.error(f"Failed to connect to WebSocket: {e}")
            raise

    async def disconnect(self):
        """Close WebSocket connection."""
        if self.connection:
            await self.connection.close()

    async def send_rapid_burst(
        self, messages: List[Dict], burst_interval: float = 0.1
    ) -> List[Dict]:
        """Send messages in rapid succession with controlled timing."""
        if not self.connection:
            await self.connect()

        tasks = []
        for i, message in enumerate(messages):
            delay = i * burst_interval
            task = asyncio.create_task(self._send_with_delay(message, delay))
            tasks.append(task)

        results = await asyncio.gather(*tasks, return_exceptions=True)
        return results

    async def _send_with_delay(self, message: Dict, delay: float) -> Dict:
        """Send message after specified delay."""
        await asyncio.sleep(delay)
        start_time = time.perf_counter()

        try:
            message_json = json.dumps(message)
            await self.connection.send(message_json)
            send_time = time.perf_counter() - start_time

            result = {
                "message": message,
                "send_time": send_time,
                "timestamp": time.time(),
                "status": "sent",
            self.sent_messages.append(result)
            return result

        except Exception as e:
            result = {
                "message": message,
                "error": str(e),
                "timestamp": time.time(),
                "status": "failed",
            self.sent_messages.append(result)
            return result

    async def receive_responses(
        self, expected_count: int, timeout: float = 30.0
    ) -> List[Dict]:
        """Receive responses with timeout."""
        responses = []
        start_time = time.time()

        try:
            while (
                len(responses) < expected_count and (time.time() - start_time) < timeout
            ):
                try:
                    response = await asyncio.wait_for(
                        self.connection.recv(),
                        timeout=min(5.0, timeout - (time.time() - start_time)),
                    response_data = json.loads(response)
                    response_data["received_time"] = time.time()
                    responses.append(response_data)
                except asyncio.TimeoutError:
                    continue
                except Exception as e:
                    logger.warning(f"Error receiving response: {e}")
                    break
        except Exception as e:
            logger.error(f"Error in receive_responses: {e}")

        return responses

    async def get_agent_state(self) -> Dict:
        """Get current agent state via WebSocket."""
        state_request = {"type": "get_agent_state", "timestamp": time.time()}

        await self.connection.send(json.dumps(state_request))

        # Wait for state response
        try:
            response = await asyncio.wait_for(self.connection.recv(), timeout=5.0)
            return json.loads(response)
        except asyncio.TimeoutError:
            return {"error": "Agent state request timeout"}

    async def monitor_connection_health(self, duration: float) -> Dict:
        """Monitor WebSocket connection health over time."""
        health_data = {
            "start_time": time.time(),
            "disconnections": 0,
            "reconnections": 0,
            "ping_failures": 0,
            "initial_memory_usage": {"rss": psutil.Process().memory_info().rss},
            "final_memory_usage": {},
            "connection_stable": True,

        end_time = time.time() + duration

        while time.time() < end_time:
            try:
                # Check connection state
                if self.connection.closed:
                    health_data["disconnections"] += 1
                    health_data["connection_stable"] = False
                    break

                # Test ping
                try:
                    pong = await self.connection.ping()
                    await asyncio.wait_for(pong, timeout=5.0)
                except asyncio.TimeoutError:
                    health_data["ping_failures"] += 1

                await asyncio.sleep(1.0)  # Check every second

            except Exception as e:
                logger.warning(f"Connection health check error: {e}")
                health_data["connection_stable"] = False
                break

        health_data["final_memory_usage"] = {"rss": psutil.Process().memory_info().rss}
        return health_data

class TestSequentialMessageProcessingRapidSuccession:
    pass

