"""

E2E Tests for Service Startup and Health

Tests critical service initialization and health checks during cold start.



Business Value Justification (BVJ):

- Segment: Platform/Internal

- Business Goal: Stability, Customer Retention

- Value Impact: Ensures all services start correctly, preventing customer-facing outages

- Strategic Impact: 100% uptime requirement for Enterprise SLA compliance

"""



import asyncio

import pytest

import aiohttp

import asyncpg

import redis.asyncio as redis

from typing import Dict, List, Optional

import docker

import time

from shared.isolated_environment import IsolatedEnvironment





@pytest.mark.e2e

@pytest.mark.real_services

class TestServiceStartup:

    """Test suite for service startup and health verification."""



    @pytest.mark.asyncio

    async def test_all_docker_containers_healthy(self):

        """

        Test that all required Docker containers are running and healthy.

        

        Critical Assertions:

        - PostgreSQL container is running

        - Redis container is running

        - ClickHouse container is running

        - All containers pass health checks

        

        Expected Failure: Containers not started or unhealthy

        Business Impact: Complete system failure, 0% functionality

        """

        client = docker.from_env()

        required_containers = {

            'postgres': {'port': 5432, 'health_check': 'pg_isready'},

            'redis': {'port': 6379, 'health_check': 'redis-cli ping'},

            'clickhouse': {'port': 8123, 'health_check': 'clickhouse-client --query="SELECT 1"'}

        }

        

        containers_status = {}

        for name, config in required_containers.items():

            try:

                # Find container by name pattern

                containers = client.containers.list(filters={'name': name})

                assert len(containers) > 0, f"No {name} container found - Docker container not started"

                

                container = containers[0]

                assert container.status == 'running', f"{name} container not running: {container.status}"

                

                # Check container health

                health = container.attrs.get('State', {}).get('Health', {})

                if health:

                    assert health.get('Status') == 'healthy', f"{name} container unhealthy: {health.get('Status')}"

                

                # Test network connectivity

                exec_result = container.exec_run(config['health_check'])

                assert exec_result.exit_code == 0, f"{name} health check failed: {exec_result.output.decode()}"

                

                containers_status[name] = 'healthy'

            except Exception as e:

                containers_status[name] = f'failed: {str(e)}'

                raise AssertionError(f"Docker container {name} initialization failed: {str(e)}")

        

        # Verify all containers are healthy

        assert all(status == 'healthy' for status in containers_status.values()), \

            f"Container health check failed: {containers_status}"



    @pytest.mark.asyncio

    async def test_backend_service_initialization(self):

        """

        Test that the main backend service initializes correctly.

        

        Critical Assertions:

        - Service starts on port 8000

        - Health endpoint responds

        - OpenAPI docs accessible

        - Service ready within 30 seconds

        

        Expected Failure: Backend crash on startup (4-minute crash issue)

        Business Impact: No API functionality, 100% feature loss

        """

        backend_url = "http://localhost:8000"

        max_retries = 30

        retry_delay = 1

        

        async with aiohttp.ClientSession() as session:

            # Wait for service to be ready

            for attempt in range(max_retries):

                try:

                    # Check health endpoint

                    async with session.get(f"{backend_url}/health") as response:

                        assert response.status == 200, f"Health check failed: {response.status}"

                        health_data = await response.json()

                        assert health_data.get('status') == 'healthy', f"Service unhealthy: {health_data}"

                        

                        # Verify critical components

                        components = health_data.get('components', {})

                        assert 'database' in components, "Database component not initialized"

                        assert 'redis' in components, "Redis component not initialized"

                        assert 'websocket' in components, "WebSocket component not initialized"

                        

                        # Check OpenAPI docs

                        async with session.get(f"{backend_url}/docs") as docs_response:

                            assert docs_response.status == 200, "OpenAPI docs not accessible"

                        

                        # Check metrics endpoint

                        async with session.get(f"{backend_url}/metrics") as metrics_response:

                            assert metrics_response.status == 200, "Metrics endpoint not accessible"

                        

                        return  # Success

                        

                except (aiohttp.ClientError, AssertionError) as e:

                    if attempt == max_retries - 1:

                        raise AssertionError(f"Backend service failed to initialize after {max_retries} seconds: {str(e)}")

                    await asyncio.sleep(retry_delay)

            

            raise AssertionError("Backend service initialization timeout")



    @pytest.mark.asyncio

    async def test_auth_service_initialization(self):

        """

        Test that the auth service initializes correctly.

        

        Critical Assertions:

        - Service starts on port 8001

        - OAuth providers configured

        - JWT secrets loaded

        - Service ready within 20 seconds

        

        Expected Failure: Auth service configuration missing

        Business Impact: No user authentication, 100% user loss

        """

        auth_url = "http://localhost:8001"

        max_retries = 20

        retry_delay = 1

        

        async with aiohttp.ClientSession() as session:

            for attempt in range(max_retries):

                try:

                    # Check health endpoint

                    async with session.get(f"{auth_url}/health") as response:

                        assert response.status == 200, f"Auth health check failed: {response.status}"

                        health_data = await response.json()

                        

                        # Verify OAuth providers

                        providers = health_data.get('oauth_providers', [])

                        assert 'google' in providers, "Google OAuth not configured"

                        assert 'github' in providers, "GitHub OAuth not configured"

                        

                        # Verify JWT configuration

                        jwt_config = health_data.get('jwt_configured', False)

                        assert jwt_config, "JWT secrets not configured"

                        

                        # Check auth endpoints

                        async with session.get(f"{auth_url}/auth/providers") as providers_response:

                            assert providers_response.status == 200, "OAuth providers endpoint not accessible"

                            providers_data = await providers_response.json()

                            assert len(providers_data) >= 2, f"Insufficient OAuth providers: {providers_data}"

                        

                        return  # Success

                        

                except (aiohttp.ClientError, AssertionError) as e:

                    if attempt == max_retries - 1:

                        raise AssertionError(f"Auth service failed to initialize: {str(e)}")

                    await asyncio.sleep(retry_delay)

            

            raise AssertionError("Auth service initialization timeout")



    @pytest.mark.asyncio

    async def test_database_connections_established(self):

        """

        Test that database connections are properly established.

        

        Critical Assertions:

        - PostgreSQL connection pool created

        - Critical tables exist (users, threads, messages)

        - ClickHouse connection established

        - Connection pooling working

        

        Expected Failure: Database migrations not run

        Business Impact: No data persistence, complete data loss

        """

        # Test PostgreSQL connection

        pg_conn = None

        try:

            pg_conn = await asyncpg.connect(

                host='localhost',

                port=5432,

                user='postgres',

                password='postgres',

                database='netra_dev',

                timeout=10

            )

            

            # Check critical tables exist (based on actual models)

            critical_tables = ['users', 'threads', 'messages', 'assistants', 'runs']

            for table in critical_tables:

                result = await pg_conn.fetchval(

                    "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = $1)",

                    table

                )

                assert result, f"Critical table '{table}' does not exist - migrations not run"

            

            # Test connection pooling

            pool = await asyncpg.create_pool(

                host='localhost',

                port=5432,

                user='postgres',

                password='postgres',

                database='netra_dev',

                min_size=5,

                max_size=20

            )

            

            # Verify pool can acquire connections

            async with pool.acquire() as conn:

                result = await conn.fetchval('SELECT 1')

                assert result == 1, "Database query failed"

            

            await pool.close()

            

        except Exception as e:

            raise AssertionError(f"PostgreSQL connection failed: {str(e)}")

        finally:

            if pg_conn:

                await pg_conn.close()

        

        # Test ClickHouse connection (optional - skip if auth issues)

        async with aiohttp.ClientSession() as session:

            try:

                async with session.get('http://localhost:8123/ping') as response:

                    if response.status == 200:

                        # Try query execution with authentication

                        query = "SELECT 1"

                        auth_headers = {'X-ClickHouse-User': 'default'}

                        async with session.post(

                            'http://localhost:8123/',

                            data=query,

                            headers=auth_headers

                        ) as response:

                            if response.status == 200:

                                result = await response.text()

                                assert '1' in result, f"Unexpected query result: {result}"

                            else:

                                print(f"Warning: ClickHouse query auth failed: {response.status} - continuing")

                    else:

                        print(f"Warning: ClickHouse ping failed: {response.status} - continuing")

                    

            except Exception as e:

                print(f"Warning: ClickHouse connection failed: {str(e)} - continuing")



    @pytest.mark.asyncio

    async def test_redis_connection_pool_healthy(self):

        """

        Test that Redis connection pool is healthy and operational.

        

        Critical Assertions:

        - Redis connection established

        - Connection pool functioning

        - Basic operations work (get/set/pub/sub)

        - Memory usage acceptable

        

        Expected Failure: Redis not started or misconfigured

        Business Impact: No caching, severe performance degradation

        """

        redis_client = None

        try:

            # Create Redis connection

            redis_client = await get_redis_client()

            

            # Test basic connectivity

            pong = await redis_client.ping()

            assert pong, "Redis ping failed"

            

            # Test basic operations

            test_key = "e2e_test_startup"

            test_value = "test_value_123"

            

            # Set and get

            await redis_client.set(test_key, test_value, ex=60)

            retrieved = await redis_client.get(test_key)

            assert retrieved == test_value, f"Redis get/set failed: expected {test_value}, got {retrieved}"

            

            # Test pub/sub

            pubsub = await redis_client.pubsub()

            await pubsub.subscribe("test_channel")

            

            # Publish a message

            await redis_client.publish("test_channel", "test_message")

            

            # Clean up test data

            await redis_client.delete(test_key)

            await pubsub.unsubscribe("test_channel")

            await pubsub.close()

            

            # Check Redis info

            info = await redis_client.info()

            assert info['redis_version'], "Redis version not available"

            assert int(info['connected_clients']) > 0, "No Redis clients connected"

            

            # Check memory usage

            memory_info = await redis_client.info('memory')

            used_memory_mb = int(memory_info['used_memory']) / (1024 * 1024)

            assert used_memory_mb < 1000, f"Redis memory usage too high: {used_memory_mb}MB"

            

        except Exception as e:

            raise AssertionError(f"Redis connection pool test failed: {str(e)}")

        finally:

            if redis_client:

                await redis_client.close()

