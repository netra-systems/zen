"""
Comprehensive unit tests for agent isolation architecture.

This test suite verifies that the new AgentClassRegistry + AgentInstanceFactory
architecture properly isolates user contexts and prevents data leakage between
concurrent users.

Business Value: Ensures 10+ concurrent users can operate safely without
context contamination or data leakage.
"""

import asyncio
import pytest
import uuid
from datetime import datetime, timezone
from typing import Dict, Any, Optional
from unittest.mock import MagicMock, AsyncMock, patch

from netra_backend.app.agents.supervisor.agent_class_registry import (
    AgentClassRegistry, 
    get_agent_class_registry,
    create_test_registry
)
from netra_backend.app.agents.supervisor.agent_instance_factory import (
    AgentInstanceFactory,
    UserWebSocketEmitter
)
from netra_backend.app.agents.supervisor.user_execution_context import (
    UserExecutionContext,
    InvalidContextError
)
from netra_backend.app.agents.supervisor.agent_registry import AgentRegistry
from netra_backend.app.agents.base_agent import BaseAgent


class MockAgent(BaseAgent):
    """Mock agent for testing isolation."""
    
    def __init__(self, name: str = "mock_agent", user_id: Optional[str] = None, **kwargs):
        super().__init__()
        self.name = name
        self.user_id = user_id
        self.description = "Mock agent for testing"
        self.version = "1.0.0"
        self.dependencies = []
        self.websocket_bridge = None
        self.run_id = None
        self.execution_calls = []
    
    def set_websocket_bridge(self, bridge, run_id: Optional[str] = None):
        """Set WebSocket bridge and run_id."""
        self.websocket_bridge = bridge
        self.run_id = run_id
    
    async def execute(self, state: Dict[str, Any], run_id: str) -> Dict[str, Any]:
        """Mock execute method that records execution context."""
        execution_record = {
            'agent_name': self.name,
            'user_id': self.user_id,
            'run_id': run_id,
            'websocket_run_id': self.run_id,
            'timestamp': datetime.now(timezone.utc),
            'state_keys': list(state.keys()) if state else []
        }
        self.execution_calls.append(execution_record)
        
        return {
            'success': True,
            'agent_name': self.name,
            'user_id': self.user_id,
            'run_id': run_id,
            'execution_id': len(self.execution_calls)
        }


class TestAgentClassRegistry:
    """Test AgentClassRegistry infrastructure-only functionality."""
    
    def test_registry_initialization(self):
        """Test registry initializes properly."""
        registry = create_test_registry()
        
        assert len(registry) == 0
        assert not registry.is_frozen()
        assert registry.list_agent_names() == []
        assert registry.get_registry_stats()['health_status'] == 'unhealthy'  # No classes yet
    
    def test_agent_class_registration(self):
        """Test agent class registration works correctly."""
        registry = create_test_registry()
        
        # Register agent class
        registry.register(
            name="mock_agent",
            agent_class=MockAgent,
            description="Test mock agent",
            version="2.0.0",
            dependencies=["llm_manager"],
            metadata={"test": True}
        )
        
        assert len(registry) == 1
        assert registry.has_agent_class("mock_agent")
        assert registry.get_agent_class("mock_agent") == MockAgent
        
        agent_info = registry.get_agent_info("mock_agent")
        assert agent_info.name == "mock_agent"
        assert agent_info.agent_class == MockAgent
        assert agent_info.description == "Test mock agent"
        assert agent_info.version == "2.0.0"
        assert agent_info.dependencies == ("llm_manager",)
        assert agent_info.metadata == {"test": True}
    
    def test_duplicate_registration_same_class(self):
        """Test duplicate registration with same class is handled gracefully."""
        registry = create_test_registry()
        
        # Register twice with same class
        registry.register("mock_agent", MockAgent, "First registration")
        registry.register("mock_agent", MockAgent, "Second registration")
        
        assert len(registry) == 1
        # Should keep first registration
        assert registry.get_agent_info("mock_agent").description == "First registration"
    
    def test_duplicate_registration_different_class(self):
        """Test duplicate registration with different class raises error."""
        registry = create_test_registry()
        
        class AnotherMockAgent(BaseAgent):
            pass
        
        registry.register("mock_agent", MockAgent)
        
        with pytest.raises(ValueError, match="already registered with different class"):
            registry.register("mock_agent", AnotherMockAgent)
    
    def test_freeze_functionality(self):
        """Test registry freeze prevents modifications."""
        registry = create_test_registry()
        
        # Register before freezing
        registry.register("mock_agent", MockAgent)
        
        # Freeze registry
        registry.freeze()
        assert registry.is_frozen()
        assert registry.get_registry_stats()['health_status'] == 'healthy'
        
        # Try to register after freezing
        with pytest.raises(RuntimeError, match="Cannot register agent classes after registry is frozen"):
            registry.register("another_agent", MockAgent)
    
    def test_thread_safety(self):
        """Test registry is thread-safe during registration."""
        import threading
        import time
        
        registry = create_test_registry()
        results = []
        errors = []
        
        def register_agent(agent_num):
            try:
                agent_name = f"agent_{agent_num}"
                registry.register(agent_name, MockAgent, f"Agent {agent_num}")
                results.append(agent_name)
            except Exception as e:
                errors.append(f"Agent {agent_num}: {e}")
        
        # Create multiple threads
        threads = []
        for i in range(10):
            thread = threading.Thread(target=register_agent, args=(i,))
            threads.append(thread)
        
        # Start all threads
        for thread in threads:
            thread.start()
        
        # Wait for completion
        for thread in threads:
            thread.join()
        
        assert len(errors) == 0, f"Errors during registration: {errors}"
        assert len(results) == 10
        assert len(registry) == 10
    
    def test_dependency_validation(self):
        """Test dependency validation functionality."""
        registry = create_test_registry()
        
        # Register agents with dependencies
        registry.register("base_agent", MockAgent, dependencies=[])
        registry.register("dependent_agent", MockAgent, dependencies=["base_agent", "missing_agent"])
        
        missing_deps = registry.validate_dependencies()
        
        assert "base_agent" not in missing_deps
        assert "dependent_agent" in missing_deps
        assert missing_deps["dependent_agent"] == ["missing_agent"]
    
    def test_immutability_after_freeze(self):
        """Test registry is truly immutable after freeze."""
        registry = create_test_registry()
        
        registry.register("mock_agent", MockAgent)
        agent_info_before = registry.get_agent_info("mock_agent")
        
        registry.freeze()
        
        # Agent info should be same object (immutable)
        agent_info_after = registry.get_agent_info("mock_agent")
        assert agent_info_before is agent_info_after
        
        # List should be consistent
        names_before = registry.list_agent_names()
        names_after = registry.list_agent_names()
        assert names_before == names_after


class TestUserExecutionContext:
    """Test UserExecutionContext isolation and validation."""
    
    def test_valid_context_creation(self):
        """Test valid context creation."""
        context = UserExecutionContext.from_request(
            user_id="user123",
            thread_id="thread456",
            run_id="run789"
        )
        
        assert context.user_id == "user123"
        assert context.thread_id == "thread456"
        assert context.run_id == "run789"
        assert context.request_id is not None
        assert isinstance(context.created_at, datetime)
        assert context.metadata == {}
    
    def test_placeholder_value_validation(self):
        """Test that placeholder values are rejected."""
        # Test exact dangerous values
        dangerous_values = ['registry', 'placeholder', 'default', 'temp', 'none', 'null']
        
        for dangerous_value in dangerous_values:
            with pytest.raises(InvalidContextError, match="forbidden placeholder value"):
                UserExecutionContext.from_request(
                    user_id=dangerous_value,
                    thread_id="thread456",
                    run_id="run789"
                )
        
        # Test dangerous patterns
        dangerous_patterns = ['placeholder_123', 'registry_temp', 'default_xxx']
        
        for dangerous_pattern in dangerous_patterns:
            with pytest.raises(InvalidContextError, match="placeholder pattern"):
                UserExecutionContext.from_request(
                    user_id=dangerous_pattern,
                    thread_id="thread456",
                    run_id="run789"
                )
    
    def test_context_immutability(self):
        """Test that context is truly immutable."""
        context = UserExecutionContext.from_request(
            user_id="user123",
            thread_id="thread456",
            run_id="run789",
            metadata={"key": "value"}
        )
        
        # Try to modify (should fail)
        with pytest.raises(AttributeError):
            context.user_id = "modified"
        
        # Metadata should be a separate copy
        original_metadata = context.metadata
        original_metadata["new_key"] = "new_value"
        
        # Context metadata should be unchanged
        assert "new_key" not in context.metadata
    
    def test_child_context_creation(self):
        """Test child context creation preserves parent data."""
        parent_context = UserExecutionContext.from_request(
            user_id="user123",
            thread_id="thread456",
            run_id="run789",
            metadata={"parent": "data"}
        )
        
        child_context = parent_context.create_child_context(
            "sub_operation",
            {"child": "data"}
        )
        
        # Child should inherit parent identifiers
        assert child_context.user_id == parent_context.user_id
        assert child_context.thread_id == parent_context.thread_id
        assert child_context.run_id == parent_context.run_id
        
        # Child should have new request_id
        assert child_context.request_id != parent_context.request_id
        
        # Child metadata should include parent + child + operation data
        assert child_context.metadata["parent"] == "data"
        assert child_context.metadata["child"] == "data"
        assert child_context.metadata["operation_name"] == "sub_operation"
        assert child_context.metadata["parent_request_id"] == parent_context.request_id
        assert child_context.metadata["operation_depth"] == 1
    
    def test_context_isolation_verification(self):
        """Test context isolation verification."""
        context = UserExecutionContext.from_request(
            user_id="user123",
            thread_id="thread456",
            run_id="run789"
        )
        
        # Should pass isolation check
        assert context.verify_isolation() is True
    
    def test_correlation_id_generation(self):
        """Test correlation ID generation."""
        context = UserExecutionContext.from_request(
            user_id="user123456789",
            thread_id="thread456789012",
            run_id="run789012345",
        )
        
        correlation_id = context.get_correlation_id()
        
        # Should contain truncated versions of IDs
        assert correlation_id.startswith("user1234:")
        assert "thread45:" in correlation_id
        assert "run78901:" in correlation_id


class TestAgentInstanceFactory:
    """Test AgentInstanceFactory per-request isolation."""
    
    @pytest.fixture
    def mock_websocket_bridge(self):
        """Create mock WebSocket bridge."""
        bridge = AsyncMock()
        bridge.notify_agent_started = AsyncMock(return_value=True)
        bridge.notify_agent_completed = AsyncMock(return_value=True)
        bridge.notify_tool_executing = AsyncMock(return_value=True)
        bridge.notify_tool_completed = AsyncMock(return_value=True)
        bridge.notify_agent_thinking = AsyncMock(return_value=True)
        bridge.notify_agent_error = AsyncMock(return_value=True)
        bridge.register_run_thread_mapping = AsyncMock(return_value=True)
        bridge.unregister_run_mapping = AsyncMock(return_value=True)
        return bridge
    
    @pytest.fixture
    def configured_factory(self, mock_websocket_bridge):
        """Create configured AgentInstanceFactory."""
        # Setup registry
        registry = create_test_registry()
        registry.register("mock_agent", MockAgent, "Test agent")
        
        # Setup factory
        factory = AgentInstanceFactory()
        factory.configure(
            agent_class_registry=registry,
            websocket_bridge=mock_websocket_bridge
        )
        
        return factory
    
    @pytest.mark.asyncio
    async def test_user_context_creation(self, configured_factory):
        """Test user execution context creation."""
        context = await configured_factory.create_user_execution_context(
            user_id="user123",
            thread_id="thread456",
            run_id="run789"
        )
        
        assert context.user_id == "user123"
        assert context.thread_id == "thread456"
        assert context.run_id == "run789"
        assert context.request_id is not None
    
    @pytest.mark.asyncio
    async def test_agent_instance_creation(self, configured_factory):
        """Test agent instance creation with proper context binding."""
        context = await configured_factory.create_user_execution_context(
            user_id="user123",
            thread_id="thread456",
            run_id="run789"
        )
        
        agent = await configured_factory.create_agent_instance("mock_agent", context)
        
        assert isinstance(agent, MockAgent)
        assert agent.user_id == "user123"
        assert agent.run_id == "run789"  # Should be set from context
        assert agent.websocket_bridge is not None
    
    @pytest.mark.asyncio
    async def test_user_execution_scope(self, configured_factory):
        """Test user execution scope context manager."""
        async with configured_factory.user_execution_scope(
            user_id="user123",
            thread_id="thread456", 
            run_id="run789"
        ) as context:
            assert context.user_id == "user123"
            
            # Create agent within scope
            agent = await configured_factory.create_agent_instance("mock_agent", context)
            assert agent.user_id == "user123"
        
        # Context should be cleaned up after scope
        # Factory should track cleanup
        metrics = configured_factory.get_factory_metrics()
        assert metrics['total_contexts_cleaned'] >= 1
    
    @pytest.mark.asyncio
    async def test_concurrent_user_isolation(self, configured_factory):
        """Test that concurrent users have completely isolated contexts."""
        async def user_workflow(user_id: str, results: list):
            async with configured_factory.user_execution_scope(
                user_id=user_id,
                thread_id=f"thread_{user_id}",
                run_id=f"run_{user_id}"
            ) as context:
                agent = await configured_factory.create_agent_instance("mock_agent", context)
                
                # Execute agent with user-specific data
                result = await agent.execute(
                    {"user_data": f"data_for_{user_id}"}, 
                    context.run_id
                )
                
                results.append({
                    'user_id': user_id,
                    'agent_user_id': agent.user_id,
                    'context_user_id': context.user_id,
                    'run_id': context.run_id,
                    'result': result
                })
        
        # Run multiple concurrent users
        results = []
        tasks = []
        for i in range(5):
            user_id = f"user{i}"
            task = asyncio.create_task(user_workflow(user_id, results))
            tasks.append(task)
        
        await asyncio.gather(*tasks)
        
        # Verify isolation
        assert len(results) == 5
        
        user_ids = [r['user_id'] for r in results]
        agent_user_ids = [r['agent_user_id'] for r in results]
        context_user_ids = [r['context_user_id'] for r in results]
        run_ids = [r['run_id'] for r in results]
        
        # All user IDs should match their respective contexts/agents
        for result in results:
            assert result['user_id'] == result['agent_user_id']
            assert result['user_id'] == result['context_user_id']
            assert result['run_id'].endswith(result['user_id'])
        
        # All run_ids should be unique
        assert len(set(run_ids)) == 5
        
        # All user_ids should be unique
        assert len(set(user_ids)) == 5
    
    @pytest.mark.asyncio
    async def test_websocket_emitter_isolation(self, configured_factory):
        """Test that WebSocket emitters are properly isolated per user."""
        # Create contexts for two different users
        context1 = await configured_factory.create_user_execution_context(
            user_id="user1",
            thread_id="thread1",
            run_id="run1"
        )
        
        context2 = await configured_factory.create_user_execution_context(
            user_id="user2",
            thread_id="thread2",
            run_id="run2"
        )
        
        # Create agents for both users
        agent1 = await configured_factory.create_agent_instance("mock_agent", context1)
        agent2 = await configured_factory.create_agent_instance("mock_agent", context2)
        
        # Agents should have different run_ids bound to their WebSocket
        assert agent1.run_id == "run1"
        assert agent2.run_id == "run2"
        assert agent1.user_id == "user1"
        assert agent2.user_id == "user2"
        
        # WebSocket bridges should be set but with different run contexts
        assert agent1.websocket_bridge is not None
        assert agent2.websocket_bridge is not None
        # Same bridge instance but different run_id contexts
        assert agent1.websocket_bridge is agent2.websocket_bridge
        assert agent1.run_id != agent2.run_id
    
    def test_factory_metrics_tracking(self, configured_factory):
        """Test factory tracks metrics properly."""
        initial_metrics = configured_factory.get_factory_metrics()
        
        assert 'total_instances_created' in initial_metrics
        assert 'active_contexts' in initial_metrics
        assert 'total_contexts_cleaned' in initial_metrics
        assert 'creation_errors' in initial_metrics
        assert 'cleanup_errors' in initial_metrics


class TestAgentRegistryMigration:
    """Test AgentRegistry migration to new architecture."""
    
    @pytest.fixture
    def legacy_registry(self):
        """Create legacy AgentRegistry for migration testing."""
        llm_manager = MagicMock()
        tool_dispatcher = MagicMock()
        
        with patch('netra_backend.app.agents.supervisor.agent_registry.warnings.warn'):
            registry = AgentRegistry(llm_manager, tool_dispatcher)
        
        # Manually register some test agents
        registry.register("mock_agent_1", MockAgent("mock_agent_1"))
        registry.register("mock_agent_2", MockAgent("mock_agent_2"))
        
        return registry
    
    def test_get_infrastructure_registry(self, legacy_registry):
        """Test getting infrastructure registry from legacy registry."""
        infrastructure_registry = legacy_registry.get_infrastructure_registry()
        
        assert infrastructure_registry is not None
        assert isinstance(infrastructure_registry, AgentClassRegistry)
    
    def test_migration_to_new_architecture(self, legacy_registry):
        """Test migration from legacy to new architecture."""
        migration_status = legacy_registry.migrate_to_new_architecture()
        
        assert migration_status['infrastructure_registry_available'] is True
        assert migration_status['legacy_agents_count'] == 2
        assert migration_status['agent_classes_migrated'] >= 2
        assert migration_status['migration_complete'] is True
        assert len(migration_status['migration_errors']) == 0
        
        # Verify agents are in infrastructure registry
        infrastructure_registry = legacy_registry.get_infrastructure_registry()
        assert infrastructure_registry.has_agent_class("mock_agent_1")
        assert infrastructure_registry.has_agent_class("mock_agent_2")
        
        # Verify recommendations
        assert any("AgentInstanceFactory" in rec for rec in migration_status['recommendations'])
        assert any("UserExecutionContext" in rec for rec in migration_status['recommendations'])
    
    @pytest.mark.asyncio
    async def test_create_request_factory(self, legacy_registry):
        """Test creating request factory from legacy registry."""
        # Create a user context
        context = UserExecutionContext.from_request(
            user_id="test_user",
            thread_id="test_thread",
            run_id="test_run"
        )
        
        # Create factory from legacy registry
        factory = legacy_registry.create_request_factory(context)
        
        assert isinstance(factory, AgentInstanceFactory)
        
        # Factory should be configured
        metrics = factory.get_factory_metrics()
        assert metrics['configuration_status']['agent_registry_configured'] is True
    
    def test_deprecation_warnings(self):
        """Test that deprecation warnings are issued for legacy usage."""
        llm_manager = MagicMock()
        tool_dispatcher = MagicMock()
        
        with patch('warnings.warn') as mock_warn:
            registry = AgentRegistry(llm_manager, tool_dispatcher)
            
            # Should have issued deprecation warning
            mock_warn.assert_called_once()
            args, kwargs = mock_warn.call_args
            assert "deprecated" in args[0].lower()
            assert kwargs.get('category') == DeprecationWarning


class TestBackwardCompatibility:
    """Test backward compatibility during migration."""
    
    @pytest.fixture
    def configured_environment(self):
        """Set up both old and new architecture components."""
        # Legacy components
        llm_manager = MagicMock()
        tool_dispatcher = MagicMock()
        
        with patch('netra_backend.app.agents.supervisor.agent_registry.warnings.warn'):
            legacy_registry = AgentRegistry(llm_manager, tool_dispatcher)
        
        # Register test agents
        legacy_registry.register("test_agent", MockAgent("test_agent"))
        
        # New components
        infrastructure_registry = legacy_registry.get_infrastructure_registry()
        factory = AgentInstanceFactory()
        
        mock_bridge = AsyncMock()
        mock_bridge.notify_agent_started = AsyncMock(return_value=True)
        mock_bridge.notify_agent_completed = AsyncMock(return_value=True)
        mock_bridge.notify_tool_executing = AsyncMock(return_value=True)
        mock_bridge.notify_tool_completed = AsyncMock(return_value=True)
        mock_bridge.notify_agent_thinking = AsyncMock(return_value=True)
        mock_bridge.notify_agent_error = AsyncMock(return_value=True)
        
        factory.configure(
            agent_class_registry=infrastructure_registry,
            agent_registry=legacy_registry,
            websocket_bridge=mock_bridge
        )
        
        return {
            'legacy_registry': legacy_registry,
            'infrastructure_registry': infrastructure_registry,
            'factory': factory,
            'websocket_bridge': mock_bridge
        }
    
    @pytest.mark.asyncio
    async def test_old_and_new_coexistence(self, configured_environment):
        """Test that old and new patterns can coexist."""
        legacy_registry = configured_environment['legacy_registry']
        factory = configured_environment['factory']
        
        # Old pattern still works
        old_agent = legacy_registry.get("test_agent")
        assert old_agent is not None
        assert isinstance(old_agent, MockAgent)
        
        # New pattern also works
        context = await factory.create_user_execution_context(
            user_id="new_user",
            thread_id="new_thread",
            run_id="new_run"
        )
        
        new_agent = await factory.create_agent_instance("test_agent", context)
        assert new_agent is not None
        assert isinstance(new_agent, MockAgent)
        
        # They should be different instances
        assert old_agent is not new_agent
        assert old_agent.user_id != new_agent.user_id
    
    def test_legacy_methods_still_work(self, configured_environment):
        """Test that legacy methods continue to function."""
        legacy_registry = configured_environment['legacy_registry']
        
        # Legacy methods should work
        assert len(legacy_registry.list_agents()) > 0
        assert legacy_registry.get("test_agent") is not None
        
        health = legacy_registry.get_registry_health()
        assert health['total_agents'] > 0
    
    @pytest.mark.asyncio
    async def test_migration_path_examples(self, configured_environment):
        """Test examples of migration path usage."""
        legacy_registry = configured_environment['legacy_registry']
        
        # Example 1: Get infrastructure registry
        infrastructure_registry = legacy_registry.get_infrastructure_registry()
        assert infrastructure_registry.has_agent_class("test_agent")
        
        # Example 2: Create request-scoped factory
        context = UserExecutionContext.from_request(
            user_id="example_user",
            thread_id="example_thread",
            run_id="example_run"
        )
        
        factory = legacy_registry.create_request_factory(context)
        agent = await factory.create_agent_instance("test_agent", context)
        
        assert agent.user_id == "example_user"
        assert agent.run_id == "example_run"
        
        # Example 3: Use migration status
        migration_status = legacy_registry.migrate_to_new_architecture()
        assert migration_status['migration_complete'] is True


if __name__ == "__main__":
    # Run tests with: python -m pytest tests/netra_backend/agents/test_agent_isolation.py -v
    pytest.main([__file__, "-v"])