"""
WebSocket Connection Pool Unit Tests

Business Value:
- Ensures connection pool properly manages WebSocket connections
- Validates resource management and cleanup
- Tests concurrent user handling
"""

import asyncio
import pytest
from unittest.mock import Mock, MagicMock, AsyncMock, patch
from datetime import datetime, timezone
import uuid

from netra_backend.app.services.websocket_bridge_factory import (
    WebSocketConnectionPool,
    UserWebSocketConnection as WebSocketConnection
)

# Mock missing classes if needed
class ConnectionStatus:
    INITIALIZING = "initializing"
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    FAILED = "failed"
    CLOSED = "closed"

class ConnectionMetrics:
    def __init__(self):
        self.total_connections = 0
        self.total_users = 0
        self.healthy_connections = 0
        self.unhealthy_connections = 0
        self.total_messages = 0
        self.total_errors = 0


class TestWebSocketConnection:
    """Unit tests for WebSocketConnection class."""
    
    @pytest.fixture
    def mock_websocket(self):
        """Create a mock WebSocket instance."""
        ws = MagicMock()
        ws.send = AsyncMock()
        ws.close = AsyncMock()
        ws.ping = AsyncMock()
        ws.state = MagicMock()
        ws.state.name = "OPEN"
        return ws
    
    @pytest.fixture
    def connection(self, mock_websocket):
        """Create a WebSocketConnection instance."""
        return WebSocketConnection(
            connection_id="test-connection-1",
            user_id="user-123",
            websocket=mock_websocket,
            created_at=datetime.now(timezone.utc)
        )
    
    def test_connection_initialization(self, connection):
        """Test WebSocketConnection initialization."""
        assert connection.connection_id == "test-connection-1"
        assert connection.user_id == "user-123"
        assert connection.status == ConnectionStatus.INITIALIZING
        assert connection.is_active is True
        assert connection.error_count == 0
        assert connection.message_count == 0
        assert connection.last_ping is None
        assert connection.last_error is None
    
    def test_connection_metrics(self, connection):
        """Test connection metrics tracking."""
        # Update message count
        connection.message_count = 10
        connection.error_count = 2
        
        assert connection.message_count == 10
        assert connection.error_count == 2
        
        # Mark as healthy
        connection.status = ConnectionStatus.HEALTHY
        assert connection.status == ConnectionStatus.HEALTHY
        
        # Mark as failed
        connection.status = ConnectionStatus.FAILED
        connection.is_active = False
        assert connection.is_active is False
    
    @pytest.mark.asyncio
    async def test_websocket_send(self, connection, mock_websocket):
        """Test sending messages through connection."""
        await connection.websocket.send("test message")
        mock_websocket.send.assert_called_once_with("test message")
        
    @pytest.mark.asyncio
    async def test_websocket_close(self, connection, mock_websocket):
        """Test closing WebSocket connection."""
        await connection.websocket.close()
        mock_websocket.close.assert_called_once()


class TestWebSocketConnectionPool:
    """Unit tests for WebSocketConnectionPool class."""
    
    @pytest.fixture
    def pool(self):
        """Create a WebSocketConnectionPool instance."""
        return WebSocketConnectionPool(
            max_connections_per_user=3,
            connection_timeout=30,
            health_check_interval=5
        )
    
    @pytest.fixture
    def mock_websocket(self):
        """Create a mock WebSocket instance."""
        ws = MagicMock()
        ws.send = AsyncMock()
        ws.close = AsyncMock()
        ws.ping = AsyncMock()
        ws.state = MagicMock()
        ws.state.name = "OPEN"
        return ws
    
    def test_pool_initialization(self, pool):
        """Test connection pool initialization."""
        assert pool.max_connections_per_user == 3
        assert pool.connection_timeout == 30
        assert pool.health_check_interval == 5
        assert len(pool.connections) == 0
        assert len(pool.user_connections) == 0
        assert pool.total_connections == 0
    
    @pytest.mark.asyncio
    async def test_add_connection(self, pool, mock_websocket):
        """Test adding a connection to the pool."""
        user_id = "user-123"
        connection_id = await pool.add_connection(user_id, mock_websocket)
        
        assert connection_id is not None
        assert pool.total_connections == 1
        assert user_id in pool.user_connections
        assert len(pool.user_connections[user_id]) == 1
        assert connection_id in pool.connections
        
        # Verify connection properties
        connection = pool.connections[connection_id]
        assert connection.user_id == user_id
        assert connection.websocket == mock_websocket
        assert connection.status == ConnectionStatus.INITIALIZING
    
    @pytest.mark.asyncio
    async def test_add_multiple_connections_same_user(self, pool, mock_websocket):
        """Test adding multiple connections for the same user."""
        user_id = "user-123"
        
        # Add three connections
        conn_ids = []
        for _ in range(3):
            ws = MagicMock()
            ws.send = AsyncMock()
            ws.close = AsyncMock()
            ws.state = MagicMock()
            ws.state.name = "OPEN"
            conn_id = await pool.add_connection(user_id, ws)
            conn_ids.append(conn_id)
        
        assert pool.total_connections == 3
        assert len(pool.user_connections[user_id]) == 3
        
        # Verify all connections are tracked
        for conn_id in conn_ids:
            assert conn_id in pool.connections
    
    @pytest.mark.asyncio
    async def test_max_connections_per_user(self, pool):
        """Test max connections per user limit."""
        user_id = "user-123"
        
        # Add max connections
        for i in range(3):
            ws = MagicMock()
            ws.send = AsyncMock()
            ws.close = AsyncMock()
            ws.state = MagicMock()
            ws.state.name = "OPEN"
            await pool.add_connection(user_id, ws)
        
        # Try to add one more (should close oldest)
        new_ws = MagicMock()
        new_ws.send = AsyncMock()
        new_ws.close = AsyncMock()
        new_ws.state = MagicMock()
        new_ws.state.name = "OPEN"
        
        oldest_conn = pool.user_connections[user_id][0]
        old_ws = pool.connections[oldest_conn].websocket
        
        await pool.add_connection(user_id, new_ws)
        
        # Should have closed the oldest connection
        old_ws.close.assert_called()
        assert oldest_conn not in pool.connections
        assert pool.total_connections == 3
    
    @pytest.mark.asyncio
    async def test_remove_connection(self, pool, mock_websocket):
        """Test removing a connection from the pool."""
        user_id = "user-123"
        connection_id = await pool.add_connection(user_id, mock_websocket)
        
        # Remove the connection
        removed = await pool.remove_connection(connection_id)
        
        assert removed is True
        assert connection_id not in pool.connections
        assert pool.total_connections == 0
        assert len(pool.user_connections.get(user_id, [])) == 0
        mock_websocket.close.assert_called()
    
    @pytest.mark.asyncio
    async def test_remove_nonexistent_connection(self, pool):
        """Test removing a non-existent connection."""
        removed = await pool.remove_connection("non-existent-id")
        assert removed is False
    
    @pytest.mark.asyncio
    async def test_get_user_connections(self, pool):
        """Test getting all connections for a user."""
        user_id = "user-123"
        
        # Add multiple connections
        conn_ids = []
        for _ in range(2):
            ws = MagicMock()
            ws.send = AsyncMock()
            ws.state = MagicMock()
            ws.state.name = "OPEN"
            conn_id = await pool.add_connection(user_id, ws)
            conn_ids.append(conn_id)
        
        # Get user connections
        connections = pool.get_user_connections(user_id)
        
        assert len(connections) == 2
        for conn in connections:
            assert conn.connection_id in conn_ids
            assert conn.user_id == user_id
    
    @pytest.mark.asyncio
    async def test_get_active_connections(self, pool):
        """Test getting only active connections for a user."""
        user_id = "user-123"
        
        # Add active connection
        ws1 = MagicMock()
        ws1.send = AsyncMock()
        ws1.state = MagicMock()
        ws1.state.name = "OPEN"
        conn_id1 = await pool.add_connection(user_id, ws1)
        pool.connections[conn_id1].status = ConnectionStatus.HEALTHY
        
        # Add inactive connection
        ws2 = MagicMock()
        ws2.send = AsyncMock()
        ws2.state = MagicMock()
        ws2.state.name = "CLOSED"
        conn_id2 = await pool.add_connection(user_id, ws2)
        pool.connections[conn_id2].status = ConnectionStatus.FAILED
        pool.connections[conn_id2].is_active = False
        
        # Get active connections
        active = pool.get_active_connections(user_id)
        
        assert len(active) == 1
        assert active[0].connection_id == conn_id1
    
    @pytest.mark.asyncio
    async def test_broadcast_to_user(self, pool):
        """Test broadcasting message to all user connections."""
        user_id = "user-123"
        
        # Add multiple connections
        websockets = []
        for _ in range(2):
            ws = MagicMock()
            ws.send = AsyncMock()
            ws.state = MagicMock()
            ws.state.name = "OPEN"
            websockets.append(ws)
            conn_id = await pool.add_connection(user_id, ws)
            pool.connections[conn_id].status = ConnectionStatus.HEALTHY
        
        # Broadcast message
        message = {"type": "test", "data": "hello"}
        success_count = await pool.broadcast_to_user(user_id, message)
        
        assert success_count == 2
        for ws in websockets:
            ws.send.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_broadcast_handles_send_errors(self, pool):
        """Test broadcast handles errors during send."""
        user_id = "user-123"
        
        # Add connection that will fail
        ws = MagicMock()
        ws.send = AsyncMock(side_effect=Exception("Send failed"))
        ws.state = MagicMock()
        ws.state.name = "OPEN"
        conn_id = await pool.add_connection(user_id, ws)
        pool.connections[conn_id].status = ConnectionStatus.HEALTHY
        
        # Broadcast should handle error gracefully
        message = {"type": "test", "data": "hello"}
        success_count = await pool.broadcast_to_user(user_id, message)
        
        assert success_count == 0
        assert pool.connections[conn_id].error_count > 0
    
    @pytest.mark.asyncio
    async def test_cleanup_inactive_connections(self, pool):
        """Test cleaning up inactive connections."""
        user_id = "user-123"
        
        # Add healthy connection
        ws1 = MagicMock()
        ws1.send = AsyncMock()
        ws1.close = AsyncMock()
        ws1.state = MagicMock()
        ws1.state.name = "OPEN"
        conn_id1 = await pool.add_connection(user_id, ws1)
        pool.connections[conn_id1].status = ConnectionStatus.HEALTHY
        
        # Add failed connection
        ws2 = MagicMock()
        ws2.send = AsyncMock()
        ws2.close = AsyncMock()
        ws2.state = MagicMock()
        ws2.state.name = "CLOSED"
        conn_id2 = await pool.add_connection(user_id, ws2)
        pool.connections[conn_id2].status = ConnectionStatus.FAILED
        pool.connections[conn_id2].is_active = False
        
        # Cleanup inactive
        removed_count = await pool.cleanup_inactive_connections()
        
        assert removed_count == 1
        assert conn_id1 in pool.connections
        assert conn_id2 not in pool.connections
        ws2.close.assert_called()
    
    @pytest.mark.asyncio
    async def test_cleanup_user_connections(self, pool):
        """Test cleaning up all connections for a user."""
        user_id = "user-123"
        
        # Add multiple connections
        websockets = []
        conn_ids = []
        for _ in range(2):
            ws = MagicMock()
            ws.send = AsyncMock()
            ws.close = AsyncMock()
            ws.state = MagicMock()
            ws.state.name = "OPEN"
            websockets.append(ws)
            conn_id = await pool.add_connection(user_id, ws)
            conn_ids.append(conn_id)
        
        # Cleanup user connections
        removed_count = await pool.cleanup_user_connections(user_id)
        
        assert removed_count == 2
        assert user_id not in pool.user_connections
        for conn_id in conn_ids:
            assert conn_id not in pool.connections
        for ws in websockets:
            ws.close.assert_called()
    
    @pytest.mark.asyncio
    async def test_get_pool_metrics(self, pool):
        """Test getting pool metrics."""
        # Add connections for multiple users
        user1 = "user-123"
        user2 = "user-456"
        
        ws1 = MagicMock()
        ws1.send = AsyncMock()
        ws1.state = MagicMock()
        ws1.state.name = "OPEN"
        conn_id1 = await pool.add_connection(user1, ws1)
        pool.connections[conn_id1].status = ConnectionStatus.HEALTHY
        pool.connections[conn_id1].message_count = 5
        
        ws2 = MagicMock()
        ws2.send = AsyncMock()
        ws2.state = MagicMock()
        ws2.state.name = "OPEN"
        conn_id2 = await pool.add_connection(user2, ws2)
        pool.connections[conn_id2].status = ConnectionStatus.UNHEALTHY
        pool.connections[conn_id2].error_count = 2
        
        # Get metrics
        metrics = pool.get_pool_metrics()
        
        assert metrics.total_connections == 2
        assert metrics.total_users == 2
        assert metrics.healthy_connections == 1
        assert metrics.unhealthy_connections == 1
        assert metrics.total_messages == 5
        assert metrics.total_errors == 2
    
    @pytest.mark.asyncio
    async def test_health_check_healthy_connection(self, pool):
        """Test health check on healthy connection."""
        user_id = "user-123"
        
        ws = MagicMock()
        ws.send = AsyncMock()
        ws.ping = AsyncMock()
        ws.state = MagicMock()
        ws.state.name = "OPEN"
        
        conn_id = await pool.add_connection(user_id, ws)
        connection = pool.connections[conn_id]
        
        # Perform health check
        is_healthy = await pool.check_connection_health(connection)
        
        assert is_healthy is True
        assert connection.status == ConnectionStatus.HEALTHY
        ws.ping.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_health_check_closed_connection(self, pool):
        """Test health check on closed connection."""
        user_id = "user-123"
        
        ws = MagicMock()
        ws.send = AsyncMock()
        ws.ping = AsyncMock()
        ws.state = MagicMock()
        ws.state.name = "CLOSED"
        
        conn_id = await pool.add_connection(user_id, ws)
        connection = pool.connections[conn_id]
        
        # Perform health check
        is_healthy = await pool.check_connection_health(connection)
        
        assert is_healthy is False
        assert connection.status == ConnectionStatus.FAILED
        assert connection.is_active is False