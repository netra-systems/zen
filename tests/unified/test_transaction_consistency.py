"""Transaction Consistency Testing Suite - Phase 5

Critical data integrity testing for distributed transactions across
Auth DB, Backend DB, and ClickHouse to prevent revenue loss from corruption.

Business Value Justification (BVJ):
1. Segment: All customer segments (Free, Early, Mid, Enterprise)
2. Business Goal: Ensure atomic operations protect billing and user data integrity
3. Value Impact: Prevents data corruption that could cause revenue loss and user churn  
4. Revenue Impact: Critical for trust - data corruption directly impacts retention (-$50K ARR risk)

Test Coverage:
- Distributed transaction rollback atomicity
- Partial failure recovery consistency
- Concurrent write conflict resolution  
- Eventual consistency verification

Architecture: 300-line limit, 8-line functions, modular design
"""

import pytest
import asyncio
import uuid
from typing import Dict, Optional
from .transaction_test_fixtures import (
    TransactionConsistencyTester,
    TransactionTestDataFactory,
    DatabaseType,
    TransactionState
)


@pytest.fixture
def transaction_tester():
    """Create transaction consistency tester."""
    return TransactionConsistencyTester()


@pytest.fixture
def sample_user_data():
    """Create sample user data for testing."""
    return {
        "user_id": f"user_{uuid.uuid4().hex[:8]}",
        "email": f"test_{uuid.uuid4().hex[:6]}@example.com", 
        "full_name": "Test User",
        "plan_tier": "mid"
    }


class TestDistributedTransactionRollback:
    """Test atomic rollback across all services."""
    
    @pytest.mark.asyncio
    async def test_distributed_transaction_rollback(self, transaction_tester, sample_user_data):
        """Test rollback atomicity across Auth DB, Backend DB, and ClickHouse."""
        # BVJ: Ensures billing data integrity during failures
        tx_id = await transaction_tester.manager.begin_transaction()
        
        # Add operations to all databases
        auth_op = transaction_tester.create_test_operation(
            DatabaseType.AUTH_DB, "create_user", sample_user_data
        )
        backend_op = transaction_tester.create_test_operation(
            DatabaseType.BACKEND_DB, "sync_user", sample_user_data
        )
        
        await transaction_tester.manager.execute_operation(tx_id, auth_op)
        await transaction_tester.manager.execute_operation(tx_id, backend_op)
        
        # Simulate failure during ClickHouse operation
        clickhouse_conn = transaction_tester.manager.connections[DatabaseType.CLICKHOUSE]
        clickhouse_conn.fail_on_operation = "track_user_creation"
        
        # Attempt operation that will fail
        with pytest.raises(Exception):
            clickhouse_op = transaction_tester.create_test_operation(
                DatabaseType.CLICKHOUSE, "track_user_creation", sample_user_data
            )
            await transaction_tester.manager.execute_operation(tx_id, clickhouse_op)
        
        # Verify rollback completed atomically
        rollback_success = await transaction_tester.verify_rollback_complete(tx_id)
        assert rollback_success
        
        # Verify transaction marked as failed
        final_state = transaction_tester.get_transaction_state(tx_id)
        assert final_state in [TransactionState.ROLLED_BACK, TransactionState.FAILED]


class TestPartialFailureRecovery:
    """Test consistency maintenance during partial failures."""
    
    @pytest.mark.asyncio  
    async def test_partial_failure_recovery(self, transaction_tester, sample_user_data):
        """Test consistency maintained when some operations fail."""
        # BVJ: Prevents orphaned records that could impact billing accuracy
        tx_id = await transaction_tester.manager.begin_transaction()
        
        # Simulate partial failure - Auth DB succeeds, Backend DB fails
        transaction_tester.setup_failure_scenario(DatabaseType.BACKEND_DB, "sync_user")
        
        # Execute operations
        auth_op = transaction_tester.create_test_operation(
            DatabaseType.AUTH_DB, "create_user", sample_user_data
        )
        await transaction_tester.manager.execute_operation(tx_id, auth_op)
        
        # Verify Auth operation succeeded
        assert auth_op.completed
        
        # Attempt Backend operation (will fail)
        with pytest.raises(Exception):
            backend_op = transaction_tester.create_test_operation(
                DatabaseType.BACKEND_DB, "sync_user", sample_user_data
            )
            await transaction_tester.manager.execute_operation(tx_id, backend_op)
        
        # After failure, transaction should be marked as failed or rolled back
        tx_state = transaction_tester.get_transaction_state(tx_id)
        assert tx_state in [TransactionState.FAILED, TransactionState.ROLLED_BACK]
        
        # Verify recovery maintains consistency - commit should fail
        commit_result = await transaction_tester.manager.commit_transaction(tx_id)
        assert not commit_result  # Should fail due to partial completion


class TestConcurrentWriteConflicts:
    """Test proper conflict resolution under concurrent writes."""
    
    @pytest.mark.asyncio
    async def test_concurrent_write_conflicts(self, transaction_tester):
        """Test conflict resolution for concurrent user updates."""
        # BVJ: Prevents data corruption during high-load scenarios 
        user_id = f"concurrent_user_{uuid.uuid4().hex[:8]}"
        
        # Create two concurrent transactions
        tx1_id = await transaction_tester.manager.begin_transaction({"user": "transaction_1"})
        tx2_id = await transaction_tester.manager.begin_transaction({"user": "transaction_2"})
        
        # Both transactions try to update same user
        update_data_1 = {"user_id": user_id, "plan_tier": "enterprise", "version": 1}
        update_data_2 = {"user_id": user_id, "plan_tier": "mid", "version": 1}
        
        # Execute operations concurrently
        op1 = transaction_tester.create_test_operation(
            DatabaseType.BACKEND_DB, "update_user", update_data_1
        )
        op2 = transaction_tester.create_test_operation(
            DatabaseType.BACKEND_DB, "update_user", update_data_2
        )
        
        await asyncio.gather(
            transaction_tester.manager.execute_operation(tx1_id, op1),
            transaction_tester.manager.execute_operation(tx2_id, op2),
            return_exceptions=True
        )
        
        # Attempt to commit both - only one should succeed
        commit_results = await asyncio.gather(
            transaction_tester.manager.commit_transaction(tx1_id),
            transaction_tester.manager.commit_transaction(tx2_id),
            return_exceptions=True
        )
        
        # Verify conflict resolution - at least one should succeed
        successful_commits = sum(1 for result in commit_results if result is True)
        assert successful_commits >= 1


class TestEventualConsistency:
    """Test data synchronization verification across services."""
    
    @pytest.mark.asyncio
    async def test_eventual_consistency(self, transaction_tester, sample_user_data):
        """Test eventual consistency after distributed operations."""
        # BVJ: Ensures analytics data matches billing data for accurate reporting
        tx_id = await transaction_tester.manager.begin_transaction()
        
        # Create user in Auth DB
        auth_op = transaction_tester.create_test_operation(
            DatabaseType.AUTH_DB, "create_user", sample_user_data
        )
        await transaction_tester.manager.execute_operation(tx_id, auth_op)
        
        # Sync to Backend DB  
        backend_op = transaction_tester.create_test_operation(
            DatabaseType.BACKEND_DB, "sync_user", sample_user_data
        )
        await transaction_tester.manager.execute_operation(tx_id, backend_op)
        
        # Track in ClickHouse
        analytics_data = {**sample_user_data, "event_type": "user_created"}
        clickhouse_op = transaction_tester.create_test_operation(
            DatabaseType.CLICKHOUSE, "track_event", analytics_data
        )
        await transaction_tester.manager.execute_operation(tx_id, clickhouse_op)
        
        # Commit transaction
        commit_success = await transaction_tester.manager.commit_transaction(tx_id)
        assert commit_success
        
        # Verify eventual consistency - all operations completed
        auth_conn = transaction_tester.manager.connections[DatabaseType.AUTH_DB]
        backend_conn = transaction_tester.manager.connections[DatabaseType.BACKEND_DB]
        clickhouse_conn = transaction_tester.manager.connections[DatabaseType.CLICKHOUSE]
        
        assert len(auth_conn.operations) == 1
        assert len(backend_conn.operations) == 1  
        assert len(clickhouse_conn.operations) == 1
        
        # Verify all operations completed successfully
        all_operations = (
            auth_conn.operations + 
            backend_conn.operations + 
            clickhouse_conn.operations
        )
        assert all(op.completed for op in all_operations)