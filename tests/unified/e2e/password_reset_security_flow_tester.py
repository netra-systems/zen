"""
Password Reset Security Flow Tester - Security Validation

BVJ (Business Value Justification):
1. Segment: All customer segments (security critical for trust)
2. Business Goal: Validate password reset security prevents abuse
3. Value Impact: Protects user accounts from unauthorized access
4. Revenue Impact: Maintains user trust and prevents security incidents

REQUIREMENTS:
- Token expiration validation
- Single-use token enforcement
- Invalid token rejection
- Security edge case testing
- 450-line file limit, 25-line function limit
"""
import time
from typing import Dict, Any

from .password_reset_test_helpers import PasswordResetE2ETester


class PasswordResetSecurityFlowTester:
    """Security-focused password reset flow tester."""
    
    def __init__(self, auth_tester):
        self.auth_tester = auth_tester
        self.reset_tester = PasswordResetE2ETester()
        self.test_email = "security@example.com"
    
    async def execute_security_validation_flow(self) -> Dict[str, Any]:
        """Execute security validation tests."""
        start_time = time.time()
        results = {"success": False, "security_tests": {}}
        
        try:
            await self.reset_tester.setup_test_environment()
            
            # Execute all security tests
            await self._execute_token_expiration_test(results)
            await self._execute_single_use_token_test(results)
            await self._execute_invalid_token_test(results)
            
            results["success"] = self._validate_security_tests(
                results["security_tests"]
            )
            results["execution_time"] = time.time() - start_time
            
        except Exception as e:
            results["error"] = str(e)
            results["execution_time"] = time.time() - start_time
        
        finally:
            await self.reset_tester.cleanup_test_environment()
        
        return results
    
    async def _execute_token_expiration_test(self, results: Dict[str, Any]) -> None:
        """Execute token expiration test."""
        expiry_test = await self._test_token_expiration()
        results["security_tests"]["token_expiration"] = expiry_test
    
    async def _execute_single_use_token_test(self, results: Dict[str, Any]) -> None:
        """Execute single-use token test."""
        single_use_test = await self._test_single_use_token()
        results["security_tests"]["single_use_token"] = single_use_test
    
    async def _execute_invalid_token_test(self, results: Dict[str, Any]) -> None:
        """Execute invalid token test."""
        invalid_token_test = await self._test_invalid_token()
        results["security_tests"]["invalid_token"] = invalid_token_test
    
    async def _test_token_expiration(self) -> Dict[str, Any]:
        """Test token expiration handling."""
        reset_token = "expired_token_12345"
        security_tester = self.reset_tester.get_security_tester()
        
        # Simulate token expiry
        security_tester.simulate_token_expiry(reset_token)
        
        # Test expired token
        is_expired = security_tester.is_token_expired(reset_token)
        
        return {
            "success": is_expired,
            "token_expired": is_expired,
            "expiry_simulation": True
        }
    
    async def _test_single_use_token(self) -> Dict[str, Any]:
        """Test single-use token validation."""
        reset_token = "single_use_token_67890"
        security_tester = self.reset_tester.get_security_tester()
        
        # First use
        first_attempt = security_tester.record_token_attempt(reset_token)
        first_valid = security_tester.validate_single_use_token(reset_token)
        
        # Second use (should be invalid)
        second_attempt = security_tester.record_token_attempt(reset_token)
        second_valid = security_tester.validate_single_use_token(reset_token)
        
        return {
            "success": first_valid and not second_valid,
            "first_use_valid": first_valid,
            "second_use_rejected": not second_valid,
            "attempt_counts": [first_attempt, second_attempt]
        }
    
    async def _test_invalid_token(self) -> Dict[str, Any]:
        """Test invalid token handling."""
        invalid_tokens = [
            "",  # Empty token
            "short",  # Too short
            "invalid_token_format_test_12345"  # Valid format but invalid
        ]
        
        security_tester = self.reset_tester.get_security_tester()
        validation_results = []
        
        for token in invalid_tokens:
            is_valid_format = security_tester.validate_token_format(token)
            validation_results.append({
                "token": token,
                "format_valid": is_valid_format,
                "should_be_rejected": len(token) < 20
            })
        
        # All invalid tokens should be properly rejected
        all_rejected = all(
            not result["format_valid"] for result in validation_results 
            if result["should_be_rejected"]
        )
        
        return {
            "success": all_rejected,
            "validation_results": validation_results,
            "invalid_tokens_rejected": all_rejected
        }
    
    def _validate_security_tests(self, tests: Dict[str, Any]) -> bool:
        """Validate all security tests passed."""
        required_tests = ["token_expiration", "single_use_token", "invalid_token"]
        return all(
            test in tests and tests[test].get("success", False)
            for test in required_tests
        )
    
    async def test_token_replay_attacks(self) -> Dict[str, Any]:
        """Test protection against token replay attacks."""
        reset_token = "replay_attack_token_99999"
        security_tester = self.reset_tester.get_security_tester()
        
        # Record multiple attempts to simulate replay attack
        attempts = []
        for i in range(5):
            attempt_count = security_tester.record_token_attempt(reset_token)
            attempts.append(attempt_count)
        
        # Only first attempt should be valid
        first_valid = security_tester.validate_single_use_token(reset_token)
        
        return {
            "success": not first_valid,  # Should be invalid after multiple attempts
            "attempt_counts": attempts,
            "replay_protection": not first_valid
        }
    
    async def test_token_format_edge_cases(self) -> Dict[str, Any]:
        """Test edge cases for token format validation."""
        security_tester = self.reset_tester.get_security_tester()
        
        edge_case_tokens = [
            None,  # Null token
            " " * 30,  # Whitespace token
            "a" * 100,  # Very long token
            "!@#$%^&*()",  # Special characters only
            "123456789012345678901234567890"  # Numbers only (valid length)
        ]
        
        validation_results = []
        for token in edge_case_tokens:
            try:
                if token is not None:
                    is_valid = security_tester.validate_token_format(token)
                else:
                    is_valid = False
                
                validation_results.append({
                    "token": token,
                    "valid": is_valid,
                    "length": len(token) if token else 0
                })
            except Exception as e:
                validation_results.append({
                    "token": token,
                    "valid": False,
                    "error": str(e)
                })
        
        return {
            "success": True,  # Always succeeds for edge case testing
            "edge_case_results": validation_results,
            "edge_cases_handled": True
        }
    
    async def test_concurrent_token_usage(self) -> Dict[str, Any]:
        """Test concurrent usage of same token."""
        reset_token = "concurrent_token_11111"
        security_tester = self.reset_tester.get_security_tester()
        
        # Simulate concurrent attempts
        concurrent_results = []
        for i in range(3):
            attempt_count = security_tester.record_token_attempt(reset_token)
            is_valid = security_tester.validate_single_use_token(reset_token)
            concurrent_results.append({
                "attempt": i + 1,
                "count": attempt_count,
                "valid": is_valid
            })
        
        # Only first attempt should be valid
        first_valid = concurrent_results[0]["valid"]
        subsequent_invalid = all(not r["valid"] for r in concurrent_results[1:])
        
        return {
            "success": first_valid and subsequent_invalid,
            "concurrent_results": concurrent_results,
            "concurrency_protection": first_valid and subsequent_invalid
        }