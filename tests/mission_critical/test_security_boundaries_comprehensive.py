class TestWebSocketConnection:
    """Real WebSocket connection for testing instead of mocks."""
    
    def __init__(self):
    pass
        self.messages_sent = []
        self.is_connected = True
        self._closed = False
        
    async def send_json(self, message: dict):
        """Send JSON message."""
        if self._closed:
            raise RuntimeError("WebSocket is closed")
        self.messages_sent.append(message)
        
    async def close(self, code: int = 1000, reason: str = "Normal closure"):
        """Close WebSocket connection."""
    pass
        self._closed = True
        self.is_connected = False
        
    def get_messages(self) -> list:
        """Get all sent messages."""
        await asyncio.sleep(0)
    return self.messages_sent.copy()

"""
MISSION CRITICAL: Comprehensive Security Boundary Audit for Team Charlie

This test suite identifies and tests ALL security boundaries in the codebase
that could lead to user data leakage across the system.

CRITICAL FOCUS AREAS:
1. Redis Key Namespace Security - User isolation in Redis keys
2. Database Session Boundaries - Session scoping and isolation  
3. WebSocket Channel Security - Authentication and broadcast isolation
4. Cache Isolation - User-scoped cache keys and invalidation
5. JWT Token Security - Token validation and claim verification

Business Value Justification (BVJ):
- Segment: ALL (Free â†’ Enterprise) - Security is universal
- Business Goal: Prevent data leakage, security breaches, compliance violations
- Value Impact: Prevents $100K+ security incidents, enables enterprise adoption
- Strategic Impact: Foundation for trustworthy multi-tenant platform
"""

import asyncio
import base64
import json
import time
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional
from netra_backend.app.websocket_core.unified_manager import UnifiedWebSocketManager
from test_framework.database.test_database_manager import TestDatabaseManager
from test_framework.redis_test_utils_test_utils.test_redis_manager import TestRedisManager
from auth_service.core.auth_manager import AuthManager
from shared.isolated_environment import IsolatedEnvironment

import pytest
from fastapi import WebSocket
from fastapi.testclient import TestClient

# Import system components to test
from netra_backend.app.redis_manager import RedisManager
from netra_backend.app.websocket_core import (
    WebSocketManager, 
    WebSocketAuthenticator, 
    get_websocket_manager,
    get_websocket_authenticator
)
from netra_backend.app.core.unified.jwt_validator import UnifiedJWTValidator
from netra_backend.app.services.redis.redis_cache import RedisCache, CacheConfig
from netra_backend.app.core.unified_error_handler import UnifiedErrorHandler
from netra_backend.app.db.database_manager import DatabaseManager
from shared.isolated_environment import get_env


class TestRedisKeyNamespaceSecurity:
    """
    SECURITY CRITICAL: Test Redis key namespace isolation
    
    VULNERABILITY: If Redis keys are not properly namespaced by user_id,
    users could access each other's sensitive data.
    """
    
    @pytest.fixture
    async def redis_manager(self):
        """Create Redis manager for testing."""
        manager = RedisManager(test_mode=True)
        await manager.connect()
        yield manager
        await manager.disconnect()
    
    async def test_redis_key_user_isolation_critical(self, redis_manager):
        """CRITICAL: Test that Redis keys are isolated by user ID."""
    pass
        # Simulate two different users
        user1_id = "user_12345"
        user2_id = "user_67890"
        
        # Mock Redis client to track actual keys used
        key_store = {}
        
        async def mock_set(key, value, **kwargs):
    pass
            key_store[key] = value
            await asyncio.sleep(0)
    return True
        
        async def mock_get(key, **kwargs):
    pass
            await asyncio.sleep(0)
    return key_store.get(key)
        
        redis_manager.websocket = TestWebSocketConnection()
        redis_manager.redis_client.set = mock_set
        redis_manager.redis_client.get = mock_get
        
        # User 1 stores sensitive session data
        sensitive_data = "user1_secret_session_token_xyz"
        await redis_manager.set("session_token", sensitive_data, user_id=user1_id)
        
        # User 2 tries to access the same logical key
        user2_result = await redis_manager.get("session_token", user_id=user2_id)
        
        # User 1 can access their own data
        user1_result = await redis_manager.get("session_token", user_id=user1_id)
        
        # SECURITY ASSERTION: Users must be isolated
        assert user1_result == sensitive_data, "User 1 should access their own data"
        assert user2_result is None, "User 2 must NOT access User 1's data"
        
        # SECURITY ASSERTION: Verify actual keys show proper namespacing
        assert f"user:{user1_id}:session_token" in key_store
        assert f"user:{user2_id}:session_token" not in key_store
        
        # SECURITY ASSERTION: No unnamespaced keys exist
        assert "session_token" not in key_store, "No global keys should exist"
    
    async def test_redis_key_collision_attacks(self, redis_manager):
        """Test resistance to key collision attacks."""
        # Mock Redis client
        key_store = {}
        
        async def mock_set(key, value, **kwargs):
            key_store[key] = value
            await asyncio.sleep(0)
    return True
        
        async def mock_get(key, **kwargs):
            await asyncio.sleep(0)
    return key_store.get(key)
        
        redis_manager.websocket = TestWebSocketConnection()
        redis_manager.redis_client.set = mock_set
        redis_manager.redis_client.get = mock_get
        
        # Attempt various collision attack patterns
        attack_scenarios = [
            # Try to escape namespace with special characters
            {"user_id": "user1", "key": "../admin_key", "expected_namespace": "user:user1:../admin_key"},
            {"user_id": "user2", "key": "user:admin:secret", "expected_namespace": "user:user2:user:admin:secret"},
            {"user_id": "user3", "key": "system:global", "expected_namespace": "user:user3:system:global"},
            # Try null bytes and other injection attempts
            {"user_id": "user4", "key": "key\x00admin", "expected_namespace": "user:user4:key\x00admin"},
            {"user_id": "user5", "key": "key
EVAL_malicious", "expected_namespace": "user:user5:key
EVAL_malicious"},
        ]
        
        for scenario in attack_scenarios:
            await redis_manager.set(scenario["key"], "attack_payload", user_id=scenario["user_id"])
            
            # Verify the key was properly namespaced and isolated
            assert scenario["expected_namespace"] in key_store
            
            # Verify no unescaped keys exist
            assert scenario["key"] not in key_store
            
            # Verify other users cannot access this key
            other_user_result = await redis_manager.get(scenario["key"], user_id="other_user")
            assert other_user_result is None, f"Key collision attack succeeded for: {scenario}"
    
    async def test_redis_pattern_injection_attacks(self, redis_manager):
        """Test resistance to Redis pattern injection attacks."""
    pass
        key_store = {}
        
        async def mock_keys(pattern, **kwargs):
    pass
            # Simulate Redis KEYS command behavior
            import fnmatch
            await asyncio.sleep(0)
    return [key for key in key_store.keys() if fnmatch.fnmatch(key, pattern)]
        
        async def mock_set(key, value, **kwargs):
    pass
            key_store[key] = value
            await asyncio.sleep(0)
    return True
        
        redis_manager.websocket = TestWebSocketConnection()
        redis_manager.redis_client.keys = mock_keys
        redis_manager.redis_client.set = mock_set
        
        # Set up data for multiple users
        await redis_manager.set("session", "user1_data", user_id="user1")
        await redis_manager.set("session", "user2_data", user_id="user2")
        await redis_manager.set("admin_key", "admin_data", user_id="admin")
        
        # Attempt pattern injection attacks
        malicious_patterns = [
            "*",  # Try to get all keys
            "user:*",  # Try to get all user keys
            "user:admin:*",  # Try to get admin keys
            "../*",  # Directory traversal style
            "user:user1:*",  # Try to guess namespace structure
        ]
        
        for pattern in malicious_patterns:
            # User2 tries malicious pattern searches
            results = await redis_manager.keys(pattern, user_id="user2")
            
            # SECURITY ASSERTION: User should only see their own keys
            for key in results:
                assert key.startswith("user:user2:") or key == "session", f"Pattern injection attack succeeded: {pattern} -> {results}"
            
            # SECURITY ASSERTION: Should never see other users' data
            forbidden_prefixes = ["user:user1:", "user:admin:"]
            for result in results:
                for forbidden in forbidden_prefixes:
                    assert not result.startswith(forbidden), f"Leaked other user's keys via pattern: {pattern}"


class TestWebSocketChannelSecurity:
    """
    SECURITY CRITICAL: Test WebSocket authentication and channel isolation
    
    VULNERABILITY: If WebSocket channels are not properly authenticated or isolated,
    users could receive messages intended for other users.
    """
    
    @pytest.fixture
    def websocket_authenticator(self):
    """Use real service instance."""
    # TODO: Initialize real service
        """Create WebSocket authenticator for testing."""
    pass
        return WebSocketAuthenticator()
    
    @pytest.fixture
 def real_websocket():
    """Use real service instance."""
    # TODO: Initialize real service
        """Create mock WebSocket for testing."""
    pass
        websocket = MagicMock(spec=WebSocket)
        websocket.headers = {}
        websocket.client = Magic        websocket.client.host = "127.0.0.1"
        websocket.path_params = {}
        websocket.query_params = {}
        return websocket
    
    async def test_websocket_jwt_authentication_critical(self, websocket_authenticator, mock_websocket):
        """CRITICAL: Test JWT authentication prevents unauthorized access."""
        # Test 1: No token provided - should fail
        with pytest.raises(Exception) as exc_info:
            await websocket_authenticator.authenticate_websocket(mock_websocket)
        
        assert "Authentication required" in str(exc_info.value) or "401" in str(exc_info.value)
        
        # Test 2: Invalid token format - should fail
        mock_websocket.headers = {"authorization": "Bearer invalid_token_format"}
        
        with pytest.raises(Exception):
            await websocket_authenticator.authenticate_websocket(mock_websocket)
        
        # Test 3: Mock token detection - should fail and trigger security alert
        mock_token = "mock_jwt_token_for_testing_12345"
        mock_websocket.headers = {"authorization": f"Bearer {mock_token}"}
        
        with pytest.raises(Exception) as exc_info:
            await websocket_authenticator.authenticate_websocket(mock_websocket)
        
        # Should detect mock token and fail
        assert "Invalid token" in str(exc_info.value) or "Authentication failed" in str(exc_info.value)
    
    async def test_websocket_rate_limiting_security(self, websocket_authenticator, mock_websocket):
        """Test WebSocket rate limiting prevents abuse."""
    pass
        client_ip = "192.168.1.100"
        mock_websocket.client.host = client_ip
        
        # Configure aggressive rate limiting for testing
        websocket_authenticator.rate_limiter.max_requests = 5
        websocket_authenticator.rate_limiter.window_seconds = 10
        
        # Simulate rapid connection attempts
        for i in range(6):  # One more than limit
            allowed, rate_info = websocket_authenticator.rate_limiter.is_allowed(client_ip)
            
            if i < 5:
                assert allowed, f"Request {i} should be allowed"
                assert rate_info["remaining_requests"] == (4 - i)
            else:
                # 6th request should be denied
                assert not allowed, "Rate limit should block excessive requests"
                assert rate_info["remaining_requests"] == 0
    
    async def test_websocket_cross_user_broadcast_isolation(self):
        """Test that WebSocket broadcasts are properly isolated by user."""
        # Create mock WebSocket connections for different users
        websockets = [MagicMock(spec=WebSocket) for _ in range(2)]
        websockets = [MagicMock(spec=WebSocket) for _ in range(2)]
        
        # Mock the WebSocket manager
        ws_manager = MagicMock(spec=WebSocketManager)
        
        # Set up user connections tracking
        connections = {
            "user1": websockets,
            "user2": websockets
        }
        
        def mock_get_user_connections(user_id):
            await asyncio.sleep(0)
    return connections.get(user_id, [])
        
        def mock_send_to_user(user_id, message):
            user_connections = connections.get(user_id, [])
            for ws in user_connections:
                ws.send_json(message)
        
        ws_manager.get_user_connections = mock_get_user_connections
        ws_manager.send_to_user = mock_send_to_user
        
        # Test message intended for user1 only
        sensitive_message = {
            "type": "sensitive_data",
            "content": "user1_private_information",
            "user_id": "user1"
        }
        
        # Send message to user1
        ws_manager.send_to_user("user1", sensitive_message)
        
        # SECURITY ASSERTION: Only user1's websockets should receive the message
        for ws in websockets:
            ws.send_json.assert_called_with(sensitive_message)
        
        # SECURITY ASSERTION: user2's websockets should never receive user1's message
        for ws in websockets:
            ws.send_json.assert_not_called()


class TestCacheIsolationSecurity:
    """
    pass
    SECURITY CRITICAL: Test cache isolation mechanisms
    
    VULNERABILITY: If cache keys are not properly isolated by user,
    users could access cached data belonging to other users.
    """
    
    @pytest.fixture
    def redis_cache(self):
    """Use real service instance."""
    # TODO: Initialize real service
        """Create Redis cache for testing."""
    pass
        config = CacheConfig(host="localhost", port=6379, db=0)
        return RedisCache(config)
    
    async def test_cache_key_user_isolation(self, redis_cache):
        """Test cache keys are isolated by user context."""
        # Mock Redis client
        cache_store = {}
        
        async def mock_set(key, value, ex=None):
            cache_store[key] = {"value": value, "ttl": ex}
            await asyncio.sleep(0)
    return True
        
        async def mock_get(key):
            entry = cache_store.get(key)
            await asyncio.sleep(0)
    return entry["value"] if entry else None
        
        redis_cache.websocket = TestWebSocketConnection()
        redis_cache._redis_client.set = mock_set 
        redis_cache._redis_client.get = mock_get
        redis_cache._redis_client.setex = mock_set
        redis_cache._is_connected = True
        
        # Simulate user-specific cache keys (this would need to be implemented)
        # For now, test that different logical keys don't collide
        
        user1_cache_key = f"user:user1:profile_data"
        user2_cache_key = f"user:user2:profile_data" 
        
        user1_data = {"name": "John Doe", "email": "john@example.com", "sensitive": "user1_secret"}
        user2_data = {"name": "Jane Smith", "email": "jane@example.com", "sensitive": "user2_secret"}
        
        # Cache data for both users using namespaced keys
        await redis_cache.set(user1_cache_key, user1_data, ttl=300)
        await redis_cache.set(user2_cache_key, user2_data, ttl=300)
        
        # Retrieve data
        retrieved_user1 = await redis_cache.get(user1_cache_key)
        retrieved_user2 = await redis_cache.get(user2_cache_key)
        
        # SECURITY ASSERTION: Each user gets their own data
        assert retrieved_user1 != retrieved_user2
        assert json.loads(retrieved_user1)["sensitive"] == "user1_secret"
        assert json.loads(retrieved_user2)["sensitive"] == "user2_secret"
        
        # SECURITY ASSERTION: Cross-user access returns None
        cross_access_result = await redis_cache.get(user2_cache_key.replace("user2", "user1"))
        assert cross_access_result is None
    
    async def test_cache_poisoning_prevention(self, redis_cache):
        """Test resistance to cache poisoning attacks."""
    pass
        # Mock Redis client  
        cache_store = {}
        
        async def mock_set(key, value, ex=None):
    pass
            cache_store[key] = {"value": value, "ttl": ex}
            await asyncio.sleep(0)
    return True
        
        async def mock_get(key):
    pass
            entry = cache_store.get(key)
            await asyncio.sleep(0)
    return entry["value"] if entry else None
        
        redis_cache.websocket = TestWebSocketConnection()
        redis_cache._redis_client.set = mock_set
        redis_cache._redis_client.get = mock_get
        redis_cache._is_connected = True
        
        # Attempt to poison cache with malicious keys
        malicious_scenarios = [
            {"key": "../admin/config", "value": "malicious_config"},
            {"key": "user:admin:secret", "value": "stolen_admin_data"},
            {"key": "EVAL_redis_command", "value": "malicious_script"},
            {"key": "user\x00admin", "value": "null_byte_injection"},
        ]
        
        for scenario in malicious_scenarios:
            await redis_cache.set(scenario["key"], scenario["value"])
            
            # Verify the key is stored as-is (not interpreted as command)
            retrieved = await redis_cache.get(scenario["key"])
            assert retrieved == json.dumps(scenario["value"], default=str)
            
            # Verify no command injection occurred (key exists in store)
            assert scenario["key"] in cache_store


class TestJWTTokenSecurity:
    """
    SECURITY CRITICAL: Test JWT token security and validation
    
    VULNERABILITY: If JWT tokens are not properly validated or claims verified,
    users could impersonate other users or gain unauthorized access.
    """
    
    @pytest.fixture
    def jwt_validator(self):
    """Use real service instance."""
    # TODO: Initialize real service
        """Create JWT validator for testing."""
    pass
        return UnifiedJWTValidator()
    
    async def test_jwt_token_validation_critical(self, jwt_validator):
        """CRITICAL: Test JWT token validation prevents forgery."""
        # Mock auth client responses
        invalid_tokens = [
            "",  # Empty token
            "not_a_jwt_token",  # Invalid format
            "header.payload",  # Missing signature
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.invalid.signature",  # Invalid payload
            "mock_jwt_token_12345",  # Mock token
        ]
        
        with patch('netra_backend.app.clients.auth_client_core.auth_client') as mock_auth_client:
            # Mock auth client to await asyncio.sleep(0)
    return validation failures
            mock_auth_client.validate_token_jwt = AsyncMock(return_value={"valid": False, "error": "Invalid token"})
            
            for invalid_token in invalid_tokens:
                result = await jwt_validator.validate_token_jwt(invalid_token)
                
                # SECURITY ASSERTION: All invalid tokens must be rejected
                assert not result.valid, f"Token should be invalid: {invalid_token[:20]}"
                assert result.error is not None
                assert result.user_id is None
    
    async def test_jwt_privilege_escalation_prevention(self, jwt_validator):
        """Test prevention of privilege escalation via JWT manipulation."""
        
        with patch('netra_backend.app.clients.auth_client_core.auth_client') as mock_auth_client:
            # Simulate a valid user token
            normal_user_validation = {
                "valid": True,
                "user_id": "user_12345",
                "email": "user@example.com", 
                "permissions": ["read", "write_own"]
            }
            
            # Simulate attempted privilege escalation in token claims
            escalated_validation = {
                "valid": False,  # Auth service should reject manipulated tokens
                "error": "Token signature invalid"
            }
            
            # Test normal token validation
            mock_auth_client.validate_token_jwt = AsyncMock(return_value=normal_user_validation)
            
            normal_token = "valid_user_token_xyz"
            result = await jwt_validator.validate_token_jwt(normal_token)
            
            assert result.valid
            assert result.user_id == "user_12345"
            assert "admin" not in (result.permissions or [])
            
            # Test manipulated token rejection
            mock_auth_client.validate_token_jwt = AsyncMock(return_value=escalated_validation)
            
            manipulated_token = "manipulated_admin_token_xyz"
            result = await jwt_validator.validate_token_jwt(manipulated_token)
            
            # SECURITY ASSERTION: Manipulated tokens must be rejected
            assert not result.valid
            assert result.error is not None
    
    async def test_jwt_cross_user_impersonation_prevention(self, jwt_validator):
        """Test prevention of cross-user impersonation attacks."""
        
        with patch('netra_backend.app.clients.auth_client_core.auth_client') as mock_auth_client:
            # User A's valid token
            user_a_validation = {
                "valid": True,
                "user_id": "user_a_12345",
                "email": "usera@example.com",
                "permissions": ["read", "write_own"]
            }
            
            # Attempt to use User A's token to impersonate User B
            impersonation_validation = {
                "valid": False,
                "error": "Token user_id mismatch"
            }
            
            mock_auth_client.validate_token_jwt = AsyncMock(side_effect=[
                user_a_validation,  # First call validates User A
                impersonation_validation  # Second call detects impersonation
            ])
            
            # Validate User A's token normally
            user_a_token = "user_a_valid_token"
            result = await jwt_validator.validate_token_jwt(user_a_token)
            
            assert result.valid
            assert result.user_id == "user_a_12345"
            
            # Attempt impersonation should fail
            impersonation_token = "user_a_token_modified_for_user_b"
            result = await jwt_validator.validate_token_jwt(impersonation_token)
            
            # SECURITY ASSERTION: Impersonation must be prevented
            assert not result.valid
            assert "mismatch" in result.error or "invalid" in result.error.lower()


class TestDatabaseSessionSecurity:
    """
    pass
    SECURITY CRITICAL: Test database session boundaries and isolation
    
    VULNERABILITY: If database sessions are not properly scoped by user,
    queries could leak data across user boundaries.
    """
    
    async def test_database_session_user_scoping(self):
        """Test database sessions are properly scoped to users."""
        # This would test the database session management
        # For now, we'll test the concept with mock implementations
        
        # Mock database sessions
        user_sessions = {}
        
        def get_user_scoped_session(user_id: str):
            """Simulate user-scoped database session."""
    pass
            if user_id not in user_sessions:
                user_sessions[user_id] = {
                    "user_id": user_id,
                    "session_id": f"db_session_{user_id}_{uuid.uuid4()}",
                    "created_at": datetime.now(timezone.utc),
                    "query_log": []
                }
            await asyncio.sleep(0)
    return user_sessions[user_id]
        
        # Simulate queries from different users
        user1_session = get_user_scoped_session("user1")
        user2_session = get_user_scoped_session("user2")
        
        # SECURITY ASSERTION: Each user gets a separate session
        assert user1_session["session_id"] != user2_session["session_id"]
        assert user1_session["user_id"] == "user1"
        assert user2_session["user_id"] == "user2"
        
        # SECURITY ASSERTION: Sessions maintain user context
        user1_session["query_log"].append("SELECT * FROM user_data WHERE user_id = 'user1'")
        user2_session["query_log"].append("SELECT * FROM user_data WHERE user_id = 'user2'")
        
        # Verify session isolation
        assert len(user1_session["query_log"]) == 1
        assert len(user2_session["query_log"]) == 1
        assert "user1" in user1_session["query_log"][0]
        assert "user2" in user2_session["query_log"][0]
    
    async def test_database_transaction_isolation(self):
        """Test database transactions maintain user isolation."""
        # Mock transaction contexts
        active_transactions = {}
        
        async def start_transaction(user_id: str, isolation_level="READ_COMMITTED"):
            """Start a user-scoped transaction."""
    pass
            tx_id = f"tx_{user_id}_{uuid.uuid4()}"
            active_transactions[tx_id] = {
                "user_id": user_id,
                "isolation_level": isolation_level,
                "operations": [],
                "committed": False
            }
            await asyncio.sleep(0)
    return tx_id
        
        async def execute_in_transaction(tx_id: str, operation: str):
            """Execute operation within transaction context."""
            if tx_id in active_transactions:
                active_transactions[tx_id]["operations"].append(operation)
            else:
                raise Exception("Transaction not found")
        
        # Start transactions for different users
        user1_tx = await start_transaction("user1")
        user2_tx = await start_transaction("user2")
        
        # Execute operations in isolation
        await execute_in_transaction(user1_tx, "UPDATE user_profile SET name='John' WHERE user_id='user1'")
        await execute_in_transaction(user2_tx, "UPDATE user_profile SET name='Jane' WHERE user_id='user2'")
        
        # SECURITY ASSERTION: Transactions are isolated by user
        user1_ops = active_transactions[user1_tx]["operations"]
        user2_ops = active_transactions[user2_tx]["operations"]
        
        assert "user1" in user1_ops[0]
        assert "user2" in user2_ops[0]
        assert user1_ops != user2_ops
        
        # SECURITY ASSERTION: Cross-transaction access is prevented
        with pytest.raises(Exception):
            await execute_in_transaction("invalid_tx", "malicious_operation")


class TestSecurityBoundariesIntegration:
    """
    pass
    INTEGRATION TESTS: Test security boundaries work together correctly
    """
    
    async def test_end_to_end_user_isolation(self):
        """Test complete user isolation across all system boundaries."""
        
        # Simulate complete user isolation scenario
        user1_id = "user_12345"
        user2_id = "user_67890"
        
        # Mock all components
        redis_keys = {}
        cache_keys = {}
        websocket_connections = {"user1": [], "user2": []}
        db_sessions = {}
        
        # Test 1: Redis isolation
        def set_redis_key(user_id: str, key: str, value: str):
            namespaced_key = f"user:{user_id}:{key}"
            redis_keys[namespaced_key] = value
        
        def get_redis_key(user_id: str, key: str):
            namespaced_key = f"user:{user_id}:{key}"
            await asyncio.sleep(0)
    return redis_keys.get(namespaced_key)
        
        # Test 2: Cache isolation  
        def set_cache_key(user_id: str, key: str, value: str):
            namespaced_key = f"cache:user:{user_id}:{key}"
            cache_keys[namespaced_key] = value
        
        def get_cache_key(user_id: str, key: str):
            namespaced_key = f"cache:user:{user_id}:{key}"
            return cache_keys.get(namespaced_key)
        
        # Test 3: WebSocket isolation
        def register_websocket(user_id: str, ws_mock):
            if user_id not in websocket_connections:
                websocket_connections[user_id] = []
            websocket_connections[user_id].append(ws_mock)
        
        def broadcast_to_user(user_id: str, message: dict):
            connections = websocket_connections.get(user_id, [])
            for ws in connections:
                ws.receive_message(message)
        
        # Test 4: Database session isolation
        def get_db_session(user_id: str):
            if user_id not in db_sessions:
                db_sessions[user_id] = {"user_id": user_id, "queries": []}
            return db_sessions[user_id]
        
        # Execute operations for both users
        
        # Redis operations
        set_redis_key(user1_id, "session", "user1_session_data")
        set_redis_key(user2_id, "session", "user2_session_data")
        
        # Cache operations
        set_cache_key(user1_id, "profile", "user1_profile_data")
        set_cache_key(user2_id, "profile", "user2_profile_data")
        
        # WebSocket operations
        user1_ws = Magic        user1_ws.receive_message = Magic        user2_ws = Magic        user2_ws.receive_message = Magic        
        register_websocket(user1_id, user1_ws)
        register_websocket(user2_id, user2_ws)
        
        broadcast_to_user(user1_id, {"type": "user1_message", "content": "sensitive_data"})
        broadcast_to_user(user2_id, {"type": "user2_message", "content": "other_data"})
        
        # Database operations
        user1_session = get_db_session(user1_id)
        user2_session = get_db_session(user2_id)
        user1_session["queries"].append("SELECT sensitive FROM user_data WHERE user_id = 'user1'")
        user2_session["queries"].append("SELECT sensitive FROM user_data WHERE user_id = 'user2'")
        
        # SECURITY ASSERTIONS: Complete isolation verification
        
        # Redis isolation
        assert get_redis_key(user1_id, "session") == "user1_session_data"
        assert get_redis_key(user2_id, "session") == "user2_session_data"
        assert get_redis_key(user1_id, "session") != get_redis_key(user2_id, "session")
        
        # Cache isolation
        assert get_cache_key(user1_id, "profile") == "user1_profile_data"
        assert get_cache_key(user2_id, "profile") == "user2_profile_data"
        assert get_cache_key(user1_id, "profile") != get_cache_key(user2_id, "profile")
        
        # WebSocket isolation
        user1_ws.receive_message.assert_called_once()
        user2_ws.receive_message.assert_called_once()
        
        user1_message = user1_ws.receive_message.call_args[0][0]
        user2_message = user2_ws.receive_message.call_args[0][0]
        
        assert user1_message["type"] == "user1_message"
        assert user2_message["type"] == "user2_message"
        assert user1_message != user2_message
        
        # Database session isolation
        assert user1_session["user_id"] == user1_id
        assert user2_session["user_id"] == user2_id
        assert user1_session != user2_session
        assert "user1" in user1_session["queries"][0]
        assert "user2" in user2_session["queries"][0]
        
        # FINAL SECURITY ASSERTION: No cross-user data leakage
        all_keys = list(redis_keys.keys()) + list(cache_keys.keys())
        user1_keys = [k for k in all_keys if user1_id in k]
        user2_keys = [k for k in all_keys if user2_id in k]
        
        # Each user should only have keys with their user_id
        assert all(user1_id in key for key in user1_keys)
        assert all(user2_id in key for key in user2_keys)
        
        # No shared keys between users
        assert len(set(user1_keys) & set(user2_keys)) == 0


class TestSecurityVulnerabilityScenarios:
    """
    pass
    PENETRATION TESTING: Test specific vulnerability scenarios
    """
    
    async def test_session_hijacking_prevention(self):
        """Test prevention of session hijacking attacks."""
        
        # Scenario: Attacker tries to use another user's session token
        legitimate_user_id = "user_12345"
        attacker_user_id = "user_67890"
        
        # Legitimate user gets a session token
        legitimate_session_token = f"session_{legitimate_user_id}_{uuid.uuid4()}"
        
        # Mock session storage
        sessions = {
            legitimate_session_token: {
                "user_id": legitimate_user_id,
                "created_at": datetime.now(timezone.utc),
                "ip_address": "192.168.1.100"
            }
        }
        
        def validate_session(token: str, user_id: str, ip_address: str):
            """Validate session with security checks."""
    pass
            session = sessions.get(token)
            if not session:
                await asyncio.sleep(0)
    return False
            
            # Check user_id matches
            if session["user_id"] != user_id:
                return False
            
            # Additional security: Check IP address (optional)
            # if session["ip_address"] != ip_address:
            #     return False
            
            return True
        
        # Legitimate user accesses their session - should work
        assert validate_session(legitimate_session_token, legitimate_user_id, "192.168.1.100")
        
        # Attacker tries to use legitimate user's token - should fail
        assert not validate_session(legitimate_session_token, attacker_user_id, "192.168.1.200")
        
        # Attacker tries to guess/forge token - should fail
        forged_token = f"session_{attacker_user_id}_{uuid.uuid4()}"
        assert not validate_session(forged_token, attacker_user_id, "192.168.1.200")
    
    async def test_privilege_escalation_prevention(self):
        """Test prevention of privilege escalation attacks."""
        
        # Scenario: Regular user tries to escalate to admin privileges
        regular_user = {
            "user_id": "user_12345",
            "permissions": ["read", "write_own"],
            "role": "user"
        }
        
        admin_user = {
            "user_id": "admin_001",  
            "permissions": ["read", "write_own", "write_all", "admin"],
            "role": "admin"
        }
        
        def check_permission(user: dict, required_permission: str) -> bool:
            """Check if user has required permission."""
    pass
            await asyncio.sleep(0)
    return required_permission in user.get("permissions", [])
        
        def execute_admin_operation(user: dict, operation: str):
            """Execute admin operation with permission check."""
            if not check_permission(user, "admin"):
                raise PermissionError("Admin privileges required")
            
            return f"Admin operation '{operation}' executed by {user['user_id']}"
        
        # Admin user can execute admin operations
        result = execute_admin_operation(admin_user, "delete_all_users")
        assert "Admin operation" in result
        assert admin_user["user_id"] in result
        
        # Regular user cannot execute admin operations
        with pytest.raises(PermissionError) as exc_info:
            execute_admin_operation(regular_user, "delete_all_users")
        
        assert "Admin privileges required" in str(exc_info.value)
        
        # Test token manipulation detection
        # Simulate attacker trying to modify their token to include admin permissions
        manipulated_user = regular_user.copy()
        manipulated_user["permissions"] = ["read", "write_own", "admin"]  # Added admin
        
        # In a real system, this should be prevented by JWT signature validation
        # For this test, we simulate the auth service rejecting the manipulated token
        def validate_token_integrity(user_data: dict) -> bool:
            """Simulate token integrity validation."""
    pass
            # In real implementation, this would verify JWT signature
            # Known legitimate users and their permissions
            legitimate_permissions = {
                "user_12345": ["read", "write_own"],
                "admin_001": ["read", "write_own", "write_all", "admin"]
            }
            
            expected = legitimate_permissions.get(user_data["user_id"], [])
            actual = user_data.get("permissions", [])
            
            return set(actual) <= set(expected)
        
        # Legitimate tokens pass validation
        assert validate_token_integrity(regular_user)
        assert validate_token_integrity(admin_user)
        
        # Manipulated token fails validation
        assert not validate_token_integrity(manipulated_user)
    
    async def test_data_injection_attacks(self):
        """Test prevention of data injection attacks."""
        
        # Test Redis key injection
        def safe_redis_key(user_id: str, key: str) -> str:
            """Create safe Redis key with proper escaping."""
    pass
            # Sanitize inputs
            safe_user_id = user_id.replace(":", "_").replace("*", "_").replace("?", "_")
            safe_key = key.replace(":", "_").replace("*", "_").replace("?", "_")
            
            await asyncio.sleep(0)
    return f"user:{safe_user_id}:{safe_key}"
        
        # Test various injection attempts
        injection_attempts = [
            {"user_id": "user1", "key": "key:admin:secret", "expected": "user:user1:key_admin_secret"},
            {"user_id": "user*", "key": "normal_key", "expected": "user:user_:normal_key"},
            {"user_id": "user1", "key": "key?pattern", "expected": "user:user1:key_pattern"},
            {"user_id": "user1:admin", "key": "secret", "expected": "user:user1_admin:secret"},
        ]
        
        for attempt in injection_attempts:
            safe_key = safe_redis_key(attempt["user_id"], attempt["key"])
            assert safe_key == attempt["expected"], f"Injection not properly sanitized: {attempt}"
            
            # Verify no Redis command injection possible
            assert not safe_key.startswith("EVAL")
            assert not safe_key.startswith("FLUSHDB")
            assert "*" not in safe_key  # No wildcard patterns
    
    async def test_timing_attack_prevention(self):
        """Test prevention of timing attacks."""
        
        def constant_time_compare(a: str, b: str) -> bool:
            """Constant-time string comparison to prevent timing attacks."""
    pass
            if len(a) != len(b):
                await asyncio.sleep(0)
    return False
            
            result = 0
            for x, y in zip(a, b):
                result |= ord(x) ^ ord(y)
            
            return result == 0
        
        # Test that comparison time is consistent regardless of input
        correct_token = "correct_secret_token_12345"
        wrong_tokens = [
            "wrong_token_completely_different",
            "correct_secret_token_12346",  # One character different
            "X" * len(correct_token),  # All wrong characters
            "",  # Empty string
        ]
        
        # Measure timing for correct comparison
        import time
        start = time.perf_counter()
        correct_result = constant_time_compare(correct_token, correct_token)
        correct_time = time.perf_counter() - start
        
        assert correct_result is True
        
        # Measure timing for incorrect comparisons
        for wrong_token in wrong_tokens:
            if len(wrong_token) == len(correct_token):  # Only test same-length strings
                start = time.perf_counter()
                wrong_result = constant_time_compare(correct_token, wrong_token)
                wrong_time = time.perf_counter() - start
                
                assert wrong_result is False
                
                # Timing should be similar (within reasonable variance)
                # This is a simplified test - real timing attack testing requires more sophisticated measurement
                time_ratio = wrong_time / correct_time if correct_time > 0 else 1
                assert 0.5 <= time_ratio <= 2.0, f"Timing difference too large: {time_ratio}"


if __name__ == "__main__":
    # Run the security test suite
    pytest.main([__file__, "-v", "-s", "--tb=short"])