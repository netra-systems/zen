"""
Test module split from original file
Generated by auto_fix_test_violations.py
"""

import pytest
import asyncio
import json
import time
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from typing import Dict, Any, List
from uuid import uuid4
from fastapi.testclient import TestClient
from fastapi import WebSocket
from starlette.websockets import WebSocketDisconnect
from app.routes.example_messages_enhanced import (
    router, MessageSequencer, ConnectionStateManager, 
    message_sequencer, connection_manager, agent_circuit_breaker
)
from app.handlers.example_message_handler_enhanced import (
    EnhancedExampleMessageHandler, SessionManager, RealAgentIntegration,
    ExampleMessageRequest, ExampleMessageResponse, ExampleMessageMetadata
)
from app.core.circuit_breaker import CircuitBreaker
from app.logging_config import central_logger
import sys
from app.routes.example_messages_enhanced import example_message_websocket_enhanced

class TestDataValidationAndSecurity:
    """Test Category 10: Data Validation and Security"""

    def test_input_validation_comprehensive(self):
        """Test comprehensive input validation"""
        
        # Test valid message
        valid_message = {
            "content": "Valid optimization request with sufficient length",
            "example_message_id": "valid_id",
            "example_message_metadata": {
                "title": "Valid Title",
                "category": "cost-optimization",
                "complexity": "basic", 
                "businessValue": "conversion",
                "estimatedTime": "30s"
            },
            "user_id": "valid_user",
            "timestamp": int(time.time() * 1000)
        }
        
        # Should validate successfully
        request = ExampleMessageRequest(**valid_message)
        assert request.content == valid_message["content"]

    def test_input_sanitization(self):
        """Test input sanitization and security"""
        
        # Test with potentially malicious input
        malicious_content = "<script>alert('xss')</script>" + "a" * 100  # Make it long enough
        
        message = {
            "content": malicious_content,
            "example_message_id": "test_id",
            "example_message_metadata": {
                "title": "Test",
                "category": "cost-optimization",
                "complexity": "basic",
                "businessValue": "conversion", 
                "estimatedTime": "30s"
            },
            "user_id": "test_user",
            "timestamp": int(time.time() * 1000)
        }
        
        # Should accept content but validation should handle it appropriately
        request = ExampleMessageRequest(**message)
        assert request.content == malicious_content  # Content preserved as-is for processing

    def test_field_validation_constraints(self):
        """Test field validation constraints"""
        
        # Test category validation
        with pytest.raises(ValueError):
            ExampleMessageMetadata(
                title="Test",
                category="invalid_category",  # Invalid category
                complexity="basic",
                businessValue="conversion",
                estimatedTime="30s"
            )
        
        # Test complexity validation
        with pytest.raises(ValueError):
            ExampleMessageMetadata(
                title="Test",
                category="cost-optimization",
                complexity="invalid_complexity",  # Invalid complexity
                businessValue="conversion",
                estimatedTime="30s"
            )

    def test_user_id_validation(self):
        """Test user ID validation and session isolation"""
        
        session_manager = SessionManager()
        
        # Create sessions for different users
        user1_session = asyncio.run(session_manager.create_session("user1", "msg1", {}))
        user2_session = asyncio.run(session_manager.create_session("user2", "msg2", {}))
        
        # Users should have isolated sessions
        user1_sessions = session_manager.get_user_sessions("user1")
        user2_sessions = session_manager.get_user_sessions("user2")
        
        assert len(user1_sessions) == 1
        assert len(user2_sessions) == 1
        assert user1_sessions[0]['session_id'] != user2_sessions[0]['session_id']
