#!/usr/bin/env python3
"""
Final Staging Test Setup Solution
Comprehensive setup for running integration tests with GCP staging services.

This script provides everything needed to run integration tests without Docker:
1. Creates staging environment configuration
2. Validates staging service connectivity
3. Provides commands to run specific integration tests
4. Handles authentication and connection issues gracefully
"""

import os
import sys
import subprocess
from pathlib import Path
import argparse
import tempfile

# Add project root to path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))


class StagingTestSetup:
    """Complete staging test environment setup."""
    
    def __init__(self):
        self.project_root = project_root
        self.staging_env_file = self.project_root / ".env.staging.tests"
        
    def create_staging_env_file(self):
        """Create a staging environment file for tests."""
        print("üìù Creating staging environment configuration...")
        
        # Staging environment configuration
        staging_config = """# Staging Test Environment Configuration
# Generated by setup_staging_tests.py
# This file configures tests to use GCP staging services

# Core environment
ENVIRONMENT=staging
TEST_MODE=true
STAGING_ENV=true
USE_STAGING_SERVICES=true
DISABLE_LOCAL_DOCKER=true

# GCP Project Configuration  
GCP_PROJECT_ID=netra-staging

# Service URLs (GCP Cloud Run)
NETRA_BACKEND_URL=https://netra-backend-701982941522.us-central1.run.app
AUTH_SERVICE_URL=https://auth-service-701982941522.us-central1.run.app
FRONTEND_URL=https://frontend-701982941522.us-central1.run.app
NETRA_API_URL=https://netra-backend-701982941522.us-central1.run.app
WEBSOCKET_URL=wss://netra-backend-701982941522.us-central1.run.app/ws

# Database Configuration (Cloud SQL)
# Note: These are placeholders - actual values come from Google Secret Manager
DATABASE_URL=postgresql://staging_user:staging_password@staging-cloudsql:5432/netra_staging
POSTGRES_HOST=staging-cloudsql-host
POSTGRES_PORT=5432
POSTGRES_DB=netra_staging  
POSTGRES_USER=staging_user
POSTGRES_PASSWORD=staging_password

# Redis Configuration (Memorystore)
# Note: These are placeholders - actual values come from Google Secret Manager
REDIS_URL=redis://staging-memorystore:6379/0
REDIS_HOST=staging-memorystore-host
REDIS_PORT=6379
REDIS_PASSWORD=staging_redis_password
REDIS_MODE=production

# ClickHouse Configuration
CLICKHOUSE_HOST=xedvrr4c3r.us-central1.gcp.clickhouse.cloud
CLICKHOUSE_PORT=8443
CLICKHOUSE_USER=default
CLICKHOUSE_DB=default
CLICKHOUSE_SECURE=true
CLICKHOUSE_PASSWORD=staging_clickhouse_password

# Authentication Configuration
JWT_ALGORITHM=HS256
JWT_ACCESS_EXPIRY_MINUTES=15
JWT_REFRESH_EXPIRY_DAYS=7
AUTH_SERVICE_ENABLED=true
FORCE_HTTPS=true

# WebSocket Configuration for staging
WEBSOCKET_CONNECTION_TIMEOUT=240
WEBSOCKET_HEARTBEAT_INTERVAL=15
WEBSOCKET_HEARTBEAT_TIMEOUT=45
WEBSOCKET_CLEANUP_INTERVAL=60

# Test Configuration
BYPASS_STARTUP_VALIDATION=true
SKIP_DOCKER_HEALTH_CHECKS=true
INTEGRATION_TEST_MODE=staging

# Development overrides disabled
DISABLE_LOCAL_ENV_OVERRIDE=true
"""
        
        with open(self.staging_env_file, 'w') as f:
            f.write(staging_config)
        
        print(f"‚úÖ Created staging environment file: {self.staging_env_file}")
        return self.staging_env_file
    
    def load_staging_environment(self):
        """Load staging environment variables."""
        if not self.staging_env_file.exists():
            self.create_staging_env_file()
        
        print("üîß Loading staging environment variables...")
        
        # Read the staging env file and set environment variables
        with open(self.staging_env_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key] = value
                    if 'PASSWORD' in key or 'SECRET' in key:
                        print(f"‚úÖ {key} = [REDACTED]")
                    else:
                        print(f"‚úÖ {key} = {value}")
        
        print("üéØ Staging environment loaded successfully")
    
    def validate_staging_readiness(self):
        """Validate that staging environment is ready for testing."""
        print("\nüîç Validating staging test readiness...")
        
        issues = []
        warnings = []
        
        # Check critical environment variables
        critical_vars = [
            'ENVIRONMENT',
            'NETRA_BACKEND_URL',
            'AUTH_SERVICE_URL', 
            'DATABASE_URL',
            'REDIS_URL',
            'USE_STAGING_SERVICES'
        ]
        
        for var in critical_vars:
            value = os.environ.get(var)
            if not value:
                issues.append(f"Missing environment variable: {var}")
            elif var == 'ENVIRONMENT' and value != 'staging':
                issues.append(f"ENVIRONMENT should be 'staging', got: {value}")
            elif 'localhost' in value:
                warnings.append(f"{var} contains 'localhost' - should use staging services")
        
        # Check gcloud availability
        try:
            result = subprocess.run(['gcloud', 'version'], capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                warnings.append("gcloud CLI not available - may affect staging service access")
        except:
            warnings.append("gcloud CLI not found - staging services may not be accessible")
        
        # Report validation results
        if issues:
            print("‚ùå Critical issues found:")
            for issue in issues:
                print(f"   - {issue}")
            return False
        
        if warnings:
            print("‚ö†Ô∏è  Warnings (non-critical):")
            for warning in warnings:
                print(f"   - {warning}")
        
        print("‚úÖ Staging environment validation passed")
        return True
    
    def show_test_commands(self):
        """Show available test commands for staging."""
        print("\nüìã Available Staging Test Commands")
        print("=" * 50)
        
        commands = [
            {
                'name': 'Basic Integration Tests',
                'command': f'PYTHONPATH={self.project_root} python3 -m pytest tests/integration/ -v -x --tb=short',
                'description': 'Run basic integration tests with staging services'
            },
            {
                'name': 'WebSocket Tests',
                'command': f'PYTHONPATH={self.project_root} python3 -m pytest tests/ -k "websocket" -v -x --tb=short',
                'description': 'Run WebSocket-related tests with staging services'
            },
            {
                'name': 'Auth Tests',
                'command': f'PYTHONPATH={self.project_root} python3 -m pytest tests/ -k "auth" -v -x --tb=short',
                'description': 'Run authentication tests with staging services'
            },
            {
                'name': 'Unified Test Runner',
                'command': f'PYTHONPATH={self.project_root} python3 tests/unified_test_runner.py --real-services --env staging --category integration',
                'description': 'Use the unified test runner with staging environment'
            },
            {
                'name': 'Single Test File',
                'command': f'PYTHONPATH={self.project_root} python3 -m pytest [TEST_FILE_PATH] -v --tb=short',
                'description': 'Run a specific test file (replace [TEST_FILE_PATH] with actual path)'
            }
        ]
        
        for i, cmd in enumerate(commands, 1):
            print(f"{i}. {cmd['name']}")
            print(f"   Description: {cmd['description']}")
            print(f"   Command: {cmd['command']}")
            print()
        
        print("üí° Tips:")
        print(f"   - Ensure the staging env file is loaded: source {self.staging_env_file}")
        print("   - Add --maxfail=1 to stop on first failure")
        print("   - Add -s to see print statements")
        print("   - Use -k 'pattern' to filter tests by pattern")
    
    def run_simple_test(self):
        """Run a simple test to verify staging connectivity."""
        print("\nüß™ Running Simple Staging Connectivity Test...")
        
        test_script = f"""
import os
import sys
sys.path.insert(0, "{self.project_root}")

# Test basic imports
try:
    from shared.isolated_environment import IsolatedEnvironment
    print("‚úÖ IsolatedEnvironment imported")
except Exception as e:
    print(f"‚ùå IsolatedEnvironment import failed: {{e}}")
    sys.exit(1)

# Test environment
env = IsolatedEnvironment()
print(f"üìç Environment: {{env.get('ENVIRONMENT', 'not_set')}}")
print(f"üîó Backend URL: {{env.get('NETRA_BACKEND_URL', 'not_set')}}")
print(f"üîÑ Redis URL: {{env.get('REDIS_URL', 'not_set')[:50]}}...")

print("‚úÖ Simple staging test completed successfully")
"""
        
        # Write test to temporary file and execute
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as tmp:
            tmp.write(test_script)
            tmp_path = tmp.name
        
        try:
            result = subprocess.run([
                sys.executable, tmp_path
            ], env=os.environ.copy(), cwd=self.project_root, capture_output=True, text=True)
            
            print("Test Output:")
            print(result.stdout)
            if result.stderr:
                print("Errors:")
                print(result.stderr)
            
            return result.returncode == 0
        finally:
            os.unlink(tmp_path)
    
    def cleanup_staging_env(self):
        """Clean up staging environment file."""
        if self.staging_env_file.exists():
            self.staging_env_file.unlink()
            print(f"üóëÔ∏è  Cleaned up staging environment file: {self.staging_env_file}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Setup staging environment for integration tests")
    parser.add_argument('--setup-only', action='store_true', 
                       help='Only create staging environment file')
    parser.add_argument('--test', action='store_true',
                       help='Run simple connectivity test')  
    parser.add_argument('--cleanup', action='store_true',
                       help='Clean up staging environment file')
    parser.add_argument('--show-commands', action='store_true',
                       help='Show available test commands')
    
    args = parser.parse_args()
    
    setup = StagingTestSetup()
    
    try:
        if args.cleanup:
            setup.cleanup_staging_env()
            return
        
        if args.setup_only:
            setup.create_staging_env_file()
            print(f"‚úÖ Staging environment file created: {setup.staging_env_file}")
            print(f"üí° To use: export $(cat {setup.staging_env_file} | grep -v '^#' | xargs)")
            return
        
        # Full setup by default
        setup.create_staging_env_file()
        setup.load_staging_environment()
        
        is_ready = setup.validate_staging_readiness()
        
        if args.test:
            if is_ready:
                test_passed = setup.run_simple_test()
                if test_passed:
                    print("‚úÖ Staging connectivity test passed")
                else:
                    print("‚ùå Staging connectivity test failed")
            else:
                print("‚è≠Ô∏è  Skipping connectivity test due to validation issues")
        
        if args.show_commands or not args.test:
            setup.show_test_commands()
        
        print("\nüéâ Staging test environment setup complete!")
        print("üí° Your integration tests can now run with GCP staging services")
        print("üîê Database and Redis connections will use staging credentials")
        print("üì° Service URLs point to GCP Cloud Run staging deployments")
        
    except KeyboardInterrupt:
        print("\n‚è∏Ô∏è  Setup interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Setup failed: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()