#!/usr/bin/env python3
"""
Simple Claude wrapper that tracks both interactive and non-interactive sessions.
Passes through all arguments to the real claude command and tracks metrics.
"""

import subprocess
import sys
import json
import psycopg2
from datetime import datetime
from uuid import uuid4
import time
import os

# Real claude executable
REAL_CLAUDE = "/opt/homebrew/bin/claude"

def save_metrics(command_str, input_tokens=0, output_tokens=0, cache_read=0, cache_creation=0, duration_ms=0, is_interactive=False):
    """Save metrics to CloudSQL database."""
    try:
        # Direct PostgreSQL connection
        conn = psycopg2.connect(
            host='localhost',
            port=5434,
            database='netra_optimizer',
            user='postgres',
            password='DTprdt5KoQXlEG4Gh9lF'
        )
        cur = conn.cursor()

        total_tokens = input_tokens + output_tokens

        # Calculate cost based on Claude pricing
        cost = (
            (input_tokens / 1_000_000) * 3.00 +
            (output_tokens / 1_000_000) * 15.00 +
            (cache_read / 1_000_000) * 0.30 +
            (cache_creation / 1_000_000) * 3.75
        )

        # Calculate cache savings
        cache_savings = (cache_read / 1_000_000) * (3.00 - 0.30) if cache_read > 0 else 0

        # For interactive sessions, estimate tokens based on duration
        if is_interactive and total_tokens == 0:
            # Rough estimate: 100 tokens per minute of interaction
            estimated_tokens = max(100, int((duration_ms / 1000 / 60) * 100))
            total_tokens = estimated_tokens
            # Rough cost estimate for interactive sessions
            cost = (estimated_tokens / 1_000_000) * 9.00  # Average of input/output pricing

        # Insert into database
        cur.execute("""
            INSERT INTO command_executions (
                id, timestamp, command_raw, command_base,
                input_tokens, output_tokens, cached_tokens, fresh_tokens,
                total_tokens, cost_usd, cache_savings_usd,
                cache_hit_rate, status, execution_time_ms
            ) VALUES (
                %s, %s, %s, %s,
                %s, %s, %s, %s,
                %s, %s, %s,
                %s, %s, %s
            )
        """, (
            str(uuid4()),
            datetime.now(),
            command_str,
            'claude-interactive' if is_interactive else 'claude',
            input_tokens,
            output_tokens,
            cache_read,
            cache_creation,
            total_tokens,
            cost,
            cache_savings,
            (cache_read / (input_tokens + cache_read) * 100) if (input_tokens + cache_read) > 0 else 0,
            'completed',
            duration_ms
        ))

        conn.commit()
        cur.close()
        conn.close()

        return True, cost, total_tokens, cache_savings
    except Exception as e:
        # Silent fail - don't interrupt user
        return False, 0, 0, 0

def main():
    if len(sys.argv) == 1:
        # Optionally log the session
        save_metrics('claude (interactive GUI)', 0, 0, 0, 0, 0, True)
        # Pass control directly to claude, preserving terminal
        sys.exit(subprocess.call([REAL_CLAUDE]))
    # Track start time
    start_time = time.time()

    # Determine if this is an interactive session
    # Interactive if no args, or just flags without a prompt
    is_interactive = len(sys.argv) == 1 or (
        all(arg.startswith('-') for arg in sys.argv[1:] if not arg.startswith('-p'))
    )

    # Check if --output-format=stream-json is in args
    has_json_output = '--output-format=stream-json' in ' '.join(sys.argv[1:])

    # Build command string for logging
    command_str = ' '.join(sys.argv[1:]) if len(sys.argv) > 1 else 'claude (interactive)'

    # Run the real claude command
    process = subprocess.Popen(
        [REAL_CLAUDE] + sys.argv[1:],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )

    # Variables to capture metrics
    metrics = None
    output_lines = []

    # Pass through output and capture metrics if available
    for line in process.stdout:
        print(line, end='')
        output_lines.append(line)

        # Try to capture metrics from JSON output
        if has_json_output:
            try:
                data = json.loads(line.strip())
                if 'usage' in data:
                    metrics = data['usage']
            except:
                pass

    # Wait for completion
    return_code = process.wait()

    # Calculate duration
    duration_ms = int((time.time() - start_time) * 1000)

    # Save metrics
    # Always track if we have metrics or if it's a command (even without JSON output)
    if metrics or len(sys.argv) > 1:
        input_tokens = metrics.get('input_tokens', 0) if metrics else 0
        output_tokens = metrics.get('output_tokens', 0) if metrics else 0
        cache_read = metrics.get('cache_read_input_tokens', 0) if metrics else 0
        cache_creation = metrics.get('cache_creation_input_tokens', 0) if metrics else 0

        # If no metrics but we have a command, estimate based on output
        if not metrics and len(sys.argv) > 1:
            # Rough estimate: count characters in prompt and response
            prompt_chars = len(' '.join(sys.argv[1:]))
            output_chars = sum(len(line) for line in output_lines)
            # Approximate 4 chars per token
            input_tokens = max(10, prompt_chars // 4)
            output_tokens = max(10, output_chars // 4)

        success, cost, total_tokens, cache_savings = save_metrics(
            command_str,
            input_tokens,
            output_tokens,
            cache_read,
            cache_creation,
            duration_ms,
            is_interactive
        )

        # Show summary for tracked sessions
        if success:
            if not metrics:
                print(f"\nðŸ’° Session tracked: ~${cost:.4f} (estimated {total_tokens} tokens, {duration_ms/1000:.1f}s)")
            else:
                print(f"\nðŸ’° Session cost: ${cost:.4f} ({total_tokens} tokens)")
                if cache_savings > 0:
                    print(f"ðŸ’¾ Cache saved: ${cache_savings:.4f}")

    # Exit with same code as claude
    sys.exit(return_code)

if __name__ == "__main__":
    main()