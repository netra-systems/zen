#!/usr/bin/env python3
"""
DeepAgentState Vulnerability Test Runner - Issue #271

CRITICAL SECURITY VULNERABILITY TEST EXECUTION

This script runs comprehensive tests to reproduce the DeepAgentState user isolation
vulnerability. Tests are designed to FAIL initially, proving the vulnerability exists,
and PASS after migration to UserExecutionContext, proving the fix works.

Usage:
    python run_deepagentstate_vulnerability_tests.py
    python run_deepagentstate_vulnerability_tests.py --category unit
    python run_deepagentstate_vulnerability_tests.py --category integration  
    python run_deepagentstate_vulnerability_tests.py --category security
    python run_deepagentstate_vulnerability_tests.py --verbose
"""

import subprocess
import sys
import os
import argparse
from pathlib import Path
from typing import List, Dict, Any
import time
from datetime import datetime


class VulnerabilityTestRunner:
    """Test runner for DeepAgentState vulnerability reproduction."""
    
    def __init__(self):
        self.project_root = Path(__file__).parent
        self.test_files = {
            "unit": "tests/unit/test_deepagentstate_user_isolation_vulnerability.py",
            "integration": "tests/integration/test_deepagentstate_e2e_isolation_vulnerability.py", 
            "security": "tests/security/test_deepagentstate_cross_contamination_patterns.py"
        }
        self.results = {}
        
    def print_header(self):
        """Print test execution header."""
        print("=" * 80)
        print(" ALERT:  DEEPAGENTSTATE VULNERABILITY REPRODUCTION - Issue #271")
        print("=" * 80)
        print("")
        print("CRITICAL SECURITY TESTING:")
        print("[U+2022] These tests reproduce user isolation vulnerabilities")
        print("[U+2022] EXPECTED RESULT: ALL TESTS SHOULD FAIL (proving vulnerability exists)")
        print("[U+2022] After UserExecutionContext migration: ALL TESTS SHOULD PASS")
        print("")
        print(f"Test Execution Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)
        print("")
    
    def print_footer(self):
        """Print test execution summary."""
        print("")
        print("=" * 80)
        print(" ALERT:  VULNERABILITY REPRODUCTION SUMMARY")
        print("=" * 80)
        
        total_failed = sum(1 for result in self.results.values() if result["failed"] > 0)
        total_passed = sum(1 for result in self.results.values() if result["failed"] == 0)
        total_categories = len(self.results)
        
        print(f"Test Categories: {total_categories}")
        print(f"Categories with Failures: {total_failed}")  
        print(f"Categories without Failures: {total_passed}")
        print("")
        
        for category, result in self.results.items():
            status = "VULNERABILITY CONFIRMED [U+2713]" if result["failed"] > 0 else "PARTIALLY MITIGATED  WARNING: [U+FE0F]"
            print(f"{category.upper()}: {result['failed']} failed, {result['passed']} passed - {status}")
        
        print("")
        if total_failed == total_categories:
            print(" ALERT:  RESULT: VULNERABILITY CONFIRMED")
            print("    ->  All test categories show failures (expected for DeepAgentState)")
            print("    ->  Cross-user contamination patterns confirmed")
            print("    ->  Migration to UserExecutionContext required")
        elif total_failed > 0:
            print(" WARNING: [U+FE0F]  RESULT: PARTIAL VULNERABILITY")  
            print("    ->  Some test categories show failures") 
            print("    ->  Inconsistent user isolation behavior")
            print("    ->  Further investigation required")
        else:
            print(" PASS:  RESULT: VULNERABILITY FIXED")
            print("    ->  All tests pass (expected after UserExecutionContext migration)")
            print("    ->  User isolation working correctly")
            print("    ->  Security vulnerability resolved")
        
        print("")
        print(f"Test Execution Completed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 80)
    
    def run_test_category(self, category: str, verbose: bool = False) -> Dict[str, Any]:
        """Run tests for a specific category."""
        if category not in self.test_files:
            print(f" FAIL:  ERROR: Unknown test category '{category}'")
            print(f"Available categories: {', '.join(self.test_files.keys())}")
            return {"failed": 0, "passed": 0, "error": True}
        
        test_file = self.project_root / self.test_files[category]
        
        if not test_file.exists():
            print(f" FAIL:  ERROR: Test file not found: {test_file}")
            return {"failed": 0, "passed": 0, "error": True}
        
        print(f"[U+1F4CB] Running {category.upper()} tests: {test_file.name}")
        print("   Expected: Tests should FAIL (proving vulnerability exists)")
        print("")
        
        # Build pytest command
        cmd = [
            sys.executable, "-m", "pytest",
            str(test_file),
            "--tb=short",
            "--disable-warnings"
        ]
        
        if verbose:
            cmd.append("-v")
        
        # Execute tests
        start_time = time.time()
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_root)
            execution_time = time.time() - start_time
            
            # Parse results
            failed_count = 0
            passed_count = 0
            
            output_lines = result.stdout.split('\n')
            for line in output_lines:
                if " FAILED " in line or "FAILURES" in line:
                    # Count individual test failures
                    if "::" in line and " FAILED " in line:
                        failed_count += 1
                elif " PASSED " in line:
                    if "::" in line and " PASSED " in line:
                        passed_count += 1
            
            # Look for summary line if individual counts not found
            if failed_count == 0 and passed_count == 0:
                for line in output_lines:
                    if "failed" in line and "passed" in line:
                        # Parse summary like "2 failed, 1 passed"
                        parts = line.split()
                        for i, part in enumerate(parts):
                            if part == "failed" and i > 0:
                                try:
                                    failed_count = int(parts[i-1])
                                except:
                                    pass
                            elif part == "passed" and i > 0:
                                try:
                                    passed_count = int(parts[i-1])
                                except:
                                    pass
            
            # Display results
            total_tests = failed_count + passed_count
            if total_tests > 0:
                print(f"   Results: {failed_count} failed, {passed_count} passed ({total_tests} total)")
                if failed_count > 0:
                    print(f"   [U+2713] VULNERABILITY CONFIRMED: {failed_count} tests failed as expected")
                else:
                    print(f"    WARNING: [U+FE0F]  UNEXPECTED: All {passed_count} tests passed (vulnerability may be fixed)")
            else:
                print(f"    WARNING: [U+FE0F]  Could not parse test results")
                failed_count = 1 if result.returncode != 0 else 0
                passed_count = 0 if result.returncode != 0 else 1
            
            print(f"   Execution time: {execution_time:.2f}s")
            
            # Show detailed output if verbose or if there were errors
            if verbose or result.returncode != 0:
                print("")
                print("   [U+1F4CB] DETAILED OUTPUT:")
                print("   " + "\n   ".join(result.stdout.split('\n')[:20]))  # First 20 lines
                if result.stderr:
                    print("")
                    print("    WARNING: [U+FE0F]  STDERR:")
                    print("   " + "\n   ".join(result.stderr.split('\n')[:10]))  # First 10 lines
            
            print("")
            
            return {
                "failed": failed_count,
                "passed": passed_count,
                "execution_time": execution_time,
                "return_code": result.returncode,
                "error": False
            }
            
        except Exception as e:
            print(f"    FAIL:  ERROR executing tests: {e}")
            return {"failed": 0, "passed": 0, "error": True}
    
    def run_all_categories(self, verbose: bool = False) -> None:
        """Run all test categories."""
        categories = ["unit", "integration", "security"]
        
        for i, category in enumerate(categories):
            if i > 0:
                print("\n" + "-" * 60 + "\n")
            
            result = self.run_test_category(category, verbose)
            self.results[category] = result
            
            if result.get("error"):
                print(f" FAIL:  {category.upper()} tests failed to execute properly")
            elif result["failed"] > 0:
                print(f"[U+2713] {category.upper()} vulnerability confirmed ({result['failed']} failures)")
            else:
                print(f" WARNING: [U+FE0F]  {category.upper()} tests all passed ({result['passed']} passed)")
    
    def run_specific_category(self, category: str, verbose: bool = False) -> None:
        """Run tests for a specific category only."""
        result = self.run_test_category(category, verbose)
        self.results[category] = result
        
        if result.get("error"):
            print(f" FAIL:  {category.upper()} tests failed to execute properly")
        elif result["failed"] > 0:
            print(f"[U+2713] {category.upper()} vulnerability confirmed ({result['failed']} failures)")
        else:
            print(f" WARNING: [U+FE0F]  {category.upper()} tests all passed ({result['passed']} passed)")


def main():
    """Main test execution function."""
    parser = argparse.ArgumentParser(description="DeepAgentState Vulnerability Test Runner")
    parser.add_argument(
        "--category", 
        choices=["unit", "integration", "security"],
        help="Run tests for specific category only"
    )
    parser.add_argument(
        "--verbose", "-v",
        action="store_true",
        help="Show detailed test output"
    )
    
    args = parser.parse_args()
    
    runner = VulnerabilityTestRunner()
    runner.print_header()
    
    try:
        if args.category:
            runner.run_specific_category(args.category, args.verbose)
        else:
            runner.run_all_categories(args.verbose)
            
    except KeyboardInterrupt:
        print("\n\n FAIL:  Test execution interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n\n FAIL:  Unexpected error: {e}")
        sys.exit(1)
    
    runner.print_footer()
    
    # Exit with appropriate code
    if any(result.get("error", False) for result in runner.results.values()):
        sys.exit(2)  # Error in test execution
    elif all(result["failed"] > 0 for result in runner.results.values()):
        sys.exit(0)  # Expected result - vulnerability confirmed
    else:
        sys.exit(0)  # Vulnerability fixed or partial mitigation


if __name__ == "__main__":
    main()