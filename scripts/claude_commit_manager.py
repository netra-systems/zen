#!/usr/bin/env python3
"""
Claude Code Commit Manager - Intelligent commit message generation using Claude Code
Handles recursion prevention and intelligent bypass logic
"""

import os
import sys
import subprocess
import json
import hashlib
import tempfile
from pathlib import Path
from datetime import datetime, timedelta
from typing import Optional, Dict, List, Tuple
import shutil


class ClaudeCommitManager:
    """Manages intelligent commit message generation via Claude Code"""
    
    def __init__(self):
        self.repo_root = Path(subprocess.check_output(
            ["git", "rev-parse", "--show-toplevel"],
            text=True
        ).strip())
        self.state_file = self.repo_root / ".git" / "claude_commit_state.json"
        self.recursion_marker = self.repo_root / ".git" / "CLAUDE_COMMIT_IN_PROGRESS"
        self.bypass_patterns = [
            "BYPASS_CLAUDE",
            "EMERGENCY_FIX",
            "QUICK_FIX",
            "[skip-claude]",
            "[no-claude]",
            "WIP:",
            "TEMP:",
            "ðŸ¤– Generated with [Claude Code]"  # Already generated by Claude
        ]
        
    def is_claude_available(self) -> bool:
        """Check if Claude Code CLI is available"""
        return shutil.which("claude") is not None
    
    def check_recursion(self) -> bool:
        """Check if we're already in a Claude commit process"""
        if self.recursion_marker.exists():
            # Check if marker is stale (> 5 minutes old)
            marker_age = datetime.now() - datetime.fromtimestamp(
                self.recursion_marker.stat().st_mtime
            )
            if marker_age > timedelta(minutes=5):
                self.recursion_marker.unlink()
                return False
            return True
        return False
    
    def should_bypass(self, message: Optional[str] = None) -> Tuple[bool, str]:
        """Determine if we should bypass Claude for this commit"""
        # Check environment variable
        if os.environ.get("CLAUDE_COMMIT_BYPASS") == "1":
            return True, "Environment bypass flag set"
        
        # Check if running in CI/CD
        if any(os.environ.get(var) for var in ["CI", "GITHUB_ACTIONS", "JENKINS_HOME"]):
            return True, "Running in CI/CD environment"
        
        # Check commit message for bypass patterns
        if message:
            for pattern in self.bypass_patterns:
                if pattern.lower() in message.lower():
                    return True, f"Bypass pattern found: {pattern}"
        
        # Check if Claude is unavailable
        if not self.is_claude_available():
            return True, "Claude Code CLI not available"
        
        # Check for recursion
        if self.check_recursion():
            return True, "Already in Claude commit process (recursion prevention)"
        
        return False, ""
    
    def get_staged_changes_summary(self) -> Dict:
        """Get a summary of staged changes"""
        try:
            # Get list of staged files
            staged_files = subprocess.check_output(
                ["git", "diff", "--cached", "--name-status"],
                text=True
            ).strip().split("\n")
            
            # Get diff stats
            stats = subprocess.check_output(
                ["git", "diff", "--cached", "--stat"],
                text=True
            ).strip()
            
            # Get actual diff (limited to prevent huge context)
            diff = subprocess.check_output(
                ["git", "diff", "--cached", "--unified=2"],
                text=True
            )
            
            # Truncate diff if too large
            max_diff_size = 10000
            if len(diff) > max_diff_size:
                diff = diff[:max_diff_size] + "\n\n... [diff truncated for size]"
            
            return {
                "files": staged_files,
                "stats": stats,
                "diff": diff,
                "file_count": len([f for f in staged_files if f]),
                "timestamp": datetime.now().isoformat()
            }
        except subprocess.CalledProcessError:
            return {}
    
    def generate_commit_message(self, context: Dict) -> Optional[str]:
        """Use Claude Code to generate a commit message"""
        try:
            # Set recursion marker
            self.recursion_marker.touch()
            
            # Create a temporary file with context
            with tempfile.NamedTemporaryFile(
                mode='w',
                suffix='.md',
                delete=False,
                dir=self.repo_root
            ) as f:
                f.write("# Git Commit Context\n\n")
                f.write("## Summary of Changes\n")
                f.write(f"Files modified: {context['file_count']}\n")
                f.write("```\n")
                f.write(context['stats'])
                f.write("\n```\n\n")
                f.write("## Detailed Changes\n")
                f.write("```diff\n")
                f.write(context['diff'])
                f.write("\n```\n\n")
                f.write("## Instructions\n")
                f.write("Generate a concise, professional git commit message following these rules:\n")
                f.write("1. First line: Brief summary (50 chars or less)\n")
                f.write("2. Optional body: Detailed explanation if needed\n")
                f.write("3. Focus on WHY not just WHAT\n")
                f.write("4. Use conventional commit format if applicable (feat:, fix:, refactor:, etc.)\n")
                f.write("5. Be specific about the business value or technical improvement\n")
                f.write("6. Reference any relevant issue numbers or tickets\n")
                f.write("7. DO NOT include the Claude Code signature - it will be added automatically\n")
                temp_file = f.name
            
            # Prepare Claude command
            claude_prompt = f"""Analyze the git changes in {Path(temp_file).name} and generate a professional commit message.
Focus on the business value and technical improvements.
Output ONLY the commit message, no explanation or markdown formatting."""
            
            # Call Claude Code
            result = subprocess.run(
                ["claude", claude_prompt],
                cwd=self.repo_root,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Clean up temp file
            Path(temp_file).unlink(missing_ok=True)
            
            if result.returncode == 0 and result.stdout.strip():
                message = result.stdout.strip()
                
                # Add Claude signature if not present
                if "Claude Code" not in message:
                    message += "\n\nðŸ¤– Generated with [Claude Code](https://claude.ai/code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>"
                
                return message
            
        except subprocess.TimeoutExpired:
            print("â±ï¸ Claude Code timeout - using fallback")
        except Exception as e:
            print(f"âŒ Error calling Claude Code: {e}")
        finally:
            # Always remove recursion marker
            self.recursion_marker.unlink(missing_ok=True)
        
        return None
    
    def get_fallback_message(self, context: Dict) -> str:
        """Generate a simple fallback commit message"""
        file_count = context.get('file_count', 0)
        files = context.get('files', [])
        
        if not files:
            return "Update files"
        
        # Analyze file patterns
        added = [f for f in files if f.startswith('A')]
        modified = [f for f in files if f.startswith('M')]
        deleted = [f for f in files if f.startswith('D')]
        
        parts = []
        if added:
            parts.append(f"Add {len(added)} file{'s' if len(added) > 1 else ''}")
        if modified:
            parts.append(f"Update {len(modified)} file{'s' if len(modified) > 1 else ''}")
        if deleted:
            parts.append(f"Remove {len(deleted)} file{'s' if len(deleted) > 1 else ''}")
        
        return " and ".join(parts) if parts else "Update project files"
    
    def save_state(self, data: Dict):
        """Save state for debugging and metrics"""
        try:
            existing = {}
            if self.state_file.exists():
                with open(self.state_file, 'r') as f:
                    existing = json.load(f)
            
            # Keep only last 100 entries
            history = existing.get('history', [])
            history.append(data)
            history = history[-100:]
            
            existing['history'] = history
            existing['last_update'] = datetime.now().isoformat()
            
            with open(self.state_file, 'w') as f:
                json.dump(existing, f, indent=2)
        except Exception:
            pass  # Non-critical, ignore errors
    
    def run(self, existing_message: Optional[str] = None) -> str:
        """Main entry point for commit message generation"""
        # Check if we should bypass
        should_bypass, bypass_reason = self.should_bypass(existing_message)
        
        if should_bypass:
            print(f"â„¹ï¸ Claude commit helper bypassed: {bypass_reason}")
            return existing_message or ""
        
        # Get staged changes
        context = self.get_staged_changes_summary()
        if not context or context.get('file_count', 0) == 0:
            print("â„¹ï¸ No staged changes found")
            return existing_message or ""
        
        print("ðŸ¤– Generating commit message with Claude Code...")
        
        # Try to generate with Claude
        generated_message = self.generate_commit_message(context)
        
        # Use generated or fallback
        if generated_message:
            final_message = generated_message
            source = "claude"
        else:
            final_message = self.get_fallback_message(context)
            source = "fallback"
        
        # Save state for metrics
        self.save_state({
            "timestamp": datetime.now().isoformat(),
            "source": source,
            "file_count": context.get('file_count', 0),
            "bypassed": False,
            "message_length": len(final_message)
        })
        
        return final_message


def main():
    """CLI entry point"""
    manager = ClaudeCommitManager()
    
    # Get existing message from stdin or args
    existing_message = None
    if len(sys.argv) > 1:
        existing_message = " ".join(sys.argv[1:])
    elif not sys.stdin.isatty():
        existing_message = sys.stdin.read().strip()
    
    # Generate or enhance message
    message = manager.run(existing_message)
    
    # Output the message
    if message:
        print(message)
        return 0
    return 1


if __name__ == "__main__":
    sys.exit(main())