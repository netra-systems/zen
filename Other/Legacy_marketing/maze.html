<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Optimization Gauntlet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #0c0a1e;
            display: block;
            border-radius: 0.5rem;
            box-shadow: 0 0 20px rgba(128, 90, 213, 0.5);
            border: 1px solid rgba(128, 90, 213, 0.3);
            cursor: pointer;
        }
        .modal {
            transition: opacity 0.3s ease;
        }
        .modal-content {
            background-color: #1a1a2e;
            border: 1px solid #4a4a6a;
        }
        #tooltip {
            position: absolute;
            display: none;
            background-color: rgba(12, 10, 30, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #4a4a6a;
            pointer-events: none;
            max-width: 250px;
            font-size: 0.9rem;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        #tooltip h3 {
            font-weight: bold;
            color: #a78bfa;
            margin-bottom: 5px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="text-center mb-4 max-w-3xl">
        <h1 class="text-3xl md:text-4xl font-bold text-purple-400 mb-2">The Optimization Gauntlet</h1>
        <p class="text-gray-300 text-sm md:text-base">
            A new "Chaotic Era" dawns. The path to optimal performance is not a straight line. Hover over nodes to see the risks/rewards, and click a destination to let your co-agent navigate the complex choices.
        </p>
    </div>

    <div id="game-container" class="relative w-full max-w-4xl aspect-[4/3]">
        <canvas id="mazeCanvas"></canvas>
        <div id="tooltip"></div>
    </div>
    
    <div class="mt-4 flex flex-col items-center">
        <p class="text-gray-400 mb-2">Click on a path or node to move automatically.</p>
    </div>


    <!-- Info Modal -->
    <div id="infoModal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content max-w-md w-full rounded-lg p-6 text-center transform scale-95 transition-transform duration-300">
            <h2 id="modalTitle" class="text-2xl font-bold text-purple-400 mb-3"></h2>
            <p id="modalDescription" class="text-gray-300 mb-5"></p>
            <button onclick="closeModal()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500">
                Continue
            </button>
        </div>
    </div>
    
    <!-- Win Modal -->
    <div id="winModal" class="modal fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 opacity-0 pointer-events-none">
        <div class="modal-content max-w-md w-full rounded-lg p-6 text-center transform scale-95 transition-transform duration-300">
            <h2 class="text-2xl font-bold text-green-400 mb-3">Optimization Achieved!</h2>
            <p class="text-gray-300 mb-5">
                Congratulations! You've navigated the chaotic landscape. This maze represents the thousands of configuration choices teams face. Winning requires moving beyond one-off tactics and embracing a system that provides continuous, data-backed optimization.
            </p>
            <button onclick="restartGame()" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-400">
                Play Again
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const tooltip = document.getElementById('tooltip');
        
        // --- Game State and Configuration ---
        let maze, player, exit, nodes, offscreenCanvas, offscreenCtx;
        let cellSize;
        const mazeWidth = 25; // Must be odd
        const mazeHeight = 13; // Must be odd
        let gameState = 'idle'; // 'idle', 'moving', 'paused'
        let currentPath = [];

        const optimizationNodes = [
            { title: "Prefix Caching", description: "Your RAG workload processes long prompts without prefix caching, leading to redundant computation costs. Enabling it can save up to 28% on cost and improve latency by 40%.", color: "#38bdf8" },
            { title: "Model Right-Sizing", description: "Are you using a large, expensive model for a simple task? Choosing the right model for each workload is critical for balancing cost and quality.", color: "#fb923c" },
            { title: "Quantization", description: "There are over 256 common quantization patterns. Using the right one, like 4-bit NF4, can reduce costs by over 60% for certain workloads.", color: "#f87171" },
            { title: "Batch Size Tuning", description: "Adjusting the batch size for inference requests can significantly impact throughput and hardware utilization. It's a key lever for optimizing self-hosted models.", color: "#a78bfa" },
            { title: "Structured Output", description: "Forcing model output into a specific format like JSON can reduce token count by over 20% by eliminating conversational filler, saving costs.", color: "#4ade80" },
            { title: "Fallback Logic", description: "What happens when your primary model fails? A resilient system automatically re-routes to a faster, cheaper model to maintain availability, but quality trade-offs must be managed.", color: "#facc15" },
        ];

        // --- Maze Generation (Recursive Backtracker) ---
        function generateMaze(width, height) {
            let matrix = Array(height).fill(0).map(() => Array(width).fill(1));
            function carve(x, y) {
                matrix[y][x] = 0;
                const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                directions.sort(() => Math.random() - 0.5);
                for (let [dx, dy] of directions) {
                    const nx = x + dx * 2;
                    const ny = y + dy * 2;
                    if (ny >= 0 && ny < height && nx >= 0 && nx < width && matrix[ny][nx] === 1) {
                        matrix[y + dy][x + dx] = 0;
                        carve(nx, ny);
                    }
                }
            }
            carve(1, 1);
            return matrix;
        }

        // --- Game Object Initialization ---
        function setupGame() {
            gameState = 'idle';
            currentPath = [];
            maze = generateMaze(mazeWidth, mazeHeight);

            player = { x: 1, y: 1, color: '#805ad5' };
            exit = { x: mazeWidth - 2, y: mazeHeight - 2, color: '#34d399' };
            
            nodes = [];
            const availableCells = [];
            for(let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 0 && !(x === 1 && y === 1) && !(x === mazeWidth - 2 && y === mazeHeight - 2)) {
                        availableCells.push({x, y});
                    }
                }
            }
            availableCells.sort(() => Math.random() - 0.5);
            
            for(let i = 0; i < optimizationNodes.length; i++) {
                if (availableCells.length > 0) {
                    const pos = availableCells.pop();
                    nodes.push({ ...pos, ...optimizationNodes[i], collected: false });
                }
            }
            
            // Pre-render the maze to an offscreen canvas for performance
            offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = canvas.width;
            offscreenCanvas.height = canvas.height;
            offscreenCtx = offscreenCanvas.getContext('2d');
            drawMazeToOffscreen();
        }

        // --- Drawing Functions ---
        function drawMazeToOffscreen() {
            offscreenCtx.fillStyle = '#0c0a1e';
            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
            offscreenCtx.fillStyle = '#4a4a6a';
            for (let y = 0; y < mazeHeight; y++) {
                for (let x = 0; x < mazeWidth; x++) {
                    if (maze[y][x] === 1) {
                        offscreenCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(offscreenCanvas, 0, 0); // Draw the pre-rendered maze
            
            drawNodes();
            drawExit();
            drawPlayer();
        }

        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellSize * 0.35, 0, 2 * Math.PI);
            ctx.fill();
            
            const gradient = ctx.createRadialGradient(
                player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, 0,
                player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellSize * 3
            );
            gradient.addColorStop(0, 'rgba(168, 85, 247, 0.3)');
            gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawExit() {
            ctx.fillStyle = exit.color;
            ctx.fillRect(exit.x * cellSize, exit.y * cellSize, cellSize, cellSize);
            const pulse = Math.abs(Math.sin(Date.now() * 0.002));
            ctx.fillStyle = `rgba(52, 211, 153, ${0.3 + pulse * 0.4})`;
            ctx.beginPath();
            ctx.arc(exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2, cellSize * (1 + pulse), 0, 2 * Math.PI);
            ctx.fill();
        }

        function drawNodes() {
            nodes.forEach(node => {
                if (!node.collected) {
                    ctx.fillStyle = node.color;
                    ctx.beginPath();
                    ctx.arc(node.x * cellSize + cellSize / 2, node.y * cellSize + cellSize / 2, cellSize * 0.3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    const pulse = Math.abs(Math.sin(Date.now() * 0.003 + node.x));
                    ctx.fillStyle = `${node.color}55`;
                    ctx.beginPath();
                    ctx.arc(node.x * cellSize + cellSize / 2, node.y * cellSize + cellSize / 2, cellSize * (0.4 + pulse * 0.3), 0, 2 * Math.PI);
                    ctx.fill();
                }
            });
        }

        // --- Pathfinding and Movement ---
        function findPath(start, end) {
            const q = [start];
            const visited = new Set([`${start.x},${start.y}`]);
            const cameFrom = new Map();

            while (q.length > 0) {
                const current = q.shift();

                if (current.x === end.x && current.y === end.y) {
                    const path = [];
                    let temp = current;
                    while (temp) {
                        path.unshift(temp);
                        temp = cameFrom.get(`${temp.x},${temp.y}`);
                    }
                    return path;
                }

                const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]]
                    .map(([dx, dy]) => ({ x: current.x + dx, y: current.y + dy }))
                    .filter(n => n.x >= 0 && n.x < mazeWidth && n.y >= 0 && n.y < mazeHeight && maze[n.y][n.x] === 0 && !visited.has(`${n.x},${n.y}`));

                for (const neighbor of neighbors) {
                    visited.add(`${neighbor.x},${neighbor.y}`);
                    cameFrom.set(`${neighbor.x},${neighbor.y}`, current);
                    q.push(neighbor);
                }
            }
            return []; // No path found
        }
        
        function startMoving(path) {
            if (gameState !== 'idle' || path.length <= 1) return;
            gameState = 'moving';
            currentPath = path;
            currentPath.shift(); // Remove the starting position
        }

        function updateMovement() {
            if (gameState !== 'moving' || currentPath.length === 0) return;

            const nextStep = currentPath.shift();
            player.x = nextStep.x;
            player.y = nextStep.y;

            const collectedNode = nodes.find(n => n.x === player.x && n.y === player.y && !n.collected);
            if (collectedNode) {
                collectedNode.collected = true;
                gameState = 'paused';
                showInfoModal(collectedNode.title, collectedNode.description);
            }

            if (player.x === exit.x && player.y === exit.y) {
                gameState = 'paused';
                showWinModal();
            }
            
            if (currentPath.length === 0 && gameState === 'moving') {
                gameState = 'idle';
            }
        }

        // --- Main Game Loop ---
        let lastUpdateTime = 0;
        const movementInterval = 50; // ms between steps

        function gameLoop(timestamp) {
            if (gameState === 'moving') {
                if (timestamp - lastUpdateTime > movementInterval) {
                    updateMovement();
                    lastUpdateTime = timestamp;
                }
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        // --- Event Handlers ---
        canvas.addEventListener('click', (e) => {
            if (gameState !== 'idle') return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const gridX = Math.floor(x / cellSize);
            const gridY = Math.floor(y / cellSize);

            if (gridX >= 0 && gridX < mazeWidth && gridY >= 0 && gridY < mazeHeight && maze[gridY][gridX] === 0) {
                const path = findPath({ x: player.x, y: player.y }, { x: gridX, y: gridY });
                startMoving(path);
            }
        });

        // Throttled mouse move for performance
        let throttleTimeout;
        canvas.addEventListener('mousemove', (e) => {
            if (throttleTimeout) return;
            throttleTimeout = setTimeout(() => {
                throttleTimeout = null;
                if (gameState !== 'idle') {
                    tooltip.style.display = 'none';
                    return;
                };
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const gridX = Math.floor(x / cellSize);
                const gridY = Math.floor(y / cellSize);

                const node = nodes.find(n => n.x === gridX && n.y === gridY && !n.collected);
                if (node) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = `${e.clientX - rect.left + 15}px`;
                    tooltip.style.top = `${e.clientY - rect.top + 15}px`;
                    tooltip.innerHTML = `<h3>${node.title}</h3><p>${node.description}</p>`;
                } else {
                    tooltip.style.display = 'none';
                }
            }, 50); // Throttle to 20fps
        });
        
        canvas.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
        });

        // --- Modal Controls ---
        const infoModal = document.getElementById('infoModal');
        const winModal = document.getElementById('winModal');

        function showInfoModal(title, description) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalDescription').textContent = description;
            infoModal.classList.remove('opacity-0', 'pointer-events-none');
            infoModal.querySelector('.modal-content').classList.remove('scale-95');
        }

        function closeModal() {
            infoModal.classList.add('opacity-0', 'pointer-events-none');
            infoModal.querySelector('.modal-content').classList.add('scale-95');
            // Resume movement if there's still a path to follow
            if (currentPath.length > 0) {
                 gameState = 'moving';
            } else {
                 gameState = 'idle';
            }
        }
        
        function showWinModal() {
            winModal.classList.remove('opacity-0', 'pointer-events-none');
            winModal.querySelector('.modal-content').classList.remove('scale-95');
        }
        
        function restartGame() {
            winModal.classList.add('opacity-0', 'pointer-events-none');
            winModal.querySelector('.modal-content').classList.add('scale-95');
            init();
        }

        // --- Initialization and Resize ---
        function init() {
            const containerWidth = gameContainer.clientWidth;
            const containerHeight = gameContainer.clientHeight;
            
            const cellWidth = Math.floor(containerWidth / mazeWidth);
            const cellHeight = Math.floor(containerHeight / mazeHeight);
            cellSize = Math.min(cellWidth, cellHeight);

            canvas.width = mazeWidth * cellSize;
            canvas.height = mazeHeight * cellSize;

            setupGame();
        }

        window.addEventListener('resize', init);
        window.onload = () => {
            init();
            requestAnimationFrame(gameLoop); // Start the main game loop
        };
    </script>
</body>
</html>
