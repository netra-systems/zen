ROOT CAUSE ANALYSIS: PostgreSQL Connection Failures

  Based on my comprehensive audit, here are the PRIMARY ROOT CAUSES of your database connection issues:

  1. MASSIVE ARCHITECTURAL VIOLATION: Multiple Database URL Builders

  The Paradox: You have a centralized DatabaseURLBuilder class that's supposed to be the single source of truth,
  BUT:

  - netra_backend/app/db/database_manager.py (lines 46-68): Has pytest-specific bypass logic that IGNORES the
  unified config and directly accesses environment variables
  - dev_launcher/database_connector.py (lines 231-245): Has its own URL normalization that conflicts with
  DatabaseURLBuilder
  - Multiple IsolatedEnvironment implementations that each handle environment variables differently

  2. PYTEST BYPASS PATTERN - THE SMOKING GUN

  # database_manager.py lines 46-51
  is_pytest = 'pytest' in sys.modules
  if is_pytest:
      raw_url = get_env().get("DATABASE_URL", "")  # BYPASSES CONFIG
  else:
      config = get_unified_config()
      raw_url = config.database_url

  Why Tests Pass: Tests bypass the entire configuration system and use direct environment variables
  Why Production Fails: Production uses the config system which has different URL handling

  3. SSL PARAMETER CHAOS

  The system has THREE different SSL parameter handling patterns:
  1. DatabaseURLBuilder: Uses sslmode=require for staging/production
  2. database_manager.py (lines 186): Converts sslmode to ssl for asyncpg
  3. Cloud SQL connections: Remove ALL SSL parameters

  This creates race conditions where different parts of the system apply conflicting SSL transformations.

  4. URL NORMALIZATION DUPLICATED 8+ TIMES

  Every service has its own postgres:// to postgresql:// conversion:
  - database_manager.py:611
  - database_connector.py:241
  - DatabaseURLBuilder:549
  - Plus 5+ other locations

  Each implementation is slightly different, causing inconsistent behavior.

  5. CLOUD SQL vs TCP DETECTION FAILURE

  The system uses string matching ("/cloudsql/" in url) to detect Cloud SQL connections, but:
  - Different modules check different patterns
  - Some check before normalization, some after
  - This causes Cloud SQL connections to sometimes get SSL parameters (which break them)

  6. ENVIRONMENT VARIABLE ACCESS CHAOS

  - 40+ direct calls to get_env().get("DATABASE_URL")
  - 12+ direct calls to os.environ.get("DATABASE_URL")
  - Each bypasses the centralized configuration

  7. THE CRITICAL RACE CONDITION

  When the system starts:
  1. dev_launcher uses DatabaseURLBuilder to create a URL
  2. database_manager bypasses it if pytest is detected (even in dev mode!)
  3. Different services apply different normalizations
  4. SSL parameters get added/removed multiple times
  5. Final URL is unpredictable

  IMMEDIATE FIXES REQUIRED:

  Fix 1: Remove ALL pytest bypasses

  # DELETE the pytest detection logic in database_manager.py
  # ALWAYS use unified config

  Fix 2: Centralize ALL URL handling

  # ONLY DatabaseURLBuilder should create/normalize URLs
  # Delete all other normalization code

  Fix 3: Fix SSL parameter handling

  # Use DatabaseURLBuilder.format_url_for_driver() consistently
  # Never manually convert SSL parameters

  Fix 4: Fix Cloud SQL detection

  # Use DatabaseURLBuilder's is_cloud_sql property
  # Never use string matching

  Fix 5: Remove duplicate database managers

  - Keep ONLY shared/database_url_builder.py
  - Delete connection logic from database_manager.py
  - Delete normalization from database_connector.py

  The system is failing because every layer thinks it knows better than the layer below it, creating a tower of
  conflicting transformations. The solution is to enforce the single source of truth principle strictly.


