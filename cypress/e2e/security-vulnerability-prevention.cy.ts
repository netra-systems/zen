
describe('Security: SQL Injection and XSS Prevention (L4)', () => {

  // Use actual existing endpoints from the current system
  const CHAT_URL = '/chat';
  const API_BASE_URL = 'http://localhost:3001/api';
  const TEST_USER = Cypress.env('CYPRESS_TEST_USER') || 'dev@example.com';
  const TEST_PASSWORD = Cypress.env('CYPRESS_TEST_PASSWORD') || 'dev';

  beforeEach(() => {
    // Clear any existing state
    cy.clearLocalStorage();
    cy.clearCookies();
    
    // Log in as a test user before each test using the updated login command
    cy.login(TEST_USER, TEST_PASSWORD);
  });

  describe('SQL Injection Prevention', () => {
    it('should handle SQL injection payloads in API calls gracefully', () => {
      // Test SQL injection on backend API endpoints that accept query parameters
      const sqlInjectionPayloads = [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT * FROM users --",
        "admin'--",
        "' OR 1=1 --"
      ];

      sqlInjectionPayloads.forEach((payload) => {
        // Test against actual API endpoints that might be vulnerable
        cy.window().then((win) => {
          const token = win.localStorage.getItem('jwt_token');
          
          // Test various API endpoints with SQL injection payloads
          const testEndpoints = [
            '/threads/search',
            '/api/users/profile',
            '/api/admin/users'
          ];
          
          testEndpoints.forEach((endpoint) => {
            cy.request({
              url: `${API_BASE_URL}${endpoint}?q=${encodeURIComponent(payload)}`,
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
              },
              failOnStatusCode: false
            }).then((response) => {
              // Should not return internal server errors or database errors
              expect(response.status).to.not.eq(500);
              
              // Response should not contain SQL error messages
              if (response.body && typeof response.body === 'string') {
                expect(response.body.toLowerCase()).to.not.include('sql');
                expect(response.body.toLowerCase()).to.not.include('database');
                expect(response.body.toLowerCase()).to.not.include('syntax error');
              }
              
              // Should return proper error codes (400, 401, 403, 404) or success (200)
              expect([200, 400, 401, 403, 404, 422]).to.include(response.status);
            });
          });
        });
      });
    });

    it('should handle SQL injection in frontend search inputs gracefully', () => {
      cy.visit(CHAT_URL);
      
      // Wait for chat interface to load
      cy.get('body', { timeout: 10000 }).should('be.visible');
      
      // SQL injection payload for frontend testing
      const sqlInjectionPayload = "' OR '1'='1 --";
      
      // Look for message input (common in chat interfaces)
      cy.get('body').then(($body) => {
        // Try to find a message input or search box
        if ($body.find('textarea').length > 0) {
          cy.get('textarea').first().type(sqlInjectionPayload + '{enter}');
          
          // Should not cause application errors
          cy.get('body').should('not.contain', 'Internal Server Error');
          cy.get('body').should('not.contain', 'SQL syntax error');
          cy.get('body').should('not.contain', 'Database error');
        } else if ($body.find('input[type="text"]').length > 0) {
          cy.get('input[type="text"]').first().type(sqlInjectionPayload + '{enter}');
          
          // Should not cause application errors
          cy.get('body').should('not.contain', 'Internal Server Error');
          cy.get('body').should('not.contain', 'SQL syntax error');
          cy.get('body').should('not.contain', 'Database error');
        } else {
          cy.log('No suitable input found for SQL injection testing');
        }
      });
    });
  });

  describe('Cross-Site Scripting (XSS) Prevention', () => {
    it('should sanitize user inputs to prevent XSS attacks in chat interface', () => {
      cy.visit(CHAT_URL);
      
      // Wait for chat interface to load
      cy.get('body', { timeout: 10000 }).should('be.visible');

      // Various XSS payloads to test
      const xssPayloads = [
        '<script>alert("XSS attack!")</script>',
        '<img src="x" onerror="alert(1)">',
        '<svg onload="alert(1)">',
        'javascript:alert(1)',
        '<iframe src="javascript:alert(1)"></iframe>',
        '<body onload="alert(1)">',
        '\\x3cscript\\x3ealert(1)\\x3c/script\\x3e'
      ];

      // Stub the window.alert method to detect if any script is executed
      let alertCalled = false;
      cy.window().then((win) => {
        cy.stub(win, 'alert').callsFake(() => {
          alertCalled = true;
        });
      });

      xssPayloads.forEach((xssPayload, index) => {
        cy.log(`Testing XSS payload ${index + 1}: ${xssPayload}`);
        
        cy.get('body').then(($body) => {
          // Try different input methods based on what's available
          if ($body.find('textarea').length > 0) {
            // Test in textarea (like chat message input)
            cy.get('textarea').first().clear().type(xssPayload);
            
            // Try to submit if there's a submit button or press enter
            if ($body.find('button[type="submit"]').length > 0) {
              cy.get('button[type="submit"]').first().click();
            } else {
              cy.get('textarea').first().type('{enter}');
            }
          } else if ($body.find('input[type="text"]').length > 0) {
            // Test in text input
            cy.get('input[type="text"]').first().clear().type(xssPayload + '{enter}');
          }
          
          // Wait a bit for any potential script execution
          cy.wait(500);
          
          // Verify the payload is rendered as plain text, not executed
          if ($body.text().includes('<script>') || $body.text().includes('<img')) {
            cy.get('body').should('contain', xssPayload.replace(/<[^>]*>/g, ''));
          }
        });
      });
      
      // Assert that no alerts were triggered
      cy.then(() => {
        expect(alertCalled).to.be.false;
      });
    });

    it('should prevent XSS in API responses', () => {
      const xssPayload = '<script>alert("XSS in API!")</script>';
      
      cy.window().then((win) => {
        const token = win.localStorage.getItem('jwt_token');
        
        // Test API endpoints that might return user data
        const apiEndpoints = [
          '/api/users/profile',
          '/threads',
          '/api/admin/users'
        ];
        
        apiEndpoints.forEach((endpoint) => {
          cy.request({
            method: 'POST',
            url: `${API_BASE_URL}${endpoint}`,
            headers: {
              'Authorization': `Bearer ${token}`,
              'Content-Type': 'application/json'
            },
            body: {
              name: xssPayload,
              description: xssPayload,
              message: xssPayload
            },
            failOnStatusCode: false
          }).then((response) => {
            // Check that response doesn't contain executable scripts
            if (response.body && typeof response.body === 'object') {
              const responseStr = JSON.stringify(response.body);
              // Scripts should be escaped or removed
              expect(responseStr).to.not.match(/<script[^>]*>.*?<\/script>/gi);
              expect(responseStr).to.not.match(/javascript:/gi);
              expect(responseStr).to.not.match(/onerror=/gi);
              expect(responseStr).to.not.match(/onload=/gi);
            }
          });
        });
      });
    });
    
    it('should handle reflected XSS in URL parameters', () => {
      // Test URL parameter XSS
      const xssPayload = encodeURIComponent('<script>alert("Reflected XSS")</script>');
      const testUrl = `${CHAT_URL}?search=${xssPayload}&message=${xssPayload}`;
      
      cy.visit(testUrl);
      
      // Set up alert detection
      let alertCalled = false;
      cy.window().then((win) => {
        cy.stub(win, 'alert').callsFake(() => {
          alertCalled = true;
        });
      });
      
      // Wait for page to load and process URL parameters
      cy.get('body', { timeout: 10000 }).should('be.visible');
      cy.wait(1000);
      
      // Verify no script execution occurred
      cy.then(() => {
        expect(alertCalled).to.be.false;
      });
      
      // URL should still be accessible without errors
      cy.url().should('include', CHAT_URL);
    });
  });
  
  describe('Additional Security Tests', () => {
    it('should prevent CSRF attacks by validating request origins', () => {
      cy.window().then((win) => {
        const token = win.localStorage.getItem('jwt_token');
        
        // Test CSRF by making requests with invalid origins
        cy.request({
          method: 'POST',
          url: `${API_BASE_URL}/users/profile`,
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
            'Origin': 'https://malicious-site.com'
          },
          body: {
            name: 'CSRF Test'
          },
          failOnStatusCode: false
        }).then((response) => {
          // Should reject requests from unauthorized origins
          expect([400, 401, 403]).to.include(response.status);
        });
      });
    });
    
    it('should handle malformed JSON payloads gracefully', () => {
      cy.window().then((win) => {
        const token = win.localStorage.getItem('jwt_token');
        
        // Test with malformed JSON
        cy.request({
          method: 'POST',
          url: `${API_BASE_URL}/threads`,
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: '{"name": "test", "invalid": }', // Malformed JSON
          failOnStatusCode: false
        }).then((response) => {
          // Should return 400 Bad Request, not 500 Internal Server Error
          expect(response.status).to.eq(400);
        });
      });
    });
    
    it('should validate input lengths and prevent buffer overflow', () => {
      // Test with extremely long inputs
      const longString = 'A'.repeat(10000);
      
      cy.window().then((win) => {
        const token = win.localStorage.getItem('jwt_token');
        
        cy.request({
          method: 'POST',
          url: `${API_BASE_URL}/threads`,
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          },
          body: {
            name: longString,
            description: longString
          },
          failOnStatusCode: false
        }).then((response) => {
          // Should handle long inputs gracefully
          expect([200, 400, 422]).to.include(response.status);
          expect(response.status).to.not.eq(500); // Should not cause server error
        });
      });
    });
  });
});
