"""
OAuth State CSRF Vulnerability Integration Tests
Tests for critical OAuth state management security flaws

Business Value Justification (BVJ):
- Segment: All (Free, Early, Mid, Enterprise)
- Business Goal: Security, Compliance, CSRF Prevention
- Value Impact: Prevents OAuth hijacking and CSRF attacks
- Strategic Impact: CRITICAL security vulnerability that could compromise user accounts

CRITICAL SECURITY ISSUE IDENTIFIED:
The initiate_oauth_login endpoint generates state parameters but doesn't store them
for later validation, creating a major CSRF vulnerability.

This test will FAIL to expose the security gap.
"""
import json
import secrets
import pytest
from fastapi.testclient import TestClient
from unittest.mock import patch, Mock

from auth_service.main import app
from auth_service.auth_core.security.oauth_security import OAuthSecurityManager

# Test client with follow_redirects=False to prevent external calls
client = TestClient(app, follow_redirects=False)


class TestOAuthStateCSRFVulnerability:
    """Test OAuth state parameter CSRF vulnerability"""
    
    def setup_method(self):
        """Set up test fixtures"""
        # Import the same oauth_security instance used by the routes
        from auth_service.auth_core.routes.auth_routes import oauth_security
        self.security_manager = oauth_security
    
    def test_oauth_initiate_stores_state_parameter(self):
        """Test that OAuth initiation properly stores state parameter for CSRF protection
        
        THIS TEST WILL FAIL - exposing the CSRF vulnerability
        """
        # Mock the Google client ID configuration
        with patch('auth_service.auth_core.routes.auth_routes.AuthConfig.get_google_client_id') as mock_client_id:
            mock_client_id.return_value = "test_client_id"
            
            # Create a session cookie for the request
            mock_session_id = "test_session_123"
            client.cookies.set("session_id", mock_session_id)
            
            # Initiate OAuth login
            response = client.get("/auth/login?provider=google")
            
            # Should redirect to Google OAuth
            assert response.status_code == 302
            assert "accounts.google.com" in response.headers["location"]
            
            # Extract state parameter from redirect URL
            location = response.headers["location"]
            state_start = location.find("state=") + 6
            state_end = location.find("&", state_start)
            if state_end == -1:
                state_end = len(location)
            state_param = location[state_start:state_end]
            
            # CRITICAL TEST: Verify state was stored in security manager
            # This should now PASS because we fixed the implementation to store state
            assert len(state_param) > 0, "State parameter should be generated"
            
            # THIS ASSERTION SHOULD NOW PASS - state is properly stored
            is_valid = self.security_manager.validate_state_parameter(state_param, mock_session_id)
            assert is_valid is True, "CRITICAL: State parameter not stored - CSRF vulnerability!"
    
    def test_oauth_callback_validates_state_parameter(self):
        """Test that OAuth callback validates state parameter
        
        THIS TEST WILL FAIL - callback doesn't validate state properly
        """
        # Mock successful Google token validation
        mock_user_info = {
            "id": "123456789",
            "email": "test@example.com",
            "name": "Test User",
            "picture": "https://example.com/photo.jpg"
        }
        
        with patch('auth_service.auth_core.routes.auth_routes.AuthConfig.get_google_client_id') as mock_client_id, \
             patch('auth_service.auth_core.routes.auth_routes.AuthConfig.get_google_client_secret') as mock_client_secret, \
             patch('auth_service.auth_core.routes.auth_routes.httpx.AsyncClient.post') as mock_post, \
             patch('auth_service.auth_core.routes.auth_routes.httpx.AsyncClient.get') as mock_get:
            
            mock_client_id.return_value = "test_client_id"
            mock_client_secret.return_value = "test_client_secret"
            
            # Mock token exchange response
            mock_token_response = Mock()
            mock_token_response.json.return_value = {
                "access_token": "fake_access_token",
                "token_type": "Bearer",
                "expires_in": 3600
            }
            mock_post.return_value = mock_token_response
            
            # Mock user info response  
            mock_user_response = Mock()
            mock_user_response.json.return_value = mock_user_info
            mock_get.return_value = mock_user_response
            
            # Generate a state parameter that wasn't properly stored
            fake_state = secrets.token_urlsafe(32)
            
            # Set a session cookie for the callback test
            fake_session_id = "fake_session_456"
            client.cookies.set("session_id", fake_session_id)
            
            # Attempt OAuth callback with unvalidated state
            response = client.get(f"/auth/callback?code=test_code&state={fake_state}")
            
            # CRITICAL TEST: Callback should REJECT invalid/unverified state
            # THIS SHOULD NOW PASS - callback properly validates state and returns 400
            assert response.status_code == 400, "Should reject invalid state parameter"
            
            error_detail = response.json().get("detail", "")
            assert "invalid" in error_detail.lower() or "csrf" in error_detail.lower(), \
                "Should indicate CSRF/state validation failure"
    
    def test_oauth_state_replay_attack_prevention(self):
        """Test that OAuth state parameters prevent replay attacks
        
        THIS TEST WILL FAIL - no replay attack prevention
        """
        # Generate a state parameter
        state_param = secrets.token_urlsafe(32)
        session_id = "test_session_456"
        
        # Simulate storing state (what should happen during login initiation)
        stored = self.security_manager.store_state_parameter(state_param, session_id)
        assert stored is True, "State should be stored successfully"
        
        # First validation should succeed
        first_validation = self.security_manager.validate_state_parameter(state_param, session_id)
        assert first_validation is True, "First state validation should succeed"
        
        # CRITICAL TEST: Second validation should fail (replay attack prevention)
        # THIS WILL FAIL if state parameters can be reused
        second_validation = self.security_manager.validate_state_parameter(state_param, session_id)
        assert second_validation is False, "State parameters should be single-use to prevent replay attacks"
    
    def test_oauth_state_session_binding(self):
        """Test that OAuth state parameters are properly bound to sessions
        
        THIS TEST MIGHT FAIL - session binding issues
        """
        correct_session_id = "correct_session_789"
        wrong_session_id = "wrong_session_999"
        
        # Test 1: Store state with correct session and validate with wrong session (should fail)
        state_param_1 = secrets.token_urlsafe(32)
        stored = self.security_manager.store_state_parameter(state_param_1, correct_session_id)
        assert stored is True, "State should be stored with session binding"
        
        # Validation with wrong session should fail
        wrong_session_validation = self.security_manager.validate_state_parameter(state_param_1, wrong_session_id)
        assert wrong_session_validation is False, "State should be bound to specific session"
        
        # Test 2: Store new state with correct session and validate with correct session (should succeed)
        state_param_2 = secrets.token_urlsafe(32)
        stored2 = self.security_manager.store_state_parameter(state_param_2, correct_session_id)
        assert stored2 is True, "Second state should be stored successfully"
        
        # Validation with correct session should succeed
        correct_session_validation = self.security_manager.validate_state_parameter(state_param_2, correct_session_id)
        assert correct_session_validation is True, "State should validate with correct session"
    
    def test_oauth_state_expiration_enforcement(self):
        """Test that OAuth state parameters expire properly"""
        state_param = secrets.token_urlsafe(32)
        session_id = "test_session_expiry"
        
        # Store state parameter
        stored = self.security_manager.store_state_parameter(state_param, session_id)
        assert stored is True, "State should be stored successfully"
        
        # Simulate time passage by directly modifying the stored timestamp
        # First, let's get the stored data and modify it
        state_key = f"oauth_state:{state_param}"
        stored_data = self.security_manager._memory_store[state_key]
        # Set timestamp to 11 minutes ago
        import time
        stored_data["timestamp"] = time.time() - (11 * 60)  # 11 minutes ago
        self.security_manager._memory_store[state_key] = stored_data
            
        # Validation should fail due to expiration
        expired_validation = self.security_manager.validate_state_parameter(state_param, session_id)
        assert expired_validation is False, "Expired state parameters should be rejected"
    
    def test_oauth_concurrent_state_collision_resistance(self):
        """Test that OAuth state parameters resist collision attacks"""
        session_id = "test_session_collision"
        
        # Generate many state parameters
        states = []
        for _ in range(1000):
            state = secrets.token_urlsafe(32)
            states.append(state)
            # Should be able to store each unique state
            stored = self.security_manager.store_state_parameter(state, session_id)
            assert stored is True, f"Should store unique state parameter: {state}"
        
        # All states should be unique
        unique_states = set(states)
        assert len(unique_states) == len(states), "All state parameters should be unique"
        
        # Each state should validate exactly once
        for state in states:
            validation = self.security_manager.validate_state_parameter(state, session_id)
            assert validation is True, f"State should validate once: {state}"
            
            # Second validation should fail (single-use)
            second_validation = self.security_manager.validate_state_parameter(state, session_id)
            assert second_validation is False, f"State should be single-use: {state}"