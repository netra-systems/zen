<?xml version="1.0" encoding="UTF-8"?>
<legacy_code_cleanup_specification>
  <metadata>
    <version>1.0</version>
    <created>2025-08-10</created>
    <purpose>Define systematic approach for identifying and removing legacy code while maintaining system integrity</purpose>
    <scope>Application-wide legacy code identification, assessment, and removal procedures</scope>
  </metadata>

  <design_principles>
    <principle id="P1">
      <name>System Integrity First</name>
      <description>Never compromise production functionality for cleanliness</description>
      <guidelines>
        - Maintain all external API contracts
        - Preserve database schema integrity
        - Keep backward compatibility during transition periods
        - Document breaking changes with migration paths
      </guidelines>
    </principle>
    
    <principle id="P2">
      <name>Complexity Reduction</name>
      <description>Each cleanup must reduce overall system complexity</description>
      <guidelines>
        - Remove duplicate implementations
        - Consolidate similar functionality
        - Eliminate indirection layers that don't add value
        - Simplify dependency chains
      </guidelines>
    </principle>
    
    <principle id="P3">
      <name>Production Safety</name>
      <description>All changes must be safely deployable to production</description>
      <guidelines>
        - Use feature flags for major transitions
        - Implement rollback mechanisms
        - Maintain monitoring for deprecated features
        - Phase out legacy code gradually
      </guidelines>
    </principle>
  </design_principles>

  <legacy_patterns>
    <pattern id="LP1">
      <name>Duplicate Implementations</name>
      <description>Multiple versions of the same functionality</description>
      <examples>
        - supervisor.py vs supervisor_consolidated.py
        - app/auth/auth.py vs app/routes/auth/auth.py
        - app/agents/tool_dispatcher.py vs app/services/apex_optimizer_agent/tools/tool_dispatcher.py
        - app/routes/llm_cache.py vs app/services/cache/llm_cache.py
      </examples>
      <identification_methods>
        - File name similarity analysis
        - Import pattern analysis
        - Functionality overlap assessment
        - Git history review for parallel development
      </identification_methods>
      <cleanup_strategy>
        <step>1. Identify canonical implementation</step>
        <step>2. Map all usage points</step>
        <step>3. Create compatibility wrapper if needed</step>
        <step>4. Migrate usage to canonical version</step>
        <step>5. Deprecate old version with warnings</step>
        <step>6. Remove after deprecation period</step>
      </cleanup_strategy>
    </pattern>
    
    <pattern id="LP2">
      <name>Backward Compatibility Layers</name>
      <description>Code maintained solely for compatibility with older versions</description>
      <examples>
        - "# For backward compatibility" comments
        - Legacy function wrappers in corpus_service.py
        - SupervisorAgent export alias
        - OAuth initialization wrapper
      </examples>
      <identification_methods>
        - Search for compatibility-related comments
        - Identify thin wrapper functions
        - Find deprecated parameter handling
        - Look for version-specific conditionals
      </identification_methods>
      <cleanup_strategy>
        <step>1. Document current usage patterns</step>
        <step>2. Determine minimum supported version</step>
        <step>3. Create migration guide for consumers</step>
        <step>4. Add deprecation warnings with timeline</step>
        <step>5. Monitor usage via telemetry</step>
        <step>6. Remove after migration period</step>
      </cleanup_strategy>
    </pattern>
    
    <pattern id="LP3">
      <name>Migration Artifacts</name>
      <description>Database migrations and schema changes that are no longer needed</description>
      <examples>
        - Table rename migrations (users -> userbase -> users)
        - Unused migration scripts
        - Temporary data transformation code
        - Schema compatibility checks
      </examples>
      <identification_methods>
        - Review migration history for reversals
        - Check for unused migration files
        - Identify temporary transformation functions
        - Find obsolete schema checks
      </identification_methods>
      <cleanup_strategy>
        <step>1. Squash related migrations into single operation</step>
        <step>2. Verify all environments are past migration point</step>
        <step>3. Create checkpoint migration</step>
        <step>4. Archive old migrations</step>
        <step>5. Update fresh install procedures</step>
      </cleanup_strategy>
    </pattern>
    
    <pattern id="LP4">
      <name>Dead Code</name>
      <description>Unused functions, classes, or modules</description>
      <identification_methods>
        - Static analysis tools (pylint, ESLint)
        - Coverage reports showing 0% coverage
        - Import graph analysis
        - API endpoint usage metrics
      </identification_methods>
      <cleanup_strategy>
        <step>1. Verify non-usage via static analysis</step>
        <step>2. Check production logs for runtime usage</step>
        <step>3. Search for dynamic imports or reflection</step>
        <step>4. Add deprecation notice if uncertain</step>
        <step>5. Remove after verification period</step>
      </cleanup_strategy>
    </pattern>
    
    <pattern id="LP5">
      <name>Test Debt</name>
      <description>Outdated, skipped, or redundant tests</description>
      <examples>
        - Tests for removed features
        - Duplicate test scenarios
        - Skipped tests without clear reason
        - Tests using old patterns
      </examples>
      <identification_methods>
        - Find @skip decorators without justification
        - Identify duplicate test names
        - Check for tests of non-existent code
        - Review test execution time outliers
      </identification_methods>
      <cleanup_strategy>
        <step>1. Audit all skipped tests</step>
        <step>2. Fix or remove broken tests</step>
        <step>3. Consolidate duplicate scenarios</step>
        <step>4. Update to modern testing patterns</step>
        <step>5. Improve test documentation</step>
      </cleanup_strategy>
    </pattern>
  </legacy_patterns>

  <cleanup_process>
    <phase id="DISCOVERY">
      <name>Discovery Phase</name>
      <activities>
        <activity>Run automated legacy pattern detection</activity>
        <activity>Generate code metrics and complexity reports</activity>
        <activity>Review git history for code churn</activity>
        <activity>Interview team about pain points</activity>
        <activity>Create legacy code inventory</activity>
      </activities>
      <outputs>
        - Legacy code inventory spreadsheet
        - Risk assessment matrix
        - Dependency impact analysis
      </outputs>
    </phase>
    
    <phase id="PLANNING">
      <name>Planning Phase</name>
      <activities>
        <activity>Prioritize cleanup based on risk/reward</activity>
        <activity>Create cleanup roadmap with milestones</activity>
        <activity>Define success metrics</activity>
        <activity>Allocate resources and timeline</activity>
        <activity>Identify production migration windows</activity>
      </activities>
      <outputs>
        - Cleanup roadmap document
        - Resource allocation plan
        - Success criteria checklist
      </outputs>
    </phase>
    
    <phase id="EXECUTION">
      <name>Execution Phase</name>
      <activities>
        <activity>Implement cleanup in feature branches</activity>
        <activity>Write comprehensive tests for changes</activity>
        <activity>Update documentation</activity>
        <activity>Conduct code reviews</activity>
        <activity>Run performance benchmarks</activity>
      </activities>
      <safeguards>
        - Require 100% test coverage for modified code
        - Mandatory peer review by senior engineer
        - Performance regression tests must pass
        - Security scan required before merge
      </safeguards>
    </phase>
    
    <phase id="DEPLOYMENT">
      <name>Deployment Phase</name>
      <activities>
        <activity>Deploy to staging environment</activity>
        <activity>Run integration test suite</activity>
        <activity>Monitor for errors and performance</activity>
        <activity>Execute canary deployment</activity>
        <activity>Full production rollout</activity>
      </activities>
      <rollback_triggers>
        - Error rate increase >5%
        - Performance degradation >10%
        - Critical functionality failure
        - Memory usage spike >20%
      </rollback_triggers>
    </phase>
    
    <phase id="VERIFICATION">
      <name>Verification Phase</name>
      <activities>
        <activity>Monitor production metrics for 48 hours</activity>
        <activity>Verify no functionality regression</activity>
        <activity>Check performance improvements</activity>
        <activity>Update metrics dashboard</activity>
        <activity>Document lessons learned</activity>
      </activities>
      <success_criteria>
        - No production incidents
        - Performance metrics stable or improved
        - Code complexity reduced by target amount
        - Test coverage maintained or improved
      </success_criteria>
    </phase>
  </cleanup_process>

  <production_migration_considerations>
    <consideration id="PMC1">
      <name>Zero Downtime Deployment</name>
      <requirements>
        - All changes must be backward compatible
        - Database migrations must be non-blocking
        - API versioning for breaking changes
        - Graceful degradation for removed features
      </requirements>
    </consideration>
    
    <consideration id="PMC2">
      <name>Data Integrity</name>
      <requirements>
        - No data loss during cleanup
        - Maintain referential integrity
        - Preserve audit trails
        - Archive before deletion
      </requirements>
    </consideration>
    
    <consideration id="PMC3">
      <name>Service Dependencies</name>
      <requirements>
        - Map all internal service dependencies
        - Coordinate with external consumers
        - Provide migration timeline
        - Maintain deprecated endpoints during transition
      </requirements>
    </consideration>
    
    <consideration id="PMC4">
      <name>Performance Impact</name>
      <requirements>
        - Benchmark before and after changes
        - Monitor resource utilization
        - Load test critical paths
        - Have rollback plan for degradation
      </requirements>
    </consideration>
  </production_migration_considerations>

  <complexity_metrics>
    <metric id="CM1">
      <name>Cyclomatic Complexity</name>
      <target>Reduce by 20% per cleanup cycle</target>
      <measurement>Use radon or similar tools</measurement>
    </metric>
    
    <metric id="CM2">
      <name>Code Duplication</name>
      <target>Less than 5% duplication ratio</target>
      <measurement>CPD (Copy-Paste Detector) analysis</measurement>
    </metric>
    
    <metric id="CM3">
      <name>Dependency Depth</name>
      <target>Maximum 5 levels of dependency</target>
      <measurement>Import graph analysis</measurement>
    </metric>
    
    <metric id="CM4">
      <name>Test Coverage</name>
      <target>Maintain or improve current coverage</target>
      <measurement>Coverage.py and Jest coverage reports</measurement>
    </metric>
    
    <metric id="CM5">
      <name>Technical Debt Ratio</name>
      <target>Below 5% of development time</target>
      <measurement>SonarQube or similar analysis</measurement>
    </metric>
  </complexity_metrics>

  <specific_cleanup_targets>
    <target priority="HIGH">
      <location>app/agents/supervisor.py</location>
      <action>Remove backward compatibility wrapper</action>
      <migration_path>
        1. Update all imports to use supervisor_consolidated directly
        2. Run tests to verify compatibility
        3. Remove supervisor.py file
      </migration_path>
    </target>
    
    <target priority="HIGH">
      <location>app/auth/auth.py and app/routes/auth/auth.py</location>
      <action>Consolidate authentication logic</action>
      <migration_path>
        1. Move all auth logic to app/auth/auth.py
        2. Make routes/auth/auth.py a thin routing layer
        3. Remove duplicate helper functions
      </migration_path>
    </target>
    
    <target priority="MEDIUM">
      <location>Tool dispatcher duplicates</location>
      <action>Unify tool dispatcher implementations</action>
      <migration_path>
        1. Create single tool_dispatcher in services
        2. Update all agents to use unified version
        3. Remove agent-specific dispatchers
      </migration_path>
    </target>
    
    <target priority="MEDIUM">
      <location>LLM cache duplicates</location>
      <action>Consolidate cache implementations</action>
      <migration_path>
        1. Use services/cache/llm_cache.py as single source
        2. Make routes/llm_cache.py pure routing
        3. Remove any duplicate caching logic
      </migration_path>
    </target>
    
    <target priority="LOW">
      <location>Database migration reversals</location>
      <action>Squash migration history</action>
      <migration_path>
        1. Create checkpoint migration at current state
        2. Archive old migration files
        3. Update fresh installation scripts
      </migration_path>
    </target>
    
    <target priority="LOW">
      <location>Legacy service functions</location>
      <action>Remove deprecated compatibility functions</action>
      <migration_path>
        1. Add deprecation warnings (1 month)
        2. Monitor usage in production
        3. Remove after verification of zero usage
      </migration_path>
    </target>
  </specific_cleanup_targets>

  <automation_tools>
    <tool>
      <name>Legacy Pattern Scanner</name>
      <script>scripts/scan_legacy_patterns.py</script>
      <description>Automated detection of legacy code patterns</description>
      <frequency>Weekly in CI/CD pipeline</frequency>
    </tool>
    
    <tool>
      <name>Complexity Analyzer</name>
      <script>scripts/analyze_complexity.py</script>
      <description>Generate complexity metrics and trends</description>
      <frequency>On every pull request</frequency>
    </tool>
    
    <tool>
      <name>Import Graph Generator</name>
      <script>scripts/generate_import_graph.py</script>
      <description>Visualize and detect circular dependencies</description>
      <frequency>Monthly architecture review</frequency>
    </tool>
    
    <tool>
      <name>Dead Code Detector</name>
      <script>scripts/detect_dead_code.py</script>
      <description>Find unused code via static analysis</description>
      <frequency>Before each cleanup cycle</frequency>
    </tool>
  </automation_tools>

  <best_practices>
    <practice>
      <name>Incremental Cleanup</name>
      <description>Clean up code in small, reviewable chunks rather than large rewrites</description>
    </practice>
    
    <practice>
      <name>Test-First Cleanup</name>
      <description>Ensure comprehensive tests exist before modifying legacy code</description>
    </practice>
    
    <practice>
      <name>Document Decisions</name>
      <description>Record why code was removed and what it was replaced with</description>
    </practice>
    
    <practice>
      <name>Monitor Impact</name>
      <description>Track metrics before and after cleanup to verify improvements</description>
    </practice>
    
    <practice>
      <name>Team Communication</name>
      <description>Announce cleanup plans and timelines to all stakeholders</description>
    </practice>
    
    <practice>
      <name>Preserve History</name>
      <description>Archive removed code with clear commit messages for future reference</description>
    </practice>
  </best_practices>

  <risk_mitigation>
    <risk level="HIGH">
      <description>Breaking production functionality</description>
      <mitigation>
        - Comprehensive test coverage before changes
        - Staged rollout with monitoring
        - Immediate rollback capability
        - Feature flags for gradual migration
      </mitigation>
    </risk>
    
    <risk level="MEDIUM">
      <description>Performance degradation</description>
      <mitigation>
        - Benchmark critical paths before/after
        - Load testing in staging environment
        - Canary deployments with metrics
        - Performance budget enforcement
      </mitigation>
    </risk>
    
    <risk level="MEDIUM">
      <description>Lost domain knowledge</description>
      <mitigation>
        - Document removed functionality
        - Create architecture decision records
        - Knowledge transfer sessions
        - Maintain changelog of removals
      </mitigation>
    </risk>
    
    <risk level="LOW">
      <description>Team resistance to change</description>
      <mitigation>
        - Involve team in planning process
        - Show measurable improvements
        - Celebrate cleanup victories
        - Provide training on new patterns
      </mitigation>
    </risk>
  </risk_mitigation>

  <success_indicators>
    <indicator>
      <name>Build Time Reduction</name>
      <target>20% faster builds after cleanup</target>
    </indicator>
    
    <indicator>
      <name>Test Execution Speed</name>
      <target>30% faster test suite execution</target>
    </indicator>
    
    <indicator>
      <name>Codebase Size</name>
      <target>15% reduction in lines of code</target>
    </indicator>
    
    <indicator>
      <name>Developer Velocity</name>
      <target>25% faster feature development</target>
    </indicator>
    
    <indicator>
      <name>Bug Rate</name>
      <target>20% reduction in bug reports</target>
    </indicator>
    
    <indicator>
      <name>Onboarding Time</name>
      <target>30% faster new developer onboarding</target>
    </indicator>
  </success_indicators>

  <maintenance_schedule>
    <activity frequency="WEEKLY">
      <name>Legacy Pattern Scan</name>
      <description>Run automated tools to detect new legacy patterns</description>
    </activity>
    
    <activity frequency="MONTHLY">
      <name>Cleanup Sprint</name>
      <description>Dedicate 20% of sprint to legacy cleanup</description>
    </activity>
    
    <activity frequency="QUARTERLY">
      <name>Architecture Review</name>
      <description>Review system architecture for complexity growth</description>
    </activity>
    
    <activity frequency="YEARLY">
      <name>Major Cleanup Initiative</name>
      <description>Large-scale legacy removal project</description>
    </activity>
  </maintenance_schedule>
</legacy_code_cleanup_specification>