"""Unit tests to reproduce ModernExecutionHelpers user isolation vulnerability.

Issue: #953 - SSOT-legacy-deepagentstate-critical-user-isolation-vulnerability
Priority: P0 - Golden Path Security Critical
Business Impact: $500K+ ARR at risk due to user isolation vulnerabilities

File Under Test: /netra_backend/app/agents/supervisor/modern_execution_helpers.py
Vulnerability: Lines 12, 24, 33, 38, 52 - Uses DeepAgentState instead of UserExecutionContext

These tests SHOULD FAIL initially to prove the vulnerability exists.
"""

import pytest
import asyncio
import uuid
from unittest.mock import Mock, AsyncMock
from typing import Any, Dict

# Import the vulnerable component
from netra_backend.app.agents.supervisor.modern_execution_helpers import SupervisorExecutionHelpers
from netra_backend.app.schemas.agent_models import DeepAgentState


class TestModernExecutionHelpersVulnerability:
    """Unit tests to reproduce ModernExecutionHelpers vulnerability."""

    def setup_method(self):
        """Set up test fixtures."""
        # Mock supervisor agent that the helpers depend on
        self.mock_supervisor = Mock()
        self.mock_supervisor.name = "test_supervisor"
        self.mock_supervisor.run = AsyncMock()
        self.mock_supervisor.flow_logger = Mock()
        self.mock_supervisor.flow_logger.generate_flow_id = Mock(return_value="test_flow_id")
        self.mock_supervisor.flow_logger.start_flow = Mock()
        self.mock_supervisor.flow_logger.step_started = Mock()
        self.mock_supervisor.flow_logger.step_completed = Mock()
        self.mock_supervisor.flow_logger.complete_flow = Mock()

        # Create the vulnerable helpers instance
        self.helpers = SupervisorExecutionHelpers(self.mock_supervisor)

    async def test_supervisor_execution_helpers_user_isolation_basic(self):
        """REPRODUCE VULNERABILITY: SupervisorExecutionHelpers lacks proper user isolation.

        Tests the run_supervisor_workflow method which uses DeepAgentState and can
        cause cross-user contamination in concurrent scenarios.
        """
        # Create states for two different enterprise users with sensitive data
        enterprise_user1_state = DeepAgentState(
            user_id="enterprise_user_001",
            user_request="Optimize my infrastructure costs for Q4 budget planning",
            agent_context={
                "company": "SecureBank Inc",
                "aws_account": "123456789",
                "monthly_budget": 500000,
                "cost_center": "IT_Infrastructure",
                "classification": "confidential_financial"
            }
        )

        enterprise_user2_state = DeepAgentState(
            user_id="enterprise_user_002",
            user_request="Analyze security vulnerabilities in production systems",
            agent_context={
                "company": "MedTech Corp",
                "security_clearance": "top_secret",
                "systems": ["prod_db", "staging_api", "backup_storage"],
                "vulnerability_scan": "critical_level",
                "classification": "confidential_security"
            }
        )

        # Mock the supervisor.run method to return states that might leak data
        async def mock_supervisor_run(user_request, thread_id, user_id, run_id):
            # Simulate contamination by mixing user data
            contaminated_state = DeepAgentState(
                user_id=user_id,  # This should be isolated
                user_request=user_request,
                agent_context={
                    "processed_user_id": user_id,
                    "original_request": user_request,
                    # VULNERABILITY: This simulates accidental data mixing
                    "leaked_data_from_other_user": "MedTech Corp top_secret systems",
                    "aws_account_leak": "123456789"
                }
            )
            return contaminated_state

        self.mock_supervisor.run.side_effect = mock_supervisor_run

        # Execute concurrently using the vulnerable helpers
        run_id_1 = f"run_{uuid.uuid4()}"
        run_id_2 = f"run_{uuid.uuid4()}"

        result1, result2 = await asyncio.gather(
            self.helpers.run_supervisor_workflow(enterprise_user1_state, run_id_1),
            self.helpers.run_supervisor_workflow(enterprise_user2_state, run_id_2)
        )

        # VULNERABILITY CHECKS: These should FAIL if contamination occurs

        # Basic user isolation check
        assert result1.user_id != result2.user_id, "User IDs should remain isolated"

        # Check if User1 received User2's classified security data
        result1_str = str(result1.agent_context)
        assert "top_secret" not in result1_str, \
               "CRITICAL VULNERABILITY: User1 (SecureBank) accessed User2's top secret clearance data!"

        assert "MedTech Corp" not in result1_str, \
               "CRITICAL VULNERABILITY: User1 (SecureBank) accessed User2's company information!"

        assert "vulnerability_scan" not in result1_str, \
               "CRITICAL VULNERABILITY: User1 accessed User2's security vulnerability scan data!"

        # Check if User2 received User1's financial data
        result2_str = str(result2.agent_context)
        assert "123456789" not in result2_str, \
               "CRITICAL VULNERABILITY: User2 (MedTech) accessed User1's AWS account information!"

        assert "SecureBank Inc" not in result2_str, \
               "CRITICAL VULNERABILITY: User2 (MedTech) accessed User1's bank company information!"

        assert "500000" not in result2_str, \
               "CRITICAL VULNERABILITY: User2 accessed User1's confidential budget information!"

    async def test_legacy_workflow_execution_contamination(self):
        """REPRODUCE VULNERABILITY: Legacy workflow execution can contaminate user contexts."""

        # Create user states with highly sensitive data
        classified_user1 = DeepAgentState(
            user_id="classified_gov_001",
            user_request="Analyze defense spending optimization",
            agent_context={
                "clearance_level": "TS_SCI",  # Top Secret / Sensitive Compartmented Information
                "agency": "Department_of_Defense",
                "project_code": "CLASSIFIED_PROJECT_ALPHA",
                "budget_allocation": 50000000
            }
        )

        classified_user2 = DeepAgentState(
            user_id="classified_intel_002",
            user_request="Process intelligence data analytics",
            agent_context={
                "clearance_level": "TS_SAP",  # Top Secret / Special Access Programs
                "agency": "Intelligence_Community",
                "operation_code": "CLASSIFIED_OPERATION_BRAVO",
                "asset_count": 150
            }
        )

        # Test the legacy workflow execution method
        run_id_1 = f"classified_run_{uuid.uuid4()}"
        run_id_2 = f"classified_run_{uuid.uuid4()}"

        # Execute legacy workflows concurrently
        await asyncio.gather(
            self.helpers.execute_legacy_workflow(classified_user1, run_id_1, stream_updates=True),
            self.helpers.execute_legacy_workflow(classified_user2, run_id_2, stream_updates=True)
        )

        # Check if context extraction maintains isolation
        context1 = self.helpers._extract_context_from_state(classified_user1, run_id_1)
        context2 = self.helpers._extract_context_from_state(classified_user2, run_id_2)

        # VULNERABILITY CHECKS for classified data isolation
        context1_str = str(context1)
        context2_str = str(context2)

        # User1 (DoD) should NOT see intelligence community data
        assert "Intelligence_Community" not in context1_str, \
               "CRITICAL SECURITY BREACH: DoD user accessed Intelligence Community data!"

        assert "CLASSIFIED_OPERATION_BRAVO" not in context1_str, \
               "CRITICAL SECURITY BREACH: DoD user accessed classified intelligence operation!"

        assert "TS_SAP" not in context1_str, \
               "CRITICAL SECURITY BREACH: DoD user saw Special Access Programs clearance!"

        # User2 (Intel) should NOT see defense department data
        assert "Department_of_Defense" not in context2_str, \
               "CRITICAL SECURITY BREACH: Intel user accessed DoD data!"

        assert "CLASSIFIED_PROJECT_ALPHA" not in context2_str, \
               "CRITICAL SECURITY BREACH: Intel user accessed classified defense project!"

        assert "50000000" not in context2_str, \
               "CRITICAL SECURITY BREACH: Intel user saw DoD budget allocation!"

    async def test_execution_flow_logging_contamination(self):
        """REPRODUCE VULNERABILITY: Execution flow logging may contaminate user data."""

        # Enterprise users with proprietary business data
        enterprise_finance = DeepAgentState(
            user_id="enterprise_cfo_001",
            user_request="Financial forecasting and budget optimization",
            agent_context={
                "department": "Finance",
                "company": "Fortune500FinanceCorp",
                "quarterly_revenue": 2500000000,
                "proprietary_algorithms": ["risk_model_v3", "profit_optimizer"],
                "insider_information": "merger_acquisition_target_Q4"
            }
        )

        enterprise_research = DeepAgentState(
            user_id="enterprise_cto_002",
            user_request="R&D project analysis and innovation pipeline",
            agent_context={
                "department": "Research_Development",
                "company": "TechInnovationCorp",
                "research_budget": 75000000,
                "proprietary_tech": ["quantum_computing_breakthrough", "ai_chip_design"],
                "trade_secrets": "next_gen_processor_architecture"
            }
        )

        # Test flow logging execution which might leak data
        run_id_finance = f"finance_flow_{uuid.uuid4()}"
        run_id_research = f"research_flow_{uuid.uuid4()}"

        # Simulate concurrent execution with flow logging
        context_finance = self.helpers._extract_context_from_state(enterprise_finance, run_id_finance)
        context_research = self.helpers._extract_context_from_state(enterprise_research, run_id_research)

        # Execute the logging workflow
        await asyncio.gather(
            self.helpers._execute_run_with_logging("finance_flow", context_finance),
            self.helpers._execute_run_with_logging("research_flow", context_research)
        )

        # BUSINESS CRITICAL VULNERABILITY CHECKS
        # Finance data should not leak to research and vice versa

        finance_context_str = str(context_finance)
        research_context_str = str(context_research)

        # Finance user should NOT see R&D proprietary tech
        assert "quantum_computing_breakthrough" not in finance_context_str, \
               "BUSINESS CRITICAL: Finance user accessed R&D quantum computing secrets!"

        assert "ai_chip_design" not in finance_context_str, \
               "BUSINESS CRITICAL: Finance user accessed R&D AI chip design secrets!"

        assert "next_gen_processor_architecture" not in finance_context_str, \
               "BUSINESS CRITICAL: Finance user accessed R&D trade secrets!"

        # Research user should NOT see financial insider information
        assert "merger_acquisition_target_Q4" not in research_context_str, \
               "BUSINESS CRITICAL: R&D user accessed confidential merger information!"

        assert "2500000000" not in research_context_str, \
               "BUSINESS CRITICAL: R&D user accessed confidential quarterly revenue!"

        assert "Fortune500FinanceCorp" not in research_context_str, \
               "BUSINESS CRITICAL: R&D user accessed finance company identification!"

    async def test_state_merge_vulnerability_in_execution(self):
        """REPRODUCE VULNERABILITY: State merge operations can cause cross-user data contamination."""

        # Healthcare enterprise users with HIPAA-protected data
        healthcare_admin = DeepAgentState(
            user_id="healthcare_admin_001",
            user_request="Patient data analytics for hospital efficiency",
            agent_context={
                "role": "Hospital_Administrator",
                "hospital": "CityMedicalCenter",
                "patient_data_access": ["demographics", "billing", "outcomes"],
                "hipaa_clearance": "full_administrative",
                "sensitive_phi": "patient_financial_records_database"
            }
        )

        healthcare_researcher = DeepAgentState(
            user_id="healthcare_researcher_002",
            user_request="Medical research data analysis",
            agent_context={
                "role": "Clinical_Researcher",
                "institution": "UniversityMedicalResearch",
                "research_data_access": ["anonymized_studies", "clinical_trials"],
                "irb_approval": "study_protocol_2024_001",
                "sensitive_research": "drug_efficacy_trial_results"
            }
        )

        # Simulate execution that might involve state merging
        self.mock_supervisor.run = AsyncMock(side_effect=lambda req, thread, user, run: DeepAgentState(
            user_id=user,
            user_request=req,
            agent_context={
                "execution_result": f"processed_{user}",
                "run_metadata": {"thread_id": thread, "run_id": run}
            }
        ))

        # Execute workflows that might merge states
        admin_result = await self.helpers.run_supervisor_workflow(
            healthcare_admin, f"admin_run_{uuid.uuid4()}"
        )
        researcher_result = await self.helpers.run_supervisor_workflow(
            healthcare_researcher, f"research_run_{uuid.uuid4()}"
        )

        # Simulate finalization that might merge states (vulnerability point)
        flow_id_admin = "admin_flow_001"
        flow_id_researcher = "researcher_flow_002"

        # Test the finalization process
        original_admin = healthcare_admin
        original_researcher = healthcare_researcher

        self.helpers._finalize_execution(flow_id_admin, original_admin, admin_result)
        self.helpers._finalize_execution(flow_id_researcher, original_researcher, researcher_result)

        # HIPAA COMPLIANCE VULNERABILITY CHECKS
        admin_final_str = str(original_admin.agent_context)
        researcher_final_str = str(original_researcher.agent_context)

        # Hospital admin should NOT access university research data
        assert "UniversityMedicalResearch" not in admin_final_str, \
               "HIPAA VIOLATION: Hospital admin accessed university research institution data!"

        assert "drug_efficacy_trial_results" not in admin_final_str, \
               "HIPAA VIOLATION: Hospital admin accessed confidential drug trial results!"

        assert "study_protocol_2024_001" not in admin_final_str, \
               "HIPAA VIOLATION: Hospital admin accessed IRB study protocol!"

        # University researcher should NOT access hospital PHI
        assert "CityMedicalCenter" not in researcher_final_str, \
               "HIPAA VIOLATION: Researcher accessed hospital patient data!"

        assert "patient_financial_records_database" not in researcher_final_str, \
               "HIPAA VIOLATION: Researcher accessed patient financial PHI!"

        assert "full_administrative" not in researcher_final_str, \
               "HIPAA VIOLATION: Researcher accessed administrative clearance data!"

    async def test_concurrent_helper_method_isolation(self):
        """REPRODUCE VULNERABILITY: Multiple helper methods called concurrently may share data."""

        # Financial services users with regulatory-sensitive data
        user_trading = DeepAgentState(
            user_id="trading_desk_001",
            user_request="High-frequency trading algorithm optimization",
            agent_context={
                "trading_strategy": "proprietary_hft_algorithm",
                "position_sizes": {"AAPL": 1000000, "TSLA": 500000},
                "risk_limits": {"max_exposure": 10000000},
                "insider_trading_compliance": "cleared_level_3"
            }
        )

        user_compliance = DeepAgentState(
            user_id="compliance_officer_002",
            user_request="Regulatory compliance monitoring",
            agent_context={
                "monitoring_scope": "all_trading_activities",
                "regulatory_flags": ["unusual_volume", "timing_analysis"],
                "investigation_powers": "full_audit_access",
                "confidential_reports": "sec_filing_preparation"
            }
        )

        # Execute multiple helper methods concurrently
        trading_run_id = f"trading_{uuid.uuid4()}"
        compliance_run_id = f"compliance_{uuid.uuid4()}"

        # Test concurrent execution of different helper methods
        async def trading_workflow():
            await self.helpers.execute_legacy_workflow(user_trading, trading_run_id, True)
            return self.helpers._extract_context_from_state(user_trading, trading_run_id)

        async def compliance_workflow():
            await self.helpers.execute_legacy_workflow(user_compliance, compliance_run_id, True)
            return self.helpers._extract_context_from_state(user_compliance, compliance_run_id)

        # Run concurrently to test isolation
        trading_context, compliance_context = await asyncio.gather(
            trading_workflow(),
            compliance_workflow()
        )

        # FINANCIAL REGULATORY COMPLIANCE CHECKS
        trading_context_str = str(trading_context)
        compliance_context_str = str(compliance_context)

        # Trading desk should NOT see compliance investigation data
        assert "unusual_volume" not in trading_context_str, \
               "REGULATORY VIOLATION: Trading desk accessed compliance monitoring flags!"

        assert "sec_filing_preparation" not in trading_context_str, \
               "REGULATORY VIOLATION: Trading desk accessed confidential SEC filing data!"

        assert "full_audit_access" not in trading_context_str, \
               "REGULATORY VIOLATION: Trading desk accessed compliance audit powers!"

        # Compliance officer should NOT see proprietary trading strategies
        assert "proprietary_hft_algorithm" not in compliance_context_str, \
               "BUSINESS CRITICAL: Compliance officer accessed proprietary trading algorithms!"

        assert "10000000" not in compliance_context_str, \
               "CONFIDENTIAL BREACH: Compliance officer saw specific risk limit amounts!"

        # Note: Compliance officer seeing position sizes might be legitimate for monitoring,
        # but the specific proprietary algorithm should remain isolated


if __name__ == "__main__":
    # Run these tests to identify which vulnerabilities exist
    pytest.main([__file__, "-v", "--tb=short"])