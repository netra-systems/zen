"""
Unit tests for Issue #1116: Agent Instance Factory Singleton Vulnerability

PURPOSE: Prove that get_agent_instance_factory() singleton causes user context leakage
- User A's responses going to User B due to shared factory instance
- Testing the vulnerability that create_agent_instance_factory(user_context) should fix

VULNERABILITY HYPOTHESIS: 
- Singleton factory shares state between users
- UserExecutionContext gets contaminated across requests
- Agent instances leak data between concurrent users

EXPECTED RESULT: These tests should FAIL initially, proving the vulnerability exists
"""

import pytest
import asyncio
import uuid
from unittest.mock import Mock, patch
from concurrent.futures import ThreadPoolExecutor
import threading
import time

from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.agents.supervisor.agent_instance_factory import (
    get_agent_instance_factory,  # VULNERABLE singleton
    # create_agent_instance_factory,  # SECURE per-user factory - not implemented yet
)
from netra_backend.app.agents.supervisor_agent_modern import SupervisorAgent
from netra_backend.app.services.user_execution_context import UserExecutionContext


class TestAgentInstanceFactorySingletonVulnerability(SSotAsyncTestCase):
    """
    Test suite to PROVE singleton vulnerability in agent instance factory.
    
    These tests should FAIL to demonstrate:
    1. Singleton factory shares state between users
    2. UserExecutionContext contamination across requests  
    3. Agent responses going to wrong users
    """

    def setUp(self):
        """Set up test environment with mock user contexts."""
        super().setUp()
        
        # Create distinct user contexts that should remain isolated
        self.user_a_context = UserExecutionContext(
            user_id="user_a_12345",
            thread_id=str(uuid.uuid4()),
            run_id=str(uuid.uuid4()),
            request_id=str(uuid.uuid4()),
            websocket_client_id="ws_alice_123",
            agent_context={"user_name": "Alice", "role": "admin"}
        )
        
        self.user_b_context = UserExecutionContext(
            user_id="user_b_67890",
            thread_id=str(uuid.uuid4()),
            run_id=str(uuid.uuid4()),
            request_id=str(uuid.uuid4()),
            websocket_client_id="ws_bob_456",
            agent_context={"user_name": "Bob", "role": "user"}
        )

    def test_singleton_factory_shares_instance_vulnerability(self):
        """
        VULNERABILITY TEST: Prove singleton factory returns same instance
        
        EXPECTED: This test should PASS (proving vulnerability exists)
        - Same factory instance returned for different users
        - State contamination risk confirmed
        """
        factory_1 = get_agent_instance_factory()
        factory_2 = get_agent_instance_factory()
        
        # VULNERABILITY: Same instance means shared state
        self.assertIs(factory_1, factory_2, 
                     "SINGLETON VULNERABILITY CONFIRMED: Same factory instance for all users")
        
        # Verify it's truly the same object in memory
        self.assertEqual(id(factory_1), id(factory_2),
                        "MEMORY ADDRESS CONFIRMATION: Singleton shares memory between users")

    def test_user_context_contamination_vulnerability(self):
        """
        VULNERABILITY TEST: Prove user context gets contaminated
        
        EXPECTED: This test should FAIL (proving vulnerability)  
        - User A's context contaminated by User B
        - Data leakage between user sessions
        """
        factory = get_agent_instance_factory()
        
        # User A creates agent first
        agent_a = asyncio.run(factory.create_agent("supervisor", self.user_a_context))
        original_user_a_id = agent_a.user_execution_context.user_id
        original_metadata_a = agent_a.user_execution_context.agent_context.copy()
        
        # User B creates agent - this should NOT affect User A's agent
        agent_b = asyncio.run(factory.create_agent("supervisor", self.user_b_context)) 
        
        # VULNERABILITY CHECK: User A's context should remain unchanged
        # This assertion SHOULD FAIL if vulnerability exists
        self.assertEqual(agent_a.user_execution_context.user_id, original_user_a_id,
                        f"VULNERABILITY: User A's ID changed from {original_user_a_id} "
                        f"to {agent_a.user_execution_context.user_id}")
        
        self.assertEqual(agent_a.user_execution_context.agent_context, original_metadata_a,
                        f"VULNERABILITY: User A's metadata contaminated: "
                        f"Original: {original_metadata_a}, "
                        f"Current: {agent_a.user_execution_context.agent_context}")

    def test_concurrent_agent_creation_race_condition(self):
        """
        VULNERABILITY TEST: Prove race condition in concurrent agent creation
        
        EXPECTED: This test should FAIL (proving race condition)
        - Concurrent agent creation causes context mixing
        - Thread safety violations confirmed
        """
        factory = get_agent_instance_factory()
        results = {}
        errors = []
        
        def create_agent_for_user(user_id, user_context):
            """Create agent and verify context integrity."""
            try:
                agent = asyncio.run(factory.create_agent("supervisor", user_context))
                # Small delay to increase race condition probability
                time.sleep(0.01)
                
                # Verify agent has correct user context
                actual_user_id = agent.user_execution_context.user_id
                results[user_id] = {
                    'expected_user_id': user_context.user_id,
                    'actual_user_id': actual_user_id,
                    'context_match': actual_user_id == user_context.user_id,
                    'thread_id': threading.current_thread().ident
                }
            except Exception as e:
                errors.append(f"User {user_id}: {str(e)}")
        
        # Create multiple users concurrently
        user_contexts = {}
        for i in range(5):
            user_id = f"user_{i}"
            user_contexts[user_id] = UserExecutionContext(
                user_id=user_id,
                thread_id=str(uuid.uuid4()),
                run_id=str(uuid.uuid4()),
                request_id=str(uuid.uuid4()),
                websocket_client_id=f"ws_{user_id}",
                agent_context={"user_name": f"User{i}", "role": "test"}
            )
        
        # Execute concurrent agent creation
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = []
            for user_id, context in user_contexts.items():
                future = executor.submit(create_agent_for_user, user_id, context)
                futures.append(future)
            
            # Wait for all to complete
            for future in futures:
                future.result()
        
        # Analyze results for context contamination
        self.assertEqual(len(errors), 0, f"Errors during concurrent creation: {errors}")
        
        contaminated_users = []
        for user_id, result in results.items():
            if not result['context_match']:
                contaminated_users.append({
                    'user_id': user_id,
                    'expected': result['expected_user_id'],
                    'actual': result['actual_user_id'],
                    'thread': result['thread_id']
                })
        
        # This assertion SHOULD FAIL if race condition exists
        self.assertEqual(len(contaminated_users), 0, 
                        f"RACE CONDITION VULNERABILITY: {len(contaminated_users)} users "
                        f"had contaminated contexts: {contaminated_users}")

    def test_agent_state_persistence_vulnerability(self):
        """
        VULNERABILITY TEST: Prove agent state persists between user requests
        
        EXPECTED: This test should FAIL (proving state persistence vulnerability)
        - Previous user's state affects new user's agent
        - Factory doesn't properly isolate agent instances
        """
        factory = get_agent_instance_factory()
        
        # User A creates agent and modifies some internal state
        agent_a = asyncio.run(factory.create_agent("supervisor", self.user_a_context))
        
        # Simulate agent processing that modifies internal state
        agent_a._execution_history = ["User A executed task 1", "User A executed task 2"]
        agent_a._current_workflow_state = {"step": "analysis", "user": "Alice"}
        
        # User B creates a NEW agent - should have clean state
        agent_b = asyncio.run(factory.create_agent("supervisor", self.user_b_context))
        
        # VULNERABILITY CHECK: Agent B should have clean state
        # These assertions SHOULD FAIL if state persists
        self.assertEqual(getattr(agent_b, '_execution_history', []), [],
                        f"VULNERABILITY: Agent B inherited execution history from User A: "
                        f"{getattr(agent_b, '_execution_history', [])}")
        
        self.assertEqual(getattr(agent_b, '_current_workflow_state', {}), {},
                        f"VULNERABILITY: Agent B inherited workflow state from User A: "
                        f"{getattr(agent_b, '_current_workflow_state', {})}")

    def test_websocket_manager_cross_contamination(self):
        """
        VULNERABILITY TEST: Prove WebSocket managers get cross-contaminated
        
        EXPECTED: This test should FAIL (proving WebSocket contamination)
        - User A's WebSocket manager used for User B  
        - Messages sent to wrong user's WebSocket connection
        """
        factory = get_agent_instance_factory()
        
        # Create distinct WebSocket managers for each user
        websocket_a = Mock()
        websocket_a.user_id = "user_a_12345"
        websocket_a.connection_id = "conn_a"
        
        websocket_b = Mock() 
        websocket_b.user_id = "user_b_67890"
        websocket_b.connection_id = "conn_b"
        
        # Create agents  
        agent_a = asyncio.run(factory.create_agent("supervisor", self.user_a_context))
        agent_b = asyncio.run(factory.create_agent("supervisor", self.user_b_context))
        
        # VULNERABILITY CHECK: Each agent should have correct WebSocket client ID
        # These assertions SHOULD FAIL if WebSocket contamination exists
        self.assertEqual(agent_a.user_execution_context.websocket_client_id, "ws_alice_123",
                        f"VULNERABILITY: Agent A has wrong WebSocket client ID. "
                        f"Expected: ws_alice_123, Got: {agent_a.user_execution_context.websocket_client_id}")
        
        self.assertEqual(agent_b.user_execution_context.websocket_client_id, "ws_bob_456", 
                        f"VULNERABILITY: Agent B has wrong WebSocket client ID. "
                        f"Expected: ws_bob_456, Got: {agent_b.user_execution_context.websocket_client_id}")
        
        # Additional check: WebSocket client IDs should be different
        websocket_a_id = agent_a.user_execution_context.websocket_client_id
        websocket_b_id = agent_b.user_execution_context.websocket_client_id
        
        self.assertNotEqual(websocket_a_id, websocket_b_id,
                           f"VULNERABILITY: WebSocket client IDs are same: "
                           f"User A: {websocket_a_id}, User B: {websocket_b_id}")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])