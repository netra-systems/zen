"""
SSOT User Context Extraction Integration Test - ISSUE #814

PURPOSE: Integration test validating user context extraction SSOT compliance
EXPECTED: PASS after SSOT remediation - validates user context from auth service only
TARGET: All user context must come from auth service, never from direct JWT decode

BUSINESS VALUE: Ensures user context consistency for $500K+ ARR user experience
EXECUTION: Staging environment integration - NO Docker dependency
"""
import logging
import pytest
import asyncio
import aiohttp
import json
import os
import time
from typing import Dict, Any, Optional, List, Set
from test_framework.ssot.base_test_case import SSotAsyncTestCase

logger = logging.getLogger(__name__)

class TestUserContextExtractionSSOT(SSotAsyncTestCase):
    """
    Integration test validating user context extraction SSOT compliance.
    Tests that all user context comes from auth service, never from direct JWT parsing.
    """

    @classmethod
    async def asyncSetUpClass(cls):
        """Setup user context SSOT testing environment"""
        await super().asyncSetUpClass()

        # Staging endpoints
        cls.staging_auth_service_url = os.getenv(
            "STAGING_AUTH_SERVICE_URL",
            "https://auth.netra-apex.com"
        )
        cls.staging_backend_url = os.getenv(
            "STAGING_BACKEND_URL",
            "https://backend-staging.netra-apex.com"
        )

        # Test user with rich context
        cls.staging_test_email = "user-context-test@example.com"
        cls.staging_test_password = "UserContext123!"

    async def asyncSetUp(self):
        """Setup individual user context test"""
        await super().asyncSetUp()
        self.http_session = aiohttp.ClientSession()
        self.auth_token = None
        self.auth_service_user_context = None

    async def asyncTearDown(self):
        """Cleanup user context test"""
        if self.http_session:
            await self.http_session.close()
        await super().asyncTearDown()

    async def test_user_context_consistency_across_backend_endpoints(self):
        """
        Integration test: User context consistent across all backend endpoints

        VALIDATES: All backend endpoints get user context from auth service
        ENSURES: No endpoint extracts user context directly from JWT
        """
        # Step 1: Get auth token and reference user context
        logger.info("Getting reference user context from auth service")
        await self._get_auth_token_and_user_context()

        # Step 2: Test user context across multiple backend endpoints
        logger.info("Testing user context across backend endpoints")
        await self._test_user_context_across_endpoints()

        # Step 3: Validate context consistency
        logger.info("Validating user context consistency")
        await self._validate_user_context_consistency()

    async def _get_auth_token_and_user_context(self):
        """Get auth token and reference user context from auth service"""
        login_payload = {
            "email": self.staging_test_email,
            "password": self.staging_test_password,
            "include_full_context": True  # Request full user context
        }

        try:
            async with self.http_session.post(
                f"{self.staging_auth_service_url}/auth/login",
                json=login_payload,
                timeout=30
            ) as response:
                if response.status == 200:
                    auth_data = await response.json()
                    self.auth_token = auth_data["access_token"]
                    self.auth_service_user_context = auth_data.get("user", {})

                    assert self.auth_token is not None, "Auth token from staging auth service"
                    assert self.auth_service_user_context, "User context from auth service"

                    # Log reference context for validation
                    logger.info(f"Reference user context: user_id={self.auth_service_user_context.get('user_id')}, "
                              f"email={self.auth_service_user_context.get('email')}, "
                              f"tier={self.auth_service_user_context.get('tier')}")

                elif response.status == 401:
                    pytest.skip("Staging user context test user not configured")
                else:
                    pytest.fail(f"Auth service context retrieval failed: {response.status}")

        except aiohttp.ClientError as e:
            pytest.skip(f"Staging auth service not accessible: {e}")

    async def _test_user_context_across_endpoints(self):
        """Test user context extraction across multiple backend endpoints"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        # Backend endpoints that should provide user context
        test_endpoints = [
            {
                "path": "/api/v1/user/profile",
                "context_fields": ["user_id", "email", "tier"],
                "description": "User profile endpoint"
            },
            {
                "path": "/api/v1/user/preferences",
                "context_fields": ["user_id"],
                "description": "User preferences endpoint"
            },
            {
                "path": "/api/v1/threads",
                "context_fields": ["user_id"],
                "description": "User threads endpoint"
            },
            {
                "path": "/api/v1/messages/recent",
                "context_fields": ["user_id"],
                "description": "Recent messages endpoint"
            },
            {
                "path": "/api/v1/user/context",
                "context_fields": ["user_id", "email", "tier", "permissions"],
                "description": "User context endpoint"
            }
        ]

        self.endpoint_contexts = []

        for endpoint_config in test_endpoints:
            try:
                async with self.http_session.get(
                    f"{self.staging_backend_url}{endpoint_config['path']}",
                    headers=headers,
                    timeout=30
                ) as response:
                    if response.status == 200:
                        endpoint_data = await response.json()

                        # Extract user context fields
                        context_data = {}
                        for field in endpoint_config["context_fields"]:
                            if field in endpoint_data:
                                context_data[field] = endpoint_data[field]

                        if context_data:
                            self.endpoint_contexts.append({
                                "endpoint": endpoint_config["path"],
                                "description": endpoint_config["description"],
                                "context": context_data,
                                "status": "success"
                            })

                            logger.info(f"User context from {endpoint_config['description']}: {context_data}")

                    elif response.status == 404:
                        # Endpoint not available in staging
                        logger.info(f"Endpoint not available: {endpoint_config['path']}")
                    else:
                        # Authentication or other error
                        logger.warning(f"Endpoint error {endpoint_config['path']}: {response.status}")

            except aiohttp.ClientError as e:
                logger.warning(f"Endpoint {endpoint_config['path']} not accessible: {e}")
                continue

    async def _validate_user_context_consistency(self):
        """Validate user context consistency across endpoints"""
        if not self.endpoint_contexts:
            pytest.skip("No backend endpoints available for user context testing")

        # Validate user_id consistency across all endpoints
        user_ids = [ctx["context"].get("user_id") for ctx in self.endpoint_contexts
                   if "user_id" in ctx["context"]]

        if user_ids:
            unique_user_ids = set(user_ids)
            assert len(unique_user_ids) == 1, \
                f"User ID inconsistent across endpoints: {unique_user_ids}"

            # Compare with auth service reference
            reference_user_id = self.auth_service_user_context.get("user_id")
            if reference_user_id:
                backend_user_id = user_ids[0]
                assert backend_user_id == reference_user_id, \
                    f"Backend user ID ({backend_user_id}) doesn't match auth service ({reference_user_id})"

            logger.info(f"User ID consistent across {len(user_ids)} endpoints: {user_ids[0]}")

        # Validate email consistency where available
        emails = [ctx["context"].get("email") for ctx in self.endpoint_contexts
                 if "email" in ctx["context"]]

        if emails:
            unique_emails = set(emails)
            assert len(unique_emails) == 1, \
                f"Email inconsistent across endpoints: {unique_emails}"

            # Compare with auth service reference
            reference_email = self.auth_service_user_context.get("email")
            if reference_email:
                assert emails[0] == reference_email, \
                    f"Backend email doesn't match auth service reference"

            logger.info(f"Email consistent across {len(emails)} endpoints")

        # Validate tier consistency where available
        tiers = [ctx["context"].get("tier") for ctx in self.endpoint_contexts
                if "tier" in ctx["context"]]

        if tiers:
            unique_tiers = set(tiers)
            assert len(unique_tiers) == 1, \
                f"Tier inconsistent across endpoints: {unique_tiers}"

            logger.info(f"Tier consistent across {len(tiers)} endpoints: {tiers[0]}")

    async def test_user_context_real_time_updates_from_auth_service(self):
        """
        Integration test: User context updates come from auth service in real-time

        VALIDATES: Backend gets fresh user context from auth service, not cached JWT
        ENSURES: User context changes reflected immediately across backend
        """
        # Step 1: Get initial user context
        await self._get_auth_token_and_user_context()

        # Step 2: Get initial backend context
        initial_context = await self._get_backend_user_context()

        # Step 3: Update user context via auth service (if supported)
        context_updated = await self._update_user_context_via_auth_service()

        # Step 4: Verify backend sees updated context
        if context_updated:
            await self._verify_backend_sees_updated_context()

    async def _get_backend_user_context(self) -> Dict[str, Any]:
        """Get user context from backend"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        try:
            async with self.http_session.get(
                f"{self.staging_backend_url}/api/v1/user/context",
                headers=headers,
                timeout=30
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    # Fallback to profile endpoint
                    async with self.http_session.get(
                        f"{self.staging_backend_url}/api/v1/user/profile",
                        headers=headers,
                        timeout=30
                    ) as profile_response:
                        if profile_response.status == 200:
                            return await profile_response.json()

        except aiohttp.ClientError:
            pass

        return {}

    async def _update_user_context_via_auth_service(self) -> bool:
        """Update user context via auth service (if supported in staging)"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        # Try to update user preferences/context
        update_payload = {
            "preferences": {
                "theme": "dark",
                "notifications": True,
                "test_update_timestamp": time.time()
            }
        }

        try:
            async with self.http_session.put(
                f"{self.staging_auth_service_url}/auth/user/preferences",
                headers=headers,
                json=update_payload,
                timeout=30
            ) as response:
                if response.status == 200:
                    logger.info("User context updated via auth service")
                    return True
                else:
                    logger.info("User context update not supported in staging")
                    return False

        except aiohttp.ClientError:
            logger.info("User context update endpoint not available")
            return False

    async def _verify_backend_sees_updated_context(self):
        """Verify backend sees updated context from auth service"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        # Small delay to allow for auth service propagation
        await asyncio.sleep(1)

        try:
            async with self.http_session.get(
                f"{self.staging_backend_url}/api/v1/user/context",
                headers=headers,
                timeout=30
            ) as response:
                if response.status == 200:
                    updated_context = await response.json()

                    # Look for the test update timestamp
                    preferences = updated_context.get("preferences", {})
                    if "test_update_timestamp" in preferences:
                        logger.info("Backend sees updated context from auth service")
                        assert preferences["theme"] == "dark", "Backend has updated preferences"
                    else:
                        logger.info("Context update not reflected in backend (expected in some configurations)")

        except aiohttp.ClientError:
            logger.info("Context verification not available")

    async def test_user_permissions_extraction_from_auth_service(self):
        """
        Integration test: User permissions extracted from auth service only

        VALIDATES: User permissions come from auth service, not JWT claims
        ENSURES: Permission changes immediately reflected in backend
        """
        # Step 1: Authenticate and get reference permissions
        await self._get_auth_token_and_user_context()

        # Step 2: Get permissions from auth service directly
        auth_service_permissions = await self._get_permissions_from_auth_service()

        # Step 3: Get permissions from backend endpoints
        backend_permissions = await self._get_permissions_from_backend()

        # Step 4: Compare permission consistency
        await self._validate_permission_consistency(auth_service_permissions, backend_permissions)

    async def _get_permissions_from_auth_service(self) -> Set[str]:
        """Get user permissions directly from auth service"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        try:
            async with self.http_session.get(
                f"{self.staging_auth_service_url}/auth/user/permissions",
                headers=headers,
                timeout=30
            ) as response:
                if response.status == 200:
                    permissions_data = await response.json()
                    permissions_list = permissions_data.get("permissions", [])

                    logger.info(f"Auth service permissions: {permissions_list}")
                    return set(permissions_list)

        except aiohttp.ClientError:
            pass

        # Fallback to login context permissions
        login_permissions = self.auth_service_user_context.get("permissions", [])
        return set(login_permissions)

    async def _get_permissions_from_backend(self) -> Set[str]:
        """Get user permissions from backend endpoints"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        backend_permissions = set()

        # Try multiple endpoints that might expose permissions
        permission_endpoints = [
            "/api/v1/user/permissions",
            "/api/v1/user/context",
            "/api/v1/user/profile"
        ]

        for endpoint in permission_endpoints:
            try:
                async with self.http_session.get(
                    f"{self.staging_backend_url}{endpoint}",
                    headers=headers,
                    timeout=30
                ) as response:
                    if response.status == 200:
                        endpoint_data = await response.json()

                        # Extract permissions from various possible fields
                        for perm_field in ["permissions", "user_permissions", "access"]:
                            if perm_field in endpoint_data:
                                perms = endpoint_data[perm_field]
                                if isinstance(perms, list):
                                    backend_permissions.update(perms)
                                elif isinstance(perms, dict):
                                    # Permissions might be in dict format
                                    backend_permissions.update(perms.keys())

            except aiohttp.ClientError:
                continue

        logger.info(f"Backend permissions: {backend_permissions}")
        return backend_permissions

    async def _validate_permission_consistency(self, auth_perms: Set[str], backend_perms: Set[str]):
        """Validate permission consistency between auth service and backend"""
        if not auth_perms and not backend_perms:
            logger.info("No permissions found in staging environment")
            return

        if auth_perms and backend_perms:
            # Permissions should be consistent
            missing_in_backend = auth_perms - backend_perms
            extra_in_backend = backend_perms - auth_perms

            if missing_in_backend:
                logger.warning(f"Permissions missing in backend: {missing_in_backend}")

            if extra_in_backend:
                logger.warning(f"Extra permissions in backend: {extra_in_backend}")

            # At least some permissions should match
            common_perms = auth_perms & backend_perms
            assert len(common_perms) > 0 or len(auth_perms) == 0, \
                "Backend permissions should align with auth service"

            logger.info(f"Permission consistency validated: {len(common_perms)} common permissions")

        elif auth_perms:
            # Auth service has permissions, backend should have them too
            logger.warning("Auth service has permissions, but backend doesn't expose them")

    async def test_user_context_session_management_ssot(self):
        """
        Integration test: User context tied to auth service session management

        VALIDATES: User context lifecycle managed by auth service sessions
        ENSURES: Context invalidated when session ends
        """
        # Step 1: Create session with user context
        await self._get_auth_token_and_user_context()

        # Step 2: Get initial backend context
        initial_backend_context = await self._get_backend_user_context()
        assert initial_backend_context, "Initial backend context available"

        # Step 3: End session via auth service
        session_ended = await self._end_auth_service_session()

        # Step 4: Verify backend context no longer available
        if session_ended:
            await self._verify_backend_context_invalidated()

    async def _end_auth_service_session(self) -> bool:
        """End session via auth service"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        try:
            async with self.http_session.post(
                f"{self.staging_auth_service_url}/auth/logout",
                headers=headers,
                timeout=30
            ) as response:
                if response.status == 200:
                    logger.info("Session ended via auth service")
                    return True

        except aiohttp.ClientError:
            pass

        logger.info("Session logout not available in staging")
        return False

    async def _verify_backend_context_invalidated(self):
        """Verify backend context invalidated after session end"""
        headers = {"Authorization": f"Bearer {self.auth_token}"}

        # Backend should reject requests after session invalidation
        try:
            async with self.http_session.get(
                f"{self.staging_backend_url}/api/v1/user/context",
                headers=headers,
                timeout=30
            ) as response:
                assert response.status == 401, \
                    "Backend should reject invalidated session"

                logger.info("Backend properly invalidated context after session end")

        except aiohttp.ClientError:
            logger.info("Backend context invalidation verification not available")

if __name__ == "__main__":
    # Run with: python -m pytest tests/integration/staging_auth/test_user_context_extraction_ssot.py -v
    pytest.main([__file__, "-v"])
