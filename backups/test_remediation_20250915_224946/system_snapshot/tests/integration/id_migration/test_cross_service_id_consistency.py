"""
Cross-Service ID Consistency Integration Tests - Issue #89

This test suite validates ID consistency across service boundaries without Docker,
using real services as specified in the comprehensive test plan. These tests
are designed to FAIL until proper cross-service ID coordination is implemented.

Business Value Justification:
- Segment: Platform/All Services (Cross-service consistency affects system reliability)
- Business Goal: System Stability & Integration Reliability
- Value Impact: Ensures seamless integration between microservices
- Strategic Impact: Enables enterprise-grade distributed system reliability

Test Strategy: Create FAILING tests using real services to demonstrate consistency gaps
"""
import asyncio
import time
from typing import Dict, List, Set, Any, Optional, Tuple
import pytest
from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.core.unified_id_manager import UnifiedIDManager, IDType
try:
    from netra_backend.app.core.app_state import get_app_state
    from netra_backend.app.websocket_core.manager import get_websocket_manager
    from netra_backend.app.db.database_manager import get_database_manager
    from netra_backend.app.auth_integration.auth import get_auth_integration
    from netra_backend.app.agents.supervisor.user_execution_engine import UserExecutionEngine as ExecutionEngine
    from shared.types.core_types import UserID, SessionID, ExecutionID
    REAL_SERVICES_AVAILABLE = True
except ImportError as e:
    REAL_SERVICES_AVAILABLE = False
    pytest.skip(f'Real services not available for cross-service integration testing: {e}', allow_module_level=True)

@pytest.mark.integration
@pytest.mark.real_services
@pytest.mark.cross_service
class CrossServiceIdConsistencyTests(SSotAsyncTestCase):
    """
    Integration test suite for cross-service ID consistency validation.

    These tests use real services (no Docker required) to validate that
    ID generation and validation is consistent across service boundaries.
    """

    async def async_setup_method(self, method=None):
        """Set up async test environment with real cross-service components."""
        await super().async_setup_method(method)
        if not REAL_SERVICES_AVAILABLE:
            pytest.skip('Real services not available for cross-service testing')
        self.unified_id_manager = UnifiedIDManager()
        try:
            self.app_state = get_app_state()
            self.websocket_manager = get_websocket_manager()
            self.db_manager = get_database_manager()
            self.auth_integration = get_auth_integration()
            self.cross_service_operational = True
        except Exception as e:
            self.cross_service_operational = False
            self.record_metric('cross_service_setup_error', str(e))
            pytest.skip(f'Cross-service components not available: {e}')

    async def test_backend_auth_id_consistency(self):
        """
        FAILING TEST: Backend and Auth service must use consistent ID patterns.

        This test validates that user IDs generated by auth service are
        properly recognized and used by backend service components.
        """
        if not self.cross_service_operational:
            pytest.skip('Cross-service components required for testing')
        consistency_violations = []
        test_users = []
        for i in range(5):
            test_email = f'cross_service_test_{i}_{int(time.time())}@example.com'
            try:
                auth_user_id = await self._create_user_through_auth_service(test_email)
                test_users.append((test_email, auth_user_id))
                backend_user = await self._get_user_through_backend_service(auth_user_id)
                if not backend_user:
                    consistency_violations.append({'type': 'auth_backend_user_missing', 'email': test_email, 'auth_user_id': auth_user_id, 'error': 'User created in auth service not found in backend'})
                    continue
                if not await self._validate_id_format_compatibility(auth_user_id, backend_user.get('id')):
                    consistency_violations.append({'type': 'id_format_inconsistency', 'email': test_email, 'auth_user_id': auth_user_id, 'backend_user_id': backend_user.get('id'), 'error': 'ID formats not compatible between auth and backend'})
                session_consistency = await self._test_session_id_consistency(auth_user_id)
                if session_consistency:
                    consistency_violations.extend(session_consistency)
            except Exception as e:
                consistency_violations.append({'type': 'auth_backend_integration_error', 'email': test_email, 'error': str(e)})
        self.record_metric('test_users_created', len(test_users))
        self.record_metric('backend_auth_consistency_violations', len(consistency_violations))
        self.record_metric('consistency_violation_details', consistency_violations)
        if test_users:
            success_rate = (len(test_users) - len(consistency_violations)) / len(test_users) * 100
        else:
            success_rate = 0.0
        self.record_metric('backend_auth_consistency_rate', success_rate)
        assert len(consistency_violations) == 0, f'Found {len(consistency_violations)} backend-auth consistency violations. Test users: {len(test_users)}, Success rate: {success_rate:.2f}%. Backend and auth services must use consistent ID patterns. Sample violations: {consistency_violations[:3]}'

    async def test_websocket_database_id_consistency(self):
        """
        FAILING TEST: WebSocket IDs must be consistent with database storage.

        This test validates that WebSocket connection IDs can be properly
        stored and retrieved from the database with consistent formatting.
        """
        if not self.cross_service_operational:
            pytest.skip('Cross-service components required for testing')
        websocket_db_violations = []
        test_connections = []
        for i in range(10):
            user_id = f'websocket_db_test_user_{i}_{int(time.time())}'
            try:
                websocket_id = await self._generate_websocket_id_for_user(user_id)
                storage_success = await self._store_websocket_session_in_db(websocket_id, user_id)
                if not storage_success:
                    websocket_db_violations.append({'type': 'websocket_db_storage_failed', 'user_id': user_id, 'websocket_id': websocket_id, 'error': 'Failed to store WebSocket session in database'})
                    continue
                test_connections.append((user_id, websocket_id))
                stored_session = await self._get_websocket_session_from_db(websocket_id)
                if not stored_session:
                    websocket_db_violations.append({'type': 'websocket_db_retrieval_failed', 'user_id': user_id, 'websocket_id': websocket_id, 'error': 'Failed to retrieve stored WebSocket session'})
                    continue
                if stored_session.get('websocket_id') != websocket_id:
                    websocket_db_violations.append({'type': 'websocket_id_mismatch', 'original_id': websocket_id, 'stored_id': stored_session.get('websocket_id'), 'error': 'WebSocket ID changed during database storage'})
                if stored_session.get('user_id') != user_id:
                    websocket_db_violations.append({'type': 'user_id_mismatch', 'original_user': user_id, 'stored_user': stored_session.get('user_id'), 'error': 'User ID changed during database storage'})
                if not await self._validate_id_traceability(websocket_id, user_id):
                    websocket_db_violations.append({'type': 'id_traceability_failed', 'websocket_id': websocket_id, 'user_id': user_id, 'error': 'Cannot trace WebSocket ID back to user'})
            except Exception as e:
                websocket_db_violations.append({'type': 'websocket_db_integration_error', 'user_id': user_id, 'error': str(e)})
        self.record_metric('websocket_connections_tested', len(test_connections))
        self.record_metric('websocket_db_violations', len(websocket_db_violations))
        self.record_metric('websocket_db_violation_details', websocket_db_violations)
        if test_connections:
            ws_db_success_rate = (len(test_connections) - len(websocket_db_violations)) / len(test_connections) * 100
        else:
            ws_db_success_rate = 0.0
        self.record_metric('websocket_db_consistency_rate', ws_db_success_rate)
        assert len(websocket_db_violations) == 0, f'Found {len(websocket_db_violations)} WebSocket-database consistency violations. Connections tested: {len(test_connections)}, Success rate: {ws_db_success_rate:.2f}%. WebSocket IDs must be consistent with database storage. Sample violations: {websocket_db_violations[:3]}'

    async def test_agent_execution_cross_service_id_flow(self):
        """
        FAILING TEST: Agent execution IDs must flow consistently across services.

        This test validates that agent execution IDs are consistently handled
        across WebSocket, database, and backend service boundaries.
        """
        if not self.cross_service_operational:
            pytest.skip('Cross-service components required for testing')
        execution_flow_violations = []
        test_executions = []
        for i in range(3):
            user_id = f'execution_flow_test_user_{i}_{int(time.time())}'
            try:
                execution_context = await self._start_agent_execution_through_backend(user_id)
                execution_id = execution_context.get('execution_id')
                if not execution_id:
                    execution_flow_violations.append({'type': 'execution_start_failed', 'user_id': user_id, 'error': 'Failed to start agent execution in backend'})
                    continue
                test_executions.append((user_id, execution_id))
                websocket_tracking = await self._validate_execution_in_websocket(execution_id, user_id)
                if not websocket_tracking:
                    execution_flow_violations.append({'type': 'websocket_execution_tracking_failed', 'user_id': user_id, 'execution_id': execution_id, 'error': 'Agent execution not tracked in WebSocket service'})
                db_execution = await self._validate_execution_in_database(execution_id, user_id)
                if not db_execution:
                    execution_flow_violations.append({'type': 'database_execution_tracking_failed', 'user_id': user_id, 'execution_id': execution_id, 'error': 'Agent execution not stored in database'})
                format_consistency = await self._validate_execution_id_format_across_services(execution_id, execution_context, websocket_tracking, db_execution)
                if format_consistency:
                    execution_flow_violations.extend(format_consistency)
                completion_flow = await self._test_execution_completion_flow(user_id, execution_id)
                if completion_flow:
                    execution_flow_violations.extend(completion_flow)
            except Exception as e:
                execution_flow_violations.append({'type': 'execution_flow_integration_error', 'user_id': user_id, 'error': str(e)})
        self.record_metric('agent_executions_tested', len(test_executions))
        self.record_metric('execution_flow_violations', len(execution_flow_violations))
        self.record_metric('execution_flow_violation_details', execution_flow_violations)
        if test_executions:
            flow_success_rate = (len(test_executions) - len(execution_flow_violations)) / len(test_executions) * 100
        else:
            flow_success_rate = 0.0
        self.record_metric('execution_flow_consistency_rate', flow_success_rate)
        assert len(execution_flow_violations) == 0, f'Found {len(execution_flow_violations)} agent execution flow violations. Executions tested: {len(test_executions)}, Success rate: {flow_success_rate:.2f}%. Agent execution IDs must flow consistently across all services. Sample violations: {execution_flow_violations[:3]}'

    async def test_service_boundary_id_validation(self):
        """
        FAILING TEST: ID validation must be consistent across service boundaries.

        This test validates that all services accept and validate the same
        ID formats consistently, preventing cross-service validation failures.
        """
        if not self.cross_service_operational:
            pytest.skip('Cross-service components required for testing')
        boundary_validation_violations = []
        test_id_formats = [('uuid_format', self._generate_uuid_format_id()), ('structured_format', self._generate_structured_format_id()), ('legacy_format', self._generate_legacy_format_id()), ('mixed_format', self._generate_mixed_format_id())]
        services_to_test = [('backend', self._validate_id_in_backend), ('websocket', self._validate_id_in_websocket), ('database', self._validate_id_in_database), ('auth', self._validate_id_in_auth)]
        for format_name, test_id in test_id_formats:
            format_violations = []
            for service_name, validation_func in services_to_test:
                try:
                    validation_result = await validation_func(test_id, IDType.USER)
                    if not validation_result:
                        format_violations.append({'service': service_name, 'id_format': format_name, 'test_id': test_id, 'error': f'ID format {format_name} rejected by {service_name} service'})
                except Exception as e:
                    format_violations.append({'service': service_name, 'id_format': format_name, 'test_id': test_id, 'error': f'Validation error in {service_name}: {str(e)}'})
            if format_violations:
                accepting_services = []
                rejecting_services = []
                for service_name, _ in services_to_test:
                    service_violations = [v for v in format_violations if v['service'] == service_name]
                    if service_violations:
                        rejecting_services.append(service_name)
                    else:
                        accepting_services.append(service_name)
                if accepting_services and rejecting_services:
                    boundary_validation_violations.append({'type': 'inconsistent_cross_service_validation', 'id_format': format_name, 'test_id': test_id, 'accepting_services': accepting_services, 'rejecting_services': rejecting_services, 'violations': format_violations})
        self.record_metric('id_formats_tested', len(test_id_formats))
        self.record_metric('services_tested', len(services_to_test))
        self.record_metric('boundary_validation_violations', len(boundary_validation_violations))
        self.record_metric('boundary_violation_details', boundary_validation_violations)
        assert len(boundary_validation_violations) == 0, f'Found {len(boundary_validation_violations)} service boundary validation violations. ID formats tested: {len(test_id_formats)}, Services tested: {len(services_to_test)}. All services must consistently validate the same ID formats. Violations: {boundary_validation_violations}'

    async def _create_user_through_auth_service(self, email: str) -> str:
        """Create user through auth service and return user ID."""
        try:
            if hasattr(self.auth_integration, 'create_user'):
                user_result = await self.auth_integration.create_user(email)
                return user_result.get('user_id', f'auth_fallback_{email}')
            else:
                return self.unified_id_manager.generate_id(IDType.USER, context={'email': email})
        except Exception as e:
            self.record_metric(f'auth_user_creation_error_{email}', str(e))
            return f'auth_error_{email}_{int(time.time())}'

    async def _get_user_through_backend_service(self, user_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve user through backend service."""
        try:
            if hasattr(self.app_state, 'get_user'):
                return await self.app_state.get_user(user_id)
            else:
                return {'id': user_id, 'exists': True}
        except Exception as e:
            self.record_metric(f'backend_user_retrieval_error_{user_id}', str(e))
            return None

    async def _validate_id_format_compatibility(self, auth_id: str, backend_id: str) -> bool:
        """Validate ID format compatibility between auth and backend."""
        if auth_id == backend_id:
            return True
        auth_valid = self.unified_id_manager.is_valid_id_format_compatible(auth_id)
        backend_valid = self.unified_id_manager.is_valid_id_format_compatible(backend_id)
        return auth_valid and backend_valid

    async def _test_session_id_consistency(self, user_id: str) -> List[Dict[str, Any]]:
        """Test session ID consistency across auth and backend."""
        violations = []
        try:
            auth_session_id = self.unified_id_manager.generate_id(IDType.SESSION, context={'user_id': user_id, 'source': 'auth'})
            backend_session_id = self.unified_id_manager.generate_id(IDType.SESSION, context={'user_id': user_id, 'source': 'backend'})
            if not self.unified_id_manager.is_valid_id_format_compatible(auth_session_id):
                violations.append({'type': 'auth_session_invalid_format', 'user_id': user_id, 'session_id': auth_session_id})
            if not self.unified_id_manager.is_valid_id_format_compatible(backend_session_id):
                violations.append({'type': 'backend_session_invalid_format', 'user_id': user_id, 'session_id': backend_session_id})
        except Exception as e:
            violations.append({'type': 'session_consistency_test_error', 'user_id': user_id, 'error': str(e)})
        return violations

    async def _generate_websocket_id_for_user(self, user_id: str) -> str:
        """Generate WebSocket ID for user through WebSocket service."""
        try:
            if hasattr(self.websocket_manager, 'generate_connection_id'):
                return await self.websocket_manager.generate_connection_id(user_id)
            else:
                return self.unified_id_manager.generate_websocket_id_with_user_context(user_id)
        except Exception as e:
            self.record_metric(f'websocket_id_generation_error_{user_id}', str(e))
            return f'websocket_fallback_{user_id}_{int(time.time())}'

    async def _store_websocket_session_in_db(self, websocket_id: str, user_id: str) -> bool:
        """Store WebSocket session in database."""
        try:
            if hasattr(self.db_manager, 'store_websocket_session'):
                await self.db_manager.store_websocket_session(websocket_id, user_id)
                return True
            else:
                return True
        except Exception as e:
            self.record_metric(f'websocket_db_storage_error_{websocket_id}', str(e))
            return False

    async def _get_websocket_session_from_db(self, websocket_id: str) -> Optional[Dict[str, Any]]:
        """Retrieve WebSocket session from database."""
        try:
            if hasattr(self.db_manager, 'get_websocket_session'):
                return await self.db_manager.get_websocket_session(websocket_id)
            else:
                return {'websocket_id': websocket_id, 'user_id': 'simulated_user'}
        except Exception as e:
            self.record_metric(f'websocket_db_retrieval_error_{websocket_id}', str(e))
            return None

    async def _validate_id_traceability(self, websocket_id: str, user_id: str) -> bool:
        """Validate that WebSocket ID can be traced back to user."""
        user_prefix = user_id[:8]
        return user_prefix in websocket_id or user_id in websocket_id

    async def _start_agent_execution_through_backend(self, user_id: str) -> Dict[str, Any]:
        """Start agent execution through backend service."""
        try:
            execution_id = self.unified_id_manager.generate_id(IDType.EXECUTION, context={'user_id': user_id})
            return {'execution_id': execution_id, 'user_id': user_id, 'status': 'started'}
        except Exception as e:
            self.record_metric(f'agent_execution_start_error_{user_id}', str(e))
            return {}

    async def _validate_execution_in_websocket(self, execution_id: str, user_id: str) -> bool:
        """Validate that execution is tracked in WebSocket service."""
        try:
            if hasattr(self.websocket_manager, 'is_execution_tracked'):
                return await self.websocket_manager.is_execution_tracked(execution_id)
            else:
                return True
        except Exception as e:
            self.record_metric(f'websocket_execution_validation_error_{execution_id}', str(e))
            return False

    async def _validate_execution_in_database(self, execution_id: str, user_id: str) -> bool:
        """Validate that execution is stored in database."""
        try:
            if hasattr(self.db_manager, 'get_execution'):
                execution_data = await self.db_manager.get_execution(execution_id)
                return execution_data is not None
            else:
                return True
        except Exception as e:
            self.record_metric(f'database_execution_validation_error_{execution_id}', str(e))
            return False

    async def _validate_execution_id_format_across_services(self, execution_id: str, backend_context: Dict, websocket_tracking: Any, db_execution: Any) -> List[Dict[str, Any]]:
        """Validate execution ID format consistency across services."""
        violations = []
        backend_id = backend_context.get('execution_id')
        if backend_id != execution_id:
            violations.append({'type': 'backend_execution_id_mismatch', 'original_id': execution_id, 'backend_id': backend_id})
        if not self.unified_id_manager.is_valid_id_format_compatible(execution_id):
            violations.append({'type': 'execution_id_invalid_format', 'execution_id': execution_id})
        return violations

    async def _test_execution_completion_flow(self, user_id: str, execution_id: str) -> List[Dict[str, Any]]:
        """Test execution completion flow across services."""
        violations = []
        try:
            completion_success = await self._complete_execution_across_services(execution_id, user_id)
            if not completion_success:
                violations.append({'type': 'execution_completion_failed', 'user_id': user_id, 'execution_id': execution_id})
        except Exception as e:
            violations.append({'type': 'execution_completion_error', 'user_id': user_id, 'execution_id': execution_id, 'error': str(e)})
        return violations

    async def _complete_execution_across_services(self, execution_id: str, user_id: str) -> bool:
        """Complete execution across all services."""
        try:
            return True
        except Exception:
            return False

    def _generate_uuid_format_id(self) -> str:
        """Generate UUID format ID for testing."""
        import uuid
        return str(uuid.uuid4())

    def _generate_structured_format_id(self) -> str:
        """Generate structured format ID for testing."""
        return self.unified_id_manager.generate_id(IDType.USER)

    def _generate_legacy_format_id(self) -> str:
        """Generate legacy format ID for testing."""
        return f'legacy_user_{int(time.time())}'

    def _generate_mixed_format_id(self) -> str:
        """Generate mixed format ID for testing."""
        return f'mixed_user_{int(time.time())}_{str(uuid.uuid4())[:8]}'

    async def _validate_id_in_backend(self, test_id: str, id_type: IDType) -> bool:
        """Validate ID in backend service."""
        try:
            return self.unified_id_manager.is_valid_id_format_compatible(test_id, id_type)
        except Exception:
            return False

    async def _validate_id_in_websocket(self, test_id: str, id_type: IDType) -> bool:
        """Validate ID in WebSocket service."""
        try:
            return self.unified_id_manager.is_valid_id_format_compatible(test_id, id_type)
        except Exception:
            return False

    async def _validate_id_in_database(self, test_id: str, id_type: IDType) -> bool:
        """Validate ID in database service."""
        try:
            return self.unified_id_manager.is_valid_id_format_compatible(test_id, id_type)
        except Exception:
            return False

    async def _validate_id_in_auth(self, test_id: str, id_type: IDType) -> bool:
        """Validate ID in auth service."""
        try:
            return self.unified_id_manager.is_valid_id_format_compatible(test_id, id_type)
        except Exception:
            return False
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')