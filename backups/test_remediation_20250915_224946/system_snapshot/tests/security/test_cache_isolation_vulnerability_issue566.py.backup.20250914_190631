"""
Security Test Suite for Issue #566: LLM Cache Isolation Vulnerability

CRITICAL P1 SECURITY VULNERABILITY:
- startup_module.py:649 creates shared LLM manager without user context
- smd.py:1019 creates shared LLM manager without user context
- This allows cross-user cache contamination and data leakage

Test Strategy:
1. Prove vulnerability exists in startup modules (should fail initially)
2. Validate security fixes work (should pass after fixes)
3. Ensure regression prevention

Security Impact: HIGH - User conversation isolation compromised
Business Impact: $500K+ ARR at risk due to privacy violations
"""

import pytest
import asyncio
from unittest.mock import Mock, patch
from fastapi import FastAPI

from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.services.user_execution_context import UserExecutionContext


class TestCacheIsolationVulnerabilityIssue566(SSotAsyncTestCase):
    """
    CRITICAL SECURITY TESTS: LLM Cache Isolation Vulnerability Issue #566
    
    This test suite demonstrates and validates fixes for a P1 security vulnerability
    where startup modules create shared LLM managers without user context isolation.
    """

    def setUp(self):
        """Set up test fixtures for security vulnerability testing."""
        super().setUp()
        
        # Create test user contexts for isolation testing
        self.user_a_context = UserExecutionContext(
            user_id="user_a_test_123",
            thread_id="thread_a_test_123",
            run_id="run_a_test_123",
            request_id="req_a_test"
        )
        
        self.user_b_context = UserExecutionContext(
            user_id="user_b_test_456", 
            thread_id="thread_b_test_456",
            run_id="run_b_test_456",
            request_id="req_b_test"
        )
        
        # Create FastAPI app for testing startup behavior
        self.test_app = FastAPI()

    def test_startup_module_security_vulnerability_demonstration(self):
        """
        SECURITY TEST: Demonstrate vulnerability in startup_module.py:649
        
        This test SHOULD FAIL initially, proving the vulnerability exists.
        After security fixes, this test SHOULD PASS.
        """
        import inspect
        from netra_backend.app.startup_module import setup_security_services
        
        # Get source code of setup_security_services function
        source_code = inspect.getsource(setup_security_services)
        
        # SECURITY VULNERABILITY CHECK: Should NOT contain vulnerable pattern
        # This assertion SHOULD FAIL initially (proving vulnerability exists)
        self.assertNotIn(
            "create_llm_manager()",
            source_code,
            "SECURITY VIOLATION DETECTED: startup_module.py:649 contains vulnerable "
            "create_llm_manager() call without user context - this allows cache isolation "
            "compromise and cross-user data leakage"
        )

    def test_smd_security_vulnerability_demonstration(self):
        """
        SECURITY TEST: Demonstrate vulnerability in smd.py:1019
        
        This test SHOULD FAIL initially, proving the vulnerability exists.
        After security fixes, this test SHOULD PASS.
        """
        import inspect
        from netra_backend.app.smd import StartupOrchestrator
        
        # Get source code of _initialize_llm_manager method
        source_code = inspect.getsource(StartupOrchestrator._initialize_llm_manager)
        
        # SECURITY VULNERABILITY CHECK: Should NOT contain vulnerable pattern
        # This assertion SHOULD FAIL initially (proving vulnerability exists)
        self.assertNotIn(
            "create_llm_manager()",
            source_code,
            "SECURITY VIOLATION DETECTED: smd.py:1019 contains vulnerable "
            "create_llm_manager() call without user context - this allows cache isolation "
            "compromise and cross-user data leakage"
        )

    async def test_cross_user_cache_isolation_vulnerability(self):
        """
        SECURITY TEST: Demonstrate cross-user cache contamination vulnerability
        
        This test simulates the real-world security impact where User A's
        cached responses could leak to User B due to shared LLM manager.
        """
        from netra_backend.app.llm.llm_manager import create_llm_manager
        
        # Create managers using the vulnerable pattern (no user context)
        vulnerable_manager_1 = create_llm_manager()  # No user context - VULNERABLE
        vulnerable_manager_2 = create_llm_manager()  # No user context - VULNERABLE
        
        # Simulate cache operations that should be isolated
        cache_key_user_a = "conversation_cache_sensitive_data_user_a"
        cache_key_user_b = "conversation_cache_sensitive_data_user_b"
        
        # Mock cache operations to demonstrate vulnerability
        with patch.object(vulnerable_manager_1, '_cache', {}) as cache_1, \
             patch.object(vulnerable_manager_2, '_cache', {}) as cache_2:
            
            # If managers share cache (vulnerability), this will fail isolation
            cache_1[cache_key_user_a] = "SENSITIVE_USER_A_DATA"
            
            # SECURITY ASSERTION: User B should NOT see User A's cached data
            self.assertNotIn(
                cache_key_user_a, cache_2,
                "CRITICAL SECURITY VIOLATION: Cross-user cache contamination detected! "
                "User B can access User A's cached conversation data"
            )

    def test_user_context_factory_pattern_security_fix(self):
        """
        SECURITY TEST: Validate user-context-aware factory pattern fixes vulnerability
        
        This test validates the security fix that replaces direct create_llm_manager()
        calls with user-context-aware factory pattern.
        """
        from netra_backend.app.llm.llm_manager import create_llm_manager
        
        # Create managers with proper user context isolation (SECURE)
        secure_manager_a = create_llm_manager(self.user_a_context)
        secure_manager_b = create_llm_manager(self.user_b_context)
        
        # SECURITY ASSERTION: Managers should be different instances
        self.assertNotEqual(
            id(secure_manager_a), id(secure_manager_b),
            "SECURITY FIX VALIDATION: User-isolated managers should be separate instances"
        )
        
        # SECURITY ASSERTION: Managers should have proper user context
        self.assertEqual(
            secure_manager_a.user_context.user_id, self.user_a_context.user_id,
            "SECURITY FIX VALIDATION: Manager A should have User A's context"
        )
        
        self.assertEqual(
            secure_manager_b.user_context.user_id, self.user_b_context.user_id,
            "SECURITY FIX VALIDATION: Manager B should have User B's context"
        )

    def test_cache_key_user_isolation_security_fix(self):
        """
        SECURITY TEST: Validate cache keys include user_id for proper isolation
        
        This test ensures the security fix includes user_id in cache keys
        to prevent cross-user data contamination.
        """
        from netra_backend.app.llm.llm_manager import create_llm_manager
        
        # Create user-isolated managers
        manager_a = create_llm_manager(self.user_a_context)
        manager_b = create_llm_manager(self.user_b_context)
        
        # Test cache key generation includes user context
        test_prompt = "What is machine learning?"
        
        # Mock cache key generation to verify user isolation
        with patch.object(manager_a, '_generate_cache_key') as mock_cache_key_a, \
             patch.object(manager_b, '_generate_cache_key') as mock_cache_key_b:
            
            mock_cache_key_a.return_value = f"user_{self.user_a_context.user_id}_{hash(test_prompt)}"
            mock_cache_key_b.return_value = f"user_{self.user_b_context.user_id}_{hash(test_prompt)}"
            
            cache_key_a = manager_a._generate_cache_key(test_prompt)
            cache_key_b = manager_b._generate_cache_key(test_prompt)
            
            # SECURITY ASSERTION: Cache keys should be different for different users
            self.assertNotEqual(
                cache_key_a, cache_key_b,
                "SECURITY FIX VALIDATION: Cache keys must include user_id for isolation"
            )
            
            # SECURITY ASSERTION: Cache keys should include user identifiers
            self.assertIn(
                self.user_a_context.user_id, cache_key_a,
                "SECURITY FIX VALIDATION: Cache key A must include User A's ID"
            )
            
            self.assertIn(
                self.user_b_context.user_id, cache_key_b,
                "SECURITY FIX VALIDATION: Cache key B must include User B's ID"
            )

    def test_regression_prevention_startup_module_security(self):
        """
        REGRESSION TEST: Prevent future introduction of vulnerable startup patterns
        
        This test ensures startup_module.py uses secure factory pattern
        and never reverts to vulnerable shared LLM manager creation.
        """
        import inspect
        from netra_backend.app.startup_module import setup_security_services
        
        # Get source code of setup_security_services function
        source_code = inspect.getsource(setup_security_services)
        
        # REGRESSION ASSERTION: Should NOT contain vulnerable pattern
        self.assertNotIn(
            "create_llm_manager()",
            source_code,
            "REGRESSION PREVENTION: startup_module.py must not use create_llm_manager() "
            "without user context - use factory pattern instead"
        )
        
        # REGRESSION ASSERTION: Should contain secure factory pattern
        # This will be updated after the security fix is implemented
        # For now, this documents the expected secure pattern

    def test_regression_prevention_smd_security(self):
        """
        REGRESSION TEST: Prevent future introduction of vulnerable SMD patterns
        
        This test ensures smd.py uses secure factory pattern
        and never reverts to vulnerable shared LLM manager creation.
        """
        import inspect
        from netra_backend.app.smd import StartupOrchestrator
        
        # Get source code of _initialize_llm_manager method
        source_code = inspect.getsource(StartupOrchestrator._initialize_llm_manager)
        
        # REGRESSION ASSERTION: Should NOT contain vulnerable pattern
        self.assertNotIn(
            "create_llm_manager()",
            source_code,
            "REGRESSION PREVENTION: smd.py must not use create_llm_manager() "
            "without user context - use factory pattern instead"
        )


class TestSecurityFixValidation(SSotAsyncTestCase):
    """
    Validation tests for security fixes - these should PASS after fixes are implemented
    """

    def test_startup_module_security_fix_validation(self):
        """
        Validate that startup_module.py has been fixed to use secure factory pattern
        """
        from netra_backend.app.startup_module import setup_security_services
        import inspect
        
        source_code = inspect.getsource(setup_security_services)
        
        # After fix: Should use factory pattern that can accept user context
        # This test validates the fix is properly implemented
        self.assertTrue(
            "# SECURITY FIX" in source_code or "factory" in source_code.lower(),
            "SECURITY FIX VALIDATION: startup_module.py should use secure factory pattern"
        )

    def test_smd_security_fix_validation(self):
        """
        Validate that smd.py has been fixed to use secure factory pattern
        """
        from netra_backend.app.smd import StartupOrchestrator
        import inspect
        
        source_code = inspect.getsource(StartupOrchestrator._initialize_llm_manager)
        
        # After fix: Should use factory pattern that can accept user context
        self.assertTrue(
            "# SECURITY FIX" in source_code or "factory" in source_code.lower(),
            "SECURITY FIX VALIDATION: smd.py should use secure factory pattern"
        )


if __name__ == "__main__":
    """
    Run security tests for Issue #566
    
    EXPECTED BEHAVIOR:
    - Initially: Many tests SHOULD FAIL, proving vulnerability exists
    - After fixes: All tests SHOULD PASS, proving vulnerability is resolved
    """
    pytest.main([__file__, "-v", "--tb=short"])
