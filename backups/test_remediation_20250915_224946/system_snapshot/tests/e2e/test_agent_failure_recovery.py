"""
Agent Failure Recovery E2E Test

Business Value Justification (BVJ):
- Segment: All (Free, Early, Mid, Enterprise)
- Business Goal: Failure recovery maintains user trust and prevents revenue loss from errors
- Value Impact: Ensures system gracefully handles failures without losing user data or context
- Strategic Impact: Platform reliability protects customer relationships and prevents churn

This test validates complete failure recovery scenarios:
1. Agent execution failures with graceful recovery
2. Tool execution errors with fallback mechanisms
3. LLM service interruptions with retry logic
4. WebSocket connection drops during agent execution
5. Database connectivity issues with session preservation
6. User notification of failures with recovery status
7. Context preservation across failure/recovery cycles

CRITICAL REQUIREMENTS:
- MANDATORY AUTHENTICATION: All failure scenarios maintain user authentication
- NO MOCKS: Real failure injection and real recovery mechanisms
- USER NOTIFICATION: Users must be informed of failures and recovery status
- CONTEXT PRESERVATION: User context and conversation state maintained
- GRACEFUL DEGRADATION: System continues operating with reduced functionality

This test ensures:
- Users don't lose work due to system failures
- Clear communication about system status
- Automatic recovery when possible
- Graceful fallback when recovery isn't possible
"""
import asyncio
import json
import time
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, Tuple
import pytest
from loguru import logger
from test_framework.base_e2e_test import BaseE2ETest
from test_framework.ssot.e2e_auth_helper import E2EAuthHelper, create_authenticated_user_context
from test_framework.real_services_test_fixtures import real_services_fixture
from test_framework.websocket_helpers import WebSocketTestHelpers, MockWebSocketConnection
from shared.isolated_environment import get_env

class AgentFailureRecoveryE2ETests(BaseE2ETest):
    """
    E2E test for agent failure recovery using REAL services only.
    
    This test validates that the platform gracefully handles various failure
    scenarios while maintaining user trust and system integrity.
    """

    @pytest.fixture(autouse=True)
    async def setup_test_environment(self):
        """Set up test environment for failure recovery testing."""
        await self.initialize_test_environment()
        self.auth_helper = E2EAuthHelper(environment='test')
        self.active_connections = []
        yield
        for connection in self.active_connections:
            try:
                await WebSocketTestHelpers.close_test_connection(connection)
            except:
                pass

    async def create_authenticated_session(self, email: str) -> Tuple[Any, Any, Any]:
        """Create authenticated user session."""
        auth_user = await self.auth_helper.create_authenticated_user(email=email, permissions=['read', 'write', 'agent_execute'])
        user_context = await create_authenticated_user_context(user_email=auth_user.email, user_id=auth_user.user_id, environment='test', permissions=auth_user.permissions, websocket_enabled=True)
        websocket_url = 'ws://localhost:8000/ws/chat'
        headers = self.auth_helper.get_websocket_headers(auth_user.jwt_token)
        websocket_connection = await WebSocketTestHelpers.create_test_websocket_connection(websocket_url, headers=headers, timeout=15.0, max_retries=3, user_id=auth_user.user_id)
        self.active_connections.append(websocket_connection)
        return (auth_user, websocket_connection, user_context)

    async def send_message_and_collect_events(self, websocket_connection: Any, message: Dict[str, Any], timeout: float=30.0, expect_failure: bool=False) -> List[Dict[str, Any]]:
        """Send message and collect all events until completion or timeout."""
        received_events = []
        await WebSocketTestHelpers.send_test_message(websocket_connection, message)
        start_time = time.time()
        while time.time() - start_time < timeout:
            try:
                event = await WebSocketTestHelpers.receive_test_message(websocket_connection, timeout=2.0)
                received_events.append(event)
                event_type = event.get('type', 'unknown')
                logger.info(f'[U+1F4E8] Received event: {event_type}')
                if event_type in ['agent_completed', 'agent_failed', 'error']:
                    break
            except Exception as e:
                if 'timeout' in str(e).lower():
                    completion_events = [e for e in received_events if e.get('type') in ['agent_completed', 'agent_failed', 'error']]
                    if completion_events:
                        break
                    continue
                else:
                    logger.error(f'Error receiving event: {e}')
                    if expect_failure:
                        break
                    else:
                        raise
        return received_events

    def create_error_scenario_message(self, scenario: str, auth_user: Any, user_context: Any) -> Dict[str, Any]:
        """Create message that triggers specific error scenarios for testing."""
        base_message = {'user_id': auth_user.user_id, 'thread_id': str(user_context.thread_id), 'request_id': str(user_context.request_id), 'timestamp': datetime.now(timezone.utc).isoformat()}
        if scenario == 'agent_execution_error':
            return {**base_message, 'type': 'agent_request', 'agent': 'non_existent_agent', 'message': "This should fail because the agent doesn't exist"}
        elif scenario == 'tool_execution_error':
            return {**base_message, 'type': 'agent_request', 'agent': 'triage_agent', 'message': 'Please use the invalid_tool to process this request', 'force_tool': 'invalid_tool'}
        elif scenario == 'authentication_error':
            return {**base_message, 'type': 'agent_request', 'agent': 'triage_agent', 'message': 'This request should fail authentication', 'user_id': ''}
        elif scenario == 'message_processing_error':
            return {**base_message, 'type': 'invalid_type', 'message': 'This message has invalid structure'}
        elif scenario == 'connection_error':
            return {**base_message, 'type': 'connection_test', 'action': 'force_disconnect', 'message': 'This should trigger connection error'}
        else:
            return {**base_message, 'type': 'agent_request', 'agent': 'triage_agent', 'message': 'Normal message for baseline testing'}

    @pytest.mark.e2e
    @pytest.mark.real_services
    @pytest.mark.mission_critical
    async def test_agent_execution_failure_recovery(self, real_services_fixture):
        """
        Test agent execution failure with graceful recovery and user notification.
        
        This test validates that when an agent fails to execute, the system:
        1. Detects the failure quickly
        2. Notifies the user appropriately  
        3. Attempts recovery if possible
        4. Maintains user context throughout
        """
        logger.info('[U+1F680] Starting agent execution failure recovery test')
        auth_user, websocket_connection, user_context = await self.create_authenticated_session('agent_failure_test@example.com')
        logger.info(f' PASS:  Created authenticated session: {auth_user.email}')
        logger.info(' FIRE:  Testing agent execution failure...')
        error_message = self.create_error_scenario_message('agent_execution_error', auth_user, user_context)
        error_events = await self.send_message_and_collect_events(websocket_connection, error_message, timeout=20.0, expect_failure=True)
        assert len(error_events) > 0, 'No events received for error scenario'
        event_types = [event.get('type') for event in error_events]
        assert any(('error' in event_type or 'failed' in event_type for event_type in event_types)), f'No error event received. Event types: {event_types}'
        logger.info(' PASS:  Agent execution failure properly detected and reported')
        logger.info(' CYCLE:  Testing recovery with valid request...')
        recovery_message = {'type': 'agent_request', 'agent': 'triage_agent', 'message': 'Please provide a simple system status check after the previous error.', 'user_id': auth_user.user_id, 'thread_id': str(user_context.thread_id), 'request_id': str(user_context.request_id) + '_recovery', 'timestamp': datetime.now(timezone.utc).isoformat()}
        recovery_events = await self.send_message_and_collect_events(websocket_connection, recovery_message, timeout=30.0)
        assert len(recovery_events) > 0, 'No recovery events received'
        recovery_event_types = [event.get('type') for event in recovery_events]
        expected_recovery_events = ['agent_started', 'agent_thinking']
        for expected_event in expected_recovery_events:
            assert expected_event in recovery_event_types, f'Missing recovery event: {expected_event}. Got: {recovery_event_types}'
        assert 'agent_completed' in recovery_event_types, f'Agent recovery did not complete successfully. Events: {recovery_event_types}'
        logger.info(' PASS:  Agent execution recovery successful')
        user_id_preserved = False
        thread_id_preserved = False
        for event in recovery_events:
            event_data = event.get('data', {})
            if event_data.get('user_id') == auth_user.user_id:
                user_id_preserved = True
            if event_data.get('thread_id') == str(user_context.thread_id):
                thread_id_preserved = True
        assert user_id_preserved, 'User context not preserved during recovery'
        if not thread_id_preserved:
            logger.warning('Thread context not preserved (acceptable but not optimal)')
        logger.info(' CELEBRATION:  AGENT EXECUTION FAILURE RECOVERY TEST PASSED')
        logger.info(f'    FAIL:  Failure Detection: VERIFIED')
        logger.info(f'    CYCLE:  Recovery Mechanism: VERIFIED')
        logger.info(f'   [U+1F464] Context Preservation: VERIFIED')

    @pytest.mark.e2e
    @pytest.mark.real_services
    async def test_tool_execution_failure_recovery(self, real_services_fixture):
        """
        Test tool execution failure with fallback and recovery mechanisms.
        
        Validates that when tools fail, the system gracefully handles the failure
        and continues with alternative approaches or meaningful error messages.
        """
        logger.info('[U+1F680] Starting tool execution failure recovery test')
        auth_user, websocket_connection, user_context = await self.create_authenticated_session('tool_failure_test@example.com')
        logger.info('[U+1F527] Testing tool execution failure...')
        tool_error_message = self.create_error_scenario_message('tool_execution_error', auth_user, user_context)
        tool_error_events = await self.send_message_and_collect_events(websocket_connection, tool_error_message, timeout=25.0, expect_failure=True)
        assert len(tool_error_events) > 0, 'No events received for tool error scenario'
        event_types = [event.get('type') for event in tool_error_events]
        assert 'agent_started' in event_types, 'Agent should start before encountering tool error'
        has_error_event = any(('error' in event_type or 'failed' in event_type or 'tool_error' in event_type for event_type in event_types))
        assert has_error_event, f'Tool error not properly reported. Events: {event_types}'
        logger.info(' PASS:  Tool execution failure properly detected')
        logger.info(' CYCLE:  Testing tool execution recovery...')
        recovery_message = {'type': 'agent_request', 'agent': 'triage_agent', 'message': 'Please help me with basic system information using only standard tools.', 'user_id': auth_user.user_id, 'thread_id': str(user_context.thread_id), 'request_id': str(user_context.request_id) + '_tool_recovery', 'timestamp': datetime.now(timezone.utc).isoformat()}
        recovery_events = await self.send_message_and_collect_events(websocket_connection, recovery_message, timeout=30.0)
        recovery_event_types = [event.get('type') for event in recovery_events]
        assert 'agent_started' in recovery_event_types, 'Recovery should start normally'
        assert 'agent_completed' in recovery_event_types, 'Recovery should complete successfully'
        has_tool_success = 'tool_executing' in recovery_event_types and 'tool_completed' in recovery_event_types
        if has_tool_success:
            logger.info(' PASS:  Tool execution recovery with actual tool usage verified')
        else:
            logger.info('[U+2139][U+FE0F] Tool execution recovery without tool usage (acceptable)')
        logger.info(' CELEBRATION:  TOOL EXECUTION FAILURE RECOVERY TEST PASSED')

    @pytest.mark.e2e
    @pytest.mark.real_services
    async def test_websocket_connection_failure_recovery(self, real_services_fixture):
        """
        Test WebSocket connection failure and recovery mechanisms.
        
        This test validates that the system can handle WebSocket disconnections
        gracefully and recover connection when possible.
        """
        logger.info('[U+1F680] Starting WebSocket connection failure recovery test')
        auth_user, websocket_connection, user_context = await self.create_authenticated_session('websocket_failure_test@example.com')
        logger.info('[U+1F4E4] Sending baseline message...')
        baseline_message = {'type': 'agent_request', 'agent': 'triage_agent', 'message': 'Please provide a quick status update before we test connection issues.', 'user_id': auth_user.user_id, 'thread_id': str(user_context.thread_id), 'request_id': str(user_context.request_id) + '_baseline', 'timestamp': datetime.now(timezone.utc).isoformat()}
        baseline_events = await self.send_message_and_collect_events(websocket_connection, baseline_message, timeout=20.0)
        assert len(baseline_events) > 0, 'Baseline message failed'
        baseline_event_types = [event.get('type') for event in baseline_events]
        assert 'agent_completed' in baseline_event_types, 'Baseline request should complete'
        logger.info(' PASS:  Baseline WebSocket communication established')
        logger.info('[U+1F50C] Testing connection error scenario...')
        connection_error_message = self.create_error_scenario_message('connection_error', auth_user, user_context)
        try:
            error_events = await self.send_message_and_collect_events(websocket_connection, connection_error_message, timeout=15.0, expect_failure=True)
            logger.info(f'Connection error events: {len(error_events)}')
        except Exception as e:
            logger.info(f'Expected connection error occurred: {e}')
        logger.info(' CYCLE:  Testing connection recovery...')
        websocket_url = 'ws://localhost:8000/ws/chat'
        headers = self.auth_helper.get_websocket_headers(auth_user.jwt_token)
        recovery_connection = await WebSocketTestHelpers.create_test_websocket_connection(websocket_url, headers=headers, timeout=15.0, max_retries=3, user_id=auth_user.user_id)
        self.active_connections.append(recovery_connection)
        recovery_message = {'type': 'agent_request', 'agent': 'triage_agent', 'message': 'Connection recovered - please confirm system is working normally.', 'user_id': auth_user.user_id, 'thread_id': str(user_context.thread_id), 'request_id': str(user_context.request_id) + '_connection_recovery', 'timestamp': datetime.now(timezone.utc).isoformat()}
        recovery_events = await self.send_message_and_collect_events(recovery_connection, recovery_message, timeout=25.0)
        assert len(recovery_events) > 0, 'No events after connection recovery'
        recovery_event_types = [event.get('type') for event in recovery_events]
        assert 'agent_started' in recovery_event_types, 'Recovery connection should allow agent execution'
        assert 'agent_completed' in recovery_event_types, 'Recovery should complete successfully'
        logger.info(' CELEBRATION:  WEBSOCKET CONNECTION FAILURE RECOVERY TEST PASSED')
        logger.info(f'   [U+1F4E1] Connection Recovery: VERIFIED')
        logger.info(f'    CYCLE:  Session Continuity: VERIFIED')

    @pytest.mark.e2e
    @pytest.mark.real_services
    async def test_multiple_failure_scenarios_recovery(self, real_services_fixture):
        """
        Test recovery from multiple failure scenarios in sequence.
        
        This comprehensive test validates that the system can handle multiple
        different types of failures and recover from each gracefully.
        """
        logger.info('[U+1F680] Starting multiple failure scenarios recovery test')
        auth_user, websocket_connection, user_context = await self.create_authenticated_session('multiple_failure_test@example.com')
        failure_scenarios = [('authentication_error', 'Authentication failure'), ('message_processing_error', 'Message processing failure'), ('agent_execution_error', 'Agent execution failure')]
        recovery_count = 0
        for scenario_type, scenario_description in failure_scenarios:
            logger.info(f' FIRE:  Testing {scenario_description}...')
            error_message = self.create_error_scenario_message(scenario_type, auth_user, user_context)
            try:
                error_events = await self.send_message_and_collect_events(websocket_connection, error_message, timeout=15.0, expect_failure=True)
                if len(error_events) > 0:
                    event_types = [event.get('type') for event in error_events]
                    has_error = any(('error' in str(event_type).lower() for event_type in event_types))
                    if has_error:
                        logger.info(f' PASS:  {scenario_description} properly detected')
                    else:
                        logger.warning(f' WARNING: [U+FE0F] {scenario_description} may not have been detected properly')
            except Exception as e:
                logger.info(f'Expected error for {scenario_description}: {e}')
            logger.info(f' CYCLE:  Testing recovery from {scenario_description}...')
            recovery_message = {'type': 'agent_request', 'agent': 'triage_agent', 'message': f'Recovery test #{recovery_count + 1} - system should work normally now.', 'user_id': auth_user.user_id, 'thread_id': str(user_context.thread_id), 'request_id': str(user_context.request_id) + f'_recovery_{recovery_count}', 'timestamp': datetime.now(timezone.utc).isoformat()}
            recovery_events = await self.send_message_and_collect_events(websocket_connection, recovery_message, timeout=25.0)
            assert len(recovery_events) > 0, f'No recovery events after {scenario_description}'
            recovery_event_types = [event.get('type') for event in recovery_events]
            assert 'agent_started' in recovery_event_types, f'Recovery failed after {scenario_description}'
            recovery_count += 1
            logger.info(f' PASS:  Recovery #{recovery_count} successful')
            await asyncio.sleep(1.0)
        logger.info(' CELEBRATION:  MULTIPLE FAILURE SCENARIOS RECOVERY TEST PASSED')
        logger.info(f'    CYCLE:  Scenarios Tested: {len(failure_scenarios)}')
        logger.info(f'    PASS:  Recoveries Successful: {recovery_count}')
        logger.info(f'   [U+1F6E1][U+FE0F] System Resilience: VERIFIED')

    @pytest.mark.e2e
    @pytest.mark.real_services
    async def test_failure_user_notification_quality(self, real_services_fixture):
        """
        Test that failure notifications provide clear, actionable information to users.
        
        This test validates that when failures occur, users receive meaningful
        error messages that help them understand what happened and what to do next.
        """
        logger.info('[U+1F680] Starting failure user notification quality test')
        auth_user, websocket_connection, user_context = await self.create_authenticated_session('notification_quality_test@example.com')
        scenarios = [('agent_execution_error', ['agent', 'not found', 'available']), ('message_processing_error', ['invalid', 'message', 'format']), ('authentication_error', ['authentication', 'user', 'required'])]
        for scenario_type, expected_keywords in scenarios:
            logger.info(f'[U+1F4E2] Testing notification quality for {scenario_type}...')
            error_message = self.create_error_scenario_message(scenario_type, auth_user, user_context)
            try:
                error_events = await self.send_message_and_collect_events(websocket_connection, error_message, timeout=15.0, expect_failure=True)
                error_messages = []
                for event in error_events:
                    if event.get('type') == 'error' or 'error' in str(event.get('type', '')).lower():
                        error_data = event.get('data', {})
                        error_text = error_data.get('message', '') or error_data.get('error', '')
                        if error_text:
                            error_messages.append(error_text.lower())
                if error_messages:
                    combined_message = ' '.join(error_messages)
                    keywords_found = 0
                    for keyword in expected_keywords:
                        if keyword.lower() in combined_message:
                            keywords_found += 1
                    keyword_coverage = keywords_found / len(expected_keywords)
                    logger.info(f'Error message keyword coverage: {keyword_coverage:.2%}')
                    assert keyword_coverage >= 0.5, f'Poor error message quality for {scenario_type}. Expected keywords: {expected_keywords}, Got: {combined_message[:200]}'
                    assert len(combined_message) >= 10, f'Error message too brief for {scenario_type}: {combined_message}'
                    logger.info(f' PASS:  {scenario_type} notification quality acceptable')
                else:
                    logger.warning(f' WARNING: [U+FE0F] No clear error messages found for {scenario_type}')
            except Exception as e:
                logger.info(f'Expected error during {scenario_type}: {e}')
        logger.info(' CELEBRATION:  FAILURE USER NOTIFICATION QUALITY TEST PASSED')
        logger.info(f'   [U+1F4E2] Error Message Quality: VERIFIED')
        logger.info(f'   [U+1F4DD] User-Friendly Notifications: VALIDATED')
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')