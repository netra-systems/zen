"""
E2E Tests for Issue #1037: SERVICE_SECRET Staging Environment Validation

PURPOSE: These E2E tests validate Issue #1037 in the real GCP staging environment.
They will FAIL initially if the regression exists in actual deployment.

STAGING VALIDATION:
1. Real GCP staging environment configuration consistency
2. Actual service-to-service authentication in Cloud Run
3. WebSocket authentication in real deployment
4. End-to-end user flows with authentication

TEST STRATEGY: Use real staging environment to prove/disprove Issue #1037
affects actual deployed services, not just local development.

Business Impact: $500K+ ARR validation in production-like environment.
"""

import pytest
import asyncio
import httpx
import logging
import os
from typing import Dict, Any, Optional, List
from datetime import datetime

from test_framework.ssot.base_test_case import SSotAsyncTestCase
from shared.isolated_environment import IsolatedEnvironment

logger = logging.getLogger(__name__)


class TestServiceSecretStagingValidation(SSotAsyncTestCase):
    """
    E2E tests validating Issue #1037 in GCP staging environment.
    These tests will FAIL if the regression exists in actual deployment.
    """

    def setUp(self):
        """Set up E2E staging test environment."""
        super().setUp()
        self.env = IsolatedEnvironment()

        # GCP Staging URLs
        self.staging_backend_url = self.env.get(
            "STAGING_BACKEND_URL",
            "https://netra-backend-staging-123456789.us-central1.run.app"
        )
        self.staging_auth_url = self.env.get(
            "STAGING_AUTH_URL",
            "https://netra-auth-123456789.us-central1.run.app"
        )

        # Skip tests if staging URLs not configured
        if not self._staging_available():
            pytest.skip("Staging environment not available for E2E testing")

        logger.info(f"E2E Staging Test Setup: Backend={self.staging_backend_url}, Auth={self.staging_auth_url}")

    def _staging_available(self) -> bool:
        """Check if staging environment is available."""
        required_env_vars = ["STAGING_BACKEND_URL", "STAGING_AUTH_URL"]
        return all(self.env.get(var) for var in required_env_vars)

    async def _check_service_health(self, service_url: str, service_name: str) -> Dict[str, Any]:
        """Check if a staging service is healthy."""
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{service_url}/health")
                return {
                    "service": service_name,
                    "url": service_url,
                    "status": response.status_code,
                    "healthy": response.status_code == 200,
                    "response": response.text[:100] if response.text else "No response"
                }
        except Exception as e:
            return {
                "service": service_name,
                "url": service_url,
                "healthy": False,
                "error": str(e)[:100]
            }

    def test_staging_service_health_prerequisite(self):
        """
        PREREQUISITE TEST: Verify staging services are healthy before
        testing Issue #1037 authentication regression.
        """
        logger.info("Checking staging service health as prerequisite...")

        async def check_all_services():
            """Check health of all staging services."""
            health_checks = await asyncio.gather(
                self._check_service_health(self.staging_backend_url, "backend"),
                self._check_service_health(self.staging_auth_url, "auth"),
                return_exceptions=True
            )

            unhealthy_services = []
            for health in health_checks:
                if isinstance(health, Exception):
                    unhealthy_services.append(f"Exception: {str(health)}")
                elif not health.get("healthy", False):
                    unhealthy_services.append(
                        f"{health['service']}: {health.get('status', 'Unknown')} - "
                        f"{health.get('error', health.get('response', 'No details'))}"
                    )

            if unhealthy_services:
                self.fail(
                    f"Staging services not healthy for Issue #1037 testing:\n" +
                    "\n".join(f"  - {service}" for service in unhealthy_services)
                )

            logger.info("All staging services healthy - ready for Issue #1037 regression testing")

        # Run health check
        asyncio.run(check_all_services())

    def test_staging_service_secret_authentication_consistency(self):
        """
        REGRESSION TEST: Verify SERVICE_SECRET authentication consistency
        between backend and auth services in GCP staging environment.

        EXPECTED: This test will FAIL if Issue #1037 affects staging deployment.
        """
        logger.info("Testing SERVICE_SECRET authentication consistency in staging...")

        async def test_service_auth_consistency():
            """Test actual service authentication in staging."""
            authentication_failures = []

            try:
                async with httpx.AsyncClient(timeout=30.0) as client:

                    # Test 1: Backend service authentication with auth service
                    logger.info("Testing backend -> auth service authentication...")
                    auth_validation_response = await client.post(
                        f"{self.staging_auth_url}/auth/service/validate",
                        headers={
                            "Content-Type": "application/json",
                            "X-Service-ID": "backend-service",
                            # Note: Real staging should handle authentication internally
                        },
                        json={"service_check": True}
                    )

                    if auth_validation_response.status_code == 403:
                        authentication_failures.append({
                            "test": "backend_auth_validation",
                            "status": 403,
                            "details": "Backend cannot authenticate with auth service",
                            "response": auth_validation_response.text[:200]
                        })

                    # Test 2: Service token request
                    logger.info("Testing service token request...")
                    token_response = await client.post(
                        f"{self.staging_auth_url}/auth/service/token",
                        headers={
                            "Content-Type": "application/json",
                            "X-Service-ID": "backend-service"
                        },
                        json={"grant_type": "service_credentials"}
                    )

                    if token_response.status_code in [401, 403]:
                        authentication_failures.append({
                            "test": "service_token_request",
                            "status": token_response.status_code,
                            "details": "Service token request failed",
                            "response": token_response.text[:200]
                        })

                    # Test 3: Cross-service health check with auth
                    logger.info("Testing authenticated health check...")
                    if token_response.status_code == 200:
                        try:
                            token_data = token_response.json()
                            access_token = token_data.get("access_token")

                            if access_token:
                                health_response = await client.get(
                                    f"{self.staging_backend_url}/health",
                                    headers={"Authorization": f"Bearer {access_token}"}
                                )

                                if health_response.status_code == 403:
                                    authentication_failures.append({
                                        "test": "authenticated_health_check",
                                        "status": 403,
                                        "details": "Backend rejected service token",
                                        "response": health_response.text[:200]
                                    })

                        except Exception as e:
                            authentication_failures.append({
                                "test": "token_parsing",
                                "error": str(e)[:200],
                                "details": "Failed to parse service token response"
                            })

                # Analyze authentication failures
                if authentication_failures:
                    failure_summary = "\n".join([
                        f"  {f['test']}: {f.get('status', 'Error')} - {f['details']}\n"
                        f"    Response: {f.get('response', f.get('error', 'No details'))}"
                        for f in authentication_failures
                    ])

                    raise AssertionError(
                        f"Issue #1037 CONFIRMED IN STAGING ENVIRONMENT:\n"
                        f"SERVICE_SECRET authentication failures detected in real deployment:\n"
                        f"{failure_summary}\n\n"
                        f"This proves Issue #1037 affects actual production-like environment. "
                        f"Business Impact: $500K+ ARR at risk from authentication breakdown."
                    )

                else:
                    logger.info(
                        "Staging authentication consistency verified - "
                        "Issue #1037 may not affect this environment or is already fixed."
                    )

            except httpx.RequestError as e:
                self.skipTest(f"Staging environment not accessible: {str(e)}")

        # Run staging authentication test
        asyncio.run(test_service_auth_consistency())

    def test_staging_websocket_authentication_regression(self):
        """
        REGRESSION TEST: Verify WebSocket authentication works in staging
        and doesn't exhibit the 503 errors mentioned in Issue #1037.

        EXPECTED: This test will FAIL if WebSocket auth regression exists in staging.
        """
        logger.info("Testing WebSocket authentication regression in staging...")

        async def test_websocket_staging_auth():
            """Test WebSocket authentication in real staging environment."""
            try:
                import websockets
                from websockets import ConnectionClosedError, InvalidStatusCode

                # Convert HTTP URL to WebSocket URL
                ws_url = self.staging_backend_url.replace("https://", "wss://") + "/ws"
                logger.info(f"Testing WebSocket connection to: {ws_url}")

                websocket_failures = []

                try:
                    # Test WebSocket connection without authentication
                    async with websockets.connect(ws_url, timeout=10) as websocket:
                        # Send test message
                        await websocket.send('{"type": "ping", "data": "staging_test"}')
                        response = await asyncio.wait_for(websocket.recv(), timeout=10.0)

                        logger.info(f"WebSocket response received: {response[:100]}...")

                        # If connection succeeded, check if we got expected response
                        if "error" in response.lower() or "403" in response:
                            websocket_failures.append({
                                "test": "websocket_connection",
                                "issue": "Authentication error in WebSocket response",
                                "response": response[:200]
                            })

                except (ConnectionClosedError, InvalidStatusCode, asyncio.TimeoutError) as e:
                    # Connection failed - could indicate authentication issues
                    if "403" in str(e) or "unauthorized" in str(e).lower():
                        websocket_failures.append({
                            "test": "websocket_connection",
                            "issue": "WebSocket connection failed with auth error",
                            "error": str(e)[:200]
                        })
                    else:
                        logger.warning(f"WebSocket connection failed (non-auth reason): {str(e)}")

                # Check for WebSocket authentication failures
                if websocket_failures:
                    failure_details = "\n".join([
                        f"  {f['test']}: {f['issue']}\n"
                        f"    Details: {f.get('response', f.get('error', 'No details'))}"
                        for f in websocket_failures
                    ])

                    raise AssertionError(
                        f"Issue #1037 WebSocket regression CONFIRMED IN STAGING:\n"
                        f"WebSocket authentication failures detected:\n{failure_details}\n\n"
                        f"This matches the 503 WebSocket errors described in Issue #1037."
                    )

                else:
                    logger.info("WebSocket authentication working in staging - regression not detected")

            except ImportError:
                self.skipTest("websockets library not available for staging WebSocket testing")
            except Exception as e:
                logger.error(f"Staging WebSocket test error: {str(e)}")
                self.skipTest(f"Cannot test staging WebSocket auth: {str(e)}")

        # Run staging WebSocket test
        asyncio.run(test_websocket_staging_auth())

    def test_staging_end_to_end_user_authentication_flow(self):
        """
        REGRESSION TEST: Test complete end-to-end user authentication flow
        in staging to verify Issue #1037 doesn't break user experience.

        EXPECTED: This test will FAIL if Issue #1037 prevents user authentication.
        """
        logger.info("Testing end-to-end user authentication flow in staging...")

        async def test_user_auth_flow():
            """Test complete user authentication flow in staging."""
            user_flow_failures = []

            try:
                async with httpx.AsyncClient(timeout=30.0) as client:

                    # Step 1: Test user registration endpoint
                    registration_response = await client.post(
                        f"{self.staging_auth_url}/auth/register",
                        headers={"Content-Type": "application/json"},
                        json={
                            "email": f"test-{datetime.now().timestamp()}@example.com",
                            "password": "TestPassword123!",
                            "name": "Issue 1037 Test User"
                        }
                    )

                    if registration_response.status_code == 403:
                        user_flow_failures.append({
                            "step": "user_registration",
                            "status": 403,
                            "issue": "User registration blocked by authentication issue",
                            "response": registration_response.text[:200]
                        })

                    # Step 2: Test login endpoint
                    login_response = await client.post(
                        f"{self.staging_auth_url}/auth/login",
                        headers={"Content-Type": "application/json"},
                        json={
                            "email": "test@example.com",
                            "password": "TestPassword123!"
                        }
                    )

                    if login_response.status_code == 403:
                        user_flow_failures.append({
                            "step": "user_login",
                            "status": 403,
                            "issue": "User login failed with authentication error",
                            "response": login_response.text[:200]
                        })

                    # Step 3: Test token refresh (if login succeeded)
                    if login_response.status_code == 200:
                        try:
                            login_data = login_response.json()
                            refresh_token = login_data.get("refresh_token")

                            if refresh_token:
                                refresh_response = await client.post(
                                    f"{self.staging_auth_url}/auth/refresh",
                                    headers={"Content-Type": "application/json"},
                                    json={"refresh_token": refresh_token}
                                )

                                if refresh_response.status_code == 403:
                                    user_flow_failures.append({
                                        "step": "token_refresh",
                                        "status": 403,
                                        "issue": "Token refresh failed with authentication error",
                                        "response": refresh_response.text[:200]
                                    })

                        except Exception as e:
                            user_flow_failures.append({
                                "step": "token_parsing",
                                "issue": "Failed to parse login response for token refresh",
                                "error": str(e)[:200]
                            })

                # Analyze user flow failures
                if user_flow_failures:
                    flow_summary = "\n".join([
                        f"  {f['step']}: {f.get('status', 'Error')} - {f['issue']}\n"
                        f"    Response: {f.get('response', f.get('error', 'No details'))}"
                        for f in user_flow_failures
                    ])

                    raise AssertionError(
                        f"Issue #1037 USER FLOW REGRESSION CONFIRMED IN STAGING:\n"
                        f"End-to-end authentication flow broken:\n{flow_summary}\n\n"
                        f"This confirms Issue #1037 affects real user experience. "
                        f"Business Impact: Complete user lockout in staging environment."
                    )

                else:
                    logger.info("End-to-end user authentication flow working in staging")

            except httpx.RequestError as e:
                self.skipTest(f"Staging user flow test failed - service unavailable: {str(e)}")

        # Run user flow test
        asyncio.run(test_user_auth_flow())

    def test_staging_configuration_drift_detection(self):
        """
        VALIDATION TEST: Check if staging environment configuration
        matches expected patterns and detect any drift that could cause Issue #1037.

        EXPECTED: This test provides configuration analysis for Issue #1037.
        """
        logger.info("Analyzing staging configuration for Issue #1037 patterns...")

        async def analyze_staging_config():
            """Analyze staging configuration for authentication issues."""
            config_issues = []

            try:
                async with httpx.AsyncClient(timeout=15.0) as client:

                    # Check configuration endpoints if available
                    config_endpoints = [
                        "/config/auth",
                        "/health/config",
                        "/debug/config"
                    ]

                    for endpoint in config_endpoints:
                        try:
                            for service_url in [self.staging_backend_url, self.staging_auth_url]:
                                config_response = await client.get(f"{service_url}{endpoint}")

                                if config_response.status_code == 200:
                                    config_data = config_response.text

                                    # Look for Issue #1037 indicators
                                    issue_indicators = [
                                        ("JWT_SECRET_KEY missing", "JWT_SECRET_KEY" not in config_data),
                                        ("SERVICE_SECRET missing", "SERVICE_SECRET" not in config_data),
                                        ("Mixed auth patterns", "JWT_SECRET" in config_data and "SERVICE_SECRET" in config_data),
                                        ("Auth service errors", "error" in config_data.lower() or "fail" in config_data.lower())
                                    ]

                                    for indicator_name, condition in issue_indicators:
                                        if condition:
                                            config_issues.append({
                                                "service": service_url,
                                                "endpoint": endpoint,
                                                "issue": indicator_name,
                                                "config_sample": config_data[:100]
                                            })

                        except httpx.RequestError:
                            # Config endpoint not available - not necessarily an issue
                            continue

                # Report configuration analysis
                if config_issues:
                    config_summary = "\n".join([
                        f"  {issue['service']}{issue['endpoint']}: {issue['issue']}\n"
                        f"    Config: {issue['config_sample']}..."
                        for issue in config_issues
                    ])

                    logger.warning(
                        f"Staging configuration analysis found potential Issue #1037 indicators:\n"
                        f"{config_summary}\n\n"
                        f"These patterns may contribute to authentication problems."
                    )

                else:
                    logger.info("Staging configuration analysis complete - no obvious Issue #1037 patterns detected")

            except Exception as e:
                logger.info(f"Staging config analysis skipped: {str(e)}")

        # Run configuration analysis
        asyncio.run(analyze_staging_config())


if __name__ == "__main__":
    # Run E2E staging tests for Issue #1037 validation
    pytest.main([__file__, "-v", "--tb=long", "-s"])