"""
Security Test Suite for Issue #566: LLM Cache Isolation Vulnerability

CRITICAL P1 SECURITY VULNERABILITY:
- startup_module.py:649 creates shared LLM manager without user context
- smd.py:1019 creates shared LLM manager without user context
- This allows cross-user cache contamination and data leakage

Test Strategy:
1. Prove vulnerability exists in startup modules (should fail initially)
2. Validate security fixes work (should pass after fixes)
3. Ensure regression prevention

Security Impact: HIGH - User conversation isolation compromised
Business Impact: $500K+ ARR at risk due to privacy violations
"""
import pytest
import asyncio
from unittest.mock import Mock, patch
from fastapi import FastAPI
from test_framework.ssot.base_test_case import SSotAsyncTestCase
from netra_backend.app.services.user_execution_context import UserExecutionContext

class CacheIsolationVulnerabilityIssue566Tests(SSotAsyncTestCase):
    """
    CRITICAL SECURITY TESTS: LLM Cache Isolation Vulnerability Issue #566
    
    This test suite demonstrates and validates fixes for a P1 security vulnerability
    where startup modules create shared LLM managers without user context isolation.
    """

    def setUp(self):
        """Set up test fixtures for security vulnerability testing."""
        super().setUp()
        self.user_a_context = UserExecutionContext(user_id='user_a_test_123', thread_id='thread_a_test_123', run_id='run_a_test_123', request_id='req_a_test')
        self.user_b_context = UserExecutionContext(user_id='user_b_test_456', thread_id='thread_b_test_456', run_id='run_b_test_456', request_id='req_b_test')
        self.test_app = FastAPI()

    def test_startup_module_security_vulnerability_demonstration(self):
        """
        SECURITY TEST: Demonstrate vulnerability in startup_module.py:649
        
        This test SHOULD FAIL initially, proving the vulnerability exists.
        After security fixes, this test SHOULD PASS.
        """
        import inspect
        from netra_backend.app.startup_module import setup_security_services
        source_code = inspect.getsource(setup_security_services)
        self.assertNotIn('create_llm_manager()', source_code, 'SECURITY VIOLATION DETECTED: startup_module.py:649 contains vulnerable create_llm_manager() call without user context - this allows cache isolation compromise and cross-user data leakage')

    def test_smd_security_vulnerability_demonstration(self):
        """
        SECURITY TEST: Demonstrate vulnerability in smd.py:1019
        
        This test SHOULD FAIL initially, proving the vulnerability exists.
        After security fixes, this test SHOULD PASS.
        """
        import inspect
        from netra_backend.app.smd import StartupOrchestrator
        source_code = inspect.getsource(StartupOrchestrator._initialize_llm_manager)
        self.assertNotIn('create_llm_manager()', source_code, 'SECURITY VIOLATION DETECTED: smd.py:1019 contains vulnerable create_llm_manager() call without user context - this allows cache isolation compromise and cross-user data leakage')

    async def test_cross_user_cache_isolation_vulnerability(self):
        """
        SECURITY TEST: Demonstrate cross-user cache contamination vulnerability
        
        This test simulates the real-world security impact where User A's
        cached responses could leak to User B due to shared LLM manager.
        """
        from netra_backend.app.llm.llm_manager import create_llm_manager
        vulnerable_manager_1 = create_llm_manager()
        vulnerable_manager_2 = create_llm_manager()
        cache_key_user_a = 'conversation_cache_sensitive_data_user_a'
        cache_key_user_b = 'conversation_cache_sensitive_data_user_b'
        with patch.object(vulnerable_manager_1, '_cache', {}) as cache_1, patch.object(vulnerable_manager_2, '_cache', {}) as cache_2:
            cache_1[cache_key_user_a] = 'SENSITIVE_USER_A_DATA'
            self.assertNotIn(cache_key_user_a, cache_2, "CRITICAL SECURITY VIOLATION: Cross-user cache contamination detected! User B can access User A's cached conversation data")

    def test_user_context_factory_pattern_security_fix(self):
        """
        SECURITY TEST: Validate user-context-aware factory pattern fixes vulnerability
        
        This test validates the security fix that replaces direct create_llm_manager()
        calls with user-context-aware factory pattern.
        """
        from netra_backend.app.llm.llm_manager import create_llm_manager
        secure_manager_a = create_llm_manager(self.user_a_context)
        secure_manager_b = create_llm_manager(self.user_b_context)
        self.assertNotEqual(id(secure_manager_a), id(secure_manager_b), 'SECURITY FIX VALIDATION: User-isolated managers should be separate instances')
        self.assertEqual(secure_manager_a.user_context.user_id, self.user_a_context.user_id, "SECURITY FIX VALIDATION: Manager A should have User A's context")
        self.assertEqual(secure_manager_b.user_context.user_id, self.user_b_context.user_id, "SECURITY FIX VALIDATION: Manager B should have User B's context")

    def test_cache_key_user_isolation_security_fix(self):
        """
        SECURITY TEST: Validate cache keys include user_id for proper isolation
        
        This test ensures the security fix includes user_id in cache keys
        to prevent cross-user data contamination.
        """
        from netra_backend.app.llm.llm_manager import create_llm_manager
        manager_a = create_llm_manager(self.user_a_context)
        manager_b = create_llm_manager(self.user_b_context)
        test_prompt = 'What is machine learning?'
        with patch.object(manager_a, '_generate_cache_key') as mock_cache_key_a, patch.object(manager_b, '_generate_cache_key') as mock_cache_key_b:
            mock_cache_key_a.return_value = f'user_{self.user_a_context.user_id}_{hash(test_prompt)}'
            mock_cache_key_b.return_value = f'user_{self.user_b_context.user_id}_{hash(test_prompt)}'
            cache_key_a = manager_a._generate_cache_key(test_prompt)
            cache_key_b = manager_b._generate_cache_key(test_prompt)
            self.assertNotEqual(cache_key_a, cache_key_b, 'SECURITY FIX VALIDATION: Cache keys must include user_id for isolation')
            self.assertIn(self.user_a_context.user_id, cache_key_a, "SECURITY FIX VALIDATION: Cache key A must include User A's ID")
            self.assertIn(self.user_b_context.user_id, cache_key_b, "SECURITY FIX VALIDATION: Cache key B must include User B's ID")

    def test_regression_prevention_startup_module_security(self):
        """
        REGRESSION TEST: Prevent future introduction of vulnerable startup patterns
        
        This test ensures startup_module.py uses secure factory pattern
        and never reverts to vulnerable shared LLM manager creation.
        """
        import inspect
        from netra_backend.app.startup_module import setup_security_services
        source_code = inspect.getsource(setup_security_services)
        self.assertNotIn('create_llm_manager()', source_code, 'REGRESSION PREVENTION: startup_module.py must not use create_llm_manager() without user context - use factory pattern instead')

    def test_regression_prevention_smd_security(self):
        """
        REGRESSION TEST: Prevent future introduction of vulnerable SMD patterns
        
        This test ensures smd.py uses secure factory pattern
        and never reverts to vulnerable shared LLM manager creation.
        """
        import inspect
        from netra_backend.app.smd import StartupOrchestrator
        source_code = inspect.getsource(StartupOrchestrator._initialize_llm_manager)
        self.assertNotIn('create_llm_manager()', source_code, 'REGRESSION PREVENTION: smd.py must not use create_llm_manager() without user context - use factory pattern instead')

class SecurityFixValidationTests(SSotAsyncTestCase):
    """
    Validation tests for security fixes - these should PASS after fixes are implemented
    """

    def test_startup_module_security_fix_validation(self):
        """
        Validate that startup_module.py has been fixed to use secure factory pattern
        """
        from netra_backend.app.startup_module import setup_security_services
        import inspect
        source_code = inspect.getsource(setup_security_services)
        self.assertTrue('# SECURITY FIX' in source_code or 'factory' in source_code.lower(), 'SECURITY FIX VALIDATION: startup_module.py should use secure factory pattern')

    def test_smd_security_fix_validation(self):
        """
        Validate that smd.py has been fixed to use secure factory pattern
        """
        from netra_backend.app.smd import StartupOrchestrator
        import inspect
        source_code = inspect.getsource(StartupOrchestrator._initialize_llm_manager)
        self.assertTrue('# SECURITY FIX' in source_code or 'factory' in source_code.lower(), 'SECURITY FIX VALIDATION: smd.py should use secure factory pattern')
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')