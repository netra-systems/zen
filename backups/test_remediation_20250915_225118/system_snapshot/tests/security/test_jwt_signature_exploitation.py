class TestWebSocketConnection:
    """Real WebSocket connection for testing instead of mocks."""

    def __init__(self):
        pass
        self.messages_sent = []
        self.is_connected = True
        self._closed = False

    async def send_json(self, message: dict):
        """Send JSON message."""
        if self._closed:
        raise RuntimeError("WebSocket is closed")
        self.messages_sent.append(message)

    async def close(self, code: int = 1000, reason: str = "Normal closure"):
        """Close WebSocket connection."""
        pass
        self._closed = True
        self.is_connected = False

    def get_messages(self) -> list:
        """Get all sent messages."""
        await asyncio.sleep(0)
        return self.messages_sent.copy()

        '''
        CRITICAL FAILING TEST SUITE: JWT Signature Exploitation
        Purpose: Expose vulnerabilities in JWT/service signature collision when using fallback
        Expected: ALL tests should FAIL to demonstrate signature exploitation risks

        This suite specifically tests the cryptographic weaknesses that arise when
        service_secret falls back to jwt_secret_key, creating signature collisions.

        Business Value Justification (BVJ):
        - Segment: All - Critical security foundation
        - Business Goal: Prevent signature forgery and token manipulation
        - Value Impact: Protects authentication integrity across all services
        - Strategic Impact: Signature vulnerabilities enable complete OAUTH SIMULATION
        '''

        import pytest
        import asyncio
        import jwt
        import hmac
        import hashlib
        import json
        import base64
        import time
        import os
        import sys
        from typing import Dict, Any, Optional
        from datetime import datetime, timedelta, timezone
        from netra_backend.app.websocket_core.canonical_import_patterns import WebSocketManager
        from test_framework.database.test_database_manager import DatabaseTestManager
        from auth_service.core.auth_manager import AuthManager
        from shared.isolated_environment import IsolatedEnvironment


        from netra_backend.app.services.user_auth_service import UserAuthService
        from netra_backend.app.core.configuration import unified_config_manager
        from netra_backend.app.schemas.config import AppConfig
        from netra_backend.app.core.unified_error_handler import UnifiedErrorHandler
        from netra_backend.app.db.database_manager import DatabaseManager
        from shared.isolated_environment import get_env


class TestJWTSignatureExploitation:
        '''
        Tests that exploit JWT and service signature weaknesses
        when service_secret falls back to jwt_secret_key
        '''

        @pytest.fixture
    def shared_secret_config(self):
        """Use real service instance."""
    # TODO: Initialize real service
        """Config where service_secret falls back to jwt_secret_key"""
        pass
    # Mock: Component isolation for controlled unit testing
        config = Mock(spec=AppConfig)
        config.service_secret = None  # Forces fallback
        config.jwt_secret_key = "shared-vulnerable-secret-123"
        config.environment = "development"
        config.auth_service_url = "http://localhost:8001"
        return config

        @pytest.fixture
    def distinct_secret_config(self):
        """Use real service instance."""
    # TODO: Initialize real service
        """Config with properly separated secrets"""
        pass
    # Mock: Component isolation for controlled unit testing
        config = Mock(spec=AppConfig)
        config.service_secret = "unique-service-secret-" + os.urandom(16).hex()
        config.jwt_secret_key = "unique-jwt-secret-" + os.urandom(16).hex()
        config.environment = "production"
        config.auth_service_url = "http://localhost:8001"
        return config

@pytest.mark.asyncio
    async def test_jwt_secret_key_service_signature_collision(self, shared_secret_config):
'''
TEST 1: Detect when JWT and service signatures use same secret
EXPECTED FAILURE: Signatures collide enabling cross-domain attacks
ATTACK VECTOR: Cross-domain signature validation bypass
'''
pass
        # Arrange
        # Mock: Component isolation for testing without external dependencies
auth_service = UserAuthService()

        # Create JWT token
jwt_payload = { )
"user_id": "user-123",
"email": "user@example.com",
"exp": time.time() + 3600
        

jwt_token = jwt.encode( )
jwt_payload,
shared_secret_config.jwt_secret_key,
algorithm="HS256"
        

        # Create service signature for same payload
service_payload = json.dumps(jwt_payload, sort_keys=True)
service_signature = hmac.new( )
shared_secret_config.jwt_secret_key.encode(),
service_payload.encode(),
hashlib.sha256
).hexdigest()

        # Act - Try to use JWT signature as service signature
jwt_signature = jwt_token.split('.')[-1]

        # Decode JWT signature (base64url)
jwt_sig_bytes = base64.urlsafe_b64decode(jwt_signature + '==')

        # Assert - Signatures should be cryptographically separated
assert service_signature != jwt_sig_bytes.hex(), ( )
"VULNERABILITY: JWT and service signatures can be interchanged! "
"Same secret used for different cryptographic purposes enables signature confusion attacks."
        

        # Verify domain separation
with pytest.raises(ValueError, match="signature domain mismatch"):
            # Attempt to validate JWT signature as service signature
auth_service._verify_service_signature(jwt_payload, jwt_signature)

@pytest.mark.asyncio
    async def test_token_signature_algorithm_confusion(self, shared_secret_config):
'''
TEST 2: Exploit algorithm confusion between JWT and service signatures
EXPECTED FAILURE: Different algorithms can be mixed
ATTACK VECTOR: Algorithm downgrade attack
'''
pass
                # Arrange
                # Mock: Component isolation for testing without external dependencies
auth_service = UserAuthService()

secret = shared_secret_config.jwt_secret_key
payload = {"user_id": "victim", "role": "user"}

                # Create signatures with different algorithms
algorithms = [ )
("HS256", hashlib.sha256),
("HS384", hashlib.sha384),
("HS512", hashlib.sha512),
("none", None),  # Algorithm confusion attack
                

signatures = {}
for alg_name, hash_func in algorithms:
if alg_name == "none":
                        # Attempt to bypass with no signature
signatures[alg_name] = ""
elif hash_func:
signatures[alg_name] = hmac.new( )
secret.encode(),
json.dumps(payload).encode(),
hash_func
).hexdigest()

                            # Act - Try to mix algorithms
for alg1 in signatures:
for alg2 in signatures:
if alg1 != alg2:
                                        # Attempt algorithm confusion
mixed_token = { )
"payload": payload,
"signature": signatures[alg1],
"algorithm": alg2
                                        

                                        # Assert - Mixed algorithms should be rejected
with pytest.raises(ValueError, match="algorithm mismatch|invalid algorithm"):
auth_service._validate_signature_algorithm(mixed_token)

                                            # Specifically test "none" algorithm bypass
assert signatures["none"] != "", ( )
"VULNERABILITY: 'none' algorithm accepted for signatures! "
"This allows complete signature bypass."
                                            

@pytest.mark.asyncio
    async def test_service_signature_tampering(self, shared_secret_config):
'''
TEST 3: Tamper with service signature using known secret
EXPECTED FAILURE: Tampered signatures accepted
ATTACK VECTOR: Signature forgery
'''
pass
                                                # Arrange
                                                # Mock: Component isolation for testing without external dependencies
auth_service = UserAuthService()

                                                # Original legitimate data
original_data = { )
"user_id": "legitimate-user",
"role": "viewer",
"permissions": ["read"]
                                                

                                                # Create legitimate signature
secret = shared_secret_config.jwt_secret_key
original_sig = hmac.new( )
secret.encode(),
json.dumps(original_data, sort_keys=True).encode(),
hashlib.sha256
).hexdigest()

                                                # Act - Tamper with data and create new signature
tampered_data = original_data.copy()
tampered_data["role"] = "admin"  # Privilege escalation
tampered_data["permissions"] = ["read", "write", "delete"]

                                                # Forge new signature with known secret
tampered_sig = hmac.new( )
secret.encode(),
json.dumps(tampered_data, sort_keys=True).encode(),
hashlib.sha256
).hexdigest()

                                                # Create mock validation context
                                                # Mock: Authentication service isolation for testing without real auth flows
websocket = TestWebSocketConnection()
mock_auth_client.validate_token.return_value = { )
**tampered_data,
"service_signature": tampered_sig,
"valid": True,
"verified_at": datetime.now(timezone.utc).isoformat()
                                                

                                                # Mock: Authentication service isolation for testing without real auth flows
result = await auth_service.validate_user_token("tampered-token")

                                                # Assert - Tampered data should be rejected
assert result is None or result.get("role") != "admin", ( )
"VULNERABILITY: Signature tampering successful! "
"Attacker escalated privileges by forging new signature with known secret."
                                                

                                                # Verify original data integrity
assert original_data["role"] == "viewer", "Original data should not be modified"

@pytest.mark.asyncio
    async def test_hmac_timing_attack_service_validation(self, shared_secret_config):
'''
TEST 4: Time-based attack on HMAC comparison
EXPECTED FAILURE: Timing differences reveal signature information
ATTACK VECTOR: Side-channel timing analysis
'''
pass
                                                    # Arrange
                                                    # Mock: Component isolation for testing without external dependencies
auth_service = UserAuthService()

secret = shared_secret_config.jwt_secret_key
payload = {"user_id": "timing-victim"}

                                                    # Create correct signature
correct_sig = hmac.new( )
secret.encode(),
json.dumps(payload).encode(),
hashlib.sha256
).hexdigest()

                                                    # Act - Measure timing for different signatures
timing_results = []

                                                    # Test signatures with increasing similarity to correct one
test_sigs = [ )
"0" * len(correct_sig),  # Completely wrong
correct_sig[:1] + "0" * (len(correct_sig) - 1),  # First char correct
correct_sig[:len(correct_sig)//2] + "0" * (len(correct_sig)//2),  # Half correct
correct_sig[:-1] + "0",  # All but last char correct
correct_sig  # Completely correct
                                                    

for test_sig in test_sigs:
start_time = time.perf_counter_ns()

                                                        # Simulate signature comparison
try:
                                                            # This should use constant-time comparison
is_valid = hmac.compare_digest(test_sig, correct_sig)
except:
is_valid = test_sig == correct_sig  # Vulnerable comparison

end_time = time.perf_counter_ns()
timing_results.append((test_sig[:8], end_time - start_time, is_valid))

                                                                # Assert - Timing should be constant regardless of similarity
timings = [t[1] for t in timing_results[:-1]]  # Exclude correct sig
avg_timing = sum(timings) / len(timings)
max_deviation = max(abs(t - avg_timing) for t in timings)

                                                                # Check for timing attack vulnerability
timing_variance_threshold = avg_timing * 0.1  # 10% variance threshold

assert max_deviation < timing_variance_threshold, ( )
f"VULNERABILITY: Timing attack possible! "
"formatted_string"
f"This reveals information about correct signature through timing side-channel. "
"formatted_string"
                                                                

@pytest.mark.asyncio
    async def test_service_signature_length_extension(self, shared_secret_config):
'''
TEST 5: Hash length extension attack
EXPECTED FAILURE: Can extend signed messages without knowing secret
ATTACK VECTOR: Extend service signature payload
'''
pass
                                                                    # Arrange
                                                                    # Mock: Component isolation for testing without external dependencies
auth_service = UserAuthService()

secret = shared_secret_config.jwt_secret_key

                                                                    # Original message and signature
original_message = json.dumps({"user_id": "user-1", "role": "user"})
original_sig = hmac.new( )
secret.encode(),
original_message.encode(),
hashlib.sha256
).hexdigest()

                                                                    # Act - Attempt length extension attack
                                                                    # Note: HMAC should prevent this, but test for vulnerability
extension = ', "admin": true}'
extended_message = original_message[:-1] + extension

                                                                    # Try to forge extended signature without knowing secret
                                                                    # This simulates what an attacker would attempt

                                                                    # Calculate what signature would be if vulnerable to length extension
                                                                    # (This would work with plain hash, not HMAC)
forged_data = { )
"message": extended_message,
"signature": original_sig,  # Reuse original
"valid": True
                                                                    

                                                                    # Assert - Length extension should fail with HMAC
extended_sig = hmac.new( )
secret.encode(),
extended_message.encode(),
hashlib.sha256
).hexdigest()

assert extended_sig != original_sig, ( )
"VULNERABILITY: Length extension attack possible! "
"Original signature valid for extended message. "
"This indicates improper use of hash function instead of HMAC."
                                                                    

                                                                    # Verify HMAC is actually being used
assert hasattr(auth_service, '_generate_service_signature'), ( )
"VULNERABILITY: No service signature generation method found"
                                                                    

@pytest.mark.asyncio
    async def test_signature_malleability_attack(self, shared_secret_config):
'''
TEST 6: Test for signature malleability
EXPECTED FAILURE: Modified signatures still validate
ATTACK VECTOR: Signature format manipulation
'''
pass
                                                                        # Arrange
                                                                        # Mock: Component isolation for testing without external dependencies
auth_service = UserAuthService()

secret = shared_secret_config.jwt_secret_key
payload = {"user_id": "malleable-user", "timestamp": time.time()}

                                                                        # Create signature
signature = hmac.new( )
secret.encode(),
json.dumps(payload, sort_keys=True).encode(),
hashlib.sha256
).hexdigest()

                                                                        # Act - Test various signature malleability attacks
malleable_sigs = [ )
signature.upper(),  # Case variation
signature.lower(),
" " + signature + " ",  # Whitespace
signature + "\x00",  # Null byte injection
signature[::-1],  # Reversed
signature + signature,  # Duplicated
                                                                        

validation_results = []
for mal_sig in malleable_sigs:
try:
                                                                                # Attempt validation with malleable signature
is_valid = mal_sig.strip().lower() == signature.lower()
validation_results.append((mal_sig[:20], is_valid))
except:
validation_results.append((mal_sig[:20], False))

                                                                                    # Assert - Only exact signature should validate
valid_count = sum(1 for _, valid in validation_results if valid)
assert valid_count == 0, ( )
f"VULNERABILITY: Signature malleability detected! "
"formatted_string"
f"Signatures should be validated with exact byte comparison. "
"formatted_string"
                                                                                    

@pytest.mark.asyncio
    async def test_key_confusion_attack(self, shared_secret_config, distinct_secret_config):
'''
TEST 7: Test for key confusion between services
EXPECTED FAILURE: Wrong keys accepted for validation
ATTACK VECTOR: Use keys from different contexts
'''
pass
                                                                                        # Arrange - Create auth services with different configs
                                                                                        # Mock: Component isolation for testing without external dependencies
vulnerable_service = UserAuthService()

                                                                                        # Mock: Component isolation for testing without external dependencies
secure_service = UserAuthService()

                                                                                        # Create token signed with one secret
payload = {"user_id": "confused-user", "service": "auth"}

vulnerable_sig = hmac.new( )
shared_secret_config.jwt_secret_key.encode(),
json.dumps(payload).encode(),
hashlib.sha256
).hexdigest()

secure_sig = hmac.new( )
distinct_secret_config.service_secret.encode(),
json.dumps(payload).encode(),
hashlib.sha256
).hexdigest()

                                                                                        # Act - Try to validate with wrong service
                                                                                        # Mock: Authentication service isolation for testing without real auth flows
websocket = TestWebSocketConnection()
mock_auth_client.validate_token.return_value = { )
**payload,
"service_signature": vulnerable_sig,
"valid": True,
"verified_at": datetime.now(timezone.utc).isoformat()
                                                                                        

                                                                                        # Try to validate vulnerable signature with secure service
                                                                                        # Mock: Authentication service isolation for testing without real auth flows
                                                                                        # Mock: Component isolation for testing without external dependencies
result = await secure_service.validate_user_token("confused-token")

                                                                                        # Assert - Cross-service signatures should fail
assert result is None, ( )
"VULNERABILITY: Key confusion attack successful! "
"Signature from one service accepted by another service. "
"Services must use cryptographically isolated keys."
                                                                                        

@pytest.mark.asyncio
    async def test_signature_stripping_attack(self, shared_secret_config):
'''
TEST 8: Test signature stripping vulnerability
EXPECTED FAILURE: Tokens accepted without signatures
ATTACK VECTOR: Remove signature from token
'''
pass
                                                                                            # Arrange
                                                                                            # Mock: Component isolation for testing without external dependencies
auth_service = UserAuthService()

                                                                                            # Create valid token data without signature
unsigned_data = { )
"user_id": "unsigned-user",
"email": "attacker@example.com",
"role": "admin",
"valid": True,
"verified_at": datetime.now(timezone.utc).isoformat()
                                                                                            

                                                                                            # Act - Try validation without signature
websocket = TestWebSocketConnection()
mock_auth_client.validate_token.return_value = unsigned_data

                                                                                            # Mock: Authentication service isolation for testing without real auth flows
result = await auth_service.validate_user_token("unsigned-token")

                                                                                            # Assert - Unsigned tokens should be rejected
assert result is None, ( )
"VULNERABILITY: Signature stripping attack successful! "
"Token accepted without service_signature field. "
"All tokens must have valid signatures."
                                                                                            

                                                                                            # Test with empty signature
unsigned_data["service_signature"] = ""
mock_auth_client.validate_token.return_value = unsigned_data

                                                                                            # Mock: Authentication service isolation for testing without real auth flows
result = await auth_service.validate_user_token("empty-sig-token")

assert result is None, ( )
"VULNERABILITY: Empty signature accepted! "
"Tokens with empty service_signature field should be rejected."
                                                                                            


                                                                                            # Standalone execution
if __name__ == "__main__":
print("=" * 80)
print("EXECUTING FAILING TEST SUITE: JWT Signature Exploitation")
print("Testing cryptographic vulnerabilities in signature handling")
print("Expected: ALL tests should FAIL")
print("=" * 80)

pytest.main([__file__, "-vvv", "-s", "--tb=short", "--color=yes"])
