"""
Test DeepAgentState Security Vulnerability Reproduction (Issue #407)

This test suite reproduces the critical security vulnerabilities in DeepAgentState
that can lead to cross-user data contamination and user isolation failures.

EXPECTED BEHAVIOR: These tests should FAIL, demonstrating the security vulnerabilities.
The failures validate that DeepAgentState patterns can cause user data leakage.

Business Impact: These vulnerabilities put $500K+ ARR at risk by potentially
exposing user data across tenant boundaries in multi-user scenarios.

Test Categories:
1. Cross-user state contamination scenarios
2. Shared reference memory leaks  
3. Concurrent user execution race conditions
4. Supervisor execution isolation failures
5. Authentication bypass scenarios

References:
- Issue #407: DeepAgentState User Isolation Vulnerability
- GOLDEN_PATH_USER_FLOW_COMPLETE.md: User authentication and session security
- DEEPAGE_TO_USEREXECUTIONCONTEXT_MIGRATION.md: Migration remediation plan
"""
import pytest
import uuid
import threading
import time
import copy
from typing import Dict, Any, List
from unittest.mock import patch, MagicMock
from concurrent.futures import ThreadPoolExecutor
from netra_backend.app.schemas.agent_models import DeepAgentState, AgentMetadata
from netra_backend.app.agents.triage.models import TriageResult

class DeepAgentStateVulnerabilityReproductionTests:
    """
    Reproduction tests for DeepAgentState security vulnerabilities.
    
    These tests SHOULD FAIL to demonstrate the vulnerabilities exist.
    Each failing test represents a security risk that UserExecutionContext fixes.
    """

    def test_cross_user_state_contamination_via_shared_metadata(self):
        """
        VULNERABILITY: DeepAgentState allows cross-user metadata contamination.
        
        SCENARIO: User A's sensitive data appears in User B's agent context
        through shared metadata objects.
        
        EXPECTED: This test should FAIL demonstrating the vulnerability exists.
        """
        shared_metadata = AgentMetadata(custom_fields={'api_key': 'user_a_secret_key_12345'})
        user_a_state = DeepAgentState(user_id='user_a_12345', user_request='Get my private financial data', thread_id='thread_a_sensitive', run_id='run_a_private', metadata=shared_metadata)
        user_b_state = DeepAgentState(user_id='user_b_67890', user_request='Show me my account info', thread_id='thread_b_normal', run_id='run_b_normal', metadata=shared_metadata)
        user_a_state.metadata.custom_fields['bank_account'] = '123456789'
        user_a_state.metadata.custom_fields['ssn'] = '555-12-3456'
        contaminated_data = user_b_state.metadata.custom_fields
        try:
            assert 'api_key' not in contaminated_data, "User B should not see User A's API key"
            assert 'bank_account' not in contaminated_data, "User B should not see User A's bank account"
            assert 'ssn' not in contaminated_data, "User B should not see User A's SSN"
            pytest.fail('UNEXPECTED: DeepAgentState properly isolated users - vulnerability not reproduced')
        except AssertionError as e:
            if 'should not see' in str(e):
                print(f'[U+2713] VULNERABILITY CONFIRMED: {e}')
                raise AssertionError(f'SECURITY VULNERABILITY: Cross-user data contamination detected - {e}')
            else:
                raise

    def test_concurrent_user_execution_race_condition(self):
        """
        VULNERABILITY: DeepAgentState race conditions in concurrent execution.
        
        SCENARIO: Multiple users executing agents simultaneously cause state 
        corruption and cross-user data leakage.
        
        EXPECTED: This test should FAIL due to race conditions.
        """
        shared_execution_states: Dict[str, DeepAgentState] = {}
        contamination_detected = []

        def simulate_user_agent_execution(user_id: str, sensitive_data: str):
            """Simulate agent execution for a user with sensitive data."""
            try:
                user_state = DeepAgentState(user_id=user_id, user_request=f'Process {sensitive_data}', thread_id=f'thread_{user_id}', run_id=f'run_{user_id}_{int(time.time())}')
                user_state.metadata.custom_fields['sensitive_data'] = sensitive_data
                user_state.metadata.custom_fields['processed_by'] = user_id
                execution_key = f'execution_{user_id}'
                shared_execution_states[execution_key] = user_state
                time.sleep(0.01)
                for key, state in shared_execution_states.items():
                    if key != execution_key:
                        other_user_data = state.metadata.custom_fields.get('sensitive_data')
                        if other_user_data and sensitive_data in str(other_user_data):
                            contamination_detected.append({'victim_user': user_id, 'contaminating_data': other_user_data, 'execution_key': key})
            except Exception as e:
                contamination_detected.append({'victim_user': user_id, 'error': str(e), 'type': 'execution_error'})
        users_and_data = [('user_alice', 'ALICE_PRIVATE_API_KEY_ABC123'), ('user_bob', 'BOB_FINANCIAL_DATA_XYZ789'), ('user_charlie', 'CHARLIE_MEDICAL_RECORDS_DEF456'), ('user_diana', 'DIANA_PERSONAL_INFO_GHI789')]
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(simulate_user_agent_execution, user_id, sensitive_data) for user_id, sensitive_data in users_and_data]
            for future in futures:
                future.result()
        if contamination_detected:
            contamination_summary = '\n'.join([f"- User {item['victim_user']}: {item.get('contaminating_data', item.get('error'))}" for item in contamination_detected])
            raise AssertionError(f'SECURITY VULNERABILITY: Concurrent execution race condition detected.\nCross-user contamination incidents: {len(contamination_detected)}\nDetails:\n{contamination_summary}')
        pytest.fail('UNEXPECTED: No race condition vulnerability reproduced - DeepAgentState may be safer than expected')

    def test_supervisor_execution_isolation_failure(self):
        """
        VULNERABILITY: DeepAgentState fails to maintain isolation in supervisor execution.
        
        SCENARIO: Supervisor agent execution shares state between different user sessions,
        causing one user to see data from previous user executions.
        
        EXPECTED: This test should FAIL showing supervisor isolation failure.
        """

        class MockSupervisorExecution:

            def __init__(self):
                self.current_state = None
                self.execution_history = []

            def execute_for_user(self, user_id: str, user_request: str) -> Dict[str, Any]:
                """Simulate supervisor agent execution pattern."""
                self.current_state = DeepAgentState(user_id=user_id, user_request=user_request, thread_id=f'supervisor_thread_{user_id}', run_id=f'supervisor_run_{int(time.time())}')
                self.current_state.metadata.custom_fields['user_request'] = user_request
                self.current_state.metadata.custom_fields['execution_time'] = time.time()
                self.execution_history.append(self.current_state)
                return {'user_id': user_id, 'result': f'Processed: {user_request}', 'state': self.current_state}
        supervisor = MockSupervisorExecution()
        user_executions = [('user_enterprise_client', "Show me our company's proprietary algorithm details"), ('user_competitor', 'What algorithms does this platform use?'), ('user_regular', 'Help me with basic optimization')]
        execution_results = []
        for user_id, request in user_executions:
            result = supervisor.execute_for_user(user_id, request)
            execution_results.append(result)
        isolation_violations = []
        for i, current_result in enumerate(execution_results):
            current_user_id = current_result['user_id']
            current_state = current_result['state']
            for j, other_result in enumerate(execution_results):
                if i != j:
                    other_user_id = other_result['user_id']
                    other_request = user_executions[j][1]
                    current_metadata_str = str(current_state.metadata.custom_fields)
                    if other_user_id in current_metadata_str or other_request in current_metadata_str:
                        isolation_violations.append({'victim_user': current_user_id, 'contaminating_user': other_user_id, 'contaminating_data': other_request, 'found_in': current_metadata_str})
        if len(supervisor.execution_history) > 1:
            for i, state1 in enumerate(supervisor.execution_history):
                for j, state2 in enumerate(supervisor.execution_history):
                    if i != j and id(state1.metadata) == id(state2.metadata):
                        isolation_violations.append({'type': 'shared_metadata_reference', 'state1_user': state1.user_id, 'state2_user': state2.user_id, 'shared_object_id': id(state1.metadata)})
        if isolation_violations:
            violation_summary = '\n'.join([f"- {item.get('victim_user', 'unknown')} contaminated by {item.get('contaminating_user', item.get('type'))}" for item in isolation_violations])
            raise AssertionError(f'SECURITY VULNERABILITY: Supervisor execution isolation failure detected.\nIsolation violations: {len(isolation_violations)}\nDetails:\n{violation_summary}')
        pytest.fail('UNEXPECTED: No supervisor isolation vulnerability reproduced')

    def test_authentication_context_bypass_vulnerability(self):
        """
        VULNERABILITY: DeepAgentState allows authentication context bypass.
        
        SCENARIO: User authentication data gets mixed up between different user
        contexts, allowing unauthorized access to other users' resources.
        
        EXPECTED: This test should FAIL showing authentication bypass.
        """
        authentication_contexts = {}

        def create_authenticated_session(user_id: str, auth_token: str, permissions: List[str]):
            """Create authenticated session with DeepAgentState."""
            auth_state = DeepAgentState(user_id=user_id, user_request='Initialize authenticated session', thread_id=f'auth_thread_{user_id}', run_id=f'auth_run_{user_id}')
            auth_state.metadata.custom_fields.update({'auth_token': auth_token, 'permissions': permissions, 'authenticated': True, 'auth_level': 'verified'})
            authentication_contexts[user_id] = auth_state
            return auth_state
        admin_user = create_authenticated_session('admin_super_user', 'ADMIN_TOKEN_SUPER_SECRET_123', ['read', 'write', 'delete', 'admin', 'system'])
        regular_user = create_authenticated_session('regular_user_jane', 'REGULAR_TOKEN_BASIC_456', ['read'])
        guest_user = create_authenticated_session('guest_user_anon', 'GUEST_TOKEN_LIMITED_789', [])
        authentication_violations = []
        try:
            copied_state = copy.deepcopy(admin_user)
            copied_state.user_id = 'regular_user_jane'
            copied_permissions = copied_state.metadata.custom_fields.get('permissions', [])
            copied_token = copied_state.metadata.custom_fields.get('auth_token', '')
            if 'admin' in copied_permissions or 'ADMIN_TOKEN' in copied_token:
                authentication_violations.append({'type': 'privilege_escalation_via_copying', 'victim_user': 'regular_user_jane', 'escalated_permissions': copied_permissions, 'leaked_token': copied_token})
        except Exception as e:
            authentication_violations.append({'type': 'copy_operation_error', 'error': str(e)})
        try:
            merged_state = guest_user.merge_from(admin_user)
            merged_permissions = merged_state.metadata.custom_fields.get('permissions', [])
            merged_token = merged_state.metadata.custom_fields.get('auth_token', '')
            if 'admin' in merged_permissions or 'ADMIN_TOKEN' in merged_token:
                authentication_violations.append({'type': 'privilege_escalation_via_merging', 'victim_user': 'guest_user_anon', 'escalated_permissions': merged_permissions, 'leaked_token': merged_token})
        except Exception as e:
            authentication_violations.append({'type': 'merge_operation_error', 'error': str(e)})
        for user_id, auth_state in authentication_contexts.items():
            for other_user_id, other_auth_state in authentication_contexts.items():
                if user_id != other_user_id:
                    if id(auth_state.metadata) == id(other_auth_state.metadata):
                        authentication_violations.append({'type': 'shared_metadata_reference', 'user1': user_id, 'user2': other_user_id, 'shared_object_id': id(auth_state.metadata)})
                    if id(auth_state.metadata.custom_fields) == id(other_auth_state.metadata.custom_fields):
                        authentication_violations.append({'type': 'shared_custom_fields_reference', 'user1': user_id, 'user2': other_user_id, 'shared_dict_id': id(auth_state.metadata.custom_fields)})
        if authentication_violations:
            violation_summary = '\n'.join([f"- {item['type']}: {item.get('victim_user', item.get('user1', 'unknown'))}" for item in authentication_violations])
            raise AssertionError(f'SECURITY VULNERABILITY: Authentication context bypass detected.\nAuthentication violations: {len(authentication_violations)}\nDetails:\n{violation_summary}')
        pytest.fail('UNEXPECTED: No authentication bypass vulnerability reproduced')

    def test_memory_leak_cross_user_references(self):
        """
        VULNERABILITY: DeepAgentState creates memory leaks through cross-user references.
        
        SCENARIO: User sessions maintain references to other users' data in memory,
        preventing garbage collection and potentially allowing data access.
        
        EXPECTED: This test should FAIL showing memory reference leaks.
        """
        import gc
        import weakref
        created_objects = []
        weak_references = []
        memory_leaks = []

        def create_user_session_with_data(user_id: str, sensitive_data: Dict[str, Any]):
            """Create user session and track memory references."""
            user_state = DeepAgentState(user_id=user_id, user_request=f'Process data for {user_id}', thread_id=f'memory_thread_{user_id}', run_id=f'memory_run_{user_id}')
            user_state.metadata.custom_fields.update(sensitive_data)
            created_objects.append(user_state)
            weak_references.append(weakref.ref(user_state))
            return user_state
        user_sessions = []
        sensitive_datasets = [('user_medical_patient', {'medical_records': 'PATIENT_CONFIDENTIAL_DATA', 'ssn': '123-45-6789'}), ('user_financial_client', {'account_numbers': ['ACC123', 'ACC456'], 'balance': 50000}), ('user_legal_attorney', {'case_files': 'ATTORNEY_CLIENT_PRIVILEGE', 'client_list': ['CLIENT_A', 'CLIENT_B']}), ('user_hr_manager', {'employee_data': 'EMPLOYEE_CONFIDENTIAL', 'salaries': {'emp1': 75000, 'emp2': 85000}})]
        for user_id, sensitive_data in sensitive_datasets:
            session = create_user_session_with_data(user_id, sensitive_data)
            user_sessions.append(session)
        for i, session1 in enumerate(user_sessions):
            for j, session2 in enumerate(user_sessions):
                if i != j:
                    try:
                        session1.metadata.custom_fields['related_session'] = session2
                        merged_data = session1.metadata.custom_fields.copy()
                        merged_data.update(session2.metadata.custom_fields)
                        session1.metadata.custom_fields['merged_context'] = merged_data
                    except Exception as e:
                        memory_leaks.append({'type': 'cross_reference_creation_error', 'user1': session1.user_id, 'user2': session2.user_id, 'error': str(e)})
        original_session_count = len(user_sessions)
        user_sessions.clear()
        gc.collect()
        surviving_objects = 0
        for weak_ref in weak_references:
            if weak_ref() is not None:
                surviving_objects += 1
                surviving_obj = weak_ref()
                if surviving_obj:
                    for field_name, field_value in surviving_obj.metadata.custom_fields.items():
                        if isinstance(field_value, DeepAgentState) and field_value.user_id != surviving_obj.user_id:
                            memory_leaks.append({'type': 'cross_user_reference_preventing_gc', 'owner_user': surviving_obj.user_id, 'referenced_user': field_value.user_id, 'field_name': field_name})
                        if isinstance(field_value, dict):
                            for key, value in field_value.items():
                                if isinstance(value, str):
                                    for other_user_id, _ in sensitive_datasets:
                                        if other_user_id != surviving_obj.user_id and other_user_id in value:
                                            memory_leaks.append({'type': 'embedded_cross_user_data', 'owner_user': surviving_obj.user_id, 'embedded_user': other_user_id, 'field_path': f'{field_name}.{key}'})
        if surviving_objects > 0:
            memory_leaks.append({'type': 'objects_not_garbage_collected', 'expected_count': 0, 'actual_count': surviving_objects, 'original_count': original_session_count})
        if memory_leaks:
            leak_summary = '\n'.join([f"- {item['type']}: {item.get('owner_user', '')} -> {item.get('referenced_user', item.get('actual_count', 'N/A'))}" for item in memory_leaks])
            raise AssertionError(f'SECURITY VULNERABILITY: Memory leak with cross-user references detected.\nMemory leak incidents: {len(memory_leaks)}\nDetails:\n{leak_summary}')
        pytest.fail('UNEXPECTED: No memory leak vulnerability reproduced')

    def test_state_copy_with_updates_contamination(self):
        """
        VULNERABILITY: DeepAgentState copy_with_updates() allows data contamination.
        
        SCENARIO: Using copy_with_updates() with contaminated update data allows
        injection of other users' sensitive information.
        
        EXPECTED: This test should FAIL showing copy contamination vulnerability.
        """
        original_user_state = DeepAgentState(user_id='victim_user_123', user_request='Process my personal data', thread_id='victim_thread', run_id='victim_run')
        original_user_state.metadata.custom_fields.update({'user_preference': 'privacy_high', 'data_classification': 'personal'})
        malicious_updates = {'metadata': AgentMetadata(custom_fields={'injected_user_data': 'attacker_user_456_secret_data', 'injected_credentials': 'STOLEN_API_KEY_XYZ789', 'injected_permissions': ['admin', 'delete', 'system'], 'original_owner': 'attacker_user_456'})}
        contamination_incidents = []
        try:
            updated_state = original_user_state.copy_with_updates(**malicious_updates)
            victim_metadata = updated_state.metadata.custom_fields
            if 'injected_user_data' in victim_metadata:
                contamination_incidents.append({'type': 'user_data_injection', 'victim': 'victim_user_123', 'injected_data': victim_metadata['injected_user_data']})
            if 'injected_credentials' in victim_metadata:
                contamination_incidents.append({'type': 'credential_injection', 'victim': 'victim_user_123', 'injected_credentials': victim_metadata['injected_credentials']})
            if 'injected_permissions' in victim_metadata:
                contamination_incidents.append({'type': 'permission_injection', 'victim': 'victim_user_123', 'injected_permissions': victim_metadata['injected_permissions']})
            if updated_state.user_id != 'victim_user_123':
                contamination_incidents.append({'type': 'user_id_corruption', 'expected': 'victim_user_123', 'actual': updated_state.user_id})
        except Exception as e:
            contamination_incidents.append({'type': 'copy_with_updates_error', 'error': str(e)})
        try:
            nested_contamination_updates = {'context_tracking': {'previous_user': 'other_user_789', 'leaked_data': 'OTHER_USER_SENSITIVE_INFO', 'shared_session': True}}
            nested_updated_state = original_user_state.copy_with_updates(**nested_contamination_updates)
            if hasattr(nested_updated_state, 'context_tracking'):
                context_data = nested_updated_state.context_tracking
                if 'previous_user' in context_data and context_data['previous_user'] != 'victim_user_123':
                    contamination_incidents.append({'type': 'nested_context_contamination', 'victim': 'victim_user_123', 'contaminating_user': context_data['previous_user']})
        except Exception as e:
            contamination_incidents.append({'type': 'nested_update_error', 'error': str(e)})
        if contamination_incidents:
            contamination_summary = '\n'.join([f"- {item['type']}: {item.get('victim', item.get('expected', 'unknown'))} affected" for item in contamination_incidents])
            raise AssertionError(f'SECURITY VULNERABILITY: copy_with_updates contamination detected.\nContamination incidents: {len(contamination_incidents)}\nDetails:\n{contamination_summary}')
        pytest.fail('UNEXPECTED: No copy_with_updates contamination vulnerability reproduced')
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')