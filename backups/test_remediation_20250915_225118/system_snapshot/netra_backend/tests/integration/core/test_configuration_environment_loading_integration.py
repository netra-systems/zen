"""
Test Configuration Environment Loading - Integration Tests

Business Value Justification (BVJ):
- Segment: All environments (Dev, Staging, Production)
- Business Goal: Ensure reliable configuration loading across environments  
- Value Impact: Prevents environment-specific deployment failures (saves $15K+ per incident)
- Strategic Impact: Enables confident multi-environment deployments for enterprise customers

This test suite validates configuration environment loading with real services and dependencies,
ensuring proper configuration management in realistic deployment scenarios.
"""
import pytest
import asyncio
import os
from typing import Dict, Any, Optional
from unittest.mock import patch
from netra_backend.app.config import get_config, reload_config
from shared.isolated_environment import IsolatedEnvironment, get_env
from test_framework.base_integration_test import BaseIntegrationTest
from test_framework.ssot.configuration_validator import validate_test_config

class ConfigurationEnvironmentLoadingIntegrationTests(BaseIntegrationTest):
    """Test configuration environment loading with real dependencies."""

    def setup_method(self):
        """Setup integration test environment."""
        validate_test_config('backend')
        self.original_env_vars = {}

    def teardown_method(self):
        """Restore original environment variables."""
        for key, value in self.original_env_vars.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    @pytest.mark.integration
    def test_testing_environment_configuration_loading_with_real_dependencies(self):
        """Test testing environment configuration loads properly with real dependencies.
        
        Critical for ensuring test runs work correctly with proper configuration.
        """
        test_config = {'ENVIRONMENT': 'testing', 'TESTING': '1', 'DATABASE_URL': 'sqlite:///test_integration.db', 'REDIS_URL': 'redis://localhost:6381/0', 'CLICKHOUSE_ENABLED': 'false', 'JWT_SECRET_KEY': 'test_jwt_secret_for_integration_testing', 'SERVICE_SECRET': 'test_service_secret_for_integration'}
        for key, value in test_config.items():
            self.original_env_vars[key] = os.environ.get(key)
            os.environ[key] = value
        config = get_config()
        assert config.environment == 'testing', 'Should detect testing environment'
        assert 'sqlite' in config.database_url.lower(), 'Should use SQLite for testing'
        redis_config = getattr(config, 'redis_url', None)
        if redis_config:
            assert '6381' in redis_config, 'Should use test Redis port'
        assert hasattr(config, 'jwt_secret_key'), 'Should have JWT secret'
        assert len(config.jwt_secret_key) > 10, 'JWT secret should be sufficient length'

    @pytest.mark.integration
    def test_development_environment_configuration_with_docker_detection(self):
        """Test development environment configuration with Docker service detection.
        
        Validates development configuration works with both local and Docker services.
        """
        dev_config = {'ENVIRONMENT': 'development', 'DEBUG': 'true', 'DATABASE_URL': 'postgresql://dev_user:dev_pass@localhost:5432/dev_db', 'REDIS_URL': 'redis://localhost:6379/0', 'CLICKHOUSE_HOST': 'localhost', 'CLICKHOUSE_PORT': '8124', 'LOG_LEVEL': 'DEBUG'}
        for key, value in dev_config.items():
            self.original_env_vars[key] = os.environ.get(key)
            os.environ[key] = value
        config = get_config()
        assert config.environment == 'development', 'Should detect development environment'
        assert config.debug is True, 'Debug should be enabled in development'
        assert 'postgresql' in config.database_url, 'Should use PostgreSQL in development'
        assert 'localhost' in config.database_url, 'Should connect to localhost'
        log_level = getattr(config, 'log_level', None)
        if log_level:
            assert log_level == 'DEBUG', 'Should use DEBUG log level'

    @pytest.mark.integration
    def test_staging_environment_configuration_with_cloud_services(self):
        """Test staging environment configuration with cloud service URLs.
        
        Ensures staging configuration properly handles cloud-based services.
        """
        staging_config = {'ENVIRONMENT': 'staging', 'DEBUG': 'false', 'DATABASE_URL': 'postgresql://staging_user:staging_pass@staging-postgres.cloud:5432/staging_db', 'REDIS_URL': 'redis://staging_user:staging_pass@staging-redis.cloud:6379/0', 'CLICKHOUSE_URL': 'clickhouse://staging_user:staging_pass@staging-clickhouse.cloud:8443/staging_analytics?secure=1', 'LOG_LEVEL': 'INFO', 'ENABLE_METRICS': 'true'}
        for key, value in staging_config.items():
            self.original_env_vars[key] = os.environ.get(key)
            os.environ[key] = value
        config = get_config()
        assert config.environment == 'staging', 'Should detect staging environment'
        assert config.debug is False, 'Debug should be disabled in staging'
        assert 'staging-postgres.cloud' in config.database_url, 'Should use staging database host'
        redis_url = getattr(config, 'redis_url', '')
        if redis_url:
            assert 'staging-redis.cloud' in redis_url, 'Should use staging Redis host'
        metrics_enabled = getattr(config, 'enable_metrics', False)
        assert metrics_enabled is True, 'Should enable metrics in staging'

class ConfigurationHotReloadingIntegrationTests(BaseIntegrationTest):
    """Test configuration hot reloading functionality with real services."""

    def setup_method(self):
        """Setup hot reload testing."""
        validate_test_config('backend')
        self.original_env_vars = {}

    def teardown_method(self):
        """Cleanup after hot reload tests."""
        for key, value in self.original_env_vars.items():
            if value is not None:
                os.environ[key] = value
            elif key in os.environ:
                del os.environ[key]

    @pytest.mark.integration
    def test_configuration_hot_reload_updates_settings(self):
        """Test configuration hot reload updates settings without restart.
        
        Critical for production configuration updates without downtime.
        """
        initial_config = {'ENVIRONMENT': 'testing', 'DEBUG': 'false', 'LOG_LEVEL': 'WARNING', 'FEATURE_FLAG_A': 'false'}
        for key, value in initial_config.items():
            self.original_env_vars[key] = os.environ.get(key)
            os.environ[key] = value
        initial_loaded_config = get_config()
        assert initial_loaded_config.environment == 'testing'
        assert initial_loaded_config.debug is False
        updated_config = {'DEBUG': 'true', 'LOG_LEVEL': 'DEBUG', 'FEATURE_FLAG_A': 'true', 'NEW_FEATURE_FLAG': 'enabled'}
        for key, value in updated_config.items():
            if key not in self.original_env_vars:
                self.original_env_vars[key] = os.environ.get(key)
            os.environ[key] = value
        reload_config(force=True)
        reloaded_config = get_config()
        assert reloaded_config.debug is True, 'Debug should be updated to True'
        new_flag = getattr(reloaded_config, 'new_feature_flag', None)
        if hasattr(reloaded_config, 'feature_flags') or new_flag:
            assert True, 'New configuration should be available after reload'

    @pytest.mark.integration
    def test_configuration_validation_during_hot_reload(self):
        """Test configuration validation during hot reload process.
        
        Ensures invalid configuration updates are rejected safely.
        """
        valid_config = {'ENVIRONMENT': 'testing', 'DATABASE_URL': 'sqlite:///valid_test.db', 'JWT_SECRET_KEY': 'valid_jwt_secret_12345'}
        for key, value in valid_config.items():
            self.original_env_vars[key] = os.environ.get(key)
            os.environ[key] = value
        initial_config = get_config()
        assert initial_config.environment == 'testing'
        invalid_updates = {'ENVIRONMENT': 'invalid_environment', 'DATABASE_URL': 'invalid://malformed/url', 'JWT_SECRET_KEY': ''}
        for key, value in invalid_updates.items():
            os.environ[key] = value
        try:
            reload_config(force=True)
            reloaded_config = get_config()
            assert reloaded_config is not None, 'Configuration should remain functional'
        except Exception as e:
            assert 'invalid' in str(e).lower() or 'configuration' in str(e).lower()

class ConfigurationServiceIntegrationTests(BaseIntegrationTest):
    """Test configuration integration with real services."""

    def setup_method(self):
        """Setup service integration testing."""
        validate_test_config('backend')

    @pytest.mark.integration
    def test_database_configuration_integration_with_real_connections(self):
        """Test database configuration integration with actual connection testing.
        
        Validates database configuration works with real connection attempts.
        """
        test_db_config = {'ENVIRONMENT': 'testing', 'DATABASE_URL': 'sqlite:///test_config_integration.db', 'POSTGRES_HOST': 'localhost', 'POSTGRES_PORT': '5434', 'POSTGRES_USER': 'test_user', 'POSTGRES_DB': 'test_db'}
        with patch.dict(os.environ, test_db_config):
            config = get_config()
            assert 'sqlite' in config.database_url.lower(), 'Should load SQLite URL'
            if hasattr(config, 'database_components'):
                components = config.database_components
                assert components.get('scheme') in ['sqlite', 'postgresql'], 'Should have valid database scheme'

    @pytest.mark.integration
    def test_redis_configuration_integration_with_connection_validation(self):
        """Test Redis configuration integration with connection validation.
        
        Ensures Redis configuration is properly validated and accessible.
        """
        redis_config = {'ENVIRONMENT': 'testing', 'REDIS_URL': 'redis://localhost:6381/0', 'REDIS_HOST': 'localhost', 'REDIS_PORT': '6381', 'REDIS_DB': '0'}
        with patch.dict(os.environ, redis_config):
            config = get_config()
            redis_url = getattr(config, 'redis_url', None)
            if redis_url:
                assert 'redis://' in redis_url, 'Should have Redis URL'
                assert '6381' in redis_url, 'Should use test Redis port'
                from urllib.parse import urlparse
                parsed = urlparse(redis_url)
                assert parsed.scheme == 'redis', 'Should be Redis scheme'
                assert parsed.hostname == 'localhost', 'Should use localhost'
                assert parsed.port == 6381, 'Should use test port'

    @pytest.mark.integration
    def test_service_configuration_dependency_resolution(self):
        """Test service configuration resolves dependencies correctly.
        
        Ensures services can find and connect to their dependencies.
        """
        service_config = {'ENVIRONMENT': 'testing', 'BACKEND_URL': 'http://localhost:8000', 'AUTH_SERVICE_URL': 'http://localhost:8081', 'FRONTEND_URL': 'http://localhost:3000', 'WEBSOCKET_URL': 'ws://localhost:8000/ws'}
        with patch.dict(os.environ, service_config):
            config = get_config()
            backend_url = getattr(config, 'backend_url', None)
            if backend_url:
                assert 'localhost:8000' in backend_url, 'Should configure backend URL'
            auth_url = getattr(config, 'auth_service_url', None)
            if auth_url:
                assert 'localhost:8081' in auth_url, 'Should configure auth service URL'
            service_urls = [getattr(config, 'backend_url', ''), getattr(config, 'auth_service_url', ''), getattr(config, 'frontend_url', '')]
            for url in service_urls:
                if url:
                    assert url.startswith(('http://', 'https://')), f'Service URL should be valid HTTP(S): {url}'
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')