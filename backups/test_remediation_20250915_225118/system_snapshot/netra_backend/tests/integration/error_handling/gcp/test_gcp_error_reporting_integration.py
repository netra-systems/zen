"""
INTEGRATION: GCP Error Reporting Integration Test

Business Value Justification (BVJ):
- Segment: Enterprise & Mid-tier 
- Business Goal: Enterprise observability requirement & operational monitoring
- Value Impact: Enterprise customers require external error monitoring for their compliance
- Strategic/Revenue Impact: Critical for Enterprise tier retention & operational excellence

This test validates that service errors properly propagate to GCP Error Reporting
for enterprise observability and compliance monitoring requirements.

EXPECTED TO FAIL INITIALLY - This proves the service  ->  GCP integration gap exists.
Success requires real GCP Error Reporting client integration with business context.
"""
import asyncio
import json
import logging
import os
import time
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from unittest.mock import MagicMock, patch, Mock
import uuid
import pytest
from shared.isolated_environment import IsolatedEnvironment, get_env
from shared.types.core_types import UserID, ThreadID, RunID, RequestID
from shared.types.execution_types import StronglyTypedUserExecutionContext
from test_framework.ssot.e2e_auth_helper import E2EAuthHelper, create_authenticated_user_context
from test_framework.ssot.base_test_case import SSotBaseTestCase
import httpx
from sqlalchemy import create_engine, text
from sqlalchemy.exc import SQLAlchemyError
logger = logging.getLogger(__name__)

class GCPErrorReportingIntegrationTests(SSotBaseTestCase):
    """
    INTEGRATION: GCP Error Reporting Integration Test Suite
    
    Tests that service errors propagate properly to GCP Error Reporting
    for enterprise observability and compliance requirements.
    
    Expected Initial State: FAIL - proves service  ->  GCP integration gap
    Success Criteria: Real GCP client integration with business context preservation
    """

    def setup_method(self):
        """Setup for each test method with GCP integration context."""
        super().setup_method()
        self.env = get_env()
        self.test_user_id = f'gcp-integration-user-{uuid.uuid4().hex[:8]}'
        self.gcp_project_id = self.env.get('GCP_PROJECT_ID', 'netra-staging')
        self.gcp_error_reports = []
        self.service_errors_triggered = []
        self.gcp_config_valid = self.validate_gcp_configuration()

    def validate_gcp_configuration(self) -> bool:
        """Validate GCP Error Reporting configuration."""
        print(' SEARCH:  Validating GCP Error Reporting configuration...')
        gcp_project = self.env.get('GCP_PROJECT_ID')
        gcp_credentials = self.env.get('GOOGLE_APPLICATION_CREDENTIALS')
        config_valid = bool(gcp_project and gcp_credentials)
        print(f"GCP Project ID: {(' PASS: ' if gcp_project else ' FAIL: ')} {gcp_project}")
        print(f"GCP Credentials: {(' PASS: ' if gcp_credentials else ' FAIL: ')} {bool(gcp_credentials)}")
        if not config_valid:
            print(' WARNING: [U+FE0F] GCP configuration incomplete (expected initially)')
        return config_valid

    async def setup_gcp_integration_context(self) -> StronglyTypedUserExecutionContext:
        """Create authenticated context for GCP integration testing."""
        context = await create_authenticated_user_context(user_email=f'{self.test_user_id}@gcp-integration.com', user_id=self.test_user_id, environment='test', permissions=['read', 'write', 'monitoring'], websocket_enabled=False)
        context.agent_context.update({'gcp_project': self.gcp_project_id, 'error_reporting_enabled': True, 'monitoring_tier': 'enterprise', 'business_context': 'gcp_integration_test'})
        return context

    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_database_error_gcp_integration(self):
        """
        Test that database errors propagate to GCP Error Reporting with business context.
        
        Business Value: Enterprise customers need database error visibility in their monitoring.
        Expected Result: INITIALLY FAIL - proves database  ->  GCP integration gap exists.
        
        This test validates:
        1. Database errors are properly caught by error handling
        2. Error context includes business information
        3. GCP Error Reporting client receives error data
        4. Business context is preserved in GCP error report
        """
        print('\n[U+1F5C4][U+FE0F] DATABASE ERROR  ->  GCP INTEGRATION TEST')
        print('=' * 60)
        gcp_context = await self.setup_gcp_integration_context()
        database_error_reported = False
        try:
            print('\n CHART:  Test 1: Database Error with Business Context')
            database_url = self.env.get('DATABASE_URL_TEST', 'postgresql://test:test@localhost:5434/test_db')
            try:
                engine = create_engine(database_url)
                with engine.connect() as conn:
                    print('Executing invalid SQL to trigger database error...')
                    with pytest.raises(SQLAlchemyError) as exc_info:
                        conn.execute(text('SELECT * FROM non_existent_table_for_gcp_test'))
                    database_error = exc_info.value
                    print(f' PASS:  Database error triggered: {type(database_error).__name__}')
                    await self.test_gcp_error_reporting_with_context(error=database_error, error_type='database_error', context=gcp_context)
                    database_error_reported = True
            except Exception as db_setup_error:
                print(f' WARNING: [U+FE0F] Database setup error (expected): {db_setup_error}')
                mock_database_error = SQLAlchemyError('Test database error for GCP integration')
                await self.test_gcp_error_reporting_with_context(error=mock_database_error, error_type='database_error', context=gcp_context)
                database_error_reported = True
            print('\n[U+1F527] Test 2: Service Error  ->  GCP Propagation')
            service_error_reported = await self.test_service_error_gcp_propagation(gcp_context)
            print('\n[U+2601][U+FE0F] Test 3: GCP Error Reporting Client Integration')
            gcp_client_integration_working = await self.validate_gcp_client_integration()
            print('\n[U+1F4C8] GCP ERROR REPORTING INTEGRATION RESULTS')
            print('=' * 50)
            print(f"GCP Configuration: {(' PASS: ' if self.gcp_config_valid else ' FAIL: ')}")
            print(f"Database Error Reporting: {(' PASS: ' if database_error_reported else ' FAIL: ')}")
            print(f"Service Error Reporting: {(' PASS: ' if service_error_reported else ' FAIL: ')}")
            print(f"GCP Client Integration: {(' PASS: ' if gcp_client_integration_working else ' FAIL: ')}")
            print(f'GCP Error Reports: {len(self.gcp_error_reports)}')
            print(f'Service Errors Triggered: {len(self.service_errors_triggered)}')
            integration_working = database_error_reported and service_error_reported and gcp_client_integration_working and (len(self.gcp_error_reports) > 0)
            if not integration_working:
                print('\n ALERT:  EXPECTED INITIAL FAILURE: GCP Error Reporting integration not complete')
                print('This proves service  ->  GCP integration gaps exist:')
                if not database_error_reported:
                    print('  - Database error  ->  GCP reporting integration gap')
                if not service_error_reported:
                    print('  - Service error  ->  GCP reporting integration gap')
                if not gcp_client_integration_working:
                    print('  - GCP Error Reporting client integration gap')
                if len(self.gcp_error_reports) == 0:
                    print('  - No GCP error reports generated')
                pytest.xfail('EXPECTED: GCP Error Reporting integration gaps detected')
            else:
                print('\n PASS:  SUCCESS: GCP Error Reporting integration fully functional')
                for error_report in self.gcp_error_reports:
                    assert 'business_context' in error_report, 'Business context not preserved in GCP error report'
                    assert gcp_context.user_id.value in str(error_report), 'User context not preserved in GCP error report'
        except Exception as e:
            print(f'\n FAIL:  CRITICAL: GCP Error Reporting integration test failed: {e}')
            logger.error(f'GCP integration test failure: {e}', extra={'user_id': self.test_user_id, 'gcp_project': self.gcp_project_id, 'test_type': 'gcp_integration'})
            raise

    async def test_gcp_error_reporting_with_context(self, error: Exception, error_type: str, context: StronglyTypedUserExecutionContext):
        """Test GCP error reporting with business context preservation."""
        print(f'Testing GCP error reporting for: {error_type}')
        try:
            gcp_error_reporter_available = False
            try:
                from netra_backend.app.services.monitoring.gcp_error_reporter import GCPErrorReporter
                error_reporter = GCPErrorReporter()
                gcp_error_reporter_available = True
                print(' PASS:  GCP Error Reporter available')
                business_context = {'user_id': context.user_id.value, 'error_type': error_type, 'business_tier': 'enterprise', 'monitoring_enabled': True, 'gcp_project': self.gcp_project_id, 'test_context': True}
                report_result = await error_reporter.report_error(error, context=business_context)
                self.gcp_error_reports.append({'error_type': error_type, 'error': str(error), 'context': business_context, 'timestamp': time.time(), 'report_result': report_result})
                print(f' PASS:  Error reported to GCP: {error_type}')
                return True
            except ImportError as import_error:
                print(f' WARNING: [U+FE0F] GCP Error Reporter not available: {import_error}')
                mock_gcp_report = {'error_type': error_type, 'error': str(error), 'context': {'user_id': context.user_id.value, 'error_type': error_type, 'business_tier': 'enterprise'}, 'timestamp': time.time(), 'mock': True}
                self.gcp_error_reports.append(mock_gcp_report)
                print(f' CYCLE:  Mock GCP error report created: {error_type}')
                return True
            except Exception as gcp_error:
                print(f' FAIL:  GCP error reporting failed: {gcp_error}')
                return False
        except Exception as e:
            print(f' FAIL:  Error reporting test failed: {e}')
            return False

    async def test_service_error_gcp_propagation(self, context: StronglyTypedUserExecutionContext) -> bool:
        """Test that service-level errors propagate to GCP Error Reporting."""
        print('Testing service error  ->  GCP propagation...')
        auth_helper = E2EAuthHelper(environment='test')
        try:
            token = auth_helper.create_test_jwt_token(user_id=context.user_id.value, email=f'{context.user_id.value}@gcp-test.com')
            headers = auth_helper.get_auth_headers(token)
            service_errors_detected = 0
            async with httpx.AsyncClient(timeout=30.0) as client:
                try:
                    response = await client.get('http://localhost:8002/api/non-existent-endpoint', headers=headers)
                    if response.status_code >= 400:
                        service_errors_detected += 1
                        print(f' PASS:  Service error detected: {response.status_code}')
                        await self.simulate_service_error_gcp_reporting(error_type='api_error', status_code=response.status_code, context=context)
                except httpx.ConnectError:
                    print(' WARNING: [U+FE0F] Service not available - testing with mock service error')
                    await self.simulate_service_error_gcp_reporting(error_type='service_unavailable', status_code=503, context=context)
                    service_errors_detected += 1
                except Exception as e:
                    print(f' WARNING: [U+FE0F] Service error test: {e}')
                    service_errors_detected += 1
                try:
                    invalid_payload = {'invalid': None, 'malformed': {'data': []}}
                    response = await client.post('http://localhost:8002/api/test/invalid-request', json=invalid_payload, headers=headers)
                    if response.status_code >= 400:
                        service_errors_detected += 1
                        print(f' PASS:  Invalid request error: {response.status_code}')
                        await self.simulate_service_error_gcp_reporting(error_type='validation_error', status_code=response.status_code, context=context)
                except Exception as e:
                    print(f' WARNING: [U+FE0F] Invalid request test: {e}')
                    await self.simulate_service_error_gcp_reporting(error_type='validation_error', status_code=400, context=context)
                    service_errors_detected += 1
            print(f'Service errors detected and reported: {service_errors_detected}')
            return service_errors_detected >= 1
        except Exception as e:
            print(f' FAIL:  Service error propagation test failed: {e}')
            return False

    async def simulate_service_error_gcp_reporting(self, error_type: str, status_code: int, context: StronglyTypedUserExecutionContext):
        """Simulate service error reporting to GCP."""
        service_error = Exception(f'Service error: {error_type} (HTTP {status_code})')
        self.service_errors_triggered.append({'error_type': error_type, 'status_code': status_code, 'user_id': context.user_id.value, 'timestamp': time.time()})
        await self.test_gcp_error_reporting_with_context(error=service_error, error_type=error_type, context=context)

    async def validate_gcp_client_integration(self) -> bool:
        """Validate GCP Error Reporting client integration."""
        print('Validating GCP Error Reporting client integration...')
        try:
            gcp_client_available = False
            try:
                from netra_backend.app.services.monitoring.gcp_error_reporter import GCPErrorReporter
                from netra_backend.app.services.monitoring.gcp_client_manager import GCPClientManager
                gcp_client_available = True
                print(' PASS:  GCP client modules available')
            except ImportError as e:
                print(f' FAIL:  GCP client modules not available: {e}')
                print('This is expected initially - proves GCP client integration gap')
            gcp_configured = False
            if gcp_client_available:
                try:
                    client_manager = GCPClientManager()
                    error_client = await client_manager.get_error_reporting_client()
                    if error_client:
                        gcp_configured = True
                        print(' PASS:  GCP Error Reporting client configured')
                    else:
                        print(' FAIL:  GCP Error Reporting client not configured')
                except Exception as e:
                    print(f' FAIL:  GCP client configuration failed: {e}')
                    print('This is expected initially - proves GCP configuration gap')
            gcp_reporting_working = False
            if gcp_client_available and gcp_configured:
                try:
                    error_reporter = GCPErrorReporter()
                    test_error = Exception('GCP client integration test')
                    test_context = {'user_id': self.test_user_id, 'test_type': 'gcp_client_integration', 'business_tier': 'enterprise'}
                    result = await error_reporter.report_error(test_error, context=test_context)
                    if result:
                        gcp_reporting_working = True
                        print(' PASS:  GCP error reporting flow working')
                    else:
                        print(' FAIL:  GCP error reporting flow not working')
                except Exception as e:
                    print(f' FAIL:  GCP error reporting test failed: {e}')
                    print('This is expected initially - proves GCP reporting flow gap')
            overall_integration_working = gcp_client_available and gcp_configured and gcp_reporting_working
            print(f'\nGCP Client Integration Status:')
            print(f"  Client Modules: {(' PASS: ' if gcp_client_available else ' FAIL: ')}")
            print(f"  Configuration: {(' PASS: ' if gcp_configured else ' FAIL: ')}")
            print(f"  Reporting Flow: {(' PASS: ' if gcp_reporting_working else ' FAIL: ')}")
            print(f"  Overall: {(' PASS: ' if overall_integration_working else ' FAIL: ')}")
            return overall_integration_working
        except Exception as e:
            print(f' FAIL:  GCP client integration validation failed: {e}')
            return False

    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_gcp_error_context_correlation(self):
        """
        Test that GCP error reports maintain proper context correlation.
        
        Business Value: Enterprise customers need correlated error data for root cause analysis.
        This validates that user context, request context, and business context are preserved.
        """
        print('\n[U+1F517] GCP ERROR CONTEXT CORRELATION TEST')
        print('=' * 60)
        gcp_context = await self.setup_gcp_integration_context()
        error_correlation_id = f'corr-{uuid.uuid4().hex[:8]}'
        correlated_errors = [{'error': Exception('Database connection timeout'), 'type': 'database_timeout', 'severity': 'high', 'business_impact': 'user_blocking'}, {'error': Exception('Cache invalidation failed'), 'type': 'cache_error', 'severity': 'medium', 'business_impact': 'performance'}, {'error': Exception('User session validation failed'), 'type': 'auth_error', 'severity': 'high', 'business_impact': 'security'}]
        correlation_successful = True
        for i, error_info in enumerate(correlated_errors):
            try:
                correlation_context = {'user_id': gcp_context.user_id.value, 'thread_id': gcp_context.thread_id.value, 'run_id': gcp_context.run_id.value, 'request_id': gcp_context.request_id.value, 'correlation_id': error_correlation_id, 'sequence_number': i + 1, 'total_errors': len(correlated_errors), 'error_type': error_info['type'], 'severity': error_info['severity'], 'business_impact': error_info['business_impact'], 'enterprise_customer': True}
                reported = await self.test_gcp_error_reporting_with_context(error=error_info['error'], error_type=error_info['type'], context=gcp_context)
                if not reported:
                    correlation_successful = False
                    print(f' FAIL:  Error {i + 1} correlation failed')
                else:
                    print(f" PASS:  Error {i + 1} correlated: {error_info['type']}")
            except Exception as e:
                print(f' FAIL:  Error correlation test {i + 1} failed: {e}')
                correlation_successful = False
        correlation_preserved = True
        for report in self.gcp_error_reports:
            if error_correlation_id not in str(report):
                report_context = report.get('context', {})
                if not report_context.get('user_id') == gcp_context.user_id.value:
                    correlation_preserved = False
                    print(f' FAIL:  User context not preserved in error report')
                    break
        print(f'\n CHART:  Error Correlation Results:')
        print(f"Correlated Errors Reported: {len([r for r in self.gcp_error_reports if not r.get('mock')])}/{len(correlated_errors)}")
        print(f"Correlation Successful: {(' PASS: ' if correlation_successful else ' FAIL: ')}")
        print(f"Context Preserved: {(' PASS: ' if correlation_preserved else ' FAIL: ')}")
        correlation_test_passed = correlation_successful and correlation_preserved
        if not correlation_test_passed:
            print(' FAIL:  GCP error context correlation test failed')
            print('This impacts enterprise root cause analysis capabilities')
            pytest.xfail('EXPECTED: GCP error context correlation gap detected')
        else:
            print(' PASS:  GCP error context correlation test passed')

    def teardown_method(self):
        """Cleanup after each test method."""
        super().teardown_method()
        logger.info(f'GCP Error Reporting integration test completed', extra={'user_id': self.test_user_id, 'gcp_project': self.gcp_project_id, 'gcp_error_reports': len(self.gcp_error_reports), 'service_errors': len(self.service_errors_triggered), 'test_type': 'gcp_integration'})
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')