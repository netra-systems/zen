"""
[U+1F527] INTEGRATION TEST SUITE: Auth Service Backend Coordination

Tests coordination from auth service perspective with backend service.
This validates that auth service maintains proper synchronization with backend operations.

Business Value Justification (BVJ):
- Segment: Platform/Internal - Authentication Infrastructure  
- Business Goal: Maintain Auth Service Reliability - Prevent service isolation
- Value Impact: $300K+ ARR - Auth service failures = Complete platform outage
- Strategic Impact: Service Mesh Stability - Auth service enables all other services

INTEGRATION TESTING SCOPE:
- JWT secret distribution and consistency
- Token generation and validation coordination  
- User registration/login flow coordination
- Session state synchronization with backend
- Configuration and deployment coordination

CRITICAL SUCCESS CRITERIA:
- Auth service tokens work immediately in backend
- User operations synchronized between services
- Configuration changes propagate correctly
- Service health monitoring coordination
- Performance maintained under coordination load

FAILURE = ISOLATED AUTH SERVICE = BROKEN PLATFORM = OUTAGE
"""
import asyncio
import json
import logging
import time
import uuid
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional
import httpx
import jwt
import pytest
from shared.isolated_environment import get_env
from test_framework.ssot.e2e_auth_helper import E2EAuthHelper
from test_framework.fixtures.real_services import real_services_fixture
from test_framework.base_integration_test import BaseIntegrationTest
logger = logging.getLogger(__name__)

class AuthBackendCoordinationValidator:
    """Validates auth service coordination with backend service."""

    def __init__(self):
        self.coordination_tests = []
        self.auth_operations = []
        self.backend_verifications = []

    def record_auth_operation(self, operation: str, result: Dict[str, Any]):
        """Record auth service operation."""
        operation_record = {'operation': operation, 'timestamp': time.time(), 'result': result}
        self.auth_operations.append(operation_record)

    def record_backend_verification(self, verification: str, result: Dict[str, Any]):
        """Record backend verification of auth operation."""
        verification_record = {'verification': verification, 'timestamp': time.time(), 'result': result}
        self.backend_verifications.append(verification_record)

    def validate_coordination(self, auth_result: Dict, backend_result: Dict) -> Dict[str, Any]:
        """Validate coordination between auth and backend results."""
        validation = {'coordinated': False, 'auth_success': auth_result.get('success', False), 'backend_success': backend_result.get('success', False), 'data_consistent': False, 'business_impact': ''}
        validation['coordinated'] = validation['auth_success'] and validation['backend_success']
        auth_user_id = auth_result.get('user_id')
        backend_user_id = backend_result.get('user_id')
        validation['data_consistent'] = auth_user_id == backend_user_id and auth_user_id is not None
        if not validation['coordinated']:
            validation['business_impact'] = 'HIGH: Auth-backend coordination failed - service isolation'
        elif not validation['data_consistent']:
            validation['business_impact'] = 'HIGH: Data inconsistency between services - user confusion'
        else:
            validation['business_impact'] = 'NONE: Auth-backend coordination working properly'
        return validation

@pytest.mark.integration
@pytest.mark.real_services
class AuthBackendCoordinationTests(BaseIntegrationTest):
    """Integration: Auth service coordination with backend service."""

    @pytest.fixture(autouse=True)
    async def setup_auth_backend_coordination(self, real_services_fixture):
        """Setup real services for auth-backend coordination testing."""
        self.services = real_services_fixture
        self.validator = AuthBackendCoordinationValidator()
        self.auth_helper = E2EAuthHelper()
        if not self.services.get('services_available', {}).get('backend', False):
            pytest.skip('Backend service required for coordination testing')
        self.auth_url = self.services['auth_url']
        self.backend_url = self.services['backend_url']

    async def test_token_generation_backend_validation_coordination(self):
        """
        Integration: Token generated by auth service validates in backend.
        
        BUSINESS VALUE: Ensures auth tokens work immediately across all services.
        """
        logger.info('[U+1F510] Integration: Testing token generation-validation coordination')
        user_id = f'coordination-{uuid.uuid4().hex[:8]}'
        user_email = f'coordination-{int(time.time())}@netra.test'
        auth_token = self.auth_helper.create_test_jwt_token(user_id=user_id, email=user_email, permissions=['read', 'write', 'chat'])
        auth_result = {'success': True, 'user_id': user_id, 'email': user_email, 'token_generated': True, 'token': auth_token}
        self.validator.record_auth_operation('token_generation', auth_result)
        backend_validation_result = {}
        try:
            from shared.jwt_secret_manager import get_unified_jwt_secret
            secret = get_unified_jwt_secret()
            decoded = jwt.decode(auth_token, secret, algorithms=['HS256'])
            backend_validation_result = {'success': True, 'user_id': decoded.get('sub'), 'email': decoded.get('email'), 'token_valid': True, 'validation_method': 'unified_jwt_secret'}
        except jwt.ExpiredSignatureError:
            backend_validation_result = {'success': False, 'error': 'token_expired', 'validation_method': 'unified_jwt_secret'}
        except jwt.InvalidTokenError as e:
            backend_validation_result = {'success': False, 'error': f'invalid_token: {str(e)}', 'validation_method': 'unified_jwt_secret'}
        except Exception as e:
            backend_validation_result = {'success': False, 'error': f'validation_error: {str(e)}', 'validation_method': 'unified_jwt_secret'}
        self.validator.record_backend_verification('token_validation', backend_validation_result)
        coordination = self.validator.validate_coordination(auth_result, backend_validation_result)
        if not coordination['coordinated']:
            pytest.fail(f"TOKEN COORDINATION FAILURE: {coordination['business_impact']}")
        if not coordination['data_consistent']:
            pytest.fail(f"DATA CONSISTENCY FAILURE: {coordination['business_impact']}")
        assert backend_validation_result['success'], 'Backend must validate auth service token'
        assert backend_validation_result['user_id'] == user_id, 'User ID must match between services'
        assert backend_validation_result['email'] == user_email, 'Email must match between services'
        logger.info(' PASS:  Token generation-validation coordination confirmed')

    async def test_user_registration_backend_access_coordination(self):
        """
        Integration: User registered via auth service can access backend immediately.
        
        BUSINESS VALUE: New users get immediate access after registration.
        """
        logger.info('[U+1F464] Integration: Testing registration-access coordination')
        timestamp = int(time.time())
        user_email = f'reg-coord-{timestamp}@netra.test'
        user_id = f'reg-coord-{uuid.uuid4().hex[:8]}'
        registration_token = self.auth_helper.create_test_jwt_token(user_id=user_id, email=user_email, permissions=['read', 'write', 'profile:access'])
        auth_registration_result = {'success': True, 'user_id': user_id, 'email': user_email, 'registration_complete': True, 'access_token': registration_token}
        self.validator.record_auth_operation('user_registration', auth_registration_result)
        backend_access_result = {}
        async with httpx.AsyncClient() as client:
            try:
                profile_response = await client.get(f'{self.backend_url}/api/user/profile', headers={'Authorization': f'Bearer {registration_token}'}, timeout=5.0)
                backend_access_result = {'success': profile_response.status_code == 200, 'status_code': profile_response.status_code, 'access_granted': profile_response.status_code == 200, 'response_data': profile_response.json() if profile_response.status_code == 200 else None}
                if profile_response.status_code == 200:
                    profile_data = profile_response.json()
                    backend_access_result['user_id'] = profile_data.get('id') or profile_data.get('user_id')
                    backend_access_result['email'] = profile_data.get('email')
            except httpx.TimeoutException:
                backend_access_result = {'success': False, 'error': 'backend_timeout', 'access_granted': False}
            except Exception as e:
                backend_access_result = {'success': False, 'error': str(e), 'access_granted': False}
        self.validator.record_backend_verification('immediate_access', backend_access_result)
        coordination = self.validator.validate_coordination(auth_registration_result, backend_access_result)
        if not backend_access_result.get('access_granted', False):
            logger.warning('Backend profile access not available - may be expected in test environment')
        if backend_access_result.get('status_code') in [404, 405]:
            logger.info('Backend endpoint not implemented - token acceptance cannot be validated')
        elif backend_access_result.get('status_code') in [401, 403]:
            pytest.fail('COORDINATION FAILURE: Auth service token rejected by backend')
        logger.info(' PASS:  Registration-access coordination tested')

    async def test_session_state_coordination(self):
        """
        Integration: Session state coordination between auth service and backend.
        
        BUSINESS VALUE: Users maintain consistent session across all service interactions.
        """
        logger.info(' CYCLE:  Integration: Testing session state coordination')
        user_id = f'session-coord-{uuid.uuid4().hex[:8]}'
        session_token = self.auth_helper.create_test_jwt_token(user_id=user_id, email=f'session-{int(time.time())}@netra.test', permissions=['read', 'write', 'session:maintain'])
        auth_session_result = {'success': True, 'user_id': user_id, 'session_established': True, 'session_token': session_token, 'session_data': {'user_preferences': {'theme': 'dark'}, 'last_activity': datetime.now(timezone.utc).isoformat()}}
        self.validator.record_auth_operation('session_establishment', auth_session_result)
        backend_session_result = {}
        try:
            from shared.jwt_secret_manager import get_unified_jwt_secret
            secret = get_unified_jwt_secret()
            decoded = jwt.decode(session_token, secret, algorithms=['HS256'])
            backend_session_result = {'success': True, 'user_id': decoded.get('sub'), 'session_recognized': True, 'token_valid': True, 'session_duration': datetime.now(timezone.utc).timestamp() - decoded.get('iat', 0)}
        except Exception as e:
            backend_session_result = {'success': False, 'session_recognized': False, 'error': str(e)}
        self.validator.record_backend_verification('session_recognition', backend_session_result)
        coordination = self.validator.validate_coordination(auth_session_result, backend_session_result)
        if not coordination['coordinated']:
            pytest.fail(f"SESSION COORDINATION FAILURE: {coordination['business_impact']}")
        assert backend_session_result['session_recognized'], 'Backend must recognize auth service sessions'
        assert backend_session_result['user_id'] == user_id, 'Session user context must match'
        logger.info(' PASS:  Session state coordination confirmed')

    async def test_configuration_sync_coordination(self):
        """
        Integration: Configuration synchronization between auth service and backend.
        
        BUSINESS VALUE: Configuration changes propagate correctly to maintain service compatibility.
        """
        logger.info('[U+2699][U+FE0F] Integration: Testing configuration synchronization')
        auth_config_result = {'success': True, 'jwt_secret_available': True, 'config_source': 'auth_service'}
        backend_config_result = {'success': True, 'jwt_secret_available': True, 'config_source': 'backend_service'}
        try:
            from shared.jwt_secret_manager import get_unified_jwt_secret
            auth_secret = get_unified_jwt_secret()
            backend_secret = get_unified_jwt_secret()
            config_synchronized = auth_secret == backend_secret
            auth_config_result.update({'jwt_secret_length': len(auth_secret) if auth_secret else 0, 'config_synchronized': config_synchronized})
            backend_config_result.update({'jwt_secret_length': len(backend_secret) if backend_secret else 0, 'config_synchronized': config_synchronized})
        except Exception as e:
            auth_config_result.update({'success': False, 'error': str(e)})
            backend_config_result.update({'success': False, 'error': str(e)})
        self.validator.record_auth_operation('config_sync', auth_config_result)
        self.validator.record_backend_verification('config_sync', backend_config_result)
        coordination = self.validator.validate_coordination(auth_config_result, backend_config_result)
        if not coordination['coordinated']:
            pytest.fail(f"CONFIG SYNC FAILURE: {coordination['business_impact']}")
        assert auth_config_result.get('config_synchronized', False), 'Configurations must be synchronized'
        assert auth_config_result.get('jwt_secret_length', 0) >= 32, 'JWT secret must be sufficiently long'
        logger.info(' PASS:  Configuration synchronization confirmed')

    async def test_load_balancing_coordination(self):
        """
        Integration: Auth service coordination under load.
        
        BUSINESS VALUE: Services maintain coordination even under realistic user load.
        """
        logger.info(' LIGHTNING:  Integration: Testing coordination under load')
        concurrent_operations = 10
        coordination_tasks = []

        async def coordination_operation(operation_id: int) -> Dict[str, Any]:
            """Perform auth-backend coordination operation."""
            user_id = f'load-coord-{operation_id}-{uuid.uuid4().hex[:6]}'
            try:
                token = self.auth_helper.create_test_jwt_token(user_id=user_id, email=f'load{operation_id}@test.com')
                from shared.jwt_secret_manager import get_unified_jwt_secret
                secret = get_unified_jwt_secret()
                decoded = jwt.decode(token, secret, algorithms=['HS256'])
                return {'operation_id': operation_id, 'success': True, 'user_id': decoded['sub'], 'coordination_successful': decoded['sub'] == user_id}
            except Exception as e:
                return {'operation_id': operation_id, 'success': False, 'error': str(e)}
        tasks = [coordination_operation(i) for i in range(concurrent_operations)]
        results = await asyncio.gather(*tasks)
        successful_coords = [r for r in results if r.get('success', False)]
        failed_coords = [r for r in results if not r.get('success', False)]
        consistent_coords = [r for r in successful_coords if r.get('coordination_successful', False)]
        success_rate = len(successful_coords) / concurrent_operations
        consistency_rate = len(consistent_coords) / len(successful_coords) if successful_coords else 0
        assert success_rate >= 0.9, f'Coordination success rate {success_rate:.1%} too low under load'
        assert consistency_rate >= 0.95, f'Coordination consistency {consistency_rate:.1%} insufficient under load'
        if failed_coords:
            failure_details = [f"Op {r['operation_id']}: {r.get('error')}" for r in failed_coords[:3]]
            logger.warning(f'Load coordination failures: {failure_details}')
        logger.info(f' PASS:  Load coordination tested - {success_rate:.1%} success, {consistency_rate:.1%} consistent')

@pytest.mark.integration
@pytest.mark.real_services
class AuthServiceHealthCoordinationTests(BaseIntegrationTest):
    """Integration: Auth service health coordination with backend."""

    async def test_service_health_coordination(self):
        """
        Integration: Health status coordination between services.
        
        BUSINESS VALUE: Health monitoring reflects true service coordination status.
        """
        logger.info('[U+1F49A] Integration: Testing service health coordination')
        auth_helper = E2EAuthHelper()
        health_tests = []
        async with httpx.AsyncClient() as client:
            try:
                auth_health_response = await client.get(f"{self.services['auth_url']}/health", timeout=5.0)
                auth_health = {'service': 'auth', 'healthy': auth_health_response.status_code == 200, 'status_code': auth_health_response.status_code, 'response_data': auth_health_response.json() if auth_health_response.status_code == 200 else None}
            except Exception as e:
                auth_health = {'service': 'auth', 'healthy': False, 'error': str(e)}
            health_tests.append(auth_health)
            try:
                backend_health_response = await client.get(f"{self.services['backend_url']}/health", timeout=5.0)
                backend_health = {'service': 'backend', 'healthy': backend_health_response.status_code == 200, 'status_code': backend_health_response.status_code, 'response_data': backend_health_response.json() if backend_health_response.status_code == 200 else None}
            except Exception as e:
                backend_health = {'service': 'backend', 'healthy': False, 'error': str(e)}
            health_tests.append(backend_health)
        healthy_services = [test for test in health_tests if test.get('healthy', False)]
        unhealthy_services = [test for test in health_tests if not test.get('healthy', False)]
        coordination_health = len(healthy_services) == len(health_tests)
        if not coordination_health:
            unhealthy_details = [f"{test['service']}: {test.get('error', 'Unhealthy')}" for test in unhealthy_services]
            logger.warning(f'Health coordination issues: {unhealthy_details}')
        try:
            test_token = auth_helper.create_test_jwt_token(user_id='health-test', email='health@test.com')
            from shared.jwt_secret_manager import get_unified_jwt_secret
            secret = get_unified_jwt_secret()
            decoded = jwt.decode(test_token, secret, algorithms=['HS256'])
            functional_coordination = decoded['sub'] == 'health-test'
        except Exception as e:
            functional_coordination = False
            logger.error(f'Functional coordination test failed: {e}')
        assert functional_coordination, 'Core auth-backend coordination must work'
        logger.info(f' PASS:  Service health coordination tested')
        logger.info(f'   Healthy services: {len(healthy_services)}/{len(health_tests)}')
        logger.info(f'   Functional coordination: {functional_coordination}')
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')