<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Frontend Testing Patterns</name>
        <type>specification</type>
        <category>Testing</category>
        <version>1.0</version>
        <last_updated>2025-08-22</last_updated>
        <description>Comprehensive frontend testing patterns for React/Jest/TypeScript with proven solutions</description>
    </metadata>
    
    <overview>
        This specification documents the comprehensive frontend testing patterns established through fixing
        numerous test failures across authentication, component integration, WebSocket connections, and
        state management. These patterns ensure reliable, maintainable tests that properly validate
        user interactions and business logic.
    </overview>
    
    <core_principles>
        <principle id="mock_services_not_components">
            <title>Mock Services, Not UI Components</title>
            <description>
                Mock external services, hooks, and data sources, but test real component interactions.
                This approach validates actual user experiences while maintaining test reliability.
            </description>
            <rationale>
                UI component mocking prevents testing real user interactions, click handlers, and
                React state management. Service mocking isolates components from external dependencies
                while preserving business logic validation.
            </rationale>
        </principle>
        
        <principle id="real_behavior_testing">
            <title>Real Behavior Testing</title>
            <description>
                Prefer testing actual component behavior over mocked interactions. Use unmocking
                strategically for integration tests that validate critical user journeys.
            </description>
            <rationale>
                Real behavior testing catches integration issues, state management bugs, and
                user experience problems that mocked tests miss.
            </rationale>
        </principle>
        
        <principle id="test_isolation">
            <title>Test Isolation</title>
            <description>
                Each test must be completely independent with proper setup/teardown, store resets,
                and mock clearing to prevent state pollution between tests.
            </description>
            <rationale>
                Test isolation prevents flaky tests, ensures reliable CI/CD, and makes tests
                debuggable by eliminating hidden dependencies.
            </rationale>
        </principle>
        
        <principle id="type_safety">
            <title>Type Safety in Tests</title>
            <description>
                Use TypeScript patterns like jest.mocked() for type-safe mock access and
                proper type checking in test scenarios.
            </description>
            <rationale>
                Type safety in tests prevents runtime errors, catches API changes early,
                and improves test maintainability.
            </rationale>
        </principle>
    </core_principles>
    
    <patterns>
        <pattern id="component_mocking_strategy">
            <title>Component Mocking Strategy</title>
            <category>mocking</category>
            <description>Comprehensive approach to mocking in React component tests</description>
            <implementation>
                <code_example language="typescript">
// GOOD: Mock only services and hooks, NOT UI components
jest.mock('@/hooks/useWebSocket', () => ({
  useWebSocket: () => ({
    messages: [],
    connected: true,
    error: null,
    sendMessage: jest.fn()
  })
}));

jest.mock('@/store/authStore', () => ({
  useAuthStore: () => ({
    isAuthenticated: true,
    user: { id: 'test-user', email: 'test@example.com' },
    token: 'mock-jwt-token',
    login: jest.fn(),
    logout: jest.fn()
  })
}));

// BAD: Mocking UI components prevents testing real interactions
jest.mock('@/components/ui/Button', () => ({ children }) => 
  &lt;div data-testid="mocked-button"&gt;{children}&lt;/div&gt;
);
                </code_example>
            </implementation>
            <rationale>
                Service mocking isolates components from external dependencies while preserving
                component logic, user interactions, and React state management.
            </rationale>
        </pattern>
        
        <pattern id="authentication_state_propagation">
            <title>Authentication State Propagation</title>
            <category>authentication</category>
            <description>Unified authentication mocking with proper context providers</description>
            <implementation>
                <code_example language="typescript">
// Comprehensive auth service mock
const mockAuthService = {
  getConfig: jest.fn().mockResolvedValue({
    development_mode: false,
    google_client_id: 'test-client-id',
    endpoints: {
      login: 'http://localhost:8081/auth/login',
      logout: 'http://localhost:8081/auth/logout',
      token: 'http://localhost:8081/auth/token',
      user: 'http://localhost:8081/auth/me'
    }
  }),
  getAuthConfig: jest.fn().mockResolvedValue(mockAuthConfig),
  initiateLogin: jest.fn(),
  logout: jest.fn().mockResolvedValue({ success: true }),
  getCurrentUser: jest.fn().mockResolvedValue({
    id: 'test-user',
    email: 'test@example.com',
    name: 'Test User'
  }),
  validateToken: jest.fn().mockResolvedValue(true),
  refreshToken: jest.fn().mockResolvedValue('new-mock-token')
};

// Mock the auth service module
jest.mock('@/auth/service', () => ({
  authService: mockAuthService
}));

// For dev mode testing, unmock real components
jest.unmock('@/auth/context');
const { AuthProvider } = require('@/auth/context');
                </code_example>
            </implementation>
            <key_points>
                <point>Include ALL required auth service methods to prevent "function not defined" errors</point>
                <point>Use realistic mock data that matches production API responses</point>
                <point>Unmock real AuthProvider for integration tests that validate auth flows</point>
                <point>Set proper environment variables for different test scenarios</point>
            </key_points>
        </pattern>
        
        <pattern id="websocket_testing">
            <title>WebSocket Testing with Unique URLs</title>
            <category>websocket</category>
            <description>Centralized WebSocket testing with conflict prevention</description>
            <implementation>
                <code_example language="typescript">
import WS from 'jest-websocket-mock';
import { act } from '@testing-library/react';

// Generate unique URLs to prevent server conflicts
function generateUniqueUrl(): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substr(2, 9);
  return `ws://localhost:8000/ws-${timestamp}-${random}`;
}

// Safe cleanup function
function safeCleanup(): void {
  try {
    if (typeof WS !== 'undefined' && WS && typeof WS.clean === 'function') {
      WS.clean();
    }
  } catch (error) {
    // Silently ignore cleanup errors - they're not critical for tests
  }
}

// WebSocket event handler wrapper for React state updates
export function createActWrapper&lt;T extends (...args: any[]) =&gt; void&gt;(callback: T): T {
  return ((...args: any[]) =&gt; {
    act(() =&gt; {
      callback(...args);
    });
  }) as T;
}

// Example usage in tests
describe('WebSocket Tests', () =&gt; {
  let server: WS;
  let uniqueUrl: string;
  
  beforeEach(() =&gt; {
    uniqueUrl = generateUniqueUrl();
    server = new WS(uniqueUrl);
  });
  
  afterEach(() =&gt; {
    safeCleanup();
  });
  
  it('should handle WebSocket messages', async () =&gt; {
    const TestComponent = () =&gt; {
      const [message, setMessage] = React.useState('');
      
      React.useEffect(() =&gt; {
        const ws = new WebSocket(uniqueUrl);
        ws.onmessage = createActWrapper((event) =&gt; {
          const data = JSON.parse(event.data);
          setMessage(data.content);
        });
        return () =&gt; ws.close();
      }, []);
      
      return &lt;div data-testid="message"&gt;{message}&lt;/div&gt;;
    };
    
    const { getByTestId } = render(&lt;TestComponent /&gt;);
    await server.connected;
    
    server.send(JSON.stringify({ content: 'Hello from server' }));
    await waitFor(() =&gt; {
      expect(getByTestId('message')).toHaveTextContent('Hello from server');
    });
  });
});
                </code_example>
            </implementation>
            <key_points>
                <point>Always use unique URLs to prevent jest-websocket-mock server conflicts</point>
                <point>Wrap WebSocket event handlers with act() to prevent React warnings</point>
                <point>Use safe cleanup that doesn't throw errors when WS is undefined</point>
                <point>Properly handle async WebSocket operations with waitFor</point>
            </key_points>
        </pattern>
        
        <pattern id="store_reset_isolation">
            <title>Store Reset and Test Isolation</title>
            <category>state_management</category>
            <description>Proper test isolation for state management and mocks</description>
            <implementation>
                <code_example language="typescript">
// Store reset utilities
function clearStorages(): void {
  localStorage.clear();
  sessionStorage.clear();
}

function resetStores(): void {
  // Reset specific stores that persist state
  if (window.__CHAT_STORE__) {
    window.__CHAT_STORE__.clear();
  }
  if (window.__THREAD_STORE__) {
    window.__THREAD_STORE__.clear();
  }
  if (window.__AUTH_STORE__) {
    window.__AUTH_STORE__.clear();
  }
}

// Test setup with proper isolation
describe('Store Integration Tests', () =&gt; {
  beforeEach(() =&gt; {
    // Clean all state before each test
    clearStorages();
    resetStores();
    jest.clearAllMocks();
    
    // Reset environment to known state
    process.env.NODE_ENV = 'test';
  });
  
  afterEach(() =&gt; {
    // Clean up after each test
    cleanupWebSocket();
    jest.resetAllMocks();
  });
  
  // Individual tests are now isolated...
});
                </code_example>
            </implementation>
            <key_points>
                <point>Clear localStorage and sessionStorage before each test</point>
                <point>Reset all global state stores that persist between tests</point>
                <point>Clear Jest mocks to prevent function call pollution</point>
                <point>Use beforeEach/afterEach consistently for reliable isolation</point>
            </key_points>
        </pattern>
        
        <pattern id="framer_motion_mocking">
            <title>Framer Motion Mocking</title>
            <category>animation</category>
            <description>Mock framer-motion to avoid animation issues in tests</description>
            <implementation>
                <code_example language="typescript">
// Mock framer-motion components as simple HTML elements
jest.mock('framer-motion', () =&gt; ({
  motion: {
    div: ({ children, ...props }: any) =&gt; 
      React.createElement('div', { ...props }, children),
    button: ({ children, ...props }: any) =&gt; 
      React.createElement('button', { ...props }, children),
    span: ({ children, ...props }: any) =&gt; 
      React.createElement('span', { ...props }, children),
    section: ({ children, ...props }: any) =&gt; 
      React.createElement('section', { ...props }, children),
  },
  AnimatePresence: ({ children }: any) =&gt; children,
  useAnimation: () =&gt; ({
    start: jest.fn(),
    stop: jest.fn(),
    set: jest.fn(),
  }),
  useMotionValue: (initial: any) =&gt; ({
    get: () =&gt; initial,
    set: jest.fn(),
    on: jest.fn(),
  }),
}));
                </code_example>
            </implementation>
            <rationale>
                Framer Motion animations can cause timing issues, act() warnings, and test flakiness.
                Mocking as simple HTML elements preserves component structure while eliminating
                animation complexity.
            </rationale>
        </pattern>
        
        <pattern id="jest_type_safety">
            <title>Jest Type Safety</title>
            <category>typescript</category>
            <description>Type-safe mock access and configuration</description>
            <implementation>
                <code_example language="typescript">
import { jest } from '@jest/globals';
import { authService } from '@/auth/service';

// Type-safe mock access
const mockAuthService = jest.mocked(authService);
const mockSendMessage = jest.fn&lt;void, [string]&gt;();

// Proper jest.fn() typing for callbacks
const mockOnMessage = jest.fn&lt;void, [MessageEvent]&gt;();
const mockOnError = jest.fn&lt;void, [Event]&gt;();

// Type-safe mock implementations
mockAuthService.getConfig.mockResolvedValue({
  development_mode: false,
  google_client_id: 'test-client-id',
  endpoints: {
    login: 'http://localhost:8081/auth/login',
    logout: 'http://localhost:8081/auth/logout'
  }
});

// Avoid untyped jest.fn() assignments
// BAD: authService.getConfig = jest.fn(); // No type safety
// GOOD: Use jest.mocked() for existing services
                </code_example>
            </implementation>
            <key_points>
                <point>Use jest.mocked() for type-safe access to existing mocked services</point>
                <point>Type jest.fn() callbacks with proper parameter and return types</point>
                <point>Avoid direct jest.fn() assignment to existing service methods</point>
                <point>Use proper TypeScript imports for Jest types</point>
            </key_points>
        </pattern>
        
        <pattern id="real_component_integration">
            <title>Real Component Integration Testing</title>
            <category>integration</category>
            <description>Strategic unmocking for critical user journey validation</description>
            <implementation>
                <code_example language="typescript">
// For integration tests that need real component behavior
describe('Auth Integration Tests', () =&gt; {
  // Unmock real components for this test suite
  jest.unmock('@/auth/context');
  jest.unmock('@/auth/service');
  
  // Import real components after unmocking
  const { AuthProvider } = require('@/auth/context');
  const { authService } = require('@/auth/service');
  
  beforeEach(() =&gt; {
    // Set up real service behavior for dev mode
    process.env.NODE_ENV = 'development';
    
    // Configure auth service for real testing
    authService.getConfig.mockResolvedValue({
      development_mode: true,
      google_client_id: 'mock-google-client-id',
      endpoints: {
        login: 'http://localhost:8081/auth/login',
        logout: 'http://localhost:8081/auth/logout',
        token: 'http://localhost:8081/auth/token'
      }
    });
  });
  
  it('should handle real auth flow', async () =&gt; {
    const TestComponent = () =&gt; {
      return (
        &lt;AuthProvider&gt;
          &lt;div data-testid="auth-component"&gt;
            {/* Real component testing */}
          &lt;/div&gt;
        &lt;/AuthProvider&gt;
      );
    };
    
    const { getByTestId } = render(&lt;TestComponent /&gt;);
    
    // Test real component interactions...
  });
});
                </code_example>
            </implementation>
            <guidelines>
                <guideline>Use real component testing for critical user journeys and integration flows</guideline>
                <guideline>Keep service-level mocking to provide controlled external dependencies</guideline>
                <guideline>Test actual component interactions, state changes, and user experiences</guideline>
                <guideline>Use environment variables to control real vs mock behavior</guideline>
            </guidelines>
        </pattern>
    </patterns>
    
    <configuration>
        <jest_setup>
            <title>Jest Setup Configuration</title>
            <description>Complete Jest setup with all required mocks and polyfills</description>
            <file_location>frontend/jest.setup.js</file_location>
            <key_elements>
                <element name="environment_variables">
                    <description>Set consistent environment variables for all tests</description>
                    <code>
process.env.NEXT_PUBLIC_API_URL = 'http://localhost:8000';
process.env.NEXT_PUBLIC_WS_URL = 'ws://localhost:8000';
process.env.NEXT_PUBLIC_AUTH_SERVICE_URL = 'http://localhost:8081';
                    </code>
                </element>
                
                <element name="global_auth_service_mock">
                    <description>Global auth service mock with all required methods</description>
                    <code>
global.mockAuthService = {
  getConfig: jest.fn().mockResolvedValue(mockAuthConfig),
  getAuthConfig: jest.fn().mockResolvedValue(mockAuthConfig),
  initiateLogin: jest.fn(),
  logout: jest.fn().mockResolvedValue({ success: true }),
  getCurrentUser: jest.fn().mockResolvedValue(mockUser),
  validateToken: jest.fn().mockResolvedValue(true),
  refreshToken: jest.fn().mockResolvedValue('new-mock-token')
};
                    </code>
                </element>
                
                <element name="websocket_enhanced_mock">
                    <description>Enhanced WebSocket mock with unique URL support</description>
                    <code>
class SimpleWebSocket {
  constructor(url) {
    // Generate unique URL if conflicting URLs detected
    this.url = url.includes('-test-') ? url : 
      `${url}-test-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    this.readyState = 1; // OPEN
    this.send = jest.fn();
    this.close = jest.fn();
    // ... other WebSocket properties
  }
}
global.WebSocket = SimpleWebSocket;
                    </code>
                </element>
                
                <element name="browser_api_polyfills">
                    <description>Polyfills for browser APIs needed in Node.js test environment</description>
                    <code>
// Mock scrollIntoView
window.HTMLElement.prototype.scrollIntoView = jest.fn();

// Mock requestAnimationFrame
global.requestAnimationFrame = jest.fn(cb =&gt; setTimeout(cb, 0));
global.cancelAnimationFrame = jest.fn(id =&gt; clearTimeout(id));

// Next.js router mock
jest.mock('next/navigation', () =&gt; ({
  useRouter: () =&gt; ({
    push: jest.fn(),
    replace: jest.fn(),
    back: jest.fn(),
    pathname: '/',
    query: {}
  })
}));
                    </code>
                </element>
            </key_elements>
        </jest_setup>
    </configuration>
    
    <anti_patterns>
        <anti_pattern id="excessive_component_mocking">
            <title>Excessive Component Mocking</title>
            <description>Mocking every UI component prevents real interaction testing</description>
            <example>
                <bad>
// BAD: Mocking UI components prevents testing real interactions
jest.mock('@/components/ui/Button');
jest.mock('@/components/chat/MessageInput');
jest.mock('@/components/auth/LoginForm');

// This prevents testing actual click handlers, form validation, etc.
                </bad>
                <good>
// GOOD: Mock only external services and hooks
jest.mock('@/hooks/useWebSocket');
jest.mock('@/auth/service');
jest.mock('@/api/client');

// UI components remain real for interaction testing
                </good>
            </example>
            <impact>Prevents validation of user interactions, accessibility, and component integration</impact>
        </anti_pattern>
        
        <anti_pattern id="shared_websocket_urls">
            <title>Shared WebSocket URLs</title>
            <description>Using same WebSocket URL across tests causes server conflicts</description>
            <example>
                <bad>
// BAD: Same URL everywhere causes "server already listening" errors
const server = new WS('ws://localhost:8000/ws');
                </bad>
                <good>
// GOOD: Unique URLs prevent conflicts
const uniqueUrl = `ws://localhost:8000/ws-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
const server = new WS(uniqueUrl);
                </good>
            </example>
            <impact>Causes test failures, flaky tests, and server conflict errors</impact>
        </anti_pattern>
        
        <anti_pattern id="incomplete_auth_mocks">
            <title>Incomplete Auth Service Mocks</title>
            <description>Partial auth service mocking causes "function not defined" errors</description>
            <example>
                <bad>
// BAD: Missing required methods
authService.getConfig = jest.fn();
// Missing: getAuthConfig, logout, getCurrentUser, etc.
                </bad>
                <good>
// GOOD: Complete auth service mock
const mockAuthService = {
  getConfig: jest.fn().mockResolvedValue(config),
  getAuthConfig: jest.fn().mockResolvedValue(config),
  initiateLogin: jest.fn(),
  logout: jest.fn().mockResolvedValue({ success: true }),
  getCurrentUser: jest.fn().mockResolvedValue(user),
  validateToken: jest.fn().mockResolvedValue(true)
};
                </good>
            </example>
            <impact>Runtime errors during test execution, undefined function calls</impact>
        </anti_pattern>
        
        <anti_pattern id="state_pollution">
            <title>State Pollution Between Tests</title>
            <description>Not resetting state between tests causes flaky, order-dependent tests</description>
            <example>
                <bad>
// BAD: No state cleanup
describe('Tests', () =&gt; {
  it('test 1', () =&gt; { /* modifies global state */ });
  it('test 2', () =&gt; { /* depends on state from test 1 */ });
});
                </bad>
                <good>
// GOOD: Proper state isolation
describe('Tests', () =&gt; {
  beforeEach(() =&gt; {
    clearStorages();
    resetStores();
    jest.clearAllMocks();
  });
  
  it('test 1', () =&gt; { /* isolated */ });
  it('test 2', () =&gt; { /* isolated */ });
});
                </good>
            </example>
            <impact>Flaky tests, order dependencies, difficult debugging</impact>
        </anti_pattern>
        
        <anti_pattern id="synchronous_async_testing">
            <title>Improper Async Testing</title>
            <description>Not properly handling async operations causes timing issues</description>
            <example>
                <bad>
// BAD: Not waiting for async operations
it('should update state', () =&gt; {
  fireEvent.click(button);
  expect(element).toHaveTextContent('Updated'); // May fail due to timing
});
                </bad>
                <good>
// GOOD: Proper async handling
it('should update state', async () =&gt; {
  fireEvent.click(button);
  await waitFor(() =&gt; {
    expect(element).toHaveTextContent('Updated');
  });
});
                </good>
            </example>
            <impact>Timing-related test failures, race conditions, flaky tests</impact>
        </anti_pattern>
    </anti_patterns>
    
    <best_practices>
        <practice id="service_mocking_hierarchy">
            <title>Service Mocking Hierarchy</title>
            <description>Mock at the appropriate level of abstraction</description>
            <guidelines>
                <guideline>Mock external APIs and network calls at the service layer</guideline>
                <guideline>Mock state management hooks for component isolation</guideline>
                <guideline>Keep UI components real for user interaction testing</guideline>
                <guideline>Use environment variables to control mock vs real behavior</guideline>
            </guidelines>
        </practice>
        
        <practice id="test_data_builders">
            <title>Test Data Builders</title>
            <description>Create reusable builders for test data</description>
            <implementation>
                <code_example language="typescript">
// Create builders for consistent test data
export const createMockUser = (overrides = {}) =&gt; ({
  id: 'test-user-id',
  email: 'test@example.com',
  name: 'Test User',
  ...overrides
});

export const createMockMessage = (overrides = {}) =&gt; ({
  id: `msg-${Date.now()}`,
  content: 'Test message content',
  role: 'user',
  timestamp: new Date().toISOString(),
  ...overrides
});

export const createMockAuthConfig = (overrides = {}) =&gt; ({
  development_mode: false,
  google_client_id: 'test-client-id',
  endpoints: {
    login: 'http://localhost:8081/auth/login',
    logout: 'http://localhost:8081/auth/logout'
  },
  ...overrides
});
                </code_example>
            </implementation>
        </practice>
        
        <practice id="test_utilities_organization">
            <title>Test Utilities Organization</title>
            <description>Organize test utilities for reusability and maintainability</description>
            <structure>
                <directory name="__tests__/setup/">
                    <file>test-providers.tsx - Shared provider components</file>
                    <file>auth-service-setup.ts - Auth service configuration</file>
                    <file>websocket-test-utils.ts - WebSocket testing utilities</file>
                </directory>
                <directory name="__tests__/helpers/">
                    <file>test-builders.ts - Test data builders</file>
                    <file>test-assertions.ts - Custom assertion helpers</file>
                    <file>websocket-helpers.ts - WebSocket message helpers</file>
                </directory>
                <directory name="__tests__/mocks/">
                    <file>auth-service-mock.ts - Auth service mock responses</file>
                    <file>websocket-mocks.ts - WebSocket mock implementations</file>
                </directory>
            </structure>
        </practice>
        
        <practice id="progressive_enhancement_testing">
            <title>Progressive Enhancement Testing</title>
            <description>Test from simple to complex scenarios</description>
            <approach>
                <level name="unit">Mock all external dependencies, test component logic</level>
                <level name="integration">Mock services, test component interactions</level>
                <level name="e2e">Minimal mocking, test complete user journeys</level>
            </approach>
        </practice>
    </best_practices>
    
    <verification>
        <success_metrics>
            <metric>Frontend tests improved from 75 passing to 469+ passing (85%+ pass rate)</metric>
            <metric>Test execution time reduced from timeouts to normal completion</metric>
            <metric>Configuration errors eliminated - only functional issues remain</metric>
            <metric>WebSocket mock conflicts resolved with unique URL generation</metric>
            <metric>Authentication state properly propagated across all test suites</metric>
        </success_metrics>
        
        <quality_indicators>
            <indicator>Tests consistently pass without flakiness</indicator>
            <indicator>New developers can understand and extend test patterns</indicator>
            <indicator>Test failures clearly indicate specific business logic issues</indicator>
            <indicator>CI/CD pipeline reliability improved significantly</indicator>
            <indicator>Test coverage accurately reflects actual user behavior validation</indicator>
        </quality_indicators>
    </verification>
    
    <maintenance>
        <regular_checks>
            <check>Review test pass rates and identify flaky tests</check>
            <check>Update mock data when API contracts change</check>
            <check>Validate test isolation by running tests in random order</check>
            <check>Check for new authentication patterns that need mocking</check>
            <check>Monitor WebSocket test stability and URL uniqueness</check>
        </regular_checks>
        
        <evolution_guidelines>
            <guideline>Add new mock patterns to centralized utilities</guideline>
            <guideline>Update this specification when new patterns emerge</guideline>
            <guideline>Refactor tests that violate the established patterns</guideline>
            <guideline>Share successful patterns across different test categories</guideline>
        </evolution_guidelines>
    </maintenance>
</specification>