<?xml version='1.0' encoding='utf-8'?>
<specification>
  <metadata>
    <name>CodeQuality.TypeSafetyProtocol</name>
    <version>3.0.0</version>
    <priority>CRITICAL</priority>
    <description>Protocols for enforcing strict type safety and maintaining a Single Source of Truth (SSOT).</description>
    <last_edited>2025-08-21T08:47:28.666801</last_edited>
  </metadata>
  <core-principles>
    <principle id="TS-P1" priority="CRITICAL">
      <title>Single Source of Truth (SSOT)</title>
      <instruction>Every type MUST be defined in exactly ONE canonical location. Duplication is forbidden WITHIN a service boundary. Cross-service duplicates may be acceptable for independence - see SPEC/acceptable_duplicates.xml.</instruction>
      <ai-workflow id="AI-TYPE-CREATION-CHECK">
        <step>1. Determine the canonical location (See `Canonical Type Locations`).</step>
        <step>2. Search for an existing type matching the requirements.</step>
        <step>3. If found, IMPORT the existing type. DO NOT REDEFINE.</step>
        <step>4. If NOT found, define the new type in the canonical location.</step>
        <step>5. For cross-service types, check SPEC/acceptable_duplicates.xml for guidance.</step>
      </ai-workflow>
    </principle>
    <principle id="TS-P2" priority="CRITICAL">
      <title>Strict Typing / No Any</title>
      <instruction>Avoid `Any` (Python) or `any` (TypeScript). Use explicit types, `unknown`, or generics.</instruction>
    </principle>
  </core-principles>
  <section title="Canonical Type Locations">
    <location domain="API Contracts (Backend)">app/schemas/[domain].py</location>
    <location domain="Database Models (Backend)">app/db/models_postgres.py</location>
    <location domain="API Contracts (Frontend)">frontend/types/backend_schema_auto_generated.ts</location>
  </section>
  <section title="Cross-Platform Synchronization">
    <protocol id="TS-SYNC-001">
      <title>Schema Synchronization</title>
      <instruction>Ensure TypeScript types reflect backend Pydantic schemas.</instruction>
      <workflow>
        <step>1. Modify Pydantic models in `app/schemas/`.</step>
        <step>2. Execute the synchronization tool.</step>
      </workflow>
      <ai-directive>After modifying any Pydantic schema, the AI agent MUST execute: `python scripts/schema_sync.py`.</ai-directive>
    </protocol>
  </section>
  <section title="Critical Patterns">
    <pattern id="ZUSTAND-SELECTORS" context="Frontend" priority="CRITICAL">
      <title>Zustand Selector Stability</title>
      <instruction>Use individual selectors only.</instruction>
      <reference>SPEC/conventions.xml#FE-001</reference>
    </pattern>
    <pattern id="DATACLASS-DECORATOR" context="Backend" priority="CRITICAL">
      <title>Dataclass Decorator Requirement</title>
      <instruction>ALL dataclass definitions MUST include @dataclass decorator.</instruction>
      <example>@dataclass\nclass HealthCheckResult:\n    service: str\n    healthy: bool\n    response_time_ms: float</example>
      <reference>SPEC/learnings/cross_system_test_fixes_comprehensive.xml#health-check-result-dataclass-decorator</reference>
    </pattern>
    <pattern id="ABSOLUTE-IMPORTS-ONLY" context="All" priority="CRITICAL">
      <title>Absolute Import Requirement</title>
      <instruction>ALL Python files MUST use absolute imports starting from package root. Relative imports are FORBIDDEN.</instruction>
      <correct_example>from netra_backend.app.services.user_auth_service import UserAuthService</correct_example>
      <incorrect_example>from ..services.user_auth_service import UserAuthService</incorrect_example>
      <reference>SPEC/learnings/cross_system_test_fixes_comprehensive.xml#import-resolution-massive-fixes</reference>
    </pattern>
  </section>
</specification>