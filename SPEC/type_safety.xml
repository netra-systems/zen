<?xml version="1.0" encoding="UTF-8"?>
<spec>
  <metadata>
    <name>Type Safety and Duplicate Prevention</name>
    <description>CRITICAL guidelines for type safety and preventing duplicate type definitions. Current status: 161 duplicate types detected across codebase requiring immediate consolidation.</description>
    <version>2.1.0</version>
    <created>2025-01-12</created>
    <updated>2025-08-16</updated>
    <priority>CRITICAL</priority>
    <tags>
      <tag>type-safety</tag>
      <tag>typescript</tag>
      <tag>python</tag>
      <tag>code-quality</tag>
      <tag>duplicate-prevention</tag>
    </tags>
  </metadata>

  <core-principles>
    <principle id="P1" priority="CRITICAL">
      <title>Single Source of Truth</title>
      <description>Each type MUST be defined in exactly ONE location</description>
      <enforcement>Fail code review if duplicate types found</enforcement>
    </principle>
    
    <principle id="P2" priority="CRITICAL">
      <title>No Any Types</title>
      <description>NEVER use Any/any without explicit justification comment</description>
      <enforcement>Require eslint-disable comment with reason</enforcement>
    </principle>
    
    <principle id="P3">
      <title>Import Over Redefine</title>
      <description>ALWAYS import existing types rather than creating new ones</description>
      <reference>SPEC/anti_regression.xml</reference>
    </principle>
  </core-principles>

  <critical-rules>
    <rule id="PY-CRITICAL-1" priority="CRITICAL">
      <title>Python Type Annotations Required</title>
      <description>ALL functions MUST have typed parameters and return types</description>
      <forbidden>def process_data(data, user_id):</forbidden>
      <correct>def process_data(data: Dict[str, Any], user_id: str) -> Optional[ProcessResult]:</correct>
      <validation>python -m mypy app/ --ignore-missing-imports</validation>
    </rule>
    
    <rule id="PY-CRITICAL-2" priority="CRITICAL">
      <title>Pydantic Models for API Data</title>
      <description>ALL API endpoints MUST use Pydantic models</description>
      <location>app/schemas/</location>
      <action>Create in appropriate schema file, NOT in routes</action>
      <reference>SPEC/conventions.xml</reference>
    </rule>
    
    <rule id="TS-CRITICAL-1" priority="CRITICAL">
      <title>React Component Props Typing</title>
      <description>ALL components MUST have typed props interfaces</description>
      <forbidden>export const MessageItem = ({ message }) => {</forbidden>
      <correct>
interface MessageItemProps {
  message: Message;
  isHighlighted?: boolean;
}
export const MessageItem: React.FC&lt;MessageItemProps&gt; = ({ message }) => {
      </correct>
    </rule>
    
    <rule id="TS-CRITICAL-2" priority="CRITICAL">
      <title>No any Type Without Justification</title>
      <description>any type ONLY allowed with eslint-disable and reason</description>
      <correct>
// eslint-disable-next-line @typescript-eslint/no-explicit-any
// Reason: Third-party library returns untyped response
const response: any = await externalApi.call();
      </correct>
      <validation>npx tsc --noEmit</validation>
    </rule>
    
    <rule id="CROSS-CRITICAL-1" priority="CRITICAL">
      <title>Backend-Frontend Type Alignment</title>
      <description>API types MUST match between Python and TypeScript</description>
      <locations>
        <backend>app/schemas/</backend>
        <frontend>frontend/types/backend_schema_auto_generated.ts</frontend>
      </locations>
      <action>Keep auto-generated types in sync using schema_sync.py</action>
    </rule>
  </critical-rules>

  <type-locations>
    <location type="API Request/Response">
      <path>app/schemas/[domain].py</path>
      <example>app/schemas/Request.py</example>
    </location>
    <location type="WebSocket Messages">
      <path>app/schemas/websocket_types.py</path>
      <note>Use websocket_unified.py for new types</note>
    </location>
    <location type="Database Models">
      <path>app/db/models_postgres.py</path>
    </location>
    <location type="React Props">
      <path>In component file or adjacent .types.ts</path>
    </location>
    <location type="Store Types">
      <path>frontend/types/[store-name].ts</path>
    </location>
  </type-locations>

  <duplicate-prevention>
    <detection id="D1">
      <name>Find Duplicate Types</name>
      <command>grep -r "^(class|interface|type) " --include="*.py" --include="*.ts" --include="*.tsx" | awk '{print $2}' | sort | uniq -d</command>
      <action>Consolidate to single definition</action>
    </detection>
    
    <detection id="D2">
      <name>Find Any Usage</name>
      <backend>grep -r "Dict\[str, Any\]" app/ --include="*.py"</backend>
      <frontend>grep -r ": any" frontend/ --include="*.ts" --include="*.tsx"</frontend>
      <action>Replace with proper types</action>
    </detection>
    
    <prevention>
      <step>BEFORE creating type: Search existing schemas</step>
      <step>BEFORE redefining: Import from canonical location</step>
      <step>AFTER adding type: Update imports in affected files</step>
    </prevention>
  </duplicate-prevention>

  <common-errors>
    <error id="E1">
      <symptom>TypeScript compilation error: Cannot find name 'Message'</symptom>
      <cause>Missing import or duplicate type definition</cause>
      <fix>Import from @/types/chat or check for naming conflicts</fix>
    </error>
    
    <error id="E2">
      <symptom>Pydantic validation error in production</symptom>
      <cause>Schema mismatch between frontend and backend</cause>
      <fix>Run schema_sync.py and regenerate types</fix>
    </error>
    
    <error id="E3">
      <symptom>mypy error: Incompatible return type</symptom>
      <cause>Missing or incorrect type annotations</cause>
      <fix>Add proper return type annotation to function</fix>
    </error>
  </common-errors>

  <frontend-state-management>
    <critical-pattern id="ZUSTAND-1" priority="CRITICAL">
      <title>Zustand Selector Infinite Loop Prevention</title>
      <problem>Object-returning selectors create new references causing infinite loops</problem>
      <solution>Use individual selectors for each piece of state</solution>
      <forbidden>
        // WRONG - Creates new object reference every render
        const storeSelector = (state: UnifiedChatState) => ({
          activeThreadId: state.activeThreadId,
          isThreadLoading: state.isThreadLoading
        });
        const storeData = useUnifiedChatStore(storeSelector, shallow);
      </forbidden>
      <correct>
        // CORRECT - Individual selectors with stable references
        const activeThreadId = useUnifiedChatStore(state => state.activeThreadId);
        const isThreadLoading = useUnifiedChatStore(state => state.isThreadLoading);
      </correct>
      <reference>SPEC/learnings/frontend.xml#zustand-individual-selectors-pattern</reference>
    </critical-pattern>
  </frontend-state-management>

  <validation>
    <check id="V1">
      <name>Python Type Coverage</name>
      <command>python -m mypy app/ --ignore-missing-imports</command>
      <target>95% coverage minimum</target>
      <integration>Run in smoke tests</integration>
    </check>
    
    <check id="V2">
      <name>TypeScript Strict Mode</name>
      <command>npx tsc --noEmit</command>
      <config>tsconfig.json with strict: true</config>
      <integration>Pre-commit hook</integration>
    </check>
    
    <check id="V3">
      <name>Schema Sync Check</name>
      <command>python scripts/schema_sync.py --check</command>
      <frequency>Before each PR</frequency>
    </check>
  </validation>

  <quick-reference>
    <naming>
      <pattern>*Payload - WebSocket messages</pattern>
      <pattern>*Request/*Response - API endpoints</pattern>
      <pattern>*Props - React components</pattern>
      <pattern>*State - Store state</pattern>
    </naming>
    
    <import-hierarchy>
      1. Import from existing schemas
      2. Import from auto-generated types
      3. Create new ONLY if unique
      4. Document why new type needed
    </import-hierarchy>
  </quick-reference>

  <references>
    <reference>SPEC/conventions.xml - General coding standards</reference>
    <reference>SPEC/code_changes.xml - Type checking in checklist</reference>
    <reference>SPEC/anti_regression.xml - Duplicate prevention patterns</reference>
    <reference>SPEC/no_test_stubs.xml - Type safety in tests</reference>
  </references>
</spec>