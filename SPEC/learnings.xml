<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Learnings and Troubleshooting</name>
        <type>reference</type>
        <version>1.0</version>
        <last_updated>2025-08-12</last_updated>
        <description>Historical learnings, troubleshooting patterns, and resolved issues</description>
    </metadata>

    <sections>
        <section id="common-gotchas" order="1">
            <title>Common Gotchas and Solutions</title>
            
            <item id="react-duplicate-keys">
                <problem>Using Date.now() for keys creates duplicates in rapid renders</problem>
                <solution>Always use generateUniqueId() from @/lib/utils</solution>
                <example>
                    // ❌ Wrong
                    key={Date.now()}
                    
                    // ✅ Correct
                    key={generateUniqueId('msg')}
                </example>
            </item>
            
            <item id="websocket-test-failures">
                <problem>Hook tests fail without provider</problem>
                <solution>Wrap with WebSocketProvider in tests</solution>
                <example>
                    const wrapper = ({ children }) => (
                        &lt;WebSocketProvider&gt;{children}&lt;/WebSocketProvider&gt;
                    );
                </example>
            </item>
            
            <item id="import-test-failures">
                <problem>New dependencies not in import tests</problem>
                <solution>Update app/tests/test_internal_imports.py and app/tests/test_external_imports.py</solution>
            </item>
            
            <item id="test-runner-reliability">
                <problem>Test runner fails due to argument parsing or Unicode encoding</problem>
                <critical>Fix test runner FIRST before running actual tests</critical>
                <issues>
                    <issue>Unicode emojis cause Windows terminal encoding errors</issue>
                    <issue>Parallel arguments must be properly formatted (--parallel=auto not --parallel auto)</issue>
                    <issue>Frontend test args should avoid Jest-specific options in unified runner</issue>
                </issues>
            </item>
        </section>

        <section id="historical-fixes" order="2">
            <title>Historical Issue Resolutions</title>
            
            <fix date="2025-08-11">
                <title>Running Tests from Subdirectories</title>
                <problem>Test runner path needs adjustment in subdirectories</problem>
                <solution>Use relative path ../test_runner.py from subdirectories</solution>
                <note>Comprehensive tests may timeout with default 2-minute limit</note>
            </fix>
            
            <fix date="2025-01-11">
                <title>Startup Check False Warnings</title>
                <problem>Services showing as unavailable despite successful connections</problem>
                <root-causes>
                    <cause>Redis set() method parameter mismatch (expire vs ex)</cause>
                    <cause>Missing Redis delete() method in RedisManager</cause>
                    <cause>Missing await for async ClickHouse execute_query() method</cause>
                </root-causes>
                <solution>Added backward compatibility, implemented delete method, added await</solution>
                <prevention>Always verify method signatures match between caller and implementation</prevention>
            </fix>
            
            <fix date="2025-01-11">
                <title>ClickHouse Startup Check</title>
                <problem>'ClickHouseDatabase' object has no attribute 'execute' error</problem>
                <root-cause>Using wrong method name - should be execute_query() not execute()</root-cause>
                <solution>Updated app/startup_checks.py:287 to use client.execute_query()</solution>
            </fix>
            
            <fix date="2025-01-11">
                <title>Database Schema Migration</title>
                <problem>Missing tables and columns causing schema validation errors</problem>
                <tables-added>tool_usage_logs, ai_supply_items, research_sessions, supply_update_logs</tables-added>
                <columns-added>tool_permissions, plan_expires_at, feature_flags, payment_status, auto_renew, plan_tier, plan_started_at, trial_period</columns-added>
                <migration>bb39e1c49e2d_add_missing_tables_and_columns.py</migration>
            </fix>
            
            <fix date="2025-08-11">
                <title>Thread Creation 500 Error</title>
                <problem>Thread creation failing with '_AsyncGeneratorContextManager' object has no attribute 'execute'</problem>
                <root-cause>Parameter order mismatch in base_repository.get_by_id()</root-cause>
                <solution>Fixed parameter order to get_by_id(self, db, entity_id)</solution>
                <files-changed>
                    <file>app/services/database/base_repository.py:55-72</file>
                    <file>app/routes/threads_route.py:81-123</file>
                </files-changed>
                <prevention>Added regression test in app/tests/test_thread_repository.py</prevention>
            </fix>
            
            <fix date="2025-08-12">
                <title>Staging Deployment Configuration Loading Failure</title>
                <problem>Database URL and other critical configs not loading in Cloud Run staging environment</problem>
                <symptoms>
                    <symptom>Error: "database url not configured etc." in Cloud Run logs</symptom>
                    <symptom>Secrets loading message appears but configs remain unset</symptom>
                    <symptom>ClickHouse credentials passed but not accessible</symptom>
                </symptoms>
                <root-causes>
                    <cause>StagingConfig class didn't override database_url from base AppConfig (which defaults to None)</cause>
                    <cause>Critical environment variables (DATABASE_URL, REDIS_URL, etc.) not loaded from environment</cause>
                    <cause>ConfigManager._load_from_environment_variables() method existed but was never called</cause>
                    <cause>No mechanism to load non-secret environment variables during config initialization</cause>
                </root-causes>
                <solution>
                    <step>Added __init__ method to StagingConfig to load DATABASE_URL from environment</step>
                    <step>Created _load_critical_env_vars() method in ConfigManager to load critical env vars</step>
                    <step>Added redis_url and clickhouse_url fields to base AppConfig</step>
                    <step>Ensured JWT_SECRET_KEY, FERNET_KEY, and GEMINI_API_KEY are loaded from environment</step>
                    <step>Added special handling for ClickHouse and LLM configuration from environment</step>
                    <step>Updated Terraform configuration to pass GEMINI_API_KEY as environment variable</step>
                </solution>
                <files-changed>
                    <file>app/schemas/Config.py - Added __init__ to StagingConfig, added redis_url/clickhouse_url fields</file>
                    <file>app/config.py - Added _load_critical_env_vars() method and call in _load_configuration()</file>
                    <file>terraform/staging/main.tf - Added GEMINI_API_KEY environment variable</file>
                    <file>terraform/staging/variables.tf - Added gemini_api_key variable</file>
                </files-changed>
                <prevention>
                    <action>Always ensure environment-specific configs override base class defaults</action>
                    <action>Load critical environment variables before attempting to load secrets</action>
                    <action>Test configuration loading with minimal environment variables set</action>
                    <action>Document which environment variables are required vs optional for each environment</action>
                </prevention>
                <key-insight>
                    Environment variables for database connections and service URLs are NOT secrets and should be 
                    loaded separately from the Secret Manager flow. The configuration loading should follow this order:
                    1. Create base config for environment
                    2. Load critical environment variables (DATABASE_URL, REDIS_URL, etc.)
                    3. Load secrets from Secret Manager or environment
                    4. Validate configuration
                </key-insight>
            </fix>
            
            <fix date="2025-08-13">
                <title>SQLAlchemy Async Engine SQL Execution</title>
                <problem>Connection monitor tests failing with "Not an executable object: 'SELECT 1'" errors</problem>
                <symptoms>
                    <symptom>ERROR | app.services.database.connection_monitor:_test_connectivity:294 | Connectivity test failed: Not an executable object: 'SELECT 1'</symptom>
                    <symptom>ERROR | app.services.database.connection_monitor:_test_performance:339 | Performance test failed: Not an executable object: 'SELECT 1'</symptom>
                </symptoms>
                <root-causes>
                    <cause>Raw SQL strings cannot be executed directly with SQLAlchemy async engines</cause>
                    <cause>conn.execute() requires SQLAlchemy text() objects, not plain strings</cause>
                    <cause>async_engine.begin() vs async_engine.connect() have different async behaviors</cause>
                </root-causes>
                <solution>
                    <step>Import text from sqlalchemy: from sqlalchemy import text</step>
                    <step>Wrap all SQL strings with text(): conn.execute(text("SELECT 1"))</step>
                    <step>Use async_engine.connect() for proper async operations instead of async_engine.begin()</step>
                </solution>
                <files-changed>
                    <file>app/services/database/connection_monitor.py - Added text import, wrapped SQL queries</file>
                </files-changed>
                <prevention>
                    <action>Always use text() wrapper for raw SQL queries with SQLAlchemy</action>
                    <action>Use async_engine.connect() for async operations with await on results</action>
                    <action>Use async_engine.begin() for transactional operations with sync results</action>
                </prevention>
                <key-insight>
                    SQLAlchemy async engines require SQL to be wrapped in text() objects for proper execution.
                    This applies to all raw SQL queries including simple SELECT 1 health checks.
                </key-insight>
            </fix>
            
            <fix date="2025-08-11">
                <title>Critical E2E Test Coverage Enhancement</title>
                <problem>Demo brittleness despite 60%+ coverage - tests focused on happy paths</problem>
                <root-causes>
                    <cause>WebSocket state desynchronization during reconnections</cause>
                    <cause>Race conditions in Zustand store updates</cause>
                    <cause>Agent orchestration failures under load</cause>
                    <cause>Missing circuit breaker and retry logic tests</cause>
                    <cause>No tests for memory leaks or performance degradation</cause>
                </root-causes>
                <solution>Implemented 50 critical e2e tests for failure scenarios</solution>
                <test-patterns>
                    <pattern>Network partition simulation: cy.intercept('**/ws**', { forceNetworkError: true })</pattern>
                    <pattern>Memory leak detection: Track performance.memory.usedJSHeapSize</pattern>
                    <pattern>Concurrent update testing: Fire multiple state updates in parallel</pattern>
                    <pattern>Circuit breaker validation: Track failure counts and verify degradation</pattern>
                </test-patterns>
                <files-created>
                    <file>critical-websocket-resilience.cy.ts - 15 WebSocket tests</file>
                    <file>critical-state-synchronization.cy.ts - 10 state tests</file>
                    <file>critical-agent-orchestration-recovery.cy.ts - 10 agent tests</file>
                </files-created>
                <prevention>Always test failure scenarios, concurrent operations, network instability, memory usage, error cascades</prevention>
            </fix>
            
            <fix date="2025-08-12">
                <title>Staging Workflow Concurrency Control</title>
                <problem>Multiple commits in quick succession cause redundant builds and resource waste</problem>
                <root-causes>
                    <cause>No cancellation of in-progress workflows when new commits pushed</cause>
                    <cause>Parallel workflows consuming resources for outdated commits</cause>
                    <cause>Developers waiting for outdated workflows to complete</cause>
                </root-causes>
                <solution>Added GitHub Actions concurrency groups with cancel-in-progress</solution>
                <implementation>
                    <code>
                        concurrency:
                          group: staging-pr-${{ github.event.pull_request.number }}
                          cancel-in-progress: true
                    </code>
                    <exception>Destroy operations use separate group with cancel-in-progress: false</exception>
                </implementation>
                <benefits>
                    <benefit>Only latest commit's workflow runs to completion</benefit>
                    <benefit>Faster feedback on latest changes</benefit>
                    <benefit>Reduced cloud costs from cancelled builds</benefit>
                    <benefit>Cleaner workflow history</benefit>
                </benefits>
                <prevention>Always use concurrency groups for PR-based workflows to prevent redundant runs</prevention>
            </fix>
            
            <fix date="2025-08-13">
                <title>GitHub Actions Deployment Permission Error</title>
                <problem>RequestError [HttpError]: Resource not accessible by integration when creating deployments</problem>
                <symptoms>
                    <symptom>Error 403 when calling github.rest.repos.createDeployment</symptom>
                    <symptom>Error 403 when calling github.rest.repos.createDeploymentStatus</symptom>
                    <symptom>Workflow fails at deployment creation step</symptom>
                </symptoms>
                <root-cause>Missing required permissions in GitHub Actions workflow file</root-cause>
                <solution>Added explicit permissions block to workflow file</solution>
                <implementation>
                    <code>
                        permissions:
                          contents: read
                          deployments: write
                          pull-requests: write
                          issues: write
                          statuses: write
                    </code>
                </implementation>
                <files-changed>
                    <file>.github/workflows/staging-environment.yml - Added permissions block at top level</file>
                </files-changed>
                <prevention>
                    <action>Always define explicit permissions for GitHub Actions workflows that use GitHub API</action>
                    <action>Include 'deployments: write' permission when using deployment API</action>
                    <action>Include 'pull-requests: write' when commenting on PRs</action>
                    <action>Include 'issues: write' when managing issue comments</action>
                    <action>Include 'statuses: write' when updating commit statuses</action>
                </prevention>
                <note>This is a recurring issue - always check permissions when workflows fail with 403 errors</note>
            </fix>
            
            <fix date="2025-08-13">
                <title>WebSocket Heartbeat KeyError on Disconnect</title>
                <problem>KeyError when stopping heartbeat for connection during disconnect</problem>
                <symptoms>
                    <symptom>KeyError: 'conn_1755126541826' in heartbeat.py line 86</symptom>
                    <symptom>Error occurs in del self.heartbeat_tasks[connection_id]</symptom>
                    <symptom>Happens during WebSocket disconnect process</symptom>
                </symptoms>
                <root-cause>Race condition between heartbeat loop cleanup and stop_heartbeat_for_connection method</root-cause>
                <details>
                    <detail>The heartbeat loop's finally block deletes from heartbeat_tasks dictionary</detail>
                    <detail>stop_heartbeat_for_connection also tries to delete the same key</detail>
                    <detail>If heartbeat loop finishes first, stop_heartbeat_for_connection causes KeyError</detail>
                </details>
                <solution>Added safety check before deletion in stop_heartbeat_for_connection</solution>
                <implementation>
                    <code>
                        # Before fix:
                        del self.heartbeat_tasks[connection_id]
                        
                        # After fix:
                        if connection_id in self.heartbeat_tasks:
                            del self.heartbeat_tasks[connection_id]
                    </code>
                </implementation>
                <files-changed>
                    <file>app/websocket/heartbeat.py:86-87 - Added safety check before deletion</file>
                </files-changed>
                <prevention>
                    <action>Always check dictionary key existence before deletion in cleanup code</action>
                    <action>Be aware of race conditions in async cleanup operations</action>
                    <action>Use safe deletion patterns when multiple code paths can delete the same resource</action>
                </prevention>
            </fix>
            
            <fix date="2025-08-13">
                <title>ThreadService Method Parameter Order Error</title>
                <problem>DB_QUERY_FAILED: Failed to get or create thread for user - AsyncSession object passed as user_id</problem>
                <symptoms>
                    <symptom>Error in handle_user_message: AsyncSession object at 0x... shown instead of user_id</symptom>
                    <symptom>ThreadService methods called with wrong parameter order</symptom>
                    <symptom>Missing get_thread method in ThreadService</symptom>
                </symptoms>
                <root-causes>
                    <cause>All ThreadService method calls had parameters in wrong order</cause>
                    <cause>db_session was passed as first argument when it should be last</cause>
                    <cause>get_thread method was called but not implemented in ThreadService</cause>
                </root-causes>
                <solution>
                    <step>Added missing get_thread method to ThreadService</step>
                    <step>Fixed parameter order for get_or_create_thread: (user_id, db) not (db, user_id)</step>
                    <step>Fixed parameter order for get_thread: (thread_id, db) not (db, thread_id)</step>
                    <step>Fixed create_message to use db= keyword argument as last parameter</step>
                    <step>Fixed create_run to use db= keyword argument as last parameter</step>
                    <step>Fixed get_thread_messages to use db= keyword argument as last parameter</step>
                    <step>Fixed update_run_status to use db= keyword argument as last parameter</step>
                </solution>
                <files-changed>
                    <file>app/services/thread_service.py:75-86 - Added get_thread method</file>
                    <file>app/services/message_handlers.py - Fixed all ThreadService method calls</file>
                </files-changed>
                <prevention>
                    <action>Always check method signatures before calling them</action>
                    <action>AsyncSession should typically be the last optional parameter with db= keyword</action>
                    <action>Entity IDs and required parameters should come first</action>
                    <action>Test database operations thoroughly with proper parameter validation</action>
                </prevention>
                <key-insight>
                    Repository pattern methods should follow consistent parameter ordering:
                    1. Required entity identifiers (user_id, thread_id, etc.)
                    2. Required data parameters
                    3. Optional parameters with defaults
                    4. Database session as last optional parameter (db: Optional[AsyncSession] = None)
                </key-insight>
            </fix>
            
            <fix date="2025-08-14">
                <title>CORS Headers Missing on API Endpoints</title>
                <problem>CORS policy blocking frontend requests to backend API endpoints</problem>
                <symptoms>
                    <symptom>Error: "No 'Access-Control-Allow-Origin' header is present on the requested resource"</symptom>
                    <symptom>Frontend at localhost:59490 unable to call backend at localhost:59409</symptom>
                    <symptom>Affects authentication endpoints like /api/auth/dev_login</symptom>
                </symptoms>
                <root-causes>
                    <cause>CORS middleware configuration using incorrect wildcard pattern in list</cause>
                    <cause>FastAPI CORSMiddleware does not handle patterns like "http://localhost:*" in allowed_origins list</cause>
                    <cause>CORS middleware was added after other middleware, affecting order of execution</cause>
                </root-causes>
                <solution>
                    <step>Simplified development CORS configuration to use ["*"] wildcard directly</step>
                    <step>Moved CORS middleware configuration to be first middleware added to app</step>
                    <step>Removed duplicate CORS configuration code</step>
                    <step>Ensured CORS is configured before OAuth initialization and other middleware</step>
                </solution>
                <files-changed>
                    <file>app/main.py:251-274 - Moved and simplified CORS configuration</file>
                    <file>app/main.py:309-334 - Removed duplicate CORS configuration</file>
                </files-changed>
                <prevention>
                    <action>Always configure CORS middleware as first middleware in FastAPI app</action>
                    <action>Use ["*"] for development instead of pattern strings in allowed_origins</action>
                    <action>Test CORS with OPTIONS preflight requests during development</action>
                    <action>Verify CORS headers with curl -v to see actual response headers</action>
                </prevention>
                <key-insight>
                    FastAPI's CORSMiddleware requires exact origin matching or wildcard ["*"].
                    Pattern strings like "http://localhost:*" are not supported.
                    Middleware order matters - CORS should be configured early in the stack.
                </key-insight>
            </fix>
            
            <fix date="2025-08-14">
                <title>Development Database Configuration - Use Real Postgres</title>
                <problem>Mock database being used in development environment instead of real Postgres</problem>
                <symptoms>
                    <symptom>Database features working in tests but failing in development</symptom>
                    <symptom>State persistence issues in development environment</symptom>
                    <symptom>Connection monitor skipping monitoring in mock mode</symptom>
                </symptoms>
                <root-causes>
                    <cause>.dev_services.json configured with postgres mode set to "mock"</cause>
                    <cause>dev_launcher/service_config.py sets mock DATABASE_URL when mode is MOCK</cause>
                    <cause>Mock database only suitable for specific testing scenarios</cause>
                </root-causes>
                <solution>
                    <step>Changed .dev_services.json postgres mode from "mock" to "local"</step>
                    <step>Ensures real Postgres database used in development environment</step>
                    <step>DATABASE_URL properly configured as postgresql://postgres:postgres@localhost:5432/netra_dev</step>
                </solution>
                <files-changed>
                    <file>.dev_services.json - Changed postgres mode from "mock" to "local"</file>
                </files-changed>
                <prevention>
                    <action>Always use real databases in development environment</action>
                    <action>Mock databases should only be used for specific unit tests</action>
                    <action>Verify .dev_services.json configuration before running dev_launcher</action>
                    <action>Integration and E2E tests should use real database connections</action>
                </prevention>
                <key-insight>
                    Development environments should mirror production as closely as possible. Using real databases
                    in development catches issues early that mock databases would miss. Mock databases should be
                    reserved for unit tests where database interaction is not the focus of the test.
                </key-insight>
            </fix>
        </section>

        <section id="test-focus-strategy" order="3">
            <title>Test Focus Strategy</title>
            <avoid>
                <item>Testing basic Python functions</item>
                <item>Simple getters/setters</item>
                <item>Trivial utilities</item>
            </avoid>
            <focus>
                <item>Netra-specific business logic and integrations</item>
                <item>Complex dependency interactions (database, Redis, ClickHouse, LLM providers)</item>
                <item>Agent orchestration and WebSocket communication</item>
                <item>API endpoints with authentication and authorization</item>
                <item>Critical data flows and error handling scenarios</item>
                <item>Performance and concurrency edge cases</item>
            </focus>
        </section>
    </sections>
</specification>