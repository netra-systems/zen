<?xml version='1.0' encoding='utf-8'?>
<specification>
  <metadata>
    <name>NetraPlatform.CodingConventions</name>
    <type>InstructionSet</type>
    <version>3.0</version>
    <last_updated>2025-08-22</last_updated>
    <description>
            MANDATORY instruction set for all AI agents contributing code to the Netra AI platform.
        </description>
    <last_edited>2025-08-22T00:00:00.000000</last_edited>
  </metadata>
  <section title="Architectural Constraints (The 450/25 Rule)">
    <ai-directive>AI agents must proactively enforce these constraints during code generation, initiating refactoring protocols if limits are approached (e.g., 250 lines for files, 6 lines for functions).</ai-directive>
    <constraint id="ARC-001" priority="CRITICAL">
      <title>File Line Limit (450 Lines)</title>
      <instruction>Ensure every source file is 450 lines or less (LOC). Exception: Test files may extend up to 1000 lines.</instruction>
      <action-on-violation>Execute 'Extract Module Protocol'. Split the file based on functional boundaries.</action-on-violation>
      <exceptions>
        <exception type="test_files">Test files (test_*.py, *.test.ts, *.test.tsx) may extend up to 1000 lines to accommodate comprehensive test suites</exception>
      </exceptions>
    </constraint>
    <constraint id="ARC-002" priority="CRITICAL">
      <title>Function/Method Line Limit (25 Lines)</title>
      <instruction>Ensure every function or method body is 25 lines or less (LOC).</instruction>
      <action-on-violation>Execute 'Extract Function Protocol'. Decompose logic into smaller, named helper functions.</action-on-violation>
    </constraint>
    <constraint id="ARC-003" priority="CRITICAL">
      <title>Prohibition of Duplication</title>
      <instruction>Do not create duplicate functionality or types. Extend existing implementations.</instruction>
      <ai-directive>Before generating new code or types, search the codebase for existing implementations. If found, IMPORT and USE it. Do not redefine.</ai-directive>
    </constraint>
    <constraint id="ARC-004" priority="CRITICAL">
      <title>Test Code Segregation</title>
      <instruction>Do not introduce test stubs or mocks into production service code.</instruction>
      <reference>SPEC/no_test_stubs.xml</reference>
    </constraint>
    <constraint id="ARC-005" priority="CRITICAL">
      <title>Test Organization Standards</title>
      <instruction>Test files and configurations must follow strict organizational standards to maintain service boundaries and prevent complexity.</instruction>
      <conftest_rules>
        <rule>conftest.py files MUST only exist at service-level directories</rule>
        <allowed_locations>auth_service/tests/conftest.py, netra_backend/tests/conftest.py, tests/conftest.py</allowed_locations>
        <prohibited>ANY subdirectory conftest.py files (e.g., netra_backend/tests/*/conftest.py)</prohibited>
      </conftest_rules>
      <naming_standards>
        <rule>ALL test files MUST use test_*.py naming pattern</rule>
        <prohibited>*_test.py, test*.py (without underscore)</prohibited>
        <examples>✅ test_user_service.py, ❌ user_service_test.py</examples>
      </naming_standards>
      <enforcement>
        <script>scripts/check_conftest_violations.py</script>
        <pre_commit_hook>.githooks/check-test-organization.py</pre_commit_hook>
      </enforcement>
      <reference>SPEC/testing.xml#test_organization_standards</reference>
    </constraint>
  </section>
  <section title="Frontend Specific Conventions">
    <guideline id="FE-001" context="State Management (Zustand)" priority="CRITICAL">
      <title>Zustand Individual Selector Pattern</title>
      <instruction>Always use individual selectors for accessing Zustand store state. Object-returning selectors are FORBIDDEN as they cause infinite loops.</instruction>
      <code-example language="typescript">
        <before description="VIOLATION: Creates unstable references">

const selector = (state) =&gt; ({ a: state.a, b: state.b });
const data = useStore(selector, shallow);

                </before>
        <after description="CORRECT: Ensures stable references">

const a = useStore(state =&gt; state.a);
const b = useStore(state =&gt; state.b);

                </after>
      </code-example>
    </guideline>
    <guideline id="FE-003" context="React Keys">
      <instruction>Ensure unique and stable keys for all list renderings.</instruction>
      <pattern>Use `generateUniqueId()` from `@/lib/utils` if no stable ID exists.</pattern>
      <forbidden-pattern>Do NOT use `Date.now()` or array indices as keys.</forbidden-pattern>
    </guideline>
  </section>
  <section title="Backend Specific Conventions">
    <guideline id="BE-001" context="Namespace Convention" priority="CRITICAL">
      <title>Service-Based Namespace Pattern - Absolute Imports Only</title>
      <instruction>All backend imports must follow the service-based namespace pattern: {top_level_service_name}.{app|tests}. NO relative imports are allowed - use absolute imports exclusively. EXCEPTION: E2E test helpers must be imported from root-level tests.unified directory.</instruction>
      <code-example language="python">
        <before description="VIOLATION: Old import pattern or relative imports">

from netra_backend.app.core.config import Settings
from netra_backend.tests.conftest import TestClient
from .config import Settings  # FORBIDDEN: relative import
from ..core.config import Settings  # FORBIDDEN: relative import
# E2E test helpers - WRONG pattern:
from netra_backend.tests.unified.harness_complete import UnifiedTestHarnessComplete

                </before>
        <after description="CORRECT: Service-based absolute namespace">

from netra_backend.app.core.config import Settings
from netra_backend.tests.conftest import TestClient
# Always use absolute imports with full service namespace

# E2E test helpers - CORRECT pattern (root-level tests directory):
from tests.harness_complete import UnifiedTestHarnessComplete
from tests.e2e.helpers.database_sync_helpers import DatabaseSyncHelper

                </after>
      </code-example>
      <pattern>For microservices: {service_name}.{app|tests} (e.g., auth_service.app, auth_service.tests)</pattern>
      <pattern>For E2E test helpers: tests.unified.{module} (root-level, not service-specific)</pattern>
      <forbidden-pattern>Relative imports using . or .. are strictly forbidden</forbidden-pattern>
      <forbidden-pattern>Importing E2E test helpers from netra_backend.tests.unified is incorrect</forbidden-pattern>
    </guideline>
    <guideline id="BE-002" context="Dependency Injection (FastAPI)" priority="CRITICAL">
      <title>Explicit Typing for DB Sessions</title>
      <instruction>Explicitly type hint database session dependencies to prevent runtime auth failures.</instruction>
      <code-example language="python">
        <before description="VIOLATION: Missing type hint causes errors">

db_session = Depends(get_db_session)

                </before>
        <after description="CORRECT: Explicit type hint">

db_session: AsyncSession = Depends(get_db_session)

                </after>
      </code-example>
    </guideline>
    <guideline id="BE-003" context="Dependency Injection (Singletons)" priority="CRITICAL">
      <title>Singleton Injection via Provider Functions</title>
      <instruction>Inject singleton services using provider functions, not the class directly, to ensure configuration (e.g., secrets) is applied.</instruction>
      <code-example language="python">
        <before description="VIOLATION: Bypasses configuration">

Depends(LLMManager)

                </before>
        <after description="CORRECT: Uses provider function">

Depends(get_llm_manager)

                </after>
      </code-example>
    </guideline>
  </section>
  <section title="Agent Architecture Naming Conventions" priority="CRITICAL">
    <instruction>Apply the correct suffix based on the component's role.</instruction>
    <classification suffix="SubAgent" or="Agent">
      <role>LLM-powered components extending `BaseSubAgent`.</role>
      <requirement>Must utilize LLM capabilities.</requirement>
    </classification>
    <classification suffix="Executor" or="Manager">
      <role>Infrastructure orchestration and system coordination (Non-LLM).</role>
    </classification>
    <classification suffix="Service">
      <role>Domain-specific business logic processing units.</role>
    </classification>
    <forbidden>Do NOT use the "Agent" suffix for utility or infrastructure modules.</forbidden>
  </section>
  <section title="Testing Protocol">
    <guideline id="TEST-003" context="TDD Workflow (Feature Flags)" priority="HIGH">
      <title>Feature Flag Driven TDD</title>
      <instruction>Utilize the feature flag system for TDD to maintain a 100% CI/CD pass rate during development.</instruction>
      <workflow>
        <step>1. Define feature in `test_feature_flags.json` with status "in_development".</step>
        <step>2. Write test using `@tdd_test("feature_name")` decorator. (Test will be skipped in CI).</step>
        <step>3. Implement functionality.</step>
        <step>4. Update status to "enabled" when implementation is complete and tests pass.</step>
      </workflow>
    </guideline>
  </section>
  <section title="Compliance and Enforcement">
    <tool id="COMP-001">
      <name>Architecture Compliance Check</name>
      <command>python scripts/check_architecture_compliance.py</command>
      <ai-directive>AI Agent MUST execute this tool before finalizing any code contribution. If violations are detected, initiate the appropriate refactoring protocol (ARC-001 or ARC-002).</ai-directive>
    </tool>
  </section>
</specification>