<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Coding Conventions</name>
        <type>conventions</type>
        <version>2.0</version>
        <description>
            MANDATORY coding standards for the Netra AI platform.
            These conventions ensure consistency, maintainability, and prevent regressions.
        </description>
    </metadata>
    
    <critical-rules>
        <rule id="file-size-limit" priority="CRITICAL">
            <title>300 Line File Limit</title>
            <description>Every file MUST be 300 lines or less</description>
            <enforcement>Split large files into focused modules</enforcement>
        </rule>
        
        <rule id="function-line-limit" priority="CRITICAL">
            <title>8 Line Function Limit</title>
            <description>Every function MUST be 8 lines or less (MANDATORY)</description>
            <enforcement>Split complex functions into smaller, focused functions</enforcement>
            <rationale>Forces single responsibility and improves readability</rationale>
        </rule>
        
        <rule id="no-duplication" priority="CRITICAL">
            <title>Prevent Function Duplication</title>
            <description>NEVER create "enhanced", "v2", or duplicate versions</description>
            <actions>
                <action>Search for existing implementations before creating new</action>
                <action>Extend existing functions with options/parameters</action>
                <action>Use composition over duplication</action>
            </actions>
        </rule>
        
        <rule id="no-test-stubs" priority="CRITICAL">
            <title>No Test Implementations in Production</title>
            <description>NEVER add test code in production services</description>
            <reference>SPEC/no_test_stubs.xml</reference>
        </rule>
    </critical-rules>

    <type-safety>
        <convention id="backend-types">
            <location>app/schemas/</location>
            <pattern>Pydantic models for all API contracts</pattern>
            <enforcement>Type hints on ALL functions</enforcement>
        </convention>
        
        <convention id="frontend-types">
            <location>frontend/types/</location>
            <pattern>TypeScript types matching backend schemas</pattern>
            <enforcement>Strict mode enabled, no any types</enforcement>
        </convention>
        
        <convention id="single-source-truth">
            <description>Each concept defined ONCE, referenced everywhere</description>
            <examples>
                <example>One WebSocket provider, not multiple</example>
                <example>One auth context, not duplicates</example>
                <example>One chat store, not enhanced versions</example>
            </examples>
        </convention>
    </type-safety>

    <async-patterns>
        <convention id="async-first">
            <description>Use async/await for ALL I/O operations</description>
            <backend>
                <pattern>async def for all database/API operations</pattern>
                <pattern>AsyncSession for database access</pattern>
                <pattern>await for all external calls</pattern>
            </backend>
            <frontend>
                <pattern>async functions for API calls</pattern>
                <pattern>Proper error handling with try/catch</pattern>
            </frontend>
        </convention>
    </async-patterns>

    <error-handling>
        <convention id="backend-exceptions">
            <pattern>Use NetraException with proper context</pattern>
            <example>
                raise NetraException(
                    message="Operation failed",
                    error_code="OP_001",
                    context={"user_id": user_id}
                )
            </example>
        </convention>
        
        <convention id="frontend-errors">
            <pattern>Centralized error handling with toast notifications</pattern>
            <pattern>Log errors to console with context</pattern>
        </convention>
    </error-handling>

    <imports>
        <convention id="backend-imports">
            <rules>
                <rule>Import at module level, not inside functions</rule>
                <rule>Group imports: stdlib, third-party, local</rule>
                <rule>Use absolute imports from app root</rule>
            </rules>
        </convention>
        
        <convention id="frontend-imports">
            <rules>
                <rule>Use @/ alias for all internal imports</rule>
                <rule>Named exports only: export const</rule>
                <rule>Import with braces: {Component}</rule>
                <rule>NO default exports</rule>
            </rules>
        </convention>
    </imports>

    <database-patterns>
        <convention id="repository-pattern">
            <description>ALL database access through repositories</description>
            <location>app/services/database/</location>
            <pattern>One repository per entity/domain</pattern>
        </convention>
        
        <convention id="database-sessions">
            <description>Explicit type hints for sessions</description>
            <pattern>db_session: AsyncSession = Depends(get_db_session)</pattern>
            <critical>Missing type hints cause auth failures</critical>
        </convention>
    </database-patterns>

    <testing>
        <convention id="test-coverage">
            <minimum>Backend: 70%, Frontend: 60%</minimum>
            <target>97% overall coverage</target>
            <enforcement>Tests required for all new code</enforcement>
        </convention>
        
        <convention id="test-organization">
            <pattern>Mirror source structure in tests</pattern>
            <pattern>One test file per source file</pattern>
            <pattern>Use descriptive test names</pattern>
        </convention>
    </testing>

    <ui-design>
        <convention id="glassmorphic">
            <description>Glassmorphic design throughout</description>
            <rules>
                <rule>NO blue gradient bars</rule>
                <rule>Use glass-panel classes</rule>
                <rule>Consistent blur and transparency</rule>
            </rules>
        </convention>
        
        <convention id="unique-ids">
            <description>Prevent React key warnings</description>
            <pattern>Use generateUniqueId() from @/lib/utils</pattern>
            <critical>NEVER use Date.now() alone</critical>
        </convention>
    </ui-design>

    <authentication>
        <convention id="auth-checks">
            <description>Check auth before API calls</description>
            <pattern>
                if (!isAuthenticated) {
                    console.error('User must be authenticated');
                    return;
                }
            </pattern>
        </convention>
        
        <convention id="auth-ui">
            <description>Provide feedback for unauthenticated state</description>
            <examples>
                <example>Disable inputs when not authenticated</example>
                <example>Show "Please sign in" messages</example>
            </examples>
        </convention>
    </authentication>

    <websockets>
        <convention id="websocket-provider">
            <description>Single WebSocketProvider for entire app</description>
            <location>frontend/providers/WebSocketProvider.tsx</location>
            <critical>NO duplicate WebSocket implementations</critical>
        </convention>
        
        <convention id="message-types">
            <description>Typed WebSocket messages</description>
            <backend>app/schemas/websocket_types.py</backend>
            <frontend>frontend/types/websocket.ts</frontend>
        </convention>
    </websockets>

    <naming>
        <convention id="python-naming">
            <classes>PascalCase: UserService, NetraException</classes>
            <functions>snake_case: get_user_by_id</functions>
            <constants>UPPER_SNAKE: MAX_RETRIES</constants>
            <files>snake_case: user_service.py</files>
        </convention>
        
        <convention id="typescript-naming">
            <components>PascalCase: ChatMessage.tsx</components>
            <functions>camelCase: getUserById</functions>
            <constants>UPPER_SNAKE: MAX_RETRIES</constants>
            <types>PascalCase with I/T prefix: IUser, TResponse</types>
        </convention>
    </naming>

    <logging>
        <convention id="backend-logging">
            <pattern>Use CentralLogger for all logging</pattern>
            <levels>
                <level>DEBUG: Detailed diagnostic info</level>
                <level>INFO: General informational messages</level>
                <level>WARNING: Warning messages</level>
                <level>ERROR: Error messages with context</level>
            </levels>
        </convention>
        
        <convention id="frontend-logging">
            <pattern>Use lib/logger for structured logging</pattern>
            <production>Minimal console output in production</production>
        </convention>
    </logging>

    <dependency-injection>
        <convention id="singleton-services">
            <description>Use provider functions for singletons</description>
            <correct>Depends(get_llm_manager)</correct>
            <incorrect>Depends(LLMManager)</incorrect>
            <critical>Direct injection loses configuration</critical>
        </convention>
    </dependency-injection>

    <file-organization>
        <convention id="keep-root-clean">
            <description>NEVER create files in project root</description>
            <rule>Place files in appropriate subdirectories</rule>
        </convention>
        
        <convention id="logical-grouping">
            <description>Group related functionality</description>
            <examples>
                <example>app/agents/ for all agent code</example>
                <example>app/services/ for business logic</example>
                <example>frontend/components/ for UI components</example>
            </examples>
        </convention>
    </file-organization>

    <boundary-enforcement>
        <enforcement id="automated-compliance">
            <description>Automated enforcement of 300/8 limits</description>
            <tool>scripts/check_architecture_compliance.py</tool>
            <frequency>Every commit, every PR</frequency>
            <threshold>0 violations allowed</threshold>
            <integration>
                <pre-commit>Run compliance check before commit</pre-commit>
                <ci-cd>Block merges on violations</ci-cd>
                <monitoring>Weekly compliance reports</monitoring>
            </integration>
        </enforcement>

        <enforcement id="growth-pattern-reviews">
            <description>Review growth patterns to maintain boundaries</description>
            <triggers>
                <trigger>File approaches 250 lines</trigger>
                <trigger>Function approaches 6 lines</trigger>
                <trigger>New module creation</trigger>
                <trigger>Major refactoring</trigger>
            </triggers>
            <checklist>
                <item>Does growth follow good patterns from SPEC/growth_control.xml?</item>
                <item>Are boundaries maintained?</item>
                <item>Is subdivision needed?</item>
                <item>Are responsibilities clear?</item>
            </checklist>
        </enforcement>

        <enforcement id="boundary-violation-response">
            <description>Immediate response to boundary violations</description>
            <response-levels>
                <level-1>
                    <condition>Single violation, first occurrence</condition>
                    <action>Developer self-remediation within same day</action>
                </level-1>
                <level-2>
                    <condition>Multiple violations or repeated patterns</condition>
                    <action>Team review and pair programming within 2 days</action>
                </level-2>
                <level-3>
                    <condition>Systemic violations or architectural resistance</condition>
                    <action>Architecture review and training within 1 week</action>
                </level-3>
            </response-levels>
        </enforcement>

        <enforcement id="proactive-monitoring">
            <description>Monitor system health to prevent boundary decay</description>
            <metrics>
                <metric>File size distribution (target: 95% under 200 lines)</metric>
                <metric>Function complexity distribution (target: 95% under 6 lines)</metric>
                <metric>Module cohesion metrics</metric>
                <metric>Dependency depth tracking</metric>
                <metric>Type duplication detection</metric>
            </metrics>
            <alerts>
                <alert>File reaches 250 lines - subdivision planning required</alert>
                <alert>Function reaches 6 lines - extraction planning required</alert>
                <alert>Duplicate type detected - consolidation required</alert>
            </alerts>
        </enforcement>
    </boundary-enforcement>

    <architectural-health>
        <health-indicator id="compliance-score">
            <description>Overall system compliance with 300/8 limits</description>
            <calculation>Percentage of files/functions within limits</calculation>
            <target>100% compliance</target>
            <monitoring>Daily automated checks</monitoring>
        </health-indicator>

        <health-indicator id="modular-cohesion">
            <description>Measure of how well modules maintain single responsibilities</description>
            <metrics>
                <metric>Functions per module (target: focused, not excessive)</metric>
                <metric>Cross-module dependencies (target: minimal)</metric>
                <metric>Public interface size (target: minimal surface area)</metric>
            </metrics>
        </health-indicator>

        <health-indicator id="growth-sustainability">
            <description>Whether system growth maintains architectural quality</description>
            <patterns>
                <good-pattern>New modules created instead of expanding existing</good-pattern>
                <good-pattern>Consistent subdivision when approaching limits</good-pattern>
                <good-pattern>Type consolidation over duplication</good-pattern>
            </patterns>
            <reference>SPEC/growth_control.xml</reference>
        </health-indicator>
    </architectural-health>
</specification>