<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Coding Conventions</name>
        <type>conventions</type>
        <version>2.2</version>
        <last_updated>2025-08-18</last_updated>
        <description>
            MANDATORY coding standards for the Netra AI platform.
            These conventions ensure consistency, maintainability, and prevent regressions.
            Includes agent naming conventions to distinguish between LLM-based agents, infrastructure components, and utility modules.
            Updated to reflect current architectural compliance status: 37.7% (6,433 violations).
        </description>
    </metadata>
    
    <critical-rules>
        <rule id="file-size-limit" priority="CRITICAL">
            <title>300 Line File Limit</title>
            <description>Every file MUST be 300 lines or less</description>
            <enforcement>Split large files into focused modules</enforcement>
        </rule>
        
        <rule id="function-line-limit" priority="CRITICAL">
            <title>8 Line Function Limit</title>
            <description>Every function MUST be 8 lines or less (MANDATORY)</description>
            <enforcement>Split complex functions into smaller, focused functions</enforcement>
            <rationale>Forces single responsibility and improves readability</rationale>
        </rule>
        
        <rule id="no-duplication" priority="CRITICAL">
            <title>Prevent Function Duplication</title>
            <description>NEVER create "enhanced", "v2", or duplicate versions</description>
            <actions>
                <action>Search for existing implementations before creating new</action>
                <action>Extend existing functions with options/parameters</action>
                <action>Use composition over duplication</action>
            </actions>
        </rule>
        
        <rule id="no-test-stubs" priority="CRITICAL">
            <title>No Test Implementations in Production</title>
            <description>NEVER add test code in production services</description>
            <reference>SPEC/no_test_stubs.xml</reference>
        </rule>
    </critical-rules>

    <frontend-state-management>
        <convention id="zustand-selectors" priority="CRITICAL">
            <title>Zustand Store Selector Pattern</title>
            <description>ALWAYS use individual selectors to prevent infinite loops</description>
            <problem>Object-returning selectors create new references on every render causing infinite loops</problem>
            <solution>Select each state property individually with separate useStore calls</solution>
            <example>
                // WRONG - Will cause infinite loop
                const selector = (state) => ({ a: state.a, b: state.b });
                const data = useStore(selector, shallow);
                
                // CORRECT - Stable references
                const a = useStore(state => state.a);
                const b = useStore(state => state.b);
            </example>
            <reference>SPEC/learnings/frontend.xml#zustand-individual-selectors-pattern</reference>
        </convention>
    </frontend-state-management>

    <type-safety>
        <convention id="backend-types">
            <location>app/schemas/</location>
            <pattern>Pydantic models for all API contracts</pattern>
            <enforcement>Type hints on ALL functions</enforcement>
        </convention>
        
        <convention id="frontend-types">
            <location>frontend/types/</location>
            <pattern>TypeScript types matching backend schemas</pattern>
            <enforcement>Strict mode enabled, no any types</enforcement>
        </convention>
        
        <convention id="single-source-truth">
            <description>Each concept defined ONCE, referenced everywhere</description>
            <examples>
                <example>One WebSocket provider, not multiple</example>
                <example>One auth context, not duplicates</example>
                <example>One chat store, not enhanced versions</example>
            </examples>
        </convention>
    </type-safety>

    <async-patterns>
        <convention id="async-first">
            <description>Use async/await for ALL I/O operations</description>
            <backend>
                <pattern>async def for all database/API operations</pattern>
                <pattern>AsyncSession for database access</pattern>
                <pattern>await for all external calls</pattern>
            </backend>
            <frontend>
                <pattern>async functions for API calls</pattern>
                <pattern>Proper error handling with try/catch</pattern>
            </frontend>
        </convention>
    </async-patterns>

    <error-handling>
        <convention id="backend-exceptions">
            <pattern>Use NetraException with proper context</pattern>
            <example>
                raise NetraException(
                    message="Operation failed",
                    error_code="OP_001",
                    context={"user_id": user_id}
                )
            </example>
        </convention>
        
        <convention id="frontend-errors">
            <pattern>Centralized error handling with toast notifications</pattern>
            <pattern>Log errors to console with context</pattern>
        </convention>
    </error-handling>

    <imports>
        <convention id="backend-imports">
            <rules>
                <rule>Import at module level, not inside functions</rule>
                <rule>Group imports: stdlib, third-party, local</rule>
                <rule>Use absolute imports from app root</rule>
            </rules>
        </convention>
        
        <convention id="frontend-imports">
            <rules>
                <rule>Use @/ alias for all internal imports</rule>
                <rule>Named exports only: export const</rule>
                <rule>Import with braces: {Component}</rule>
                <rule>NO default exports</rule>
            </rules>
        </convention>
    </imports>

    <database-patterns>
        <convention id="repository-pattern">
            <description>ALL database access through repositories</description>
            <location>app/services/database/</location>
            <pattern>One repository per entity/domain</pattern>
        </convention>
        
        <convention id="database-sessions">
            <description>Explicit type hints for sessions</description>
            <pattern>db_session: AsyncSession = Depends(get_db_session)</pattern>
            <critical>Missing type hints cause auth failures</critical>
        </convention>
    </database-patterns>

    <testing>
        <convention id="test-coverage">
            <minimum>Backend: 70%, Frontend: 60%</minimum>
            <target>97% overall coverage</target>
            <enforcement>Tests required for all new code</enforcement>
        </convention>
        
        <convention id="test-organization">
            <pattern>Mirror source structure in tests</pattern>
            <pattern>One test file per source file</pattern>
            <pattern>Use descriptive test names</pattern>
        </convention>
    </testing>

    <ui-design>
        <convention id="glassmorphic">
            <description>Glassmorphic design throughout</description>
            <rules>
                <rule>NO blue gradient bars</rule>
                <rule>Use glass-panel classes</rule>
                <rule>Consistent blur and transparency</rule>
            </rules>
        </convention>
        
        <convention id="unique-ids">
            <description>Prevent React key warnings</description>
            <pattern>Use generateUniqueId() from @/lib/utils</pattern>
            <critical>NEVER use Date.now() alone</critical>
        </convention>
    </ui-design>

    <authentication>
        <convention id="auth-checks">
            <description>Check auth before API calls</description>
            <pattern>
                if (!isAuthenticated) {
                    console.error('User must be authenticated');
                    return;
                }
            </pattern>
        </convention>
        
        <convention id="auth-ui">
            <description>Provide feedback for unauthenticated state</description>
            <examples>
                <example>Disable inputs when not authenticated</example>
                <example>Show "Please sign in" messages</example>
            </examples>
        </convention>
    </authentication>

    <websockets>
        <convention id="websocket-provider">
            <description>Single WebSocketProvider for entire app</description>
            <location>frontend/providers/WebSocketProvider.tsx</location>
            <critical>NO duplicate WebSocket implementations</critical>
        </convention>
        
        <convention id="message-types">
            <description>Typed WebSocket messages</description>
            <backend>app/schemas/websocket_types.py</backend>
            <frontend>frontend/types/websocket.ts</frontend>
        </convention>
    </websockets>

    <naming>
        <convention id="python-naming">
            <classes>PascalCase: UserService, NetraException</classes>
            <functions>snake_case: get_user_by_id</functions>
            <constants>UPPER_SNAKE: MAX_RETRIES</constants>
            <files>snake_case: user_service.py</files>
        </convention>
        
        <convention id="typescript-naming">
            <components>PascalCase: ChatMessage.tsx</components>
            <functions>camelCase: getUserById</functions>
            <constants>UPPER_SNAKE: MAX_RETRIES</constants>
            <types>PascalCase with I/T prefix: IUser, TResponse</types>
        </convention>
    </naming>

    <agent-naming-conventions>
        <convention id="agent-classification" priority="CRITICAL">
            <title>Agent Component Classification</title>
            <description>Clear naming patterns to distinguish between different component types in the Netra platform</description>
            
            <agent-suffix>
                <description>Reserved ONLY for LLM-based SubAgents that extend BaseSubAgent</description>
                <pattern>*SubAgent or *Agent</pattern>
                <examples>
                    <example>TriageSubAgent: LLM-powered triage operations</example>
                    <example>DataSubAgent: LLM-powered data analysis</example>
                    <example>ReportingSubAgent: LLM-powered report generation</example>
                </examples>
                <requirement>Must extend BaseSubAgent and use LLM capabilities</requirement>
            </agent-suffix>
            
            <executor-suffix>
                <description>Infrastructure pattern implementations for orchestration and management</description>
                <pattern>*Executor or *Manager</pattern>
                <examples>
                    <example>BroadcastExecutor: Message broadcasting infrastructure</example>
                    <example>MCPManager: MCP protocol management</example>
                    <example>ExecutionManager: Task execution coordination</example>
                </examples>
                <responsibility>Handles infrastructure patterns, orchestration, and system coordination</responsibility>
            </executor-suffix>
            
            <service-suffix>
                <description>Specialized processing units for domain-specific operations</description>
                <pattern>*Service</pattern>
                <examples>
                    <example>GitHubAnalyzerService: Specialized GitHub analysis</example>
                    <example>DemoService: Demo functionality processing</example>
                    <example>ValidationService: Data validation operations</example>
                </examples>
                <responsibility>Focused processing units for specific business domains</responsibility>
            </service-suffix>
            
            <utility-naming>
                <description>Descriptive names for utility and support modules</description>
                <patterns>
                    <pattern>*Dispatcher: Request routing and dispatching</pattern>
                    <pattern>*Handler: Event and error handling</pattern>
                    <pattern>*Validator: Data validation operations</pattern>
                    <pattern>*Processor: Data processing operations</pattern>
                </patterns>
                <examples>
                    <example>ToolDispatcher: Routes tool requests to appropriate handlers</example>
                    <example>StateManager: Manages application state</example>
                    <example>ErrorHandler: Centralized error processing</example>
                    <example>MessageValidator: Validates incoming messages</example>
                </examples>
                <avoid>Using "Agent" suffix for utility modules</avoid>
            </utility-naming>
        </convention>
        
        <convention id="naming-enforcement" priority="HIGH">
            <title>Naming Convention Enforcement</title>
            <description>Guidelines for consistent application of naming patterns</description>
            <rules>
                <rule>Use descriptive, intention-revealing names</rule>
                <rule>Match suffix to actual component responsibility</rule>
                <rule>Avoid generic names like "Handler" or "Manager" without context</rule>
                <rule>Maintain consistency within related component groups</rule>
            </rules>
            <verification>
                <check>Component functionality matches naming suffix</check>
                <check>LLM usage justifies "Agent" suffix</check>
                <check>Infrastructure components use appropriate "Executor/Manager" suffixes</check>
                <check>Business logic components use "Service" suffix</check>
            </verification>
        </convention>
    </agent-naming-conventions>

    <logging>
        <convention id="backend-logging">
            <pattern>Use CentralLogger for all logging</pattern>
            <levels>
                <level>DEBUG: Detailed diagnostic info</level>
                <level>INFO: General informational messages</level>
                <level>WARNING: Warning messages</level>
                <level>ERROR: Error messages with context</level>
            </levels>
        </convention>
        
        <convention id="frontend-logging">
            <pattern>Use lib/logger for structured logging</pattern>
            <production>Minimal console output in production</production>
        </convention>
    </logging>

    <dependency-injection>
        <convention id="singleton-services">
            <description>Use provider functions for singletons</description>
            <correct>Depends(get_llm_manager)</correct>
            <incorrect>Depends(LLMManager)</incorrect>
            <critical>Direct injection loses configuration</critical>
        </convention>
    </dependency-injection>

    <file-organization>
        <convention id="keep-root-clean">
            <description>NEVER create files in project root</description>
            <rule>Place files in appropriate subdirectories</rule>
        </convention>
        
        <convention id="logical-grouping">
            <description>Group related functionality</description>
            <examples>
                <example>app/agents/ for all agent code</example>
                <example>app/services/ for business logic</example>
                <example>frontend/components/ for UI components</example>
            </examples>
        </convention>
    </file-organization>

    <boundary-enforcement>
        <enforcement id="automated-compliance">
            <description>Automated enforcement of 300/8 limits with enhanced reporting</description>
            <tool>scripts/check_architecture_compliance.py</tool>
            <frequency>Every commit, every PR</frequency>
            <threshold>0 violations allowed</threshold>
            <features>
                <feature>Smart violation limits (adaptive display)</feature>
                <feature>Severity-based prioritization</feature>
                <feature>Accurate violation statistics</feature>
                <feature>Visual severity markers</feature>
            </features>
            <cli-options>
                <option>--violation-limit N: Set display limit</option>
                <option>--show-all: Show all violations</option>
                <option>--no-smart-limits: Disable adaptive limits</option>
                <option>--no-emoji: Use text markers for compatibility</option>
            </cli-options>
            <integration>
                <pre-commit>Run compliance check before commit</pre-commit>
                <ci-cd>Block merges on violations</ci-cd>
                <monitoring>Weekly compliance reports with statistics</monitoring>
            </integration>
        </enforcement>

        <enforcement id="growth-pattern-reviews">
            <description>Review growth patterns to maintain boundaries</description>
            <triggers>
                <trigger>File approaches 250 lines</trigger>
                <trigger>Function approaches 6 lines</trigger>
                <trigger>New module creation</trigger>
                <trigger>Major refactoring</trigger>
            </triggers>
            <checklist>
                <item>Does growth follow good patterns from SPEC/growth_control.xml?</item>
                <item>Are boundaries maintained?</item>
                <item>Is subdivision needed?</item>
                <item>Are responsibilities clear?</item>
            </checklist>
        </enforcement>

        <enforcement id="boundary-violation-response">
            <description>Immediate response to boundary violations</description>
            <response-levels>
                <level-1>
                    <condition>Single violation, first occurrence</condition>
                    <action>Developer self-remediation within same day</action>
                </level-1>
                <level-2>
                    <condition>Multiple violations or repeated patterns</condition>
                    <action>Team review and pair programming within 2 days</action>
                </level-2>
                <level-3>
                    <condition>Systemic violations or architectural resistance</condition>
                    <action>Architecture review and training within 1 week</action>
                </level-3>
            </response-levels>
        </enforcement>

        <enforcement id="proactive-monitoring">
            <description>Monitor system health to prevent boundary decay</description>
            <metrics>
                <metric>File size distribution (target: 95% under 200 lines)</metric>
                <metric>Function complexity distribution (target: 95% under 6 lines)</metric>
                <metric>Module cohesion metrics</metric>
                <metric>Dependency depth tracking</metric>
                <metric>Type duplication detection</metric>
            </metrics>
            <alerts>
                <alert>File reaches 250 lines - subdivision planning required</alert>
                <alert>Function reaches 6 lines - extraction planning required</alert>
                <alert>Duplicate type detected - consolidation required</alert>
            </alerts>
        </enforcement>
    </boundary-enforcement>

    <architectural-health>
        <health-indicator id="compliance-score">
            <description>Overall system compliance with 300/8 limits</description>
            <calculation>Percentage of files/functions within limits</calculation>
            <target>100% compliance</target>
            <monitoring>Daily automated checks</monitoring>
        </health-indicator>

        <health-indicator id="modular-cohesion">
            <description>Measure of how well modules maintain single responsibilities</description>
            <metrics>
                <metric>Functions per module (target: focused, not excessive)</metric>
                <metric>Cross-module dependencies (target: minimal)</metric>
                <metric>Public interface size (target: minimal surface area)</metric>
            </metrics>
        </health-indicator>

        <health-indicator id="growth-sustainability">
            <description>Whether system growth maintains architectural quality</description>
            <patterns>
                <good-pattern>New modules created instead of expanding existing</good-pattern>
                <good-pattern>Consistent subdivision when approaching limits</good-pattern>
                <good-pattern>Type consolidation over duplication</good-pattern>
            </patterns>
            <reference>SPEC/growth_control.xml</reference>
        </health-indicator>
    </architectural-health>
    
    <testing-conventions>
        <convention id="bad-test-detection" priority="HIGH">
            <title>Automatic Bad Test Detection</title>
            <description>All test runs automatically track and report consistently failing tests</description>
            <enabled-by-default>true</enabled-by-default>
            <disable-flag>--no-bad-test-detection</disable-flag>
            
            <tracking>
                <description>Track test failures with {test}:{failure_count} pattern</description>
                <storage>test_reports/bad_tests.json</storage>
                <persistence>Maintains history across test runs</persistence>
            </tracking>
            
            <detection-thresholds>
                <threshold type="consecutive_failures" value="5">
                    <action>Mark for immediate fix</action>
                    <priority>HIGH</priority>
                </threshold>
                <threshold type="failure_rate" value="70%" runs="10+">
                    <action>Consider refactoring</action>
                    <priority>MEDIUM</priority>
                </threshold>
                <threshold type="failure_rate" value="90%">
                    <action>Recommend deletion/rewrite</action>
                    <priority>CRITICAL</priority>
                </threshold>
            </detection-thresholds>
            
            <reporting>
                <command>python -m test_framework.bad_test_reporter</command>
                <options>
                    <option>--summary: View statistics only</option>
                    <option>--details: Include test histories</option>
                    <option>--test NAME: View specific test history</option>
                    <option>--reset: Clear bad test data</option>
                    <option>--export FILE: Export report to file</option>
                </options>
            </reporting>
            
            <best-practices>
                <practice>Review bad test report weekly</practice>
                <practice>Fix consistently failing tests immediately</practice>
                <practice>Delete tests with 90%+ failure rate after review</practice>
                <practice>Refactor tests with high failure rates (70-90%)</practice>
                <practice>Use test history to identify flaky test patterns</practice>
            </best-practices>
        </convention>
        
        <convention id="test-maintenance" priority="HIGH">
            <title>Test Health Maintenance</title>
            <description>Regular maintenance of test suite health</description>
            <actions>
                <action>Fix tests that test non-existent SUT (System Under Test)</action>
                <action>Update tests when code changes</action>
                <action>Remove obsolete tests promptly</action>
                <action>Maintain test coverage above 97% for revenue paths</action>
            </actions>
        </convention>
    </testing-conventions>
</specification>