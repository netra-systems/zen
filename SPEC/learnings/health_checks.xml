<?xml version='1.0' encoding='utf-8'?>
<specification>
  <metadata>
    <name>HealthChecks.Learnings</name>
    <type>ArchitecturalLearnings</type>
    <version>1.0</version>
    <description>Critical learnings about health check implementation across services</description>
    <created>2025-08-19</created>
    <last_edited>2025-08-21T08:47:29.429850</last_edited>
  </metadata>
  <learning id="database-initialization-in-health-checks">
    <title>Database Must Be Lazily Initialized in Health Checks</title>
    <problem>
            Health check endpoints were failing with "Database engine not initialized" errors because
            async_engine was None when check_postgres_health() tried to use it directly.
        </problem>
    <root-cause>
            The health check assumed the database engine would always be initialized, but during
            startup or after certain failures, async_engine could be None.
        </root-cause>
    <solution>
            Modified _execute_postgres_query() in netra_backend/app/core/health_checkers.py to:
            1. Check if async_engine is None
            2. Call initialize_postgres() if needed
            3. Re-import async_engine after initialization
            4. Gracefully handle initialization failures
        </solution>
    <implementation>
      <file>netra_backend/app/core/health_checkers.py</file>
      <pattern>
                if async_engine is None:
                    initialize_postgres()
                    from app.db.postgres import async_engine as refreshed_engine
            </pattern>
    </implementation>
  </learning>
  <learning id="auth-service-ready-endpoint">
    <title>Auth Service Requires /health/ready Endpoint</title>
    <problem>
            Startup scripts expected /health/ready endpoint on auth service but only /health existed,
            causing startup verification to fail with 404 errors.
        </problem>
    <solution>
            Added /health/ready endpoint to auth service main.py that:
            1. Checks database connectivity via auth_db.is_ready()
            2. Returns appropriate status codes (200 for ready, 503 for not ready)
            3. Handles development mode gracefully
        </solution>
    <implementation>
      <file>auth_service/main.py</file>
      <file>auth_service/auth_core/database/connection.py</file>
    </implementation>
  </learning>
  <learning id="auth-service-port-configuration">
    <title>Auth Service Port Configuration</title>
    <problem>
            Startup scripts were checking port 8001 for auth service but it runs on port 8080 by default.
        </problem>
    <clarification>
            - Main backend: port 8000
            - Auth service: port 8080 (configured via PORT env var)
            - Frontend: port 3000
        </clarification>
    <note>
            Startup scripts should check the correct ports or use environment variables to determine
            the actual port configuration.
        </note>
  </learning>
  <learning id="health-check-database-methods">
    <title>Database Classes Need is_ready() Methods</title>
    <problem>
            Health check endpoints couldn't verify database readiness because database connection
            classes lacked standardized readiness check methods.
        </problem>
    <solution>
            Added is_ready() method to AuthDatabase class that:
            1. Initializes connection if not already done
            2. Executes a simple SELECT 1 query
            3. Returns boolean indicating readiness
            4. Handles exceptions gracefully
        </solution>
    <pattern>
            All database connection classes should implement:
            - async def is_ready() -&gt; bool
            - Lazy initialization support
            - Graceful error handling
        </pattern>
  </learning>
  <learning id="clickhouse-development-mode-handling">
    <title>ClickHouse Health Checks Must Handle Development Mode</title>
    <problem>
            Health readiness checks were failing with 503 errors during startup because ClickHouse
            connection was not yet established, and the error handler only ignored failures in
            staging but not development mode.
        </problem>
    <root-cause>
            The _handle_clickhouse_error function in netra_backend/app/routes/health.py was only checking for
            staging environment, causing it to re-raise exceptions in development mode when
            ClickHouse wasn't ready yet during startup.
        </root-cause>
    <solution>
            Modified _handle_clickhouse_error to treat both staging and development environments
            as non-critical for ClickHouse failures, allowing the service to start successfully
            even if ClickHouse isn't immediately available.
        </solution>
    <implementation>
      <file>netra_backend/app/routes/health.py</file>
      <pattern>
                if settings.environment in ["staging", "development"]:
                    logger.info(f"Ignoring ClickHouse failure in {settings.environment} environment")
            </pattern>
    </implementation>
  </learning>
  <learning id="auth-service-health-check-integration-test">
    <title>Auth Service Health Check Integration Test Implementation</title>
    <problem>
            Need comprehensive integration testing for Auth service health check endpoints to prevent
            startup failures that could impact $50K+ MRR across all customer segments.
        </problem>
    <solution>
            Created test_auth_service_health_check_integration.py with comprehensive coverage:
            1. Basic health check on port 8080 validation
            2. Ready endpoint testing with fallback to /health when /health/ready unavailable
            3. Database initialization scenarios (initialized vs uninitialized)
            4. Database failure handling and graceful degradation
            5. Service recovery testing after database restoration
            6. Performance requirement validation (&lt;1s response time)
        </solution>
    <implementation>
      <file>tests/unified/e2e/test_auth_service_health_check_integration.py</file>
      <pattern>
                # Fallback pattern for missing ready endpoint:
                if response.status_code == 404:
                    response = await client.get(self.health_endpoint)
                    endpoint_used = "/health"
                else:
                    endpoint_used = "/health/ready"
            </pattern>
    </implementation>
    <test-scenarios>
      <scenario>Basic health check responds on correct port (8080)</scenario>
      <scenario>Ready endpoint with uninitialized database</scenario>
      <scenario>Ready endpoint with initialized database</scenario>
      <scenario>Health check during database failure</scenario>
      <scenario>Service recovery from database failures</scenario>
      <scenario>Performance requirement under 1s</scenario>
    </test-scenarios>
    <business-impact>
            Tests protect $50K+ MRR by ensuring Auth service reliability across all customer
            segments (Free, Early, Mid, Enterprise), preventing authentication downtime.
        </business-impact>
  </learning>
  <learning id="python-import-caching-health-check-failure">
    <title>Python Import Caching Causes Health Check 503 Errors</title>
    <problem>
            Health check endpoints consistently returned 503 Service Unavailable errors despite
            database services running correctly. The issue persisted through multiple "fix" attempts
            and was incorrectly marked as solved repeatedly.
        </problem>
    <root-cause>
            Python caches module-level imports. When health_checkers.py imported async_engine from
            app.db.postgres at module load time (before database initialization), it cached the
            None value. Even after database initialization in postgres_core.py set async_engine
            to a valid engine, the cached import reference in health_checkers.py remained None,
            causing "Database engine not initialized" errors.
        </root-cause>
    <solution>
            Modified health check functions to use dynamic imports that get fresh references
            after database initialization:
            1. Import directly from app.db.postgres_core where engine is defined
            2. Check if engine is None and initialize if needed
            3. Re-import after initialization to get fresh reference
            4. Use the fresh reference for database operations
        </solution>
    <implementation>
      <file>netra_backend/app/core/health_checkers.py</file>
      <pattern>
                from app.db.postgres import initialize_postgres
                from app.db.postgres_core import async_engine
                
                if async_engine is None:
                    initialize_postgres()
                    from app.db.postgres_core import async_engine as engine_ref
                    engine = engine_ref
                else:
                    engine = async_engine
                
                if engine is None:
                    raise RuntimeError("Database engine not initialized")
                    
                async with engine.begin() as conn:
                    await conn.execute(text("SELECT 1"))
            </pattern>
    </implementation>
    <prevention>
            Never import dynamically initialized resources at module level in health checks.
            Always use dynamic imports or getter functions to retrieve current references.
        </prevention>
    <validation>
            Health checks now properly return:
            - /health: status "healthy"
            - /health/ready: status "ready" with all database checks passing
            - No more 503 Service Unavailable errors
        </validation>
    <business-impact>
            Critical fix for production deployments - without this, Kubernetes readiness
            probes fail, load balancers mark services as unhealthy, and deployments fail
            to roll out, affecting all customer segments and SLAs.
        </business-impact>
  </learning>
  <best-practices>
    <practice>
            Always implement both /health (liveness) and /health/ready (readiness) endpoints
            for proper Kubernetes/orchestration support.
        </practice>
    <practice>
            Health checks should never cause service failures - handle all exceptions gracefully
            and return appropriate status codes.
        </practice>
    <practice>
            Database connections should be initialized lazily in health checks to avoid
            circular dependencies during startup.
        </practice>
    <practice>
            Use consistent response formats across all services for health endpoints to
            simplify monitoring and alerting.
        </practice>
  </best-practices>
  <checklist>
    <item>Implement /health endpoint for basic liveness check</item>
    <item>Implement /health/ready endpoint for readiness check</item>
    <item>Add is_ready() method to database connection classes</item>
    <item>Handle uninitialized database engines gracefully</item>
    <item>Return appropriate HTTP status codes (200, 503)</item>
    <item>Include service name and version in responses</item>
    <item>Log health check failures for debugging</item>
    <item>Support development mode with degraded checks</item>
  </checklist>
</specification>