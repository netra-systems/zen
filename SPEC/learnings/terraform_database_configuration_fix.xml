<?xml version='1.0' encoding='utf-8'?>
<learnings>
  <metadata>
    <last_edited>2025-08-21T08:47:29.811798</last_edited>
    <legacy_status is_legacy="true" identified_date="2025-08-21T08:47:29.811798">
      <reasons>
        <reason>Content contains: old</reason>
      </reasons>
    </legacy_status>
  </metadata>
  <title>Terraform Database Configuration Root Cause Analysis and Prevention</title>
  <date>2025-08-19</date>
  <severity>CRITICAL</severity>
  <summary>
    Root cause analysis of database URL mismatch and comprehensive solution for future Terraform deployments.
    The issue stems from manual secret creation with hardcoded values instead of dynamic Terraform-managed configuration.
  </summary>
  <root_cause_analysis>
    <problem>Manual vs Terraform-Managed Configuration Disconnect</problem>
    <finding id="1">
      <title>Secret Created Manually Outside Terraform</title>
      <evidence>
        The database-url-staging secret was created on 2025-08-18 manually with a hardcoded IP (34.68.229.240)
        that doesn't match any current Cloud SQL instance.
      </evidence>
      <impact>
        Terraform doesn't know about or manage this secret, leading to configuration drift.
      </impact>
    </finding>
    <finding id="2">
      <title>Hardcoded Variable Instead of Dynamic Reference</title>
      <evidence>
        In terraform-gcp/auth_service.tf:
        secret_data = var.DATABASE_URL
        
        This expects #removed-legacyas an input variable rather than dynamically generating it.
      </evidence>
      <impact>
        Connection string must be manually updated when infrastructure changes.
      </impact>
    </finding>
    <finding id="3">
      <title>Multiple Database Instances Causing Confusion</title>
      <evidence>
        Two PostgreSQL instances exist in staging:
        - netra-postgres-2db4ccab (34.132.142.103)
        - staging-shared-postgres (34.171.226.17)
      </evidence>
      <impact>
        Unclear which instance should be used for which service.
      </impact>
    </finding>
    <finding id="4">
      <title>IP Address 34.68.229.240 Origin Unknown</title>
      <analysis>
        This IP doesn't match any current staging resources.
        Likely scenarios:
        - Old Cloud SQL instance that was deleted
        - Production instance IP accidentally used
        - Typo or miscommunication during manual setup
      </analysis>
    </finding>
  </root_cause_analysis>
  <terraform_solution>
    <principle>All infrastructure and secrets must be managed by Terraform with dynamic references</principle>
    <step id="1">
      <title>Create Data Source for Existing Cloud SQL Instance</title>
      <code>
# terraform-gcp/data_sources.tf
data "google_sql_database_instance" "staging_postgres" {
  name    = "netra-postgres-2db4ccab"
  project = var.project_id
}

data "google_sql_database" "staging_db" {
  name     = "netra"
  instance = data.google_sql_database_instance.staging_postgres.name
  project  = var.project_id
}
      </code>
    </step>
    <step id="2">
      <title>Generate Database URL Dynamically</title>
      <code>
# terraform-gcp/locals.tf
locals {
  # Dynamically construct database URL from actual resources
  database_url_staging = format(
    "postgresql://%s:%s@%s:5432/%s?sslmode=require",
    var.db_user,
    random_password.db_password.result,
    data.google_sql_database_instance.staging_postgres.public_ip_address,
    data.google_sql_database.staging_db.name
  )
}
      </code>
    </step>
    <step id="3">
      <title>Update Secret Resource to Use Dynamic Value</title>
      <code>
# terraform-gcp/auth_service.tf
resource "google_secret_manager_secret_version" "database_url_staging" {
  count       = var.environment == "staging" ? 1 : 0
  secret      = google_secret_manager_secret.database_url_staging[0].id
  secret_data = local.database_url_staging  # Use dynamic local instead of variable
}
      </code>
    </step>
    <step id="4">
      <title>Add Validation Resource</title>
      <code>
# terraform-gcp/validations.tf
resource "null_resource" "validate_database_connection" {
  depends_on = [google_secret_manager_secret_version.database_url_staging]
  
  provisioner "local-exec" {
    command = &lt;&lt;-EOT
      echo "Testing database connection..."
      psql "${local.database_url_staging}" -c "SELECT 1" || exit 1
      echo "Database connection successful!"
    EOT
  }
}
      </code>
    </step>
    <step id="5">
      <title>Create Output for Verification</title>
      <code>
# terraform-gcp/outputs.tf
output "database_connection_info" {
  value = {
    instance_name = data.google_sql_database_instance.staging_postgres.name
    instance_ip   = data.google_sql_database_instance.staging_postgres.public_ip_address
    database_name = data.google_sql_database.staging_db.name
    secret_name   = google_secret_manager_secret.database_url_staging[0].secret_id
  }
  description = "Database connection information for verification"
}
      </code>
    </step>
  </terraform_solution>
  <immediate_action_plan>
    <action priority="1">
      <description>Reset database password and update secret</description>
      <commands>
# Reset password for netra_user
gcloud sql users set-password netra_user \
  --instance=netra-postgres-2db4ccab \
  --project=netra-staging \
  --prompt-for-password

# Update secret with correct connection string
echo -n "postgresql://netra_user:[NEW_PASSWORD]@34.132.142.103:5432/netra?sslmode=require" | \
  gcloud secrets versions add database-url-staging --data-file=- --project=netra-staging

# Force service update
gcloud run services update netra-auth-service \
  --region=us-central1 \
  --project=netra-staging
      </commands>
    </action>
    <action priority="2">
      <description>Import existing resources into Terraform</description>
      <commands>
# Import the existing secret
terraform import google_secret_manager_secret.database_url_staging \
  projects/netra-staging/secrets/database-url-staging

# Import the Cloud SQL instance
terraform import google_sql_database_instance.staging \
  projects/netra-staging/instances/netra-postgres-2db4ccab
      </commands>
    </action>
  </immediate_action_plan>
  <prevention_checklist>
    <item checked="false">
      All secrets are managed by Terraform with dynamic values
    </item>
    <item checked="false">
      No hardcoded IPs or connection strings in configuration
    </item>
    <item checked="false">
      Database instances are clearly labeled by purpose
    </item>
    <item checked="false">
      Connection validation runs before deployment
    </item>
    <item checked="false">
      Terraform outputs show actual connection details
    </item>
    <item checked="false">
      Documentation clearly maps services to databases
    </item>
    <item checked="false">
      CI/CD pipeline validates database connectivity
    </item>
    <item checked="false">
      Monitoring alerts for connection failures
    </item>
  </prevention_checklist>
  <best_practices>
    <practice>
      <title>Single Source of Truth</title>
      <description>
        Terraform must be the single source of truth for all infrastructure.
        Never create or modify resources manually in staging/production.
      </description>
    </practice>
    <practice>
      <title>Dynamic References</title>
      <description>
        Always use data sources and resource references instead of hardcoded values.
        This ensures configuration updates automatically when infrastructure changes.
      </description>
    </practice>
    <practice>
      <title>Environment Separation</title>
      <description>
        Use separate Terraform workspaces or directories for each environment.
        Never share resources between environments.
      </description>
    </practice>
    <practice>
      <title>Automated Validation</title>
      <description>
        Include connection validation in Terraform apply process.
        Fail fast if connections cannot be established.
      </description>
    </practice>
    <practice>
      <title>Clear Naming Conventions</title>
      <description>
        Use descriptive names that include environment and purpose.
        Example: staging-auth-postgres-instance
      </description>
    </practice>
  </best_practices>
  <monitoring_setup>
    <metric name="database_connection_success_rate">
      <query>
        rate(database_connection_attempts[5m]) / rate(database_connection_total[5m])
      </query>
      <alert_threshold>less than 0.95</alert_threshold>
    </metric>
    <metric name="secret_access_failures">
      <query>
        sum(rate(secret_manager_access_denied[5m])) by (secret_name)
      </query>
      <alert_threshold>greater than 0</alert_threshold>
    </metric>
    <metric name="terraform_drift_detection">
      <description>
        Run terraform plan daily and alert if changes detected
      </description>
      <schedule>0 9 * * *</schedule>
    </metric>
  </monitoring_setup>
  <long_term_improvements>
    <improvement>
      <title>Migrate to Cloud SQL Auth Proxy</title>
      <benefits>
        - No need for public IPs
        - Automatic SSL/TLS
        - IAM-based authentication
        - Better security
      </benefits>
    </improvement>
    <improvement>
      <title>Implement GitOps for Infrastructure</title>
      <benefits>
        - All changes via pull requests
        - Automated validation
        - Audit trail
        - Rollback capability
      </benefits>
    </improvement>
    <improvement>
      <title>Database Connection Pool Management</title>
      <benefits>
        - Reuse connections
        - Better performance
        - Connection limit management
        - Automatic retry logic
      </benefits>
    </improvement>
  </long_term_improvements>
</learnings>