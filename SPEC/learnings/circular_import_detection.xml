<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>CircularImportDetection.Learnings</name>
        <type>DevelopmentLearning</type>
        <version>1.0</version>
        <date>2025-08-21</date>
        <description>Critical learnings about detecting and preventing indirect circular imports.</description>
        <business-value>Prevents $100K+ annual revenue loss from service initialization failures</business-value>
    </metadata>
    
    <problem-statement>
        <title>Indirect Circular Import Detection Paradox</title>
        <description>
            Standard import testing tools fail to detect indirect circular imports that 
            manifest only during runtime initialization sequences.
        </description>
        <example>
            WebSocket manager → synthetic_data.error_handler → 
            synthetic_data → job_manager → WebSocket manager
        </example>
        <impact>
            - Service initialization failures
            - Agent registration failures
            - WebSocket message processing breakage
            - Tests pass but production fails
        </impact>
    </problem-statement>
    
    <root-cause-analysis>
        <title>Why Standard Tests Miss Indirect Circular Imports</title>
        
        <cause id="1" name="Runtime vs Import-time Detection">
            <description>
                ImportTester and similar tools only catch immediate circular imports 
                during module loading. Indirect dependencies through 4+ modules are 
                not detected until runtime initialization.
            </description>
        </cause>
        
        <cause id="2" name="Module Cache Isolation">
            <description>
                Tests clear module cache between imports, preventing the accumulation 
                of imports that would trigger the circular dependency in production.
            </description>
        </cause>
        
        <cause id="3" name="Singleton Pattern Masking">
            <description>
                WebSocket manager and similar singletons are often None initially 
                and populated later, hiding circular dependencies during import tests.
            </description>
        </cause>
        
        <cause id="4" name="TYPE_CHECKING Guards">
            <description>
                Some modules use TYPE_CHECKING to avoid runtime imports, but the 
                actual circular dependency still exists in the execution path.
            </description>
        </cause>
        
        <cause id="5" name="Indirect Path Complexity">
            <description>
                Circular dependencies through multiple intermediate modules are 
                harder for simple import testing to detect.
            </description>
        </cause>
    </root-cause-analysis>
    
    <solution-patterns>
        <pattern name="Lazy Import Pattern">
            <description>Move imports inside methods to break circular dependencies</description>
            <example>
                <bad>
                    # Module level - causes circular import
                    from netra_backend.app.services.websocket.ws_manager import manager
                    
                    class JobManager:
                        async def notify(self):
                            await manager.broadcast(...)
                </bad>
                <good>
                    # Lazy import - breaks circular dependency
                    class JobManager:
                        async def notify(self):
                            from netra_backend.app.services.websocket.ws_manager import manager
                            await manager.broadcast(...)
                </good>
            </example>
        </pattern>
        
        <pattern name="TYPE_CHECKING Pattern">
            <description>Use TYPE_CHECKING for type hints without runtime imports</description>
            <example>
                from typing import TYPE_CHECKING
                
                if TYPE_CHECKING:
                    from netra_backend.app.services.websocket.ws_manager import WebSocketManager
            </example>
        </pattern>
        
        <pattern name="Dependency Injection">
            <description>Pass dependencies as parameters instead of importing</description>
            <example>
                class JobManager:
                    def __init__(self, ws_manager=None):
                        self.ws_manager = ws_manager or self._get_ws_manager()
                    
                    def _get_ws_manager(self):
                        # Lazy import only when needed
                        from netra_backend.app.services.websocket.ws_manager import manager
                        return manager
            </example>
        </pattern>
    </solution-patterns>
    
    <testing-enhancements>
        <enhancement name="AST-based Import Analysis">
            <description>
                Use Abstract Syntax Tree parsing to detect module-level imports 
                that could cause circular dependencies.
            </description>
            <implementation>test_websocket_circular_import_regression.py:TestIndirectCircularImportPrevention</implementation>
        </enhancement>
        
        <enhancement name="Import Tracking">
            <description>
                Replace __import__ temporarily to track import chains and detect 
                cycles during test execution.
            </description>
            <implementation>test_websocket_to_synthetic_data_import_chain</implementation>
        </enhancement>
        
        <enhancement name="Lazy Import Verification">
            <description>
                Verify that problematic modules use lazy imports or TYPE_CHECKING 
                guards for circular-prone dependencies.
            </description>
            <implementation>test_job_manager_lazy_imports</implementation>
        </enhancement>
    </testing-enhancements>
    
    <prevention-checklist>
        <item>Identify modules with bidirectional dependencies (A imports B, B imports A)</item>
        <item>Use lazy imports for WebSocket notifications in job/task managers</item>
        <item>Use TYPE_CHECKING for type hints in circular-prone modules</item>
        <item>Consider event-driven architecture to decouple modules</item>
        <item>Run import tests with full module chains, not isolated imports</item>
        <item>Add AST-based analysis to CI/CD pipeline</item>
    </prevention-checklist>
    
    <affected-modules>
        <module>netra_backend.app.services.synthetic_data.job_manager</module>
        <module>netra_backend.app.services.synthetic_data.job_operations</module>
        <module>netra_backend.app.services.synthetic_data.analytics_reporter</module>
        <module>netra_backend.app.services.websocket.ws_manager</module>
        <module>netra_backend.app.websocket.heartbeat_manager</module>
        <module>netra_backend.app.websocket.message_handler_core</module>
        <module>netra_backend.app.websocket.reliable_connection_manager</module>
    </affected-modules>
    
    <critical-learnings>
        <learning priority="HIGH">
            Import tests MUST track full import chains, not just direct imports, 
            to detect indirect circular dependencies.
        </learning>
        <learning priority="HIGH">
            WebSocket manager imports in job/task managers should ALWAYS be lazy 
            (inside methods) to prevent circular dependencies.
        </learning>
        <learning priority="MEDIUM">
            Use AST parsing to verify module-level imports don't create cycles 
            in critical service initialization paths.
        </learning>
        <learning priority="MEDIUM">
            TYPE_CHECKING guards are essential for type hints in modules with 
            bidirectional dependencies.
        </learning>
    </critical-learnings>
</specification>