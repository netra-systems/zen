<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>JWT Secret Configuration Learnings</name>
        <type>learnings</type>
        <version>1.0</version>
        <created>2025-08-19</created>
        <description>Critical learnings about JWT secret configuration across services</description>
        <severity>CRITICAL</severity>
        <affects>auth_service, backend, websocket_auth</affects>
    </metadata>
    
    <learnings>
        <learning>
            <id>jwt-secret-mismatch</id>
            <date>2025-08-19</date>
            <severity>CRITICAL</severity>
            <symptom>WebSocket authentication fails with "Invalid token: Signature verification failed"</symptom>
            <root_cause>Auth service and backend using different JWT secrets</root_cause>
            <problem>
                Auth service was not loading .env file and falling back to hardcoded development secret
                "dev-secret-key-DO-NOT-USE-IN-PRODUCTION" while backend used actual JWT_SECRET_KEY from .env
            </problem>
            <solution>
                1. Added dotenv loading to auth_service/main.py
                2. Created unified AuthSecretLoader for consistent secret loading
                3. Updated AuthConfig to use the unified loader
            </solution>
            <prevention>
                - Always ensure microservices load from shared .env file
                - Use unified secret loading mechanism across all services
                - Validate JWT secrets match during service startup
            </prevention>
            <files_modified>
                <file>auth_service/main.py</file>
                <file>auth_service/auth_core/secret_loader.py</file>
                <file>auth_service/auth_core/config.py</file>
            </files_modified>
        </learning>
        
        <learning>
            <id>secret-manager-integration</id>
            <date>2025-08-19</date>
            <severity>HIGH</severity>
            <symptom>Different secret sources for staging/production environments</symptom>
            <requirement>Auth service must use same secret source as backend for all environments</requirement>
            <solution>
                Created AuthSecretLoader with proper fallback chain:
                1. Environment-specific Google Secret Manager (staging/production)
                2. Environment-specific env vars (JWT_SECRET_STAGING, JWT_SECRET_PRODUCTION)
                3. Generic env vars (JWT_SECRET, JWT_SECRET_KEY)
                4. Development fallback (only in development)
            </solution>
            <terraform_integration>
                Staging/Production secrets come from Google Secret Manager via Terraform:
                - staging-jwt-secret
                - prod-jwt-secret
            </terraform_integration>
        </learning>
        
        <learning>
            <id>environment-variable-naming</id>
            <date>2025-08-19</date>
            <severity>MEDIUM</severity>
            <issue>Inconsistent JWT secret environment variable names</issue>
            <finding>
                - Backend uses: JWT_SECRET_KEY
                - Auth service expected: JWT_SECRET
                - Both must be supported for compatibility
            </finding>
            <solution>
                AuthSecretLoader checks both JWT_SECRET and JWT_SECRET_KEY in order
            </solution>
            <best_practice>
                Use consistent naming across all services. Consider standardizing on JWT_SECRET_KEY
            </best_practice>
        </learning>
        
        <learning>
            <id>dev-login-token-validation</id>
            <date>2025-08-19</date>
            <severity>HIGH</severity>
            <symptom>Frontend dev login creates tokens that backend cannot validate</symptom>
            <flow>
                1. Frontend calls auth service /auth/dev/login directly
                2. Auth service creates token with its JWT handler
                3. Frontend uses token for WebSocket connection
                4. Backend validates token via auth service /auth/validate
                5. Validation fails due to signature mismatch
            </flow>
            <root_cause>JWT secret not shared between services</root_cause>
            <solution>Ensure all services read JWT secret from same source</solution>
        </learning>
        
        <learning>
            <id>path-traversal-csp-blocking</id>
            <date>2025-08-19</date>
            <severity>MEDIUM</severity>
            <symptom>Health check endpoints return 400 Bad Request</symptom>
            <issue>Path traversal middleware incorrectly flags Content-Security-Policy headers as suspicious</issue>
            <root_cause>
                Regex pattern '\.' in suspicious patterns matches legitimate CSP directives like 'self'
            </root_cause>
            <solution>
                Modified path_traversal_protection.py to exclude legitimate headers from suspicious path checks
            </solution>
            <prevention>
                Be careful with broad regex patterns that might match legitimate content
            </prevention>
            <file_modified>app/middleware/path_traversal_protection.py</file>
        </learning>
    </learnings>
    
    <configuration_requirements>
        <requirement>
            <id>shared-jwt-secret</id>
            <description>All services MUST use the same JWT secret</description>
            <implementation>
                - Development: Read from shared .env file
                - Staging: Read from Google Secret Manager (staging-jwt-secret)
                - Production: Read from Google Secret Manager (prod-jwt-secret)
            </implementation>
        </requirement>
        
        <requirement>
            <id>env-file-loading</id>
            <description>All services MUST load environment from parent .env file</description>
            <implementation>
                Load from Path(__file__).parent.parent / ".env" to ensure shared configuration
            </implementation>
        </requirement>
        
        <requirement>
            <id>secret-validation</id>
            <description>Services should validate JWT secret on startup</description>
            <implementation>
                Log the first 10 characters of loaded JWT secret for verification
            </implementation>
        </requirement>
    </configuration_requirements>
    
    <testing_checklist>
        <test>Verify auth service loads JWT_SECRET_KEY from .env file</test>
        <test>Verify dev login tokens can be validated by backend</test>
        <test>Verify WebSocket authentication succeeds with dev tokens</test>
        <test>Test secret loading in staging environment (should use Secret Manager)</test>
        <test>Verify CSP headers are not blocked by path traversal middleware</test>
    </testing_checklist>
</specification>