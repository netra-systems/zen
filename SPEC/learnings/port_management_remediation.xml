<?xml version="1.0" encoding="UTF-8"?>
<learning>
    <metadata>
        <title>Dynamic Port Management Implementation</title>
        <category>Testing Infrastructure</category>
        <created>2025-09-01</created>
        <severity>CRITICAL</severity>
        <business_impact>
            Enables parallel test execution, prevents CI/CD bottlenecks, 
            improves developer productivity by eliminating port conflicts
        </business_impact>
    </metadata>
    
    <problem>
        <description>
            The test framework had significant issues with hardcoded ports that prevented
            proper dynamic allocation for dedicated test environments. This caused:
            1. Port conflicts when multiple test environments ran simultaneously  
            2. Test failures due to port already in use errors
            3. Inability to scale CI/CD with parallel test execution
            4. Developer downtime from environment conflicts
        </description>
        
        <root_causes>
            <cause>Hardcoded default ports in unified_docker_manager.py (lines 194-230)</cause>
            <cause>Static port mappings in _docker_ports and _local_ports dictionaries</cause>
            <cause>No mechanism for dynamic port allocation across parallel runs</cause>
            <cause>Docker port discovery fallback to hardcoded values</cause>
            <cause>No port conflict detection or retry mechanism</cause>
        </root_causes>
        
        <affected_components>
            <component>test_framework/unified_docker_manager.py</component>
            <component>test_framework/docker_port_discovery.py</component>
            <component>All E2E and integration tests</component>
        </affected_components>
    </problem>
    
    <solution>
        <approach>
            Implemented a comprehensive dynamic port allocation system with:
            1. OS-level port binding verification
            2. Port range segregation by environment type
            3. Persistent state tracking across processes
            4. Automatic conflict detection and resolution
            5. Port cleanup on test completion
        </approach>
        
        <implementation>
            <file name="test_framework/dynamic_port_allocator.py">
                <description>
                    New module providing DynamicPortAllocator class with:
                    - Port ranges for different environment types (30000-30999 for shared tests)
                    - OS-level socket binding to verify port availability
                    - Cross-platform file locking for state persistence
                    - Automatic cleanup of expired allocations
                    - Process and test ID tracking
                </description>
            </file>
            
            <file name="test_framework/unified_docker_manager.py">
                <changes>
                    - Replaced hardcoded "port" with "default_port" in SERVICES dict
                    - Added port_allocator initialization based on environment type
                    - Integrated dynamic allocation in acquire_environment()
                    - Added port release in cleanup methods
                    - Removed static _docker_ports and _local_ports dictionaries
                </changes>
            </file>
            
            <file name="test_framework/docker_port_discovery.py">
                <changes>
                    - Added dynamic allocation support with fallback
                    - Import DynamicPortAllocator when available
                    - Modified _get_default_mappings() to use allocated ports
                    - Maintained backward compatibility for systems without allocator
                </changes>
            </file>
        </implementation>
        
        <testing>
            <file name="test_framework/tests/test_dynamic_port_allocator.py">
                Comprehensive test suite covering:
                - Port allocation and conflict detection
                - Parallel allocation safety with threading
                - Port reuse for same environment
                - Cleanup and expiration
                - State persistence
                - Different port ranges
            </file>
        </testing>
    </solution>
    
    <architecture_decisions>
        <decision>
            <what>Use OS-level socket binding for port availability checks</what>
            <why>Most reliable way to verify port availability across all platforms</why>
        </decision>
        
        <decision>
            <what>Implement file-based state persistence with locking</what>
            <why>Enables coordination across multiple processes and test runs</why>
        </decision>
        
        <decision>
            <what>Segregate port ranges by environment type</what>
            <why>Prevents conflicts between development, testing, and CI environments</why>
        </decision>
        
        <decision>
            <what>Random port selection within ranges</what>
            <why>Better distribution and reduced collision probability</why>
        </decision>
    </architecture_decisions>
    
    <benefits>
        <benefit>Enables true parallel test execution without port conflicts</benefit>
        <benefit>Supports multiple dedicated test environments simultaneously</benefit>
        <benefit>Automatic cleanup prevents port exhaustion</benefit>
        <benefit>Cross-platform compatibility (Windows/Unix)</benefit>
        <benefit>Backward compatible with existing test infrastructure</benefit>
    </benefits>
    
    <future_improvements>
        <improvement>
            Add network namespace isolation for complete test separation
        </improvement>
        <improvement>
            Implement port reservation API for pre-allocating ranges
        </improvement>
        <improvement>
            Add metrics tracking for port usage patterns
        </improvement>
        <improvement>
            Create admin UI for viewing and managing port allocations
        </improvement>
    </future_improvements>
    
    <verification>
        <command>python -m pytest test_framework/tests/test_dynamic_port_allocator.py -v</command>
        <command>python test_framework/dynamic_port_allocator.py --stats</command>
        <command>python -c "from test_framework.dynamic_port_allocator import allocate_test_ports; print(allocate_test_ports(['backend', 'auth', 'postgres']))"</command>
    </verification>
</learning>