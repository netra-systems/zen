<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Database Connection Best Practices</name>
        <version>1.0.0</version>
        <created>2025-08-25</created>
        <category>Database Configuration</category>
        <tags>
            <tag>database</tag>
            <tag>postgresql</tag>
            <tag>connection</tag>
            <tag>validation</tag>
            <tag>configuration</tag>
            <tag>staging</tag>
            <tag>production</tag>
        </tags>
    </metadata>

    <overview>
        <summary>
            Critical learnings from recent PostgreSQL connection issues and fixes, establishing 
            best practices for database URL construction, password handling, and early validation 
            to prevent runtime failures.
        </summary>
        
        <problem_statement>
            Database connection failures in staging/production often result from:
            - Using placeholder values for passwords and other credentials
            - Attempting connections with invalid or empty credentials
            - Constructing URLs incorrectly rather than from validated components
            - Late validation that wastes resources and obscures root causes
        </problem_statement>
    </overview>

    <learnings>
        <learning id="no-placeholder-passwords" priority="critical">
            <title>Never Use Placeholder Values for Passwords</title>
            <description>
                Database passwords should NEVER have placeholder values like "placeholder", 
                "TODO", or empty strings. If a password is not available, the value should 
                be None/null, which allows proper validation and error handling.
            </description>
            <bad_practice>
                <code>
                # BAD: Using placeholder that will fail at runtime
                password = "placeholder"  # Will attempt connection and fail
                password = ""  # Empty string passes checks but fails authentication
                </code>
            </bad_practice>
            <good_practice>
                <code>
                # GOOD: Use None when password not available
                password = os.getenv("POSTGRES_PASSWORD")  # Returns None if not set
                if password is None:
                    logger.warning("POSTGRES_PASSWORD not configured")
                    # Handle appropriately - skip connection or use default for dev
                </code>
            </good_practice>
            <rationale>
                Placeholder values create confusion between "not configured" and "configured 
                incorrectly". Using None makes the absence of configuration explicit and 
                allows for proper fallback logic.
            </rationale>
        </learning>

        <learning id="build-url-from-components" priority="critical">
            <title>Build Database URLs from Validated Components</title>
            <description>
                Database URLs should be constructed programmatically from individual 
                validated components rather than assembled through string manipulation 
                or guesswork.
            </description>
            <bad_practice>
                <code>
                # BAD: Guessing at URL format
                url = f"postgresql://{user}:{password}@{host}/{db}"  # What about port? SSL?
                
                # BAD: String manipulation of existing URL
                url = DATABASE_URL.replace("postgres://", "postgresql+asyncpg://")
                </code>
            </bad_practice>
            <good_practice>
                <code>
                # GOOD: Use centralized DatabaseURLBuilder
                from shared.database_url_builder import DatabaseURLBuilder
                
                # Build from environment variables
                builder = DatabaseURLBuilder(os.environ)
                
                # Validate configuration
                is_valid, error_msg = builder.validate()
                if not is_valid:
                    raise ConfigurationError(error_msg)
                
                # Get appropriate URL for environment
                url = builder.get_url_for_environment(sync=False)  # async URL
                
                # Or access specific URL patterns directly
                if builder.cloud_sql.is_cloud_sql:
                    url = builder.cloud_sql.async_url
                elif builder.tcp.has_config:
                    url = builder.tcp.async_url_with_ssl
                </code>
            </good_practice>
            <rationale>
                Building URLs from components ensures correct format for different 
                connection types (TCP vs Unix socket) and prevents format errors.
            </rationale>
        </learning>

        <learning id="validate-early" priority="critical">
            <title>Validate Database Configuration Early</title>
            <description>
                Database configuration should be validated as early as possible in the 
                application lifecycle, before attempting any connections. This includes 
                checking for required values, valid formats, and logical consistency.
            </description>
            <bad_practice>
                <code>
                # BAD: Attempting connection with unvalidated config
                async def connect():
                    url = os.getenv("DATABASE_URL", "")  # Empty string default
                    engine = create_async_engine(url)  # Will fail at runtime
                    await engine.connect()  # Obscure error message
                </code>
            </bad_practice>
            <good_practice>
                <code>
                # GOOD: Validate before connection attempt
                def validate_database_config():
                    errors = []
                    
                    # Check required fields
                    if not os.getenv("POSTGRES_HOST"):
                        errors.append("POSTGRES_HOST not configured")
                    
                    password = os.getenv("POSTGRES_PASSWORD")
                    if password == "":
                        errors.append("POSTGRES_PASSWORD is empty string")
                    elif password is None and ENVIRONMENT != "development":
                        errors.append("POSTGRES_PASSWORD required in non-dev environments")
                    
                    if errors:
                        raise ConfigurationError(f"Database config invalid: {'; '.join(errors)}")
                    
                    return True

                # Validate before creating engine
                validate_database_config()
                engine = create_async_engine(build_database_url(...))
                </code>
            </good_practice>
            <rationale>
                Early validation provides clear error messages, prevents wasted connection 
                attempts, and makes configuration issues immediately visible during startup 
                rather than at runtime.
            </rationale>
        </learning>

        <learning id="environment-specific-defaults" priority="high">
            <title>Use Environment-Specific Default Strategies</title>
            <description>
                Default values for database configuration should be environment-aware. 
                Development can have permissive defaults, while staging/production should 
                fail fast without proper configuration.
            </description>
            <implementation>
                <code>
                # Use DatabaseURLBuilder for environment-aware defaults
                from shared.database_url_builder import DatabaseURLBuilder
                
                builder = DatabaseURLBuilder(os.environ)
                
                # Builder handles environment-specific logic:
                # - Development: Uses defaults if not configured
                # - Testing: Can use memory DB or test PostgreSQL
                # - Staging/Production: Validates required fields
                
                is_valid, error_msg = builder.validate()
                if not is_valid:
                    raise ConfigurationError(error_msg)
                
                # Get environment-appropriate URL
                url = builder.get_url_for_environment()
                </code>
            </implementation>
        </learning>

        <learning id="connection-test-utility" priority="medium">
            <title>Provide Connection Test Utilities</title>
            <description>
                Include utilities to test database connections independently of the main 
                application, allowing operators to validate configuration before deployment.
            </description>
            <implementation>
                <code>
                # scripts/test_database_connection.py
                from shared.database_url_builder import DatabaseURLBuilder
                
                async def test_connection():
                    """Test database connection with current configuration."""
                    try:
                        # Build and validate using DatabaseURLBuilder
                        builder = DatabaseURLBuilder(os.environ)
                        
                        # Validate configuration
                        is_valid, error_msg = builder.validate()
                        if not is_valid:
                            raise ConfigurationError(error_msg)
                        
                        # Get URL from builder
                        url = builder.get_url_for_environment(sync=False)
                        
                        # Log safely
                        logger.info(builder.get_safe_log_message())
                        
                        # Attempt connection
                        engine = create_async_engine(url)
                        async with engine.connect() as conn:
                            result = await conn.execute(text("SELECT 1"))
                            print(f"✓ Database connection successful")
                            return True
                    except ConfigurationError as e:
                        print(f"✗ Configuration error: {e}")
                        return False
                    except Exception as e:
                        print(f"✗ Connection failed: {e}")
                        return False
                </code>
            </implementation>
        </learning>

        <learning id="credential-source-tracking" priority="medium">
            <title>Track Credential Sources for Debugging</title>
            <description>
                When loading credentials from multiple sources (env vars, files, secrets 
                manager), track and log the source for easier debugging.
            </description>
            <implementation>
                <code>
                def load_database_credentials():
                    sources = {}
                    
                    # Try environment variable
                    password = os.getenv("POSTGRES_PASSWORD")
                    if password:
                        sources["password"] = "environment"
                    
                    # Try secret manager
                    if not password and SECRET_MANAGER:
                        password = SECRET_MANAGER.get("postgres-password")
                        if password:
                            sources["password"] = "secret_manager"
                    
                    # Try .env file
                    if not password:
                        password = load_from_env_file("POSTGRES_PASSWORD")
                        if password:
                            sources["password"] = ".env file"
                    
                    logger.info(f"Database credentials loaded from: {sources}")
                    return password
                </code>
            </implementation>
        </learning>
    </learnings>

    <patterns>
        <pattern name="database-config-validator">
            <description>
                Comprehensive database configuration validator that checks all aspects 
                before attempting connections.
            </description>
            <implementation>
                <code>
                class DatabaseConfigValidator:
                    def __init__(self, environment: str):
                        self.environment = environment
                        self.errors = []
                        self.warnings = []
                    
                    def validate(self) -> bool:
                        """Validate complete database configuration."""
                        self._validate_credentials()
                        self._validate_connection_params()
                        self._validate_ssl_config()
                        self._validate_pool_settings()
                        
                        if self.errors:
                            raise ConfigurationError(
                                f"Database configuration errors: {'; '.join(self.errors)}"
                            )
                        
                        if self.warnings:
                            for warning in self.warnings:
                                logger.warning(f"Database config: {warning}")
                        
                        return True
                    
                    def _validate_credentials(self):
                        """Validate database credentials."""
                        password = os.getenv("POSTGRES_PASSWORD")
                        
                        # Check for empty string (common mistake)
                        if password == "":
                            self.errors.append("POSTGRES_PASSWORD is empty string")
                        
                        # Check for placeholder values
                        if password and password.lower() in ["placeholder", "todo", "changeme"]:
                            self.errors.append(f"POSTGRES_PASSWORD contains placeholder: {password}")
                        
                        # Check for None in non-dev environments
                        if password is None and self.environment not in ["development", "testing"]:
                            self.errors.append(f"POSTGRES_PASSWORD required in {self.environment}")
                    
                    def _validate_connection_params(self):
                        """Validate connection parameters."""
                        host = os.getenv("POSTGRES_HOST")
                        
                        if not host:
                            self.errors.append("POSTGRES_HOST not configured")
                        elif host == "localhost" and self.environment in ["staging", "production"]:
                            self.errors.append(f"localhost not allowed in {self.environment}")
                        
                        port = os.getenv("POSTGRES_PORT")
                        if port and not port.isdigit():
                            self.errors.append(f"POSTGRES_PORT must be numeric: {port}")
                </code>
            </implementation>
        </pattern>

        <pattern name="connection-factory">
            <description>
                Factory pattern for creating database connections with proper validation 
                and environment-specific configuration.
            </description>
            <implementation>
                <code>
                class DatabaseConnectionFactory:
                    @staticmethod
                    async def create_connection(validate_first: bool = True):
                        """Create database connection with optional validation."""
                        if validate_first:
                            validator = DatabaseConfigValidator(get_environment())
                            validator.validate()
                        
                        # Build URL from validated components
                        url = DatabaseConnectionFactory._build_url()
                        
                        # Create engine with environment-specific settings
                        engine = create_async_engine(
                            url,
                            pool_pre_ping=True,  # Validate connections before use
                            pool_size=DatabaseConnectionFactory._get_pool_size(),
                            max_overflow=DatabaseConnectionFactory._get_max_overflow()
                        )
                        
                        # Test connection
                        try:
                            async with engine.connect() as conn:
                                await conn.execute(text("SELECT 1"))
                        except Exception as e:
                            await engine.dispose()
                            raise ConnectionError(f"Database connection test failed: {e}")
                        
                        return engine
                </code>
            </implementation>
        </pattern>
    </patterns>

    <testing>
        <test_scenario name="password-validation">
            <description>Test that placeholder passwords are properly rejected</description>
            <test_cases>
                <case>Empty string password raises ConfigurationError</case>
                <case>Placeholder values ("TODO", "changeme") are rejected</case>
                <case>None password allowed in development, rejected in production</case>
                <case>Valid passwords pass validation</case>
            </test_cases>
        </test_scenario>

        <test_scenario name="url-construction">
            <description>Test URL construction from components</description>
            <test_cases>
                <case>Standard TCP connection URL format</case>
                <case>Cloud SQL Unix socket URL format</case>
                <case>URL with/without passwords</case>
                <case>URL with/without custom ports</case>
                <case>SSL parameters added correctly per environment</case>
            </test_cases>
        </test_scenario>

        <test_scenario name="early-validation">
            <description>Test that validation occurs before connection attempts</description>
            <test_cases>
                <case>Invalid config raises error before engine creation</case>
                <case>Error messages clearly identify configuration issues</case>
                <case>Validation can be run independently</case>
                <case>Connection test utilities work correctly</case>
            </test_cases>
        </test_scenario>
    </testing>

    <migration_guide>
        <step number="1">
            <action>Audit existing database configuration code</action>
            <command>grep -r "DATABASE_URL\|POSTGRES_PASSWORD" --include="*.py"</command>
        </step>
        
        <step number="2">
            <action>Replace placeholder values with None</action>
            <description>
                Find all placeholder passwords and replace with proper None checks
            </description>
        </step>
        
        <step number="3">
            <action>Implement validation functions</action>
            <description>
                Add validate_database_config() function to configuration module
            </description>
        </step>
        
        <step number="4">
            <action>Update connection code to validate first</action>
            <description>
                Ensure all database connection code calls validation before attempting connections
            </description>
        </step>
        
        <step number="5">
            <action>Add connection test script</action>
            <description>
                Create scripts/test_database_connection.py for pre-deployment validation
            </description>
        </step>
    </migration_guide>

    <references>
        <reference>SPEC/database_connectivity_architecture.xml</reference>
        <reference>SPEC/database_url_migration.xml</reference>
        <reference>SPEC/learnings/staging_deployment_comprehensive.xml</reference>
        <reference>SPEC/learnings/database.xml</reference>
    </references>
</specification>