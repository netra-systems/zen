<?xml version="1.0" encoding="UTF-8"?>
<learning>
    <metadata>
        <title>Singleton Removal Phase 2: Factory Pattern Migration Learnings</title>
        <date>2025-09-02</date>
        <agent>Documentation Agent</agent>
        <category>Architecture</category>
        <priority>critical</priority>
        <business_impact>high</business_impact>
        <relates_to>
            <file>netra_backend/app/services/agent_websocket_bridge.py</file>
            <file>netra_backend/app/agents/supervisor/execution_engine.py</file>
            <file>netra_backend/app/websocket_core/manager.py</file>
        </relates_to>
    </metadata>

    <problem_statement>
        <summary>Singleton patterns in ExecutionEngine and AgentWebSocketBridge prevent concurrent user isolation and create critical data leakage risks</summary>
        <business_context>
            <segment>Enterprise/Platform</segment>
            <goal>Enable 10+ concurrent users with zero data leakage</goal>
            <risk>Privacy violations, compliance issues, system instability</risk>
            <value_impact>Foundation for enterprise scalability</value_impact>
        </business_context>
        <technical_context>
            <pattern_type>Singleton Anti-Pattern</pattern_type>
            <affected_components>
                <component>AgentWebSocketBridge - Lines 101-108</component>
                <component>ExecutionEngine - Shared state dictionaries</component>
                <component>WebSocketManager - Global factory functions</component>
                <component>AgentExecutionRegistry - Shared execution state</component>
            </affected_components>
            <failure_modes>
                <mode>Cross-user WebSocket event leakage</mode>
                <mode>Shared execution state corruption</mode>
                <mode>Race conditions in concurrent access</mode>
                <mode>Unbounded memory growth</mode>
            </failure_modes>
        </technical_context>
    </problem_statement>

    <root_cause_analysis>
        <primary_causes>
            <cause>
                <type>Architectural Anti-Pattern</type>
                <description>Singleton pattern used for components that should be per-user scoped</description>
                <evidence>
                    <code_location>netra_backend/app/services/agent_websocket_bridge.py:101-108</code_location>
                    <pattern>_instance: Optional['AgentWebSocketBridge'] = None</pattern>
                    <impact>All users share same WebSocket routing state</impact>
                </evidence>
            </cause>
            <cause>
                <type>Shared Mutable State</type>
                <description>Global dictionaries accumulate state across all users</description>
                <evidence>
                    <code_location>netra_backend/app/agents/supervisor/execution_engine.py:96-97</code_location>
                    <pattern>self.active_runs: Dict[str, AgentExecutionContext] = {}</pattern>
                    <impact>User execution contexts mixed in shared dictionary</impact>
                </evidence>
            </cause>
            <cause>
                <type>Factory Function Misuse</type>
                <description>Factory functions return shared instances instead of creating new ones</description>
                <evidence>
                    <function>get_websocket_manager(), get_agent_websocket_bridge()</function>
                    <behavior>Return same singleton instance for all users</behavior>
                    <impact>No user isolation at component level</impact>
                </evidence>
            </cause>
        </primary_causes>
        <contributing_factors>
            <factor>No user context threading through application layers</factor>
            <factor>Lack of proper lifecycle management for user-scoped resources</factor>
            <factor>Insufficient concurrent user testing during development</factor>
            <factor>Missing architectural patterns for multi-tenancy</factor>
        </contributing_factors>
    </root_cause_analysis>

    <solution_approach>
        <strategy>Factory Pattern with User Context Isolation</strategy>
        <architecture_principles>
            <principle>Separate Infrastructure from Request Layer</principle>
            <principle>Per-User Resource Scoping</principle>
            <principle>Proper Lifecycle Management</principle>
            <principle>Concurrent-Safe Resource Access</principle>
        </architecture_principles>
        <key_components>
            <component>
                <name>UserExecutionContext</name>
                <purpose>Per-request execution context with complete isolation</purpose>
                <design>Dataclass with user_id, thread_id, and user-specific state</design>
                <cleanup>Async cleanup with callback registration</cleanup>
            </component>
            <component>
                <name>ExecutionEngineFactory</name>
                <purpose>Create isolated ExecutionEngine instances per user</purpose>
                <design>Factory with infrastructure configuration and per-user instances</design>
                <features>User-specific semaphores, resource management, cleanup</features>
            </component>
            <component>
                <name>WebSocketBridgeFactory</name>
                <purpose>Create per-user WebSocket event emitters</purpose>
                <design>Factory with connection pooling and user-scoped event routing</design>
                <features>Event isolation, delivery guarantees, connection health monitoring</features>
            </component>
        </key_components>
    </solution_approach>

    <implementation_lessons>
        <what_worked_well>
            <lesson>
                <title>Systematic Analysis Approach</title>
                <description>Deep analysis of singleton patterns identified all critical issues comprehensively</description>
                <evidence>347 lines of detailed analysis covering all failure modes</evidence>
                <value>Prevented incomplete solutions by understanding full scope</value>
            </lesson>
            <lesson>
                <title>Test-Driven Design Validation</title>
                <description>Comprehensive test suite created before implementation guides correct behavior</description>
                <evidence>15 concurrent user isolation tests with realistic scenarios</evidence>
                <value>Tests document expected behavior and validate fixes</value>
            </lesson>
            <lesson>
                <title>Factory Pattern Architecture</title>
                <description>Clean separation of concerns between infrastructure and per-user components</description>
                <evidence>Clear interfaces for ExecutionEngineFactory and WebSocketBridgeFactory</evidence>
                <value>Scalable architecture supporting 10+ concurrent users</value>
            </lesson>
            <lesson>
                <title>Business Value Driven</title>
                <description>Clear understanding of business impact drives technical decisions</description>
                <evidence>Privacy compliance, enterprise scalability, user experience focus</evidence>
                <value>Technical work aligned with business objectives</value>
            </lesson>
        </what_worked_well>
        <challenges_encountered>
            <challenge>
                <title>Implementation Complexity Underestimated</title>
                <description>Singleton removal more complex than initially estimated due to tight coupling</description>
                <impact>Implementation phase incomplete, affecting timeline</impact>
                <lesson>Break down large migrations into smaller, more atomic changes</lesson>
                <mitigation>Phase implementation with clear intermediate validation points</mitigation>
            </challenge>
            <challenge>
                <title>WebSocket Integration Coupling</title>
                <description>WebSocket event system more tightly coupled to singletons than expected</description>
                <impact>WebSocket event delivery broken during migration</impact>
                <lesson>Map all dependencies thoroughly before starting implementation</lesson>
                <mitigation>Create integration test suite early to catch coupling issues</mitigation>
            </challenge>
            <challenge>
                <title>Test Infrastructure Limitations</title>
                <description>Docker unavailability limits full integration testing capability</description>
                <impact>Cannot validate complete end-to-end scenarios with real services</impact>
                <lesson>Ensure test infrastructure available before starting complex migrations</lesson>
                <mitigation>Set up alternative testing approaches for environment constraints</mitigation>
            </challenge>
            <challenge>
                <title>Deprecation Cascade Effects</title>
                <description>Multiple deprecated components complicate migration path</description>
                <impact>WebSocketNotifier vs AgentWebSocketBridge confusion, import issues</impact>
                <lesson>Address deprecation debt systematically before major refactors</lesson>
                <mitigation>Create deprecation roadmap with clear migration timeline</mitigation>
            </challenge>
        </challenges_encountered>
    </implementation_lessons>

    <performance_implications>
        <baseline_metrics>
            <metric name="concurrent_users_supported">1 (effective)</metric>
            <metric name="response_time_avg">12ms</metric>
            <metric name="memory_per_user">Unbounded (shared state)</metric>
            <metric name="race_condition_risk">HIGH</metric>
            <metric name="data_leakage_risk">HIGH</metric>
        </baseline_metrics>
        <target_metrics>
            <metric name="concurrent_users_supported">10+</metric>
            <metric name="response_time_avg">Sub-2s (under concurrent load)</metric>
            <metric name="memory_per_user">Bounded (isolated state)</metric>
            <metric name="race_condition_risk">NONE</metric>
            <metric name="data_leakage_risk">NONE</metric>
        </target_metrics>
        <performance_considerations>
            <consideration>
                <aspect>Memory Usage</aspect>
                <impact>Per-user instances increase memory usage linearly with user count</impact>
                <mitigation>Proper cleanup mechanisms and resource limits</mitigation>
                <acceptable_overhead>10MB per active user maximum</acceptable_overhead>
            </consideration>
            <consideration>
                <aspect>CPU Overhead</aspect>
                <impact>Factory pattern adds minimal per-request overhead</impact>
                <measurement>Less than 1ms per factory call measured</measurement>
                <acceptable_overhead>Sub-2% of total request time</acceptable_overhead>
            </consideration>
            <consideration>
                <aspect>Connection Management</aspect>
                <impact>Per-user WebSocket connections require proper pooling</impact>
                <mitigation>Connection pool with health monitoring and stale connection cleanup</mitigation>
                <scalability_limit>100+ concurrent users with proper infrastructure</scalability_limit>
            </consideration>
        </performance_considerations>
    </performance_implications>

    <testing_strategy>
        <comprehensive_test_categories>
            <category>
                <name>Concurrent User Execution Isolation</name>
                <purpose>Validate no shared state between concurrent users</purpose>
                <users_tested>12-25 concurrent users</users_tested>
                <key_validations>
                    <validation>Component instance uniqueness</validation>
                    <validation>Execution state isolation</validation>
                    <validation>Race condition detection</validation>
                    <validation>Data leakage prevention</validation>
                </key_validations>
            </category>
            <category>
                <name>WebSocket Event User Isolation</name>
                <purpose>Ensure events reach only correct user</purpose>
                <users_tested>15 concurrent users</users_tested>
                <key_validations>
                    <validation>Event routing correctness</validation>
                    <validation>Cross-user event prevention</validation>
                    <validation>Death notification isolation</validation>
                    <validation>Event queue isolation</validation>
                </key_validations>
            </category>
            <category>
                <name>Factory Pattern Validation</name>
                <purpose>Verify factory methods create unique instances</purpose>
                <iterations>10-15 per factory method</iterations>
                <key_validations>
                    <validation>Instance uniqueness verification</validation>
                    <validation>Memory address comparison</validation>
                    <validation>State isolation between instances</validation>
                </key_validations>
            </category>
            <category>
                <name>Memory Leak Prevention</name>
                <purpose>Ensure bounded memory growth with user count</purpose>
                <users_tested>50-100 concurrent users</users_tested>
                <key_validations>
                    <validation>Linear memory scaling</validation>
                    <validation>Proper resource cleanup</validation>
                    <validation>Connection pool management</validation>
                </key_validations>
            </category>
        </comprehensive_test_categories>
        <test_results>
            <current_status>
                <singleton_removal_tests>8/15 passing (53%)</singleton_removal_tests>
                <websocket_event_tests>14/21 passing (67%)</websocket_event_tests>
                <factory_pattern_tests>0/3 passing (0% - all failing)</factory_pattern_tests>
                <overall_validation>INCOMPLETE - Implementation required</overall_validation>
            </current_status>
            <critical_failures>
                <failure>AgentExecutionRegistry isolation - 8 race conditions detected</failure>
                <failure>WebSocket event user isolation - Cross-user event mixing</failure>
                <failure>Factory uniqueness - All factory methods returning shared instances</failure>
                <failure>Tool execution events - UnifiedToolExecutionEngine has null websocket_notifier</failure>
            </critical_failures>
        </test_results>
    </testing_strategy>

    <migration_strategy>
        <phased_approach>
            <phase number="1" status="COMPLETE">
                <name>Analysis and Design</name>
                <duration>1 week</duration>
                <deliverables>
                    <deliverable>Comprehensive singleton analysis report</deliverable>
                    <deliverable>Factory pattern architectural designs</deliverable>
                    <deliverable>Test suite development</deliverable>
                    <deliverable>Business value justification</deliverable>
                </deliverables>
                <success_criteria>
                    <criterion>All singleton patterns identified and analyzed</criterion>
                    <criterion>Factory pattern designs complete and reviewed</criterion>
                    <criterion>Test suite covers all critical scenarios</criterion>
                </success_criteria>
            </phase>
            <phase number="2" status="INCOMPLETE">
                <name>Infrastructure Implementation</name>
                <duration>1-2 weeks</duration>
                <deliverables>
                    <deliverable>ExecutionEngineFactory implementation</deliverable>
                    <deliverable>WebSocketBridgeFactory implementation</deliverable>
                    <deliverable>UserExecutionContext implementation</deliverable>
                    <deliverable>Factory method uniqueness</deliverable>
                </deliverables>
                <success_criteria>
                    <criterion>All factory methods create unique instances</criterion>
                    <criterion>User context isolation working</criterion>
                    <criterion>Basic factory pattern tests passing</criterion>
                </success_criteria>
                <blocking_issues>
                    <issue>WebSocket integration coupling more complex than expected</issue>
                    <issue>ExecutionEngine shared state deeply integrated</issue>
                    <issue>Deprecation cascade effects on implementation</issue>
                </blocking_issues>
            </phase>
            <phase number="3" status="PARTIAL">
                <name>Integration and Testing</name>
                <duration>1 week</duration>
                <deliverables>
                    <deliverable>All singleton removal tests passing</deliverable>
                    <deliverable>WebSocket event integration restored</deliverable>
                    <deliverable>End-to-end validation complete</deliverable>
                    <deliverable>Performance validation under concurrent load</deliverable>
                </deliverables>
                <success_criteria>
                    <criterion>100% test pass rate for singleton removal</criterion>
                    <criterion>Zero race conditions detected</criterion>
                    <criterion>All WebSocket events delivered correctly</criterion>
                </success_criteria>
                <current_status>
                    <item>Comprehensive test suite created ✅</item>
                    <item>Test failures indicate implementation gaps ❌</item>
                    <item>WebSocket integration broken ❌</item>
                    <item>Docker test infrastructure unavailable ❌</item>
                </current_status>
            </phase>
            <phase number="4" status="NOT_STARTED">
                <name>Migration and Cleanup</name>
                <duration>1 week</duration>
                <deliverables>
                    <deliverable>Legacy singleton code removal</deliverable>
                    <deliverable>Performance optimization</deliverable>
                    <deliverable>Production deployment preparation</deliverable>
                    <deliverable>Monitoring and alerting setup</deliverable>
                </deliverables>
                <success_criteria>
                    <criterion>No singleton patterns in production code</criterion>
                    <criterion>System ready for production deployment</criterion>
                    <criterion>Performance meets concurrent user requirements</criterion>
                </success_criteria>
            </phase>
        </phased_approach>
        <rollback_strategy>
            <safety_measures>
                <measure>Feature flag control for factory vs singleton behavior</measure>
                <measure>Backward compatibility adapters maintain existing interfaces</measure>
                <measure>Gradual rollout with monitoring and alerting</measure>
                <measure>Database migrations reversible</measure>
            </safety_measures>
            <rollback_triggers>
                <trigger>Performance degradation > 2x baseline</trigger>
                <trigger>Memory usage growth > 10MB per user</trigger>
                <trigger>Any data leakage incidents detected</trigger>
                <trigger>System instability or crashes</trigger>
            </rollback_triggers>
        </rollback_strategy>
    </migration_strategy>

    <business_impact>
        <risk_mitigation>
            <risk type="DATA_LEAKAGE" severity="CRITICAL">
                <description>User A could receive User B's private agent events or execution data</description>
                <business_cost>Privacy violations, compliance fines, legal liability</business_cost>
                <mitigation_approach>Complete user isolation through factory pattern</mitigation_approach>
                <validation_method>Comprehensive concurrent user testing</validation_method>
            </risk>
            <risk type="SCALABILITY_LIMITS" severity="HIGH">
                <description>Cannot safely support more than 1-2 concurrent users</description>
                <business_cost>Enterprise customer acquisition blocked</business_cost>
                <mitigation_approach>Per-user resource scoping with proper lifecycle management</mitigation_approach>
                <validation_method>Load testing with 10+ concurrent users</validation_method>
            </risk>
            <risk type="USER_EXPERIENCE" severity="HIGH">
                <description>Users don't receive real-time agent execution feedback</description>
                <business_cost>Poor UX, customer churn, support burden</business_cost>
                <mitigation_approach>Restore WebSocket event delivery with user isolation</mitigation_approach>
                <validation_method>End-to-end WebSocket event testing</validation_method>
            </risk>
        </risk_mitigation>
        <value_delivered>
            <value type="ENTERPRISE_SCALABILITY">
                <description>Foundation for supporting 10+ concurrent enterprise users</description>
                <business_benefit>Enables enterprise customer segment expansion</business_benefit>
                <revenue_impact>Unlocks enterprise pricing tiers and larger contracts</revenue_impact>
            </value>
            <value type="COMPLIANCE_READINESS">
                <description>User data isolation meets privacy and compliance requirements</description>
                <business_benefit>Reduces regulatory risk and enables compliant deployments</business_benefit>
                <operational_benefit>Fewer support issues from data leakage incidents</operational_benefit>
            </value>
            <value type="SYSTEM_RELIABILITY">
                <description>Eliminates race conditions and singleton-related failures</description>
                <business_benefit>More stable platform with predictable behavior</business_benefit>
                <engineering_benefit>Easier debugging and system maintenance</engineering_benefit>
            </value>
        </value_delivered>
    </business_impact>

    <architectural_patterns>
        <pattern_established>
            <name>Factory Pattern with User Context</name>
            <applicability>Any component that needs per-user state isolation</applicability>
            <implementation_template>
                <code><![CDATA[
@dataclass
class UserContext:
    user_id: str
    request_id: str
    # User-specific state
    cleanup_callbacks: List[Callable] = field(default_factory=list)

class ComponentFactory:
    def __init__(self):
        # Infrastructure components (shared, immutable)
        self._shared_resources = {}
    
    async def create_component(self, user_context: UserContext) -> Component:
        # Create per-user component with infrastructure access
        component = Component(user_context, self._shared_resources)
        user_context.cleanup_callbacks.append(component.cleanup)
        return component
                ]]></code>
            </implementation_template>
            <key_principles>
                <principle>Separate infrastructure (shared) from user state (isolated)</principle>
                <principle>Proper resource lifecycle management with cleanup callbacks</principle>
                <principle>Type-safe interfaces with clear user context threading</principle>
            </key_principles>
        </pattern_established>
        <anti_pattern_identified>
            <name>Singleton for User-Scoped Components</name>
            <problem>Components that should be per-user implemented as singletons</problem>
            <symptoms>
                <symptom>Shared dictionaries accumulating per-user data</symptom>
                <symptom>Global factory functions returning same instance</symptom>
                <symptom>Race conditions in concurrent user scenarios</symptom>
                <symptom>Memory leaks from unbounded singleton state growth</symptom>
            </symptoms>
            <detection_methods>
                <method>Factory uniqueness tests (check instance IDs)</method>
                <method>Concurrent user isolation tests</method>
                <method>Memory growth analysis with user count</method>
                <method>Race condition detection under load</method>
            </detection_methods>
        </anti_pattern_identified>
    </architectural_patterns>

    <future_considerations>
        <scalability_planning>
            <consideration>
                <aspect>Database Session Management</aspect>
                <current_state>Sessions potentially shared between users</current_state>
                <future_need>Per-user database session isolation</future_need>
                <implementation>Extend factory pattern to database connection management</implementation>
            </consideration>
            <consideration>
                <aspect>Caching Strategy</aspect>
                <current_state>Global caches may leak data between users</current_state>
                <future_need>User-scoped caching with proper isolation</future_need>
                <implementation>Per-user cache namespaces or separate cache instances</implementation>
            </consideration>
            <consideration>
                <aspect>Monitoring and Observability</aspect>
                <current_state>Global metrics may not show per-user behavior</current_state>
                <future_need>Per-user metrics and tracing</future_need>
                <implementation>User context threading through observability stack</implementation>
            </consideration>
        </scalability_planning>
        <technical_debt>
            <debt_item>
                <category>Deprecation Cleanup</category>
                <description>Multiple deprecated WebSocket components need systematic removal</description>
                <effort>1 week</effort>
                <risk>Medium - affects maintainability</risk>
            </debt_item>
            <debt_item>
                <category>Test Infrastructure</category>
                <description>Docker unavailability limits integration testing capability</description>
                <effort>Setup alternative testing environment</effort>
                <risk>High - affects validation quality</risk>
            </debt_item>
            <debt_item>
                <category>Import Dependencies</category>
                <description>ClickHouse dependency issues blocking some tests</description>
                <effort>2 days</effort>
                <risk>Low - workarounds available</risk>
            </debt_item>
        </technical_debt>
    </future_considerations>

    <success_criteria>
        <technical_criteria>
            <criterion>100% singleton removal test pass rate</criterion>
            <criterion>100% WebSocket event test pass rate</criterion>
            <criterion>Zero race conditions detected under concurrent load</criterion>
            <criterion>All factory methods create unique instances</criterion>
            <criterion>User data completely isolated (no shared state)</criterion>
            <criterion>Memory growth linear with user count</criterion>
            <criterion>Performance degradation < 2x under 10+ concurrent users</criterion>
        </technical_criteria>
        <business_criteria>
            <criterion>10+ concurrent users supported safely</criterion>
            <criterion>Zero data leakage incidents possible</criterion>
            <criterion>Real-time agent execution feedback working</criterion>
            <criterion>System stable under production load scenarios</criterion>
            <criterion>Enterprise security requirements met</criterion>
            <criterion>Privacy compliance requirements satisfied</criterion>
        </business_criteria>
        <validation_methods>
            <method>Comprehensive concurrent user testing (15-25 users)</method>
            <method>WebSocket event routing validation</method>
            <method>Memory leak testing with cleanup verification</method>
            <method>Performance regression testing</method>
            <method>Security audit of user isolation</method>
            <method>Production load simulation</method>
        </validation_methods>
    </success_criteria>

    <recommendations>
        <immediate_actions>
            <action priority="P0">
                <title>Complete ExecutionEngine Factory Implementation</title>
                <description>Implement UserExecutionContext and ExecutionEngineFactory with proper user isolation</description>
                <timeline>1 week</timeline>
                <owner>Implementation Agent</owner>
                <validation>All singleton removal tests passing for ExecutionEngine</validation>
            </action>
            <action priority="P0">
                <title>Fix WebSocket Event Delivery</title>
                <description>Restore UnifiedToolExecutionEngine WebSocket notifier integration</description>
                <timeline>3 days</timeline>
                <owner>WebSocket Integration Specialist</owner>
                <validation>All WebSocket agent event tests passing</validation>
            </action>
            <action priority="P0">
                <title>Implement WebSocketBridge Factory</title>
                <description>Create WebSocketBridgeFactory with per-user event emitters</description>
                <timeline>1 week</timeline>
                <owner>Design + Implementation Agents</owner>
                <validation>WebSocket event isolation tests passing</validation>
            </action>
        </immediate_actions>
        <architectural_guidance>
            <guidance>
                <principle>Always consider user isolation from the start of component design</principle>
                <application>Before creating any shared component, ask "Should this be per-user?"</application>
            </guidance>
            <guidance>
                <principle>Use factory pattern for any component with user-specific state</principle>
                <application>Create factories that separate infrastructure from user context</application>
            </guidance>
            <guidance>
                <principle>Thread user context through all application layers</principle>
                <application>Every component should receive UserContext for proper isolation</application>
            </guidance>
            <guidance>
                <principle>Implement comprehensive concurrent user testing early</principle>
                <application>Create isolation tests before implementation to guide correct behavior</application>
            </guidance>
        </architectural_guidance>
        <process_improvements>
            <improvement>
                <area>Migration Planning</area>
                <recommendation>Break large migrations into smaller, independently deployable phases</recommendation>
                <rationale>Reduces risk and enables faster feedback cycles</rationale>
            </improvement>
            <improvement>
                <area>Dependency Analysis</area>
                <recommendation>Create comprehensive dependency maps before starting complex refactors</recommendation>
                <rationale>Identifies coupling issues that affect implementation complexity</rationale>
            </improvement>
            <improvement>
                <area>Test Infrastructure</area>
                <recommendation>Ensure test infrastructure is available early in migration process</recommendation>
                <rationale>Enables proper validation of changes and early issue detection</rationale>
            </improvement>
        </process_improvements>
    </recommendations>

    <conclusion>
        <summary>
            The singleton removal effort has made significant progress in understanding and designing solutions for critical user isolation issues. While the implementation is incomplete, the foundation is solid and the path forward is clear.
        </summary>
        <key_achievements>
            <achievement>Comprehensive analysis of singleton patterns and business risks</achievement>
            <achievement>Detailed factory pattern architecture designed for user isolation</achievement>
            <achievement>Extensive test suite created for validation</achievement>
            <achievement>Clear understanding of implementation requirements</achievement>
        </key_achievements>
        <remaining_work>
            <work_item>Complete ExecutionEngine factory implementation (P0)</work_item>
            <work_item>Restore WebSocket event delivery (P0)</work_item>
            <work_item>Implement WebSocket bridge factory (P0)</work_item>
            <work_item>Validate all concurrent user scenarios (P1)</work_item>
        </remaining_work>
        <business_readiness>
            <current_state>NOT READY for production with concurrent users</current_state>
            <blocking_issues>User isolation not guaranteed, WebSocket events broken</blocking_issues>
            <timeline_to_ready>2-3 weeks with focused effort on P0 items</timeline_to_ready>
            <confidence_level>HIGH for architectural approach, MEDIUM for timeline</confidence_level>
        </business_readiness>
    </conclusion>
</learning>