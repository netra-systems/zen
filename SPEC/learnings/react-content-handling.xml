<?xml version="1.0" encoding="UTF-8"?>
<learnings category="react-content-handling">
  <learning id="react-child-object-error" date="2025-08-16" severity="high">
    <title>React Child Object Rendering Error Prevention</title>
    
    <problem>
      <description>
        React throws "Objects are not valid as a React child" error when attempting to render
        objects directly as children. This commonly occurs when message content can be either
        a string or an object structure (e.g., {type: 'text', text: 'content'}).
      </description>
      <error_message>
        Objects are not valid as a React child (found: object with keys {type, text}).
        If you meant to render a collection of children, use an array instead.
      </error_message>
      <affected_components>
        - MessageList.tsx
        - MessageItem.tsx
        - Any component rendering dynamic content that could be objects
      </affected_components>
    </problem>
    
    <root_cause>
      Message content from the store/API can be in multiple formats:
      1. Plain string: "Hello world"
      2. Object with text property: {type: 'text', text: 'Hello world'}
      3. Complex objects: {type: 'custom', data: {...}}
      4. Null/undefined values
      
      Direct assignment of content without type checking causes React to attempt
      rendering objects as children, which is invalid.
    </root_cause>
    
    <solution>
      <implementation>
        Always normalize content before rendering by checking its type:
        
        ```typescript
        const normalizedContent = typeof content === 'string' 
          ? content 
          : (content?.text || JSON.stringify(content));
        ```
        
        This ensures:
        1. Strings are passed through unchanged
        2. Objects with 'text' property extract the text
        3. Other objects are stringified for display
        4. Null/undefined are handled gracefully
      </implementation>
      
      <applied_fixes>
        1. MessageList.tsx line 59-61: Added content normalization in displayedMessages mapping
        2. MessageItem.tsx line 83-85: Added content type checking in renderRegularContent
        3. Created comprehensive test suite in message-content-handling.test.tsx
      </applied_fixes>
    </solution>
    
    <prevention>
      <best_practices>
        1. Always validate and normalize dynamic content before rendering
        2. Use TypeScript types to enforce content structure
        3. Create utility functions for content normalization
        4. Add unit tests for all content format variations
        5. Consider using discriminated unions for content types
      </best_practices>
      
      <code_pattern>
        ```typescript
        // Utility function for content normalization
        const normalizeMessageContent = (content: any): string => {
          if (typeof content === 'string') return content;
          if (content?.text) return content.text;
          if (content === null || content === undefined) return '';
          return JSON.stringify(content);
        };
        ```
      </code_pattern>
    </prevention>
    
    <testing>
      <test_cases>
        1. String content rendering
        2. Object with text property
        3. Object without text property
        4. Null/undefined content
        5. Array content
        6. Nested object content
        7. React element-like objects
        8. Mixed content types in list
        9. Empty string content
        10. Special characters in content
      </test_cases>
      
      <regression_prevention>
        Run test suite: npm test -- message-content-handling.test.tsx
      </regression_prevention>
    </testing>
    
    <business_impact>
      <segment>All segments (Free, Early, Mid, Enterprise)</segment>
      <value_impact>
        Prevents application crashes during chat interactions,
        ensuring consistent user experience and reducing support tickets.
        Critical for maintaining platform reliability.
      </value_impact>
    </business_impact>
    
    <related_issues>
      - Content serialization from WebSocket messages
      - Store message format consistency
      - Type safety in message interfaces
    </related_issues>
  </learning>
</learnings>