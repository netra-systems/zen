<?xml version="1.0" encoding="UTF-8"?>
<learning>
    <metadata>
        <title>Frontend Type Definition Consolidation</title>
        <date>2025-01-03</date>
        <scope>frontend/types</scope>
        <business_value>Development velocity, code maintainability, type safety</business_value>
        <segments>All (Free, Early, Mid, Enterprise)</segments>
    </metadata>

    <context>
        <problem>
            Frontend codebase had duplicate type definitions scattered across multiple files, violating Single Source of Truth (SSOT) principles and creating maintenance overhead.
        </problem>
        
        <business_justification>
            - **Development Velocity**: Reduces confusion and debugging time for developers
            - **Code Maintainability**: Single source of truth eliminates inconsistencies
            - **Type Safety**: Consolidated types ensure consistent interfaces across components
            - **Risk Reduction**: Fewer duplicate definitions = fewer places for errors to hide
        </business_justification>
    </context>

    <solution>
        <approach>
            Systematic consolidation of duplicate type definitions by:
            1. Identifying canonical locations for each type
            2. Removing duplicates and replacing with imports
            3. Maintaining backward compatibility through re-exports
            4. Updating isolatedModules exports to use 'export type'
        </approach>

        <consolidations_completed>
            <type name="PerformanceMetrics" canonical="frontend/types/performance-metrics.ts">
                <duplicates_removed>
                    - frontend/services/animation-engine.ts (different properties, updated to match canonical)
                    - frontend/components/chat/AgentStatusIndicator.tsx (different properties, updated to match canonical)  
                    - frontend/__tests__/utils/test-helpers.tsx (different properties, removed and imported)
                </duplicates_removed>
                <notes>Cypress GTM performance test kept separate as it serves different purpose (web vitals vs app metrics)</notes>
            </type>

            <type name="ValidationResult" canonical="frontend/types/shared/validation.ts">
                <duplicates_removed>
                    - frontend/lib/hydration-validator.ts (replaced with HydrationValidationResult import)
                    - frontend/components/chat/admin/ConfigurationBuilder.backup.tsx (replaced with ConfigValidationResult import)
                    - frontend/components/chat/admin/ConfigurationBuilder.types.ts (replaced with ConfigValidationResult import)
                </duplicates_removed>
                <notes>Used specific validation result types (HydrationValidationResult, ConfigValidationResult) rather than generic ValidationResult</notes>
            </type>

            <type name="CircuitBreakerState" canonical="frontend/lib/circuit-breaker.ts">
                <duplicates_removed>
                    - frontend/services/webSocketServiceResilient.ts (union type renamed to CircuitBreakerStateValue, imported from canonical)
                    - frontend/cypress/e2e/critical-websocket-resilience.cy.ts (renamed to TestCircuitBreakerState for test-specific use)
                </duplicates_removed>
                <notes>Added CircuitBreakerStateValue union type to canonical file for state values vs state objects</notes>
            </type>

            <type name="BaseMessage" canonical="frontend/types/shared/base.ts">
                <duplicates_removed>
                    - frontend/types/domains/messages.ts (removed duplicate, imported from shared/base.ts)
                    - frontend/types/domains/agents.ts (renamed to AgentMessage with BaseMessage alias for backward compatibility)
                </duplicates_removed>
                <notes>backend_schema_base.ts BaseMessage kept separate as it serves LangChain backend schema purpose</notes>
            </type>

            <type name="RunComplete" canonical="frontend/types/backend_schema_base.ts">
                <duplicates_removed>
                    - frontend/types/Run.ts (removed duplicate, re-exported canonical with 'export type')
                </duplicates_removed>
                <notes>frontend/types/messages.ts kept as is since it's auto-generated from pydantic models</notes>
            </type>

            <type name="StreamEvent" canonical="frontend/types/backend_schema_base.ts">
                <duplicates_removed>
                    - frontend/types/StreamEvent.ts (removed duplicate, re-exported canonical with 'export type')
                </duplicates_removed>
                <notes>frontend/types/messages.ts kept as is since it's auto-generated from pydantic models</notes>
            </type>

            <type name="ReferenceItem" canonical="frontend/types/backend_schema_tools.ts">
                <duplicates_removed>
                    - frontend/types/domains/tools.ts (removed duplicate, imported and re-exported canonical)
                </duplicates_removed>
                <notes>frontend/types/Reference.ts kept separate as it has completely different structure and purpose</notes>
            </type>
        </consolidations_completed>
    </solution>

    <implementation_details>
        <patterns_established>
            <pattern name="Canonical Location Priority">
                1. backend_schema_*.ts files (for types that mirror backend schemas)
                2. types/shared/*.ts files (for shared UI types)  
                3. types/domains/*.ts files (for domain-specific types)
                4. Individual component/service types (least preferred)
            </pattern>

            <pattern name="Import Strategy">
                - Use absolute imports from canonical locations
                - Provide backward compatibility aliases where needed
                - Use 'export type' for re-exports when isolatedModules is enabled
                - Update initialization code to match canonical interface
            </pattern>

            <pattern name="Test-Specific Types">
                - Cypress tests may have specialized types (e.g., GTM performance metrics)
                - Rename to be explicit (TestCircuitBreakerState vs CircuitBreakerState)
                - Document when test types serve different purposes than application types
            </pattern>
        </patterns_established>

        <files_modified>
            <modified>frontend/types/performance-metrics.ts</modified>
            <modified>frontend/services/animation-engine.ts</modified>
            <modified>frontend/components/chat/AgentStatusIndicator.tsx</modified>
            <modified>frontend/__tests__/utils/test-helpers.tsx</modified>
            <modified>frontend/lib/hydration-validator.ts</modified>
            <modified>frontend/components/chat/admin/ConfigurationBuilder.backup.tsx</modified>
            <modified>frontend/components/chat/admin/ConfigurationBuilder.types.ts</modified>
            <modified>frontend/lib/circuit-breaker.ts</modified>
            <modified>frontend/services/webSocketServiceResilient.ts</modified>
            <modified>frontend/cypress/e2e/critical-websocket-resilience.cy.ts</modified>
            <modified>frontend/types/domains/messages.ts</modified>
            <modified>frontend/types/domains/agents.ts</modified>
            <modified>frontend/types/Run.ts</modified>
            <modified>frontend/types/StreamEvent.ts</modified>
            <modified>frontend/types/domains/tools.ts</modified>
        </files_modified>
    </implementation_details>

    <validation>
        <type_checking>
            Major TypeScript errors resolved related to duplicate type definitions.
            Some remaining errors exist in test files and legacy code, unrelated to consolidation work.
        </type_checking>

        <backward_compatibility>
            All consolidations maintain backward compatibility through:
            - Re-export aliases (AgentMessage as BaseMessage)
            - Import path updates without interface changes
            - Canonical interface enhancements rather than breaking changes
        </backward_compatibility>
    </validation>

    <lessons_learned>
        <lesson>
            <title>Auto-Generated Files</title>
            <description>Files like messages.ts that are auto-generated from pydantic models should not be modified manually. Leave these as-is and work around them.</description>
        </lesson>

        <lesson>
            <title>Test-Specific Types</title>
            <description>Not all "duplicate" types are actually duplicates - some serve different purposes (e.g., GTM performance metrics vs app performance metrics). Analyze usage before consolidating.</description>
        </lesson>

        <lesson>
            <title>Interface vs Union Types</title>
            <description>Some types need both interface and union type variants (CircuitBreakerState interface vs CircuitBreakerStateValue union). Enhance canonical files to provide both when needed.</description>
        </lesson>

        <lesson>
            <title>Import Path Strategy</title>
            <description>Using absolute imports from canonical locations makes dependencies clear and prevents circular import issues.</description>
        </lesson>

        <lesson>
            <title>Backward Compatibility</title>
            <description>Always provide aliases or re-exports to maintain compatibility with existing code that expects the old import paths.</description>
        </lesson>
    </lessons_learned>

    <next_steps>
        <step>Run comprehensive type checking after consolidation</step>
        <step>Update any remaining TypeScript errors in test files</step>
        <step>Consider creating type definition lint rules to prevent future duplications</step>
        <step>Document canonical type locations in developer documentation</step>
        <step>Regular audits for new type duplications</step>
    </next_steps>

    <metrics>
        <before>
            - 7 major duplicate type definitions across 15+ files
            - Multiple variations of same interfaces with different properties
            - No clear canonical locations for shared types
        </before>
        
        <after>
            - Single source of truth established for each type
            - Clear canonical locations documented
            - Backward compatibility maintained
            - Import relationships clarified
        </after>
    </metrics>
</learning>