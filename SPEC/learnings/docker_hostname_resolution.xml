<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <metadata>
    <title>Docker Hostname Resolution for Database Connections</title>
    <date>2025-08-29</date>
    <category>Infrastructure</category>
    <services>auth_service, netra_backend</services>
    <importance>HIGH</importance>
  </metadata>

  <problem>
    <description>
      Auth service fails to connect to PostgreSQL database when running in Docker containers
      with the error "Name or service not known". This occurs because the service uses
      'localhost' from the .env file, which doesn't resolve to the PostgreSQL container
      within the Docker network.
    </description>
    
    <error_signature>
      socket.gaierror: [Errno -2] Name or service not known
      RuntimeError: Database connection failed: [Errno -2] Name or service not known
    </error_signature>
    
    <root_cause>
      When services run inside Docker containers, they must use Docker service names
      (e.g., 'postgres') instead of 'localhost' to communicate with other containers
      in the same Docker network. The .env file is configured for local development
      with localhost, causing hostname resolution failures in Docker context.
    </root_cause>
  </problem>

  <solution>
    <approach>
      Implement automatic Docker environment detection that overrides localhost
      hostnames with Docker service names when running inside containers.
      This only applies in development and test environments for safety.
    </approach>
    
    <implementation>
      <location>shared/database_url_builder.py::DatabaseURLBuilder</location>
      <detection_methods>
        <method>Check RUNNING_IN_DOCKER environment variable</method>
        <method>Check IS_DOCKER environment variable</method>
        <method>Check DOCKER_CONTAINER environment variable</method>
        <method>Check for /.dockerenv file existence</method>
        <method>Check /proc/self/cgroup for docker references</method>
      </detection_methods>
      
      <logic>
        1. Check if environment is 'development' or 'test'
        2. Only in dev/test: Detect if running in Docker using multiple indicators
        3. If in Docker and host is 'localhost' or '127.0.0.1':
           - Override with Docker service name ('postgres')
        4. Keep custom hostnames unchanged
        5. #removed-legacytakes precedence if set
        6. Production/staging environments use explicit configuration only
      </logic>
      
      <methods_added>
        <method>is_docker_environment() -> bool: Detects Docker using multiple indicators</method>
        <method>apply_docker_hostname_resolution(host: str) -> str: Applies hostname resolution with environment and host checks</method>
      </methods_added>
      
      <integration_points>
        <point>TCPBuilder.async_url: Applies Docker hostname resolution to TCP connections</point>
        <point>TCPBuilder.sync_url: Applies Docker hostname resolution to sync TCP connections</point>
        <point>TCPBuilder.async_url_psycopg: Applies Docker hostname resolution to psycopg connections</point>
        <point>TestBuilder.postgres_url: Applies Docker hostname resolution to test PostgreSQL connections</point>
      </integration_points>
    </implementation>
    
    <code_example><![CDATA[
# Implementation in DatabaseURLBuilder class
def is_docker_environment(self) -> bool:
    """Detect if running in Docker container using multiple indicators."""
    # Method 1: Check environment variables
    docker_env_vars = ["RUNNING_IN_DOCKER", "IS_DOCKER", "DOCKER_CONTAINER"]
    for var in docker_env_vars:
        if self.env.get(var) == "true":
            return True
    
    # Method 2: Check for .dockerenv file
    if os.path.exists("/.dockerenv"):
        return True
    
    # Method 3: Check /proc/self/cgroup for docker references
    try:
        if os.path.exists("/proc/self/cgroup"):
            with open("/proc/self/cgroup", "r") as f:
                content = f.read()
                if "docker" in content.lower():
                    return True
    except (OSError, IOError):
        pass
    
    return False

def apply_docker_hostname_resolution(self, host: str) -> str:
    """Apply Docker hostname resolution if conditions are met."""
    # Only apply in development/test environments
    if self.environment not in ["development", "test"]:
        return host
    
    # Only override localhost/127.0.0.1 
    if host not in ["localhost", "127.0.0.1"]:
        return host
    
    # Check if running in Docker
    if self.is_docker_environment():
        logger.info(f"Detected Docker environment in {self.environment}, using 'postgres' as database host")
        return "postgres"
    
    return host

# Usage in TCPBuilder.async_url:
resolved_host = self.parent.apply_docker_hostname_resolution(self.parent.postgres_host)
return f"postgresql+asyncpg://{user}{password_part}@{resolved_host}:{port}/{db}"
    ]]></code_example>
  </solution>

  <testing>
    <test_file>auth_service/tests/unit/test_docker_hostname_resolution.py</test_file>
    <test_approach>Tests use DatabaseURLBuilder directly with mocked environment variables to verify Docker hostname resolution logic without interference from AuthEnvironment's test-specific SQLite behavior.</test_approach>
    <test_cases>
      <case>Docker detection via environment variables - RUNNING_IN_DOCKER=true</case>
      <case>Docker detection via .dockerenv file existence</case>
      <case>Docker detection via /proc/self/cgroup docker references</case>
      <case>Non-Docker environment keeps original hostname</case>
      <case>Custom hostnames not overridden in Docker</case>
      <case>#removed-legacyprecedence when set</case>
      <case>Docker hostname NOT applied in production environment</case>
      <case>Docker hostname NOT applied in staging environment</case>
    </test_cases>
    <test_status>All 8 tests passing</test_status>
  </testing>

  <best_practices>
    <practice>
      Always use service names (not localhost) in docker-compose.yml environment variables
    </practice>
    <practice>
      Implement multiple Docker detection methods for robustness
    </practice>
    <practice>
      Only override localhost/127.0.0.1; preserve custom hostnames
    </practice>
    <practice>
      Log hostname resolution decisions for debugging
    </practice>
    <practice>
      Provide #removed-legacyoverride for special cases
    </practice>
  </best_practices>

  <related_issues>
    <issue>
      Similar hostname resolution needed for Redis and ClickHouse connections
    </issue>
    <issue>
      Consider adding RUNNING_IN_DOCKER to Dockerfile ENV for explicit detection
    </issue>
    <issue>
      May need similar logic in netra_backend service
    </issue>
  </related_issues>

  <future_improvements>
    <improvement>
      Create shared utility for Docker environment detection across all services
    </improvement>
    <improvement>
      Add docker-compose override file for development with proper hostnames
    </improvement>
    <improvement>
      Consider using environment-specific .env files (.env.docker, .env.local)
    </improvement>
  </future_improvements>
</learning>