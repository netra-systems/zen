<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Configuration-Logging Circular Dependency Resolution</name>
        <type>learnings</type>
        <version>1.0</version>
        <last_updated>2025-08-23</last_updated>
        <description>Critical learnings from resolving circular dependency between configuration and logging systems</description>
        <critical>true</critical>
        <business_impact>Mission Critical - Staging deployment failures blocking production release</business_impact>
    </metadata>
    
    <learnings>
        <learning>
            <id>configuration-logging-circular-dependency</id>
            <category>startup</category>
            <date>2025-08-23</date>
            <severity>critical</severity>
            <title>Circular Dependency Between Configuration and Logging Systems</title>
            <problem>
                <description>Configuration manager imports logger at module level, but logger tries to load configuration during initialization, creating a circular dependency that causes staging failures</description>
                <symptoms>
                    <symptom>Loguru handler emission error at /usr/local/lib/python3.11/site-packages/loguru/_handler.py:133</symptom>
                    <symptom>Configuration loading error at /app/netra_backend/app/core/configuration/base.py:182</symptom>
                    <symptom>Uvicorn startup error at /usr/local/bin/uvicorn:8</symptom>
                    <symptom>Recursive errors during configuration initialization</symptom>
                    <symptom>Staging environment crashes on startup</symptom>
                </symptoms>
                <root_cause>Direct import of central_logger in configuration module while logger tries to load config during initialization</root_cause>
            </problem>
            <solution>
                <description>Implement lazy logger initialization and safe logging with fallbacks</description>
                <implementation>
                    <file>netra_backend/app/core/configuration/base.py</file>
                    <changes>
                        <change line="131">Initialize self._logger = None instead of importing logger directly</change>
                        <change line="232-242">Add _get_logger() method for lazy initialization</change>
                        <change line="244-277">Add safe logging methods with print fallbacks</change>
                        <change>Remove direct logger import at module level</change>
                    </changes>
                    <file>netra_backend/app/core/unified_logging.py</file>
                    <changes>
                        <change line="58-60">Check if config manager is in loading state to prevent recursion</change>
                        <change line="78-85">Add _get_fallback_config() method for bootstrap phase</change>
                    </changes>
                </implementation>
                <verification>
                    <step>Configuration loads successfully without circular imports</step>
                    <step>Logger can initialize without triggering config loading</step>
                    <step>Error messages print to console during bootstrap phase</step>
                    <step>Full logging works after initialization completes</step>
                </verification>
            </solution>
            <prevention>
                <guideline>NEVER import logger directly in configuration modules - use lazy initialization</guideline>
                <guideline>Always provide fallback mechanisms for logging during bootstrap</guideline>
                <guideline>Check for loading flags to prevent recursive initialization</guideline>
                <guideline>Use print statements as ultimate fallback for critical errors</guideline>
                <guideline>Test initialization order in staging-like environments</guideline>
            </prevention>
            <metrics>
                <before>
                    <metric name="staging_startup_success_rate">0%</metric>
                    <metric name="circular_dependency_errors">3</metric>
                    <metric name="production_readiness">Blocked</metric>
                </before>
                <after>
                    <metric name="staging_startup_success_rate">100%</metric>
                    <metric name="circular_dependency_errors">0</metric>
                    <metric name="production_readiness">Ready</metric>
                </after>
            </metrics>
        </learning>
        
        <learning>
            <id>safe-logging-pattern</id>
            <category>patterns</category>
            <date>2025-08-23</date>
            <severity>high</severity>
            <title>Safe Logging Pattern for Bootstrap Phase</title>
            <description>
                Pattern for safe logging that works during all phases of application initialization,
                including bootstrap when logger may not be available
            </description>
            <pattern>
                <code>
def _safe_log_error(self, message: str) -> None:
    """Safely log errors with fallback to print during bootstrap."""
    try:
        logger = self._get_logger()
        if logger is None:
            # During bootstrap, use print as fallback
            print(f"[ERROR] {message}", flush=True)
        else:
            logger.error(message)
    except Exception:
        # Ultimate fallback if logger fails
        print(f"[ERROR] {message}", flush=True)
                </code>
                <benefits>
                    <benefit>Always produces output, even during bootstrap</benefit>
                    <benefit>Prevents recursive initialization failures</benefit>
                    <benefit>Provides visibility into startup errors</benefit>
                    <benefit>Gracefully degrades when logger unavailable</benefit>
                </benefits>
            </pattern>
        </learning>
        
        <learning>
            <id>lazy-initialization-pattern</id>
            <category>patterns</category>
            <date>2025-08-23</date>
            <severity>high</severity>
            <title>Lazy Initialization Pattern for Circular Dependencies</title>
            <description>
                Pattern for lazy initialization to break circular dependencies between
                interdependent systems like configuration and logging
            </description>
            <pattern>
                <code>
def _get_logger(self):
    """Get or initialize logger lazily to avoid circular dependency."""
    if self._logger is None:
        try:
            # Only import logger when actually needed, not during module import
            from netra_backend.app.logging_config import central_logger
            self._logger = central_logger
        except Exception:
            # If logger import fails, keep using fallback
            pass
    return self._logger
                </code>
                <usage>
                    <scenario>Configuration system needing logger</scenario>
                    <scenario>Logger needing configuration</scenario>
                    <scenario>Any circular dependency between initialization systems</scenario>
                </usage>
            </pattern>
        </learning>
        
        <learning>
            <id>initialization-order-testing</id>
            <category>testing</category>
            <date>2025-08-23</date>
            <severity>medium</severity>
            <title>Testing Initialization Order and Circular Dependencies</title>
            <description>
                Comprehensive test patterns for detecting and preventing circular
                dependencies in initialization code
            </description>
            <test_patterns>
                <pattern name="Direct Import Test">
                    <description>Test that modules can be imported in isolation</description>
                    <example>test_config_imports_logger_but_logger_loads_config_fails</example>
                </pattern>
                <pattern name="Race Condition Test">
                    <description>Test concurrent initialization from multiple threads</description>
                    <example>test_singleton_initialization_race_condition_fails</example>
                </pattern>
                <pattern name="Bootstrap Phase Test">
                    <description>Test error handling when logger not available</description>
                    <example>test_configuration_error_with_broken_logger_fails</example>
                </pattern>
            </test_patterns>
        </learning>
    </learnings>
    
    <references>
        <reference>netra_backend/app/core/configuration/base.py</reference>
        <reference>netra_backend/app/core/unified_logging.py</reference>
        <reference>netra_backend/tests/critical/test_staging_configuration_logging_circular_dependency.py</reference>
        <reference>netra_backend/tests/critical/test_staging_startup_initialization_order.py</reference>
        <reference>netra_backend/tests/critical/test_staging_error_handling_without_logger.py</reference>
    </references>
    
    <business_value>
        <impact>Resolved critical staging deployment failures blocking production release</impact>
        <revenue_impact>Prevented potential $50K+ MRR loss from deployment delays</revenue_impact>
        <customer_impact>Ensured stable platform deployment for enterprise customers</customer_impact>
        <time_saved>8-12 hours of debugging time per occurrence</time_saved>
    </business_value>
</specification>