<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <title>Authentication State Race Condition During Initialization</title>
  <id>auth-state-race-condition-2025-08-31</id>
  <date>2025-08-31</date>
  <severity>CRITICAL</severity>
  <category>authentication</category>
  <tags>
    <tag>frontend</tag>
    <tag>auth-context</tag>
    <tag>race-condition</tag>
    <tag>state-management</tag>
    <tag>react</tag>
  </tags>
  
  <problem>
    <description>
      Critical authentication state inconsistency where hasToken=true but hasUser=false
      during auth context initialization, causing chat failures and user experience issues.
    </description>
    
    <symptoms>
      <symptom>Error logs showing "[AUTH VALIDATION] Token without user detected"</symptom>
      <symptom>Chat initialization failures in staging environment</symptom>
      <symptom>monitorAuthState detecting critical bug on auth_init_complete</symptom>
      <symptom>Users appearing logged out despite having valid tokens</symptom>
    </symptoms>
    
    <root_cause>
      React state updates are asynchronous. When fetchAuthConfig calls setUser(decodedUser),
      the state doesn't update immediately. The finally block then calls monitorAuthState
      with the OLD user value (null) but the NEW token value, creating an inconsistent state.
    </root_cause>
    
    <code_location>
      <file>frontend/auth/context.tsx</file>
      <function>fetchAuthConfig</function>
      <lines>220-386</lines>
    </code_location>
  </problem>
  
  <solution>
    <approach>
      Track the actual values being set in local variables within the fetchAuthConfig
      function, then pass these tracked values to monitorAuthState instead of relying
      on React state values which haven't updated yet.
    </approach>
    
    <implementation>
      <![CDATA[
      // Before fix - using stale state values:
      finally {
        setLoading(false);
        setInitialized(true);
        monitorAuthState(token, user, true, 'auth_init_complete'); // user is stale!
      }
      
      // After fix - using tracked actual values:
      const fetchAuthConfig = useCallback(async () => {
        let actualUser: User | null = null;
        let actualToken: string | null = token;
        
        try {
          // ... auth logic ...
          if (storedToken) {
            const decodedUser = jwtDecode(storedToken) as User;
            setUser(decodedUser);
            actualUser = decodedUser; // Track what we're setting
            actualToken = storedToken;
          }
        } finally {
          setLoading(false);
          setInitialized(true);
          monitorAuthState(actualToken, actualUser, true, 'auth_init_complete'); // Use tracked values
        }
      }, [/* deps */]);
      ]]>
    </implementation>
    
    <key_insights>
      <insight>
        React setState is asynchronous and batched - never assume state has updated
        immediately after calling setState
      </insight>
      <insight>
        When monitoring or validating state during initialization, use local variables
        to track what values are being set rather than relying on state values
      </insight>
      <insight>
        Auth state consistency is CRITICAL for chat functionality - any mismatch
        between token and user can break the entire user experience
      </insight>
    </key_insights>
  </solution>
  
  <similar_patterns_to_check>
    <pattern>
      <location>Any useEffect or callback that sets multiple related state values</location>
      <risk>State dependencies being out of sync during updates</risk>
    </pattern>
    <pattern>
      <location>WebSocket connection handlers that rely on auth state</location>
      <risk>WebSocket might connect with partial auth state</risk>
    </pattern>
    <pattern>
      <location>Token refresh handlers</location>
      <risk>Similar race conditions during token refresh cycles</risk>
    </pattern>
  </similar_patterns_to_check>
  
  <prevention>
    <guideline>
      Always track actual values being set when multiple related state updates occur
    </guideline>
    <guideline>
      Use local variables to capture the "next state" when validation is needed
      immediately after state updates
    </guideline>
    <guideline>
      Consider using useReducer for complex state updates that must be atomic
    </guideline>
    <guideline>
      Add comprehensive auth state validation at critical points in the application
    </guideline>
  </prevention>
  
  <testing_requirements>
    <requirement>Test auth context initialization with existing token in localStorage</requirement>
    <requirement>Test race conditions during rapid token updates</requirement>
    <requirement>Test monitoring functions receive consistent state</requirement>
    <requirement>Test WebSocket connections only establish with valid auth state</requirement>
  </testing_requirements>
</learning>