<?xml version='1.0' encoding='utf-8'?>
<learnings>
  <metadata>
    <category>WebSockets</category>
    <last_updated>2025-08-22</last_updated>
    <last_edited>2025-08-22T10:00:00</last_edited>
    <critical>true</critical>
    <business_impact>Critical - Real-time functionality depends on WebSocket stability</business_impact>
  </metadata>
  <learning id="websocket-jwt-subprotocol-encoding">
    <title>JWT Token Encoding for WebSocket Subprotocols</title>
    <description>
            WebSocket subprotocol names have strict character restrictions per RFC 6455.
            JWT tokens contain characters (spaces, dots, special chars) that are invalid for subprotocols.
        </description>
    <problem>
            Browser error: "SyntaxError: Failed to construct 'WebSocket': The subprotocol 'jwt.Bearer eyJhbG...' is invalid"
            JWT tokens with Bearer prefix and base64 encoding contain invalid characters for subprotocol names.
        </problem>
    <solution>
            1. Frontend: Base64URL encode the JWT token before using as subprotocol
            2. Backend: Decode the base64URL-encoded token when receiving
            3. Use standard subprotocol name 'jwt-auth' alongside encoded token
        </solution>
    <implementation>
            Frontend (webSocketService.ts):
            - Remove Bearer prefix from token
            - Base64URL encode: btoa(token).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '')
            - Send as: ['jwt-auth', 'jwt.encodedToken']
            
            Backend (websocket_secure.py):
            - Detect jwt. prefix in subprotocol
            - Decode base64URL back to original JWT
            - Validate decoded token with auth service
        </implementation>
    <files_changed>
      <file>frontend/services/webSocketService.ts:557-570</file>
      <file>app/routes/websocket_secure.py:123-151</file>
      <file>app/routes/websocket_secure.py:587-600</file>
    </files_changed>
    <testing>
            Integration tests required for:
            - Valid JWT encoding/decoding
            - Invalid token rejection
            - Malformed encoding handling
            - Subprotocol negotiation
        </testing>
  </learning>
  <learning id="websocket-subprotocol-restrictions">
    <title>WebSocket Subprotocol Character Restrictions</title>
    <description>
            RFC 6455 restricts subprotocol names to ASCII printable characters excluding specific chars.
            Cannot use raw JWT tokens or any strings with spaces/special characters.
        </description>
    <allowed_characters>
            Letters (a-z, A-Z), digits (0-9), and limited punctuation: !#$%&amp;'*+-.^_`|~
        </allowed_characters>
    <forbidden_characters>
            Spaces, commas, semicolons, equals signs, forward slashes, backslashes, quotes
        </forbidden_characters>
    <best_practice>
            Always encode complex data (JWTs, URLs, etc.) using base64URL before using as subprotocol
        </best_practice>
  </learning>
  <learning id="websocket-auth-methods">
    <title>WebSocket Authentication Methods Priority</title>
    <description>
            Multiple authentication methods for WebSocket connections with fallback strategy
        </description>
    <priority_order>
            1. Authorization header (preferred but not always available in browsers)
            2. Subprotocol with encoded JWT (browser-compatible)
            3. Never use query parameters (security risk)
        </priority_order>
    <browser_limitations>
            Browser WebSocket API doesn't support custom headers directly.
            Must use subprotocol or cookies for authentication.
        </browser_limitations>
  </learning>
  
  <learning id="websocket-route-registration-cold-start">
    <title>WebSocket Route Registration Critical for Cold Start</title>
    <description>
            WebSocket endpoints must be properly registered during application startup.
            Missing route registration causes complete WebSocket functionality failure.
        </description>
    <problem>
            Backend starts successfully but WebSocket connections fail with 404 errors.
            Frontend cannot establish real-time connections to backend.
        </problem>
    <root_cause>
            WebSocket routes not registered in FastAPI application factory.
            Route modules not imported during app initialization.
        </root_cause>
    <solution>
            1. Create comprehensive WebSocket route module
            2. Register routes in app factory configuration
            3. Implement multiple WebSocket endpoint patterns for compatibility
        </solution>
    <implementation>
            Files created/modified:
            - netra_backend/app/routes/websocket.py: Main WebSocket endpoints
            - netra_backend/app/core/app_factory_route_imports.py: Route imports
            - netra_backend/app/core/app_factory_route_configs.py: Route configuration
            
            Endpoints implemented:
            - /ws: Main WebSocket endpoint
            - /ws/{user_id}: User-specific WebSocket
            - /ws/{user_id}: Versioned WebSocket API
            - /ws/config: WebSocket configuration endpoint
            - /ws/info: WebSocket information endpoint
        </implementation>
    <testing>
            - Test WebSocket connection to /ws endpoint
            - Verify authentication protection (403 without valid token)
            - Check all WebSocket endpoints respond correctly
            - Validate WebSocket upgrade headers
        </testing>
    <prevention>
            - Always register WebSocket routes in app factory
            - Test WebSocket connectivity in cold start validation
            - Include WebSocket endpoints in health checks
            - Document WebSocket endpoint patterns clearly
        </prevention>
  </learning>
  
  <learning id="websocket-authentication-protection">
    <title>WebSocket Authentication Protection in Cold Start</title>
    <description>
            WebSocket endpoints must be properly protected with authentication.
            Unauthenticated connections should be rejected with clear error messages.
        </description>
    <problem>
            WebSocket connections were accessible without authentication.
            Security vulnerability allowing unauthorized real-time access.
        </problem>
    <solution>
            1. Implement JWT token validation for WebSocket connections
            2. Return 403 Forbidden for unauthenticated connections
            3. Support multiple authentication methods (header, subprotocol)
        </solution>
    <implementation>
            Authentication methods supported:
            - Authorization header with Bearer token
            - Subprotocol with base64URL-encoded JWT
            - Fallback to query parameter (development only)
            
            Error handling:
            - 403 Forbidden for missing/invalid tokens
            - Clear error messages for debugging
            - Proper WebSocket close codes
        </implementation>
    <verification>
            - Unauthenticated connections rejected with 403
            - Valid tokens allow successful connections
            - Invalid tokens properly rejected
            - Error messages provide clear feedback
        </verification>
  </learning>
  
  <learning id="websocket-cors-dynamic-ports">
    <title>WebSocket CORS Configuration for Dynamic Development Ports</title>
    <description>
            WebSocket connections require proper CORS configuration that supports
            dynamic port allocation during development.
        </description>
    <problem>
            WebSocket connections blocked by CORS policies in development.
            Dynamic port allocation not supported by static CORS configuration.
        </problem>
    <solution>
            Enhanced DynamicCORSMiddleware with:
            - Service discovery integration
            - Dynamic localhost port pattern matching
            - Cached regex patterns for performance
            - Environment-specific CORS rules
        </solution>
    <implementation>
            File: auth_service/main.py (lines 246-350)
            Features:
            - Automatic port discovery from .service_discovery/*.json
            - Cached pattern compilation for performance
            - Support for localhost:* patterns
            - WebSocket-specific headers (Upgrade, Connection)
        </implementation>
    <testing>
            - Test WebSocket connections from dynamic frontend ports
            - Verify CORS headers include WebSocket-specific values
            - Check pattern caching works correctly
            - Validate environment-specific behavior
        </testing>
  </learning>
  
  <learning id="websocket-frontend-configuration">
    <title>Frontend WebSocket Configuration Alignment</title>
    <description>
            Frontend WebSocket configuration must align with backend endpoint patterns
            and authentication requirements.
        </description>
    <problem>
            Frontend WebSocket URLs not matching backend endpoint configuration.
            Authentication token passing not working correctly.
        </problem>
    <solution>
            1. Simplified WebSocket URL to /ws for consistency
            2. Updated authentication token handling
            3. Aligned with service discovery port allocation
        </solution>
    <implementation>
            File: frontend/.env.local
            Changes:
            - WebSocket URL simplified to /ws
            - Removed complex versioned URL patterns
            - Aligned with backend port configuration
            
            Authentication:
            - Base64URL encode JWT tokens for subprotocol
            - Support Authorization header when available
            - Graceful fallback for different auth methods
        </implementation>
    <verification>
            - Frontend can establish WebSocket connections
            - Authentication tokens passed correctly
            - Dynamic port changes handled automatically
            - Connection persistence works across page reloads
        </verification>
  </learning>
  
  <learning id="websocket-cold-start-testing">
    <title>WebSocket Testing in Cold Start Validation</title>
    <description>
            WebSocket functionality must be validated as part of cold start testing
            to ensure real-time features work correctly.
        </description>
    <test_scenarios>
            1. WebSocket endpoint accessibility
            2. Authentication protection verification
            3. Connection establishment and persistence
            4. Message exchange functionality
            5. Graceful connection closure
        </test_scenarios>
    <implementation>
            Test scripts:
            - test_websocket_simple.py: Basic connectivity test
            - test_websocket_auth.py: Authentication flow test
            - Integration with e2e test suite
        </implementation>
    <critical_validation>
            - WebSocket upgrade succeeds with valid auth
            - Unauthenticated connections properly rejected
            - Real-time message exchange works
            - Connection handling is stable
        </critical_validation>
  </learning>
  
  <learning id="websocket-connection-manager-backward-compatibility" date="2025-08-23" severity="HIGH">
    <title>WebSocket ConnectionManager Backward Compatibility Requirements</title>
    <problem>
        WebSocket ConnectionManager refactoring broke existing tests expecting old interface.
        Tests failing because ConnectionManager was renamed to ModernConnectionManager
        but tests still importing and mocking the old ConnectionManager class.
    </problem>
    <root_cause>
        Major refactoring renamed ConnectionManager to ModernConnectionManager for clarity
        but didn't maintain backward compatibility layer for existing test infrastructure.
        35+ test files were importing and mocking ConnectionManager directly.
    </root_cause>
    <solution>
        Implemented comprehensive backward compatibility strategy:
        1. Added ConnectionManager alias that points to ModernConnectionManager
        2. Created get_connection_manager() factory function for consistent access
        3. Updated all test imports to use new patterns systematically
        4. Maintained interface stability while allowing internal refactoring
    </solution>
    <implementation>
        Backward Compatibility Layer:
        
        # netra_backend/app/core/websocket/connection_manager.py
        from .modern_connection_manager import ModernConnectionManager
        
        # Backward compatibility alias
        ConnectionManager = ModernConnectionManager
        
        def get_connection_manager():
            """Factory function for consistent ConnectionManager access"""
            return ModernConnectionManager()
        
        Test Update Pattern:
        OLD: from netra_backend.app.core.websocket.connection_manager import ConnectionManager
        NEW: from netra_backend.app.core.websocket.connection_manager import get_connection_manager
        
        Mock Update Pattern:
        OLD: @patch('netra_backend.app.core.websocket.connection_manager.ConnectionManager')
        NEW: @patch('netra_backend.app.core.websocket.connection_manager.ModernConnectionManager')
    </implementation>
    <interface_stability>
        Key principles for WebSocket interface evolution:
        
        1. MAINTAIN backward compatibility during major refactoring
        2. USE factory functions to abstract instantiation details
        3. PROVIDE aliases for renamed classes during transition period
        4. UPDATE tests systematically rather than breaking compatibility
        5. DOCUMENT interface changes clearly in migration guides
        
        Interface contract preservation:
        - Same method signatures maintained
        - Same connection lifecycle behavior  
        - Same event handling patterns
        - Same error conditions and responses
    </interface_stability>
    <migration_strategy>
        Three-phase migration approach:
        
        Phase 1: Add compatibility layer (DONE)
        - Create aliases for renamed classes
        - Add factory functions for access
        - Maintain full backward compatibility
        
        Phase 2: Systematic test updates (DONE)  
        - Update imports to use new patterns
        - Fix mock specifications
        - Validate all tests pass
        
        Phase 3: Deprecation warnings (FUTURE)
        - Add deprecation warnings for old patterns
        - Document migration path clearly
        - Plan removal timeline for deprecated interfaces
    </migration_strategy>
    <files_affected>
        <file>netra_backend/app/core/websocket/connection_manager.py</file>
        <file>netra_backend/tests/websocket/test_connection_manager.py</file>
        <file>35+ test files using WebSocket ConnectionManager</file>
    </files_affected>
    <verification>
        All WebSocket ConnectionManager tests pass
        Backward compatibility maintained for existing code
        New code can use modern interface patterns
        No breaking changes for dependent modules
    </verification>
    <prevention>
        Plan backward compatibility before major refactoring
        Use factory patterns to abstract implementation details
        Update tests systematically rather than breaking interfaces
        Document interface changes with clear migration paths
        Test both old and new interface patterns during transition
    </prevention>
    <business_impact>
        Development Velocity: No time lost to broken WebSocket tests
        System Stability: WebSocket functionality remains uninterrupted
        Technical Debt: Clean migration path prevents accumulation
        Developer Experience: Smooth transition without breaking changes
    </business_impact>
  </learning>
  
  <learning id="websocket-test-compatibility-considerations" date="2025-08-23" severity="MEDIUM">
    <title>WebSocket Test Compatibility Considerations</title>
    <problem>
        WebSocket tests require special consideration for interface stability
        because they often involve complex async patterns, connection lifecycle
        management, and real-time message handling that can be brittle.
    </problem>
    <solution>
        Established WebSocket test compatibility patterns:
        
        1. INTERFACE ABSTRACTION: Use factory functions instead of direct class imports
        2. LIFECYCLE MOCKING: Provide complete connection lifecycle simulation
        3. MESSAGE PATTERN CONSISTENCY: Maintain message format compatibility
        4. ERROR HANDLING COMPATIBILITY: Preserve error condition behavior
        5. ASYNC PATTERN CONSISTENCY: Maintain async/await patterns
    </solution>
    <patterns>
        Factory Pattern for Tests:
        # Use factory instead of direct instantiation
        connection_manager = get_connection_manager()
        
        Mock Lifecycle Completeness:
        mock_manager = Mock()
        mock_manager.connect = AsyncMock()
        mock_manager.disconnect = AsyncMock() 
        mock_manager.send_message = AsyncMock()
        mock_manager.is_connected = Mock(return_value=True)
        
        Message Format Consistency:
        # Maintain same message structure across versions
        message = {
            "type": "chat_message",
            "content": "test message",
            "timestamp": datetime.now().isoformat()
        }
        
        Error Handling Preservation:
        # Same exception types and error conditions
        with pytest.raises(ConnectionError):
            await connection_manager.connect_invalid()
    </patterns>
    <verification>
        WebSocket tests pass across different ConnectionManager versions
        Message handling behavior consistent across implementations
        Error conditions preserved during refactoring
        Async patterns work correctly in all test scenarios
    </verification>
    <best_practices>
        Test WebSocket refactoring thoroughly before deployment
        Maintain message format compatibility across versions
        Use factory patterns to abstract implementation details
        Preserve error handling behavior during interface changes
        Document WebSocket interface contracts clearly
    </best_practices>
  </learning>
</learnings>