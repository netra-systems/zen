<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <metadata>
    <title>ToolRegistry Duplicate Registration - BaseModel as Tools Issue</title>
    <date>2025-01-09</date>
    <severity>CRITICAL</severity>
    <category>toolregistry,basemodel,websocket,architecture</category>
    <github_issue>110</github_issue>
  </metadata>

  <problem>
    <description>
      ToolRegistry was failing with "modelmetaclass already registered" errors, completely
      breaking WebSocket supervisor creation and agent message handling in GCP staging.
      Pydantic BaseModel classes were being incorrectly treated as executable tools.
    </description>
    <affected_user>105945141827451681156</affected_user>
    <error_location>
      - netra_backend/app/websocket_core/supervisor_factory.py:131
      - netra_backend/app/websocket_core/agent_handler.py:163
    </error_location>
    <symptoms>
      - WebSocket supervisor creation fails
      - Agent message handling blocked
      - "modelmetaclass already registered" errors
      - Complete chat functionality breakdown
    </symptoms>
  </problem>

  <root_causes>
    <cause priority="1">
      <title>Data Model Confusion</title>
      <description>
        Pydantic BaseModel classes (data schemas) were being incorrectly treated as
        executable tools due to insufficient type checking during tool discovery.
      </description>
    </cause>
    <cause priority="2">
      <title>Tool Identity Crisis</title>
      <description>
        Tools without proper 'name' attributes fall back to __class__.__name__.lower(),
        causing BaseModel's metaclass to generate "modelmetaclass" as the tool name.
      </description>
    </cause>
    <cause priority="3">
      <title>Registry Proliferation</title>
      <description>
        Multiple ToolRegistry instances created without coordination (11+ instantiation 
        points identified), leading to duplicate registration attempts.
      </description>
    </cause>
    <cause priority="4">
      <title>Lifecycle Management Gap</title>
      <description>
        No cleanup mechanism for WebSocket connection registries, causing resource
        accumulation and conflicts on reconnection.
      </description>
    </cause>
    <cause priority="5">
      <title>Concurrency Safety</title>
      <description>
        Race conditions in concurrent user scenarios where multiple WebSocket
        connections attempt to register the same malformed tool names.
      </description>
    </cause>
  </root_causes>

  <solution>
    <change file="universal_registry.py">
      <description>
        Added comprehensive BaseModel detection and filtering:
        - _is_basemodel_class_or_instance() method detects Pydantic models
        - _is_valid_tool() validates tool interface contracts
        - _generate_safe_tool_name() prevents dangerous metaclass fallbacks
        - Enhanced duplicate prevention with informative error messages
      </description>
    </change>
    <change file="supervisor_factory.py">
      <description>
        Added WebSocket registry tracking and cleanup:
        - Connection registry tracking using weak references
        - cleanup_websocket_registries() for proper resource management
        - Registry scoping with user-specific naming
      </description>
    </change>
    <change file="unified_tool_dispatcher.py">
      <description>
        Added graceful error handling:
        - Try/catch blocks for validation failures
        - Informative error messages for BaseModel rejections
        - System continues with valid tools if invalid ones rejected
      </description>
    </change>
  </solution>

  <testing>
    <test_strategy>
      - E2E tests for duplicate registration prevention in GCP staging
      - Integration tests for tool validation and lifecycle management  
      - Unit tests for BaseModel detection and filtering
      - Mission critical tests for complete chat functionality validation
    </test_strategy>
    <validation>
      Tests designed to FAIL in broken state with "modelmetaclass" errors,
      PASS after fixes with proper tool filtering and cleanup.
    </validation>
  </testing>

  <lessons_learned>
    <lesson priority="CRITICAL">
      Data models and executable tools must be strictly separated. Implement type
      checking at tool discovery to prevent schema classes being treated as tools.
    </lesson>
    <lesson priority="HIGH">
      Never use metaclass names as fallbacks for missing attributes. This creates
      unpredictable and duplicate identifiers across different classes.
    </lesson>
    <lesson priority="HIGH">
      WebSocket connection lifecycle requires explicit resource management.
      Registry cleanup must be paired with connection creation to prevent leaks.
    </lesson>
    <lesson priority="MEDIUM">
      Tool interface contracts must be validated at registration time, not
      just at execution time, to prevent invalid registrations.
    </lesson>
    <lesson priority="MEDIUM">
      Registry proliferation indicates architecture issues. Consider centralized
      registry management with proper scoping instead of multiple instances.
    </lesson>
  </lessons_learned>

  <prevention>
    <recommendation>
      Implement strict type checking in tool discovery. Only classes with proper
      tool interface (name attribute, execute method) should be registered.
    </recommendation>
    <recommendation>
      Add automated tests that attempt to register BaseModel classes as tools
      to catch similar issues early in development.
    </recommendation>
    <recommendation>
      Implement WebSocket connection lifecycle tests that validate resource
      cleanup on disconnect and reconnection scenarios.
    </recommendation>
    <recommendation>
      Consider architectural patterns that prevent registry proliferation,
      such as dependency injection or centralized registry management.
    </recommendation>
    <recommendation>
      Add monitoring for registry health and tool registration patterns
      to detect similar issues in production environments.
    </recommendation>
  </prevention>

  <business_impact>
    <before>
      - Complete chat functionality breakdown
      - Users unable to interact with agents
      - WebSocket connections failing
      - Critical business value lost
    </before>
    <after>
      - Chat functionality fully restored
      - Reliable WebSocket connections
      - Proper multi-user isolation
      - Business value protected
    </after>
  </business_impact>
</learning>