<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Frontend Learnings</name>
        <type>learnings</type>
        <version>1.0</version>
        <last_updated>2025-01-16</last_updated>
        <description>Frontend-specific learnings and troubleshooting patterns</description>
    </metadata>
    
    <learnings>
        <learning>
            <id>zustand-selector-infinite-loop</id>
            <date>2025-01-16</date>
            <category>State Management</category>
            <severity>critical</severity>
            <title>Zustand Selector Infinite Loop Prevention</title>
            
            <problem>
                <description>Creating new selector functions on every render causes infinite loops with useSyncExternalStore</description>
                <error_message>Error: The result of getSnapshot should be cached to avoid an infinite loop</error_message>
                <impact>Application crashes with infinite re-render loop</impact>
            </problem>
            
            <solution>
                <description>Use stable selector references with shallow comparison</description>
                <implementation>
                    <step>Define selector functions outside of components/hooks</step>
                    <step>Use zustand's shallow comparison for object selectors</step>
                    <step>Import shallow from 'zustand/shallow'</step>
                </implementation>
                <code_example>
// WRONG - Creates new selector on every render
const extractStoreData = () => {
  return useUnifiedChatStore((state) => ({
    activeThreadId: state.activeThreadId,
    isThreadLoading: state.isThreadLoading
  }));
};

// CORRECT - Stable selector with shallow comparison
import { shallow } from 'zustand/shallow';

const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

const extractStoreData = () => {
  return useUnifiedChatStore(storeSelector, shallow);
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Always define Zustand selectors outside of components or hooks</rule>
                <rule>Use shallow comparison when selecting multiple properties as an object</rule>
                <rule>Memoize complex selectors with useCallback if they must be inside components</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/hooks/useLoadingState.ts</file>
            </affected_files>
            
            <references>
                <reference>https://github.com/pmndrs/zustand#selecting-multiple-state-slices</reference>
                <reference>React useSyncExternalStore documentation</reference>
            </references>
        </learning>
        
        <learning>
            <id>zustand-hook-selector-inline</id>
            <date>2025-01-16</date>
            <category>State Management</category>
            <severity>critical</severity>
            <title>Zustand Hook Selector Must Be Called Inline</title>
            
            <problem>
                <description>Wrapping useStore hook call in a function causes getSnapshot infinite loop even with stable selector</description>
                <error_message>Error: The result of getSnapshot should be cached to avoid an infinite loop</error_message>
                <impact>Hook creates infinite render loop when selector is wrapped in function</impact>
            </problem>
            
            <solution>
                <description>Call useStore directly in component/hook without wrapper function</description>
                <implementation>
                    <step>Remove wrapper functions around useStore calls</step>
                    <step>Call useStore directly with selector and shallow</step>
                    <step>Keep selector definition stable outside hook</step>
                </implementation>
                <code_example>
// WRONG - Wrapper function causes infinite loop
const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

const extractStoreData = () => {
  return useUnifiedChatStore(storeSelector, shallow);
};

export const useLoadingState = () => {
  const storeData = extractStoreData(); // INFINITE LOOP!
  // ...
};

// CORRECT - Direct inline call
const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

export const useLoadingState = () => {
  const storeData = useUnifiedChatStore(storeSelector, shallow); // WORKS!
  // ...
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Never wrap useStore calls in functions within hooks</rule>
                <rule>Call useStore directly at the hook's top level</rule>
                <rule>Keep selector definitions outside component to maintain stability</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/hooks/useLoadingState.ts</file>
            </affected_files>
            
            <references>
                <reference>React Rules of Hooks - hooks must be called at top level</reference>
                <reference>useSyncExternalStore getSnapshot caching requirements</reference>
            </references>
        </learning>
        
        <learning>
            <id>zustand-selector-memoization</id>
            <date>2025-01-16</date>
            <category>State Management</category>
            <severity>critical</severity>
            <title>Zustand Selector Must Be Memoized for useSyncExternalStore</title>
            
            <problem>
                <description>Selectors passed to Zustand stores must have stable references to avoid getSnapshot infinite loops</description>
                <error_message>Error: The result of getSnapshot should be cached to avoid an infinite loop</error_message>
                <impact>Infinite re-render loop crashes application</impact>
            </problem>
            
            <solution>
                <description>Memoize selectors using useMemo to ensure stable references</description>
                <implementation>
                    <step>Define selector function outside component with proper typing</step>
                    <step>Use useMemo to memoize selector inside hook if needed</step>
                    <step>Always use shallow comparison for object selectors</step>
                    <step>Type selector parameter as UnifiedChatState not any</step>
                </implementation>
                <code_example>
// WRONG - Selector without proper typing
const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

export const useLoadingState = () => {
  const storeData = useUnifiedChatStore(storeSelector, shallow);
  // ...
};

// CORRECT - Properly typed and memoized selector
import type { UnifiedChatState } from '../types/store-types';

const storeSelector = (state: UnifiedChatState) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

export const useLoadingState = () => {
  const memoizedSelector = useMemo(() => storeSelector, []);
  const storeData = useUnifiedChatStore(memoizedSelector, shallow);
  // ...
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Always type selectors with proper store state type, never use any</rule>
                <rule>Memoize selectors with useMemo when passing to store hooks</rule>
                <rule>Use shallow comparison for all object-returning selectors</rule>
                <rule>Define selector functions outside components when possible</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/hooks/useLoadingState.ts</file>
                <file>frontend/hooks/useThreadSwitching.ts</file>
            </affected_files>
            
            <references>
                <reference>React 18 useSyncExternalStore requirements</reference>
                <reference>Zustand getSnapshot caching documentation</reference>
            </references>
        </learning>
        
        <learning>
            <id>zustand-individual-selectors-pattern</id>
            <date>2025-08-16</date>
            <category>State Management</category>
            <severity>critical</severity>
            <title>Use Individual Selectors Instead of Object Selectors</title>
            
            <problem>
                <description>Object-returning selectors create new references on every call causing infinite loops</description>
                <error_message>Error: The result of getSnapshot should be cached to avoid an infinite loop</error_message>
                <impact>Even with shallow comparison and memoization, object selectors can cause infinite loops</impact>
            </problem>
            
            <solution>
                <description>Use individual selectors for each piece of state instead of selecting multiple as an object</description>
                <implementation>
                    <step>Select each state property individually with separate useStore calls</step>
                    <step>Construct objects locally after selection if needed</step>
                    <step>This ensures React only re-renders when actual values change</step>
                    <step>Eliminates need for shallow comparison and complex memoization</step>
                </implementation>
                <code_example>
// PROBLEMATIC - Object selector (can cause infinite loops)
const storeSelector = (state: UnifiedChatState) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading,
  messages: state.messages,
  isProcessing: state.isProcessing
});

export const useLoadingState = () => {
  const storeData = useUnifiedChatStore(storeSelector, shallow); // CAN STILL LOOP!
  // ...
};

// RECOMMENDED - Individual selectors (no infinite loops)
export const useLoadingState = () => {
  // Select individual properties to avoid creating new objects
  const activeThreadId = useUnifiedChatStore(state => state.activeThreadId);
  const isThreadLoading = useUnifiedChatStore(state => state.isThreadLoading);
  const messages = useUnifiedChatStore(state => state.messages);
  const isProcessing = useUnifiedChatStore(state => state.isProcessing);
  
  // Create object locally if needed
  const storeData = {
    activeThreadId,
    isThreadLoading,
    messages,
    isProcessing
  };
  // ...
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Prefer individual selectors over object-returning selectors</rule>
                <rule>Each useStore call should select a single primitive or stable reference</rule>
                <rule>Construct objects locally after selection if grouping is needed</rule>
                <rule>This pattern completely avoids infinite loop issues</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/hooks/useLoadingState.ts</file>
                <file>frontend/hooks/useThreadSwitching.ts</file>
            </affected_files>
            
            <references>
                <reference>React useSyncExternalStore stable getSnapshot requirement</reference>
                <reference>Zustand performance best practices</reference>
            </references>
        </learning>
        
        <learning>
            <id>websocket-loading-state-transitions</id>
            <date>2025-08-16</date>
            <category>WebSocket/State Management</category>
            <severity>high</severity>
            <title>WebSocket Loading State Machine Transition Rules</title>
            
            <problem>
                <description>Chat UI stuck on "Loading chat..." even though WebSocket connected and backend sending data</description>
                <symptoms>
                    <symptom>WebSocket successfully connects to backend</symptom>
                    <symptom>Backend logs show successful connection and data transmission</symptom>
                    <symptom>Frontend receives WebSocket status OPEN</symptom>
                    <symptom>Chat UI remains stuck showing loading spinner with "Loading chat..." message</symptom>
                </symptoms>
                <root_cause>State machine transition rules too restrictive - INITIALIZING state could not transition directly to THREAD_READY when WebSocket already connected with active thread</root_cause>
                <impact>Users cannot interact with chat even though system fully operational</impact>
            </problem>
            
            <solution>
                <description>Allow direct state transitions from INITIALIZING to READY/THREAD_READY states when appropriate conditions met</description>
                <implementation>
                    <step>Modified getValidTransitions in loading-state-machine.ts to allow INITIALIZING -> THREAD_READY transition</step>
                    <step>Added INITIALIZING -> READY transition for when WebSocket already connected</step>
                    <step>Ensures state machine can handle hot-reload and pre-connected scenarios</step>
                </implementation>
                <code_example>
// BEFORE - Too restrictive transitions
const getValidTransitions = (state: ChatLoadingState): ChatLoadingState[] => {
  const transitions: Record<ChatLoadingState, ChatLoadingState[]> = {
    [ChatLoadingState.INITIALIZING]: [ChatLoadingState.CONNECTING, ChatLoadingState.ERROR],
    // Could not go directly to THREAD_READY from INITIALIZING
    // ...
  };
};

// AFTER - Flexible transitions for real-world scenarios
const getValidTransitions = (state: ChatLoadingState): ChatLoadingState[] => {
  const transitions: Record<ChatLoadingState, ChatLoadingState[]> = {
    [ChatLoadingState.INITIALIZING]: [
      ChatLoadingState.CONNECTING, 
      ChatLoadingState.ERROR,
      ChatLoadingState.READY,  // Allow direct to READY if already connected
      ChatLoadingState.THREAD_READY  // Allow direct to THREAD_READY if thread exists
    ],
    // ...
  };
};
                </code_example>
            </solution>
            
            <debugging_approach>
                <step>Added console logging to useLoadingState hook to track state values</step>
                <step>Monitored WebSocket connection status in browser DevTools</step>
                <step>Traced state machine transitions to identify blocked transition</step>
                <step>Compared currentState vs newState to find stuck state</step>
            </debugging_approach>
            
            <prevention>
                <rule>State machines should account for all possible initial conditions</rule>
                <rule>Consider hot-reload scenarios where components reinitialize with existing connections</rule>
                <rule>Allow flexible transitions for initialization states</rule>
                <rule>Add comprehensive logging for state transitions during development</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/utils/loading-state-machine.ts</file>
                <file>frontend/hooks/useLoadingState.ts</file>
                <file>frontend/components/chat/MainChat.tsx</file>
            </affected_files>
            
            <related_patterns>
                <pattern>WebSocket reconnection handling</pattern>
                <pattern>Component initialization with existing state</pattern>
                <pattern>State machine design for async operations</pattern>
            </related_patterns>
        </learning>
        </learning>
        
        <learning>
            <id>module-default-export-initialization</id>
            <date>2025-08-18</date>
            <category>Module System</category>
            <severity>critical</severity>
            <title>Default Export Module Initialization Runtime Error</title>
            
            <problem>
                <description>Default exports containing enum references cause runtime ReferenceError</description>
                <error_message>Runtime ReferenceError: MessageType is not defined</error_message>
                <location>types/registry.ts, types/shared/enums.ts</location>
                <impact>Application fails to start with runtime error</impact>
                <root_cause>Default export objects trying to reference imported enums before they are fully initialized in the module system</root_cause>
            </problem>
            
            <solution>
                <description>Remove default exports containing enum references, use named exports only</description>
                <implementation>
                    <step>Remove all default exports that reference imported enums</step>
                    <step>Use only named exports for enums and utilities</step>
                    <step>Ensure all consumers use named imports</step>
                </implementation>
                <code_example>
// WRONG - Default export with enum references
export default {
  MessageType,  // ReferenceError at runtime
  AgentStatus,
  WebSocketMessageType
};

// CORRECT - Named exports only
export {
  MessageType,
  AgentStatus,
  WebSocketMessageType
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Never use default exports containing imported enum references</rule>
                <rule>Prefer named exports for type modules</rule>
                <rule>Test module initialization order in development environment</rule>
            </prevention>
            
            <tags>
                <tag>module-system</tag>
                <tag>typescript</tag>
                <tag>runtime-error</tag>
                <tag>enums</tag>
            </tags>
        </learning>
    </learnings>
</specification>