<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Frontend Learnings</name>
        <type>learnings</type>
        <version>1.0</version>
        <last_updated>2025-01-16</last_updated>
        <description>Frontend-specific learnings and troubleshooting patterns</description>
    </metadata>
    
    <learnings>
        <learning>
            <id>zustand-selector-infinite-loop</id>
            <date>2025-01-16</date>
            <category>State Management</category>
            <severity>critical</severity>
            <title>Zustand Selector Infinite Loop Prevention</title>
            
            <problem>
                <description>Creating new selector functions on every render causes infinite loops with useSyncExternalStore</description>
                <error_message>Error: The result of getSnapshot should be cached to avoid an infinite loop</error_message>
                <impact>Application crashes with infinite re-render loop</impact>
            </problem>
            
            <solution>
                <description>Use stable selector references with shallow comparison</description>
                <implementation>
                    <step>Define selector functions outside of components/hooks</step>
                    <step>Use zustand's shallow comparison for object selectors</step>
                    <step>Import shallow from 'zustand/shallow'</step>
                </implementation>
                <code_example>
// WRONG - Creates new selector on every render
const extractStoreData = () => {
  return useUnifiedChatStore((state) => ({
    activeThreadId: state.activeThreadId,
    isThreadLoading: state.isThreadLoading
  }));
};

// CORRECT - Stable selector with shallow comparison
import { shallow } from 'zustand/shallow';

const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

const extractStoreData = () => {
  return useUnifiedChatStore(storeSelector, shallow);
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Always define Zustand selectors outside of components or hooks</rule>
                <rule>Use shallow comparison when selecting multiple properties as an object</rule>
                <rule>Memoize complex selectors with useCallback if they must be inside components</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/hooks/useLoadingState.ts</file>
            </affected_files>
            
            <references>
                <reference>https://github.com/pmndrs/zustand#selecting-multiple-state-slices</reference>
                <reference>React useSyncExternalStore documentation</reference>
            </references>
        </learning>
        
        <learning>
            <id>zustand-hook-selector-inline</id>
            <date>2025-01-16</date>
            <category>State Management</category>
            <severity>critical</severity>
            <title>Zustand Hook Selector Must Be Called Inline</title>
            
            <problem>
                <description>Wrapping useStore hook call in a function causes getSnapshot infinite loop even with stable selector</description>
                <error_message>Error: The result of getSnapshot should be cached to avoid an infinite loop</error_message>
                <impact>Hook creates infinite render loop when selector is wrapped in function</impact>
            </problem>
            
            <solution>
                <description>Call useStore directly in component/hook without wrapper function</description>
                <implementation>
                    <step>Remove wrapper functions around useStore calls</step>
                    <step>Call useStore directly with selector and shallow</step>
                    <step>Keep selector definition stable outside hook</step>
                </implementation>
                <code_example>
// WRONG - Wrapper function causes infinite loop
const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

const extractStoreData = () => {
  return useUnifiedChatStore(storeSelector, shallow);
};

export const useLoadingState = () => {
  const storeData = extractStoreData(); // INFINITE LOOP!
  // ...
};

// CORRECT - Direct inline call
const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

export const useLoadingState = () => {
  const storeData = useUnifiedChatStore(storeSelector, shallow); // WORKS!
  // ...
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Never wrap useStore calls in functions within hooks</rule>
                <rule>Call useStore directly at the hook's top level</rule>
                <rule>Keep selector definitions outside component to maintain stability</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/hooks/useLoadingState.ts</file>
            </affected_files>
            
            <references>
                <reference>React Rules of Hooks - hooks must be called at top level</reference>
                <reference>useSyncExternalStore getSnapshot caching requirements</reference>
            </references>
        </learning>
        
        <learning>
            <id>zustand-selector-memoization</id>
            <date>2025-01-16</date>
            <category>State Management</category>
            <severity>critical</severity>
            <title>Zustand Selector Must Be Memoized for useSyncExternalStore</title>
            
            <problem>
                <description>Selectors passed to Zustand stores must have stable references to avoid getSnapshot infinite loops</description>
                <error_message>Error: The result of getSnapshot should be cached to avoid an infinite loop</error_message>
                <impact>Infinite re-render loop crashes application</impact>
            </problem>
            
            <solution>
                <description>Memoize selectors using useMemo to ensure stable references</description>
                <implementation>
                    <step>Define selector function outside component with proper typing</step>
                    <step>Use useMemo to memoize selector inside hook if needed</step>
                    <step>Always use shallow comparison for object selectors</step>
                    <step>Type selector parameter as UnifiedChatState not any</step>
                </implementation>
                <code_example>
// WRONG - Selector without proper typing
const storeSelector = (state: any) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

export const useLoadingState = () => {
  const storeData = useUnifiedChatStore(storeSelector, shallow);
  // ...
};

// CORRECT - Properly typed and memoized selector
import type { UnifiedChatState } from '../types/store-types';

const storeSelector = (state: UnifiedChatState) => ({
  activeThreadId: state.activeThreadId,
  isThreadLoading: state.isThreadLoading
});

export const useLoadingState = () => {
  const memoizedSelector = useMemo(() => storeSelector, []);
  const storeData = useUnifiedChatStore(memoizedSelector, shallow);
  // ...
};
                </code_example>
            </solution>
            
            <prevention>
                <rule>Always type selectors with proper store state type, never use any</rule>
                <rule>Memoize selectors with useMemo when passing to store hooks</rule>
                <rule>Use shallow comparison for all object-returning selectors</rule>
                <rule>Define selector functions outside components when possible</rule>
            </prevention>
            
            <affected_files>
                <file>frontend/hooks/useLoadingState.ts</file>
                <file>frontend/hooks/useThreadSwitching.ts</file>
            </affected_files>
            
            <references>
                <reference>React 18 useSyncExternalStore requirements</reference>
                <reference>Zustand getSnapshot caching documentation</reference>
            </references>
        </learning>
    </learnings>
</specification>