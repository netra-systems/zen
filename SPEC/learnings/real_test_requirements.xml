<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Real Test Requirements</name>
        <type>learnings</type>
        <version>1.0</version>
        <created>2025-08-20</created>
        <last_updated>2025-08-20</last_updated>
        <business_impact>HIGH - Prevents $50K+ engineering waste on fake tests</business_impact>
        <tags>testing, quality, real-tests, anti-patterns</tags>
    </metadata>
    
    <overview>
        <description>
            Critical learnings about enforcing REAL test requirements to prevent the
            "frontend test paradox" - tests that test their own mocks instead of real functionality.
            
            Based on 2025-08-19 analysis that found extensive test files creating mock component
            implementations and then testing those mocks rather than real components.
        </description>
        
        <business_value_justification>
            <segment>Platform/Internal - All tiers benefit from test quality</segment>
            <business_goal>Prevent $50K+ engineering waste on fake tests</business_goal>
            <value_impact>Ensures tests actually validate functionality vs mocks</value_impact>
            <revenue_impact>Higher quality tests = fewer production bugs = customer retention</revenue_impact>
            <platform_stability>Real tests catch real bugs before customer impact</platform_stability>
        </business_value_justification>
        
        <problem_statement>
            Many test files violate the fundamental principle that tests should test REAL functionality.
            Common violations include:
            - Creating mock component implementations inside test files
            - Integration tests that mock all child components (defeating the purpose)
            - Overuse of jest.fn() and mock objects instead of testing real behavior
            - Tests that become circular - testing the test mocks instead of production code
        </problem_statement>
    </overview>
    
    <mandatory_rules>
        <rule id="no-mock-components" severity="CRITICAL">
            <title>No Mock Component Implementations</title>
            <description>
                Tests MUST NOT include their own mock component implementations.
                Test the real component or don't test at all.
            </description>
            <rationale>
                Creating mock components inside tests leads to circular testing where
                you're validating the mock instead of the real component behavior.
            </rationale>
            <examples>
                <violation>
                    // BAD: Mock component inside test file
                    const MockButton = ({ onClick, children }) => (
                        &lt;div data-testid="mock-button" onClick={onClick}&gt;{children}&lt;/div&gt;
                    );
                    
                    test('button click works', () => {
                        // This tests the mock, not the real Button component
                        render(&lt;MockButton onClick={mockClick}&gt;Click me&lt;/MockButton&gt;);
                    });
                </violation>
                <solution>
                    // GOOD: Test the real component
                    import { Button } from '../components/Button';
                    
                    test('button click works', () => {
                        // This tests the actual Button component
                        render(&lt;Button onClick={mockClick}&gt;Click me&lt;/Button&gt;);
                    });
                </solution>
            </examples>
        </rule>
        
        <rule id="real-child-components" severity="CRITICAL">
            <title>Integration Tests Use Real Child Components</title>
            <description>
                Integration tests MUST use real child components, not mock divs.
                Mocking all children defeats the purpose of integration testing.
            </description>
            <rationale>
                Integration tests verify that components work together correctly.
                If all children are mocked, you're not testing integration at all.
            </rationale>
            <examples>
                <violation>
                    // BAD: Integration test with all children mocked
                    jest.mock('../components/UserProfile', () => () => &lt;div&gt;Mock Profile&lt;/div&gt;);
                    jest.mock('../components/UserSettings', () => () => &lt;div&gt;Mock Settings&lt;/div&gt;);
                    jest.mock('../components/UserActivity', () => () => &lt;div&gt;Mock Activity&lt;/div&gt;);
                    
                    test('user dashboard integration', () => {
                        // This doesn't test real integration - everything is mocked
                        render(&lt;UserDashboard userId={123} /&gt;);
                    });
                </violation>
                <solution>
                    // GOOD: Integration test with real child components
                    // Only mock external APIs, not internal components
                    jest.mock('../services/api', () => ({
                        fetchUser: jest.fn(),
                        fetchActivity: jest.fn()
                    }));
                    
                    test('user dashboard integration', () => {
                        // This tests real component integration
                        render(&lt;UserDashboard userId={123} /&gt;);
                        // Tests that UserProfile, UserSettings, UserActivity work together
                    });
                </solution>
            </examples>
        </rule>
        
        <rule id="minimal-mocking" severity="HIGH">
            <title>Minimal Mocking - External APIs Only</title>
            <description>
                Mock ONLY external APIs and truly unavailable resources.
                WebSocket, state management, and UI components should be real.
                Maximum 30% of imports should be mocked.
            </description>
            <rationale>
                Over-mocking prevents tests from catching real integration issues
                and makes tests less valuable for regression detection.
            </rationale>
            <examples>
                <violation>
                    // BAD: Excessive mocking (>30% of imports)
                    jest.mock('../hooks/useAuth');
                    jest.mock('../hooks/useWebSocket');
                    jest.mock('../components/LoadingSpinner');
                    jest.mock('../components/ErrorBoundary');
                    jest.mock('../utils/formatDate');
                    jest.mock('../store/authStore');
                    jest.mock('../services/logger');
                    
                    // Only 2 real imports vs 7 mocked = 78% mocked (excessive)
                </violation>
                <solution>
                    // GOOD: Only mock external APIs
                    jest.mock('../services/api', () => ({
                        login: jest.fn(),
                        fetchUserData: jest.fn()
                    }));
                    
                    // Everything else is real - hooks, components, utils, store
                    // This tests the actual application behavior
                </solution>
            </examples>
        </rule>
        
        <rule id="test-size-limits" severity="MEDIUM">
            <title>Test Size Limits</title>
            <description>
                Test files MUST follow same 300-line limit as production code.
                Test functions MUST follow same 8-line limit as production code.
            </description>
            <rationale>
                Large test files and functions become unmaintainable and often
                indicate over-testing or poorly focused tests.
            </rationale>
            <examples>
                <violation>
                    test('complex user workflow', () => {
                        // BAD: 15+ line test function
                        const user = createMockUser();
                        const mockApi = jest.fn();
                        const component = render(&lt;UserWorkflow api={mockApi} /&gt;);
                        fireEvent.click(component.getByTestId('start-button'));
                        expect(mockApi).toHaveBeenCalledWith('start');
                        fireEvent.change(component.getByTestId('name-input'), { target: { value: 'John' } });
                        fireEvent.change(component.getByTestId('email-input'), { target: { value: 'john@example.com' } });
                        fireEvent.click(component.getByTestId('submit-button'));
                        expect(mockApi).toHaveBeenCalledWith('submit', { name: 'John', email: 'john@example.com' });
                        expect(component.getByTestId('success-message')).toBeVisible();
                        fireEvent.click(component.getByTestId('reset-button'));
                        expect(component.getByTestId('name-input')).toHaveValue('');
                        expect(component.getByTestId('email-input')).toHaveValue('');
                        // ... continues for 20+ lines
                    });
                </violation>
                <solution>
                    // GOOD: Focused tests â‰¤8 lines each
                    test('starts workflow on button click', () => {
                        const mockApi = jest.fn();
                        const component = render(&lt;UserWorkflow api={mockApi} /&gt;);
                        fireEvent.click(component.getByTestId('start-button'));
                        expect(mockApi).toHaveBeenCalledWith('start');
                    });
                    
                    test('submits form data', () => {
                        const mockApi = jest.fn();
                        const component = render(&lt;UserWorkflow api={mockApi} /&gt;);
                        fireEvent.change(component.getByTestId('name-input'), { target: { value: 'John' } });
                        fireEvent.click(component.getByTestId('submit-button'));
                        expect(mockApi).toHaveBeenCalledWith('submit', { name: 'John' });
                    });
                </solution>
            </examples>
        </rule>
        
        <rule id="fix-sut-not-tests" severity="HIGH">
            <title>Fix System Under Test, Not Tests</title>
            <description>
                When tests fail, fix the System Under Test (SUT) first.
                Only modify tests if the requirements genuinely changed.
            </description>
            <rationale>
                Tests are documentation of intended behavior. Changing tests to make
                them pass often hides real bugs or regressions.
            </rationale>
            <process>
                <step>1. Analyze WHY the test is failing</step>
                <step>2. Determine if the failure indicates a real bug</step>
                <step>3. Fix the production code to meet the test expectation</step>
                <step>4. Only change the test if requirements actually changed</step>
                <step>5. Document any test changes with justification</step>
            </process>
        </rule>
    </mandatory_rules>
    
    <test_pyramid_guidance>
        <level name="unit" percentage="20">
            <description>Test individual functions with minimal mocking</description>
            <mocking_rules>
                <rule>Mock external APIs only (HTTP requests, database calls)</rule>
                <rule>Do NOT mock internal functions or utilities</rule>
                <rule>Do NOT mock language features or third-party libraries</rule>
            </mocking_rules>
            <examples>
                <good>
                    // GOOD: Unit test with minimal mocking
                    test('calculateDiscount applies correct percentage', () => {
                        const result = calculateDiscount(100, 0.2);
                        expect(result).toBe(20);
                    });
                </good>
                <bad>
                    // BAD: Unit test that mocks the thing being tested
                    const mockCalculateDiscount = jest.fn().mockReturnValue(20);
                    jest.mock('../utils/calculateDiscount', () => mockCalculateDiscount);
                    
                    test('discount calculation works', () => {
                        const result = calculateDiscount(100, 0.2);
                        expect(result).toBe(20); // This tests the mock, not the real function
                    });
                </bad>
            </examples>
        </level>
        
        <level name="integration" percentage="60">
            <description>Test real component interactions with real child components</description>
            <mocking_rules>
                <rule>Mock ONLY external services and APIs</rule>
                <rule>Use real child components for integration testing</rule>
                <rule>Test actual data flow between components</rule>
            </mocking_rules>
            <examples>
                <good>
                    // GOOD: Integration test with real components
                    jest.mock('../services/userService', () => ({
                        fetchUser: jest.fn().mockResolvedValue({ name: 'John', email: 'john@test.com' })
                    }));
                    
                    test('user profile page displays user data', async () => {
                        render(&lt;UserProfilePage userId="123" /&gt;);
                        // Tests real UserProfile, UserAvatar, UserDetails components working together
                        await waitFor(() => {
                            expect(screen.getByText('John')).toBeInTheDocument();
                            expect(screen.getByText('john@test.com')).toBeInTheDocument();
                        });
                    });
                </good>
                <bad>
                    // BAD: Integration test with all components mocked
                    jest.mock('../components/UserProfile');
                    jest.mock('../components/UserAvatar');  
                    jest.mock('../components/UserDetails');
                    
                    test('user profile page works', () => {
                        render(&lt;UserProfilePage userId="123" /&gt;);
                        // This doesn't test integration at all - everything is mocked
                    });
                </bad>
            </examples>
        </level>
        
        <level name="e2e" percentage="20">
            <description>Test complete user flows with real backend</description>
            <mocking_rules>
                <rule>Mock ONLY external third-party APIs</rule>
                <rule>Use real database (test database)</rule>
                <rule>Use real authentication flow</rule>
                <rule>Test complete user journeys</rule>
            </mocking_rules>
            <examples>
                <good>
                    // GOOD: E2E test with real backend
                    test('user can complete signup flow', async () => {
                        // Uses real API, real database, real auth
                        await page.goto('/signup');
                        await page.fill('[data-testid="email"]', 'test@example.com');
                        await page.fill('[data-testid="password"]', 'password123');
                        await page.click('[data-testid="submit"]');
                        await page.waitForURL('/dashboard');
                        expect(await page.textContent('h1')).toBe('Welcome to Dashboard');
                    });
                </good>
            </examples>
        </level>
    </test_pyramid_guidance>
    
    <anti_patterns>
        <anti_pattern name="mock_everything">
            <title>The "Mock Everything" Pattern</title>
            <description>
                Tests that mock all dependencies, including internal components,
                resulting in tests that only validate mock behavior.
            </description>
            <why_bad>
                These tests provide false confidence and miss real integration bugs.
                They pass even when the real system is broken.
            </why_bad>
            <detection>
                <indicator>More than 30% of imports are mocked</indicator>
                <indicator>jest.mock() calls outnumber real imports</indicator>
                <indicator>Tests only verify mock.called, not actual outcomes</indicator>
            </detection>
        </anti_pattern>
        
        <anti_pattern name="circular_testing">
            <title>Circular Testing Pattern</title>
            <description>
                Tests create their own mock implementation of the system under test,
                then verify that the mock behaves as expected.
            </description>
            <why_bad>
                This creates a circular dependency where tests validate their own
                assumptions rather than real system behavior.
            </why_bad>
            <detection>
                <indicator>Mock implementations defined inside test files</indicator>
                <indicator>Tests that set mock return values then assert those same values</indicator>
                <indicator>Component mocks that reimplement the same logic</indicator>
            </detection>
        </anti_pattern>
        
        <anti_pattern name="integration_without_integration">
            <title>Fake Integration Testing</title>
            <description>
                Integration tests that mock all child components, defeating the
                entire purpose of integration testing.
            </description>
            <why_bad>
                These tests miss real integration issues like prop passing errors,
                component compatibility problems, and data flow issues.
            </why_bad>
            <detection>
                <indicator>Integration test files with jest.mock() for every child component</indicator>
                <indicator>Integration tests that only render mock divs</indicator>
                <indicator>No real component interaction being tested</indicator>
            </detection>
        </anti_pattern>
        
        <anti_pattern name="jest_fn_overuse">
            <title>jest.fn() Overuse Pattern</title>
            <description>
                Using jest.fn() for everything, including internal application logic
                that should be tested with real implementations.
            </description>
            <why_bad>
                Overuse of jest.fn() prevents tests from catching real bugs in
                the actual application logic.
            </why_bad>
            <detection>
                <indicator>More jest.fn() calls than actual assertions</indicator>
                <indicator>Mocking internal utility functions</indicator>
                <indicator>Replacing real event handlers with jest.fn()</indicator>
            </detection>
        </anti_pattern>
    </anti_patterns>
    
    <migration_guide>
        <title>Migrating from Mock-Heavy to Real Tests</title>
        
        <step_by_step>
            <step number="1">
                <title>Audit Current Tests</title>
                <action>Run real test linter to identify violations</action>
                <command>python scripts/compliance/real_test_linter.py</command>
                <expected_output>Report showing mock percentage and violations</expected_output>
            </step>
            
            <step number="2">
                <title>Identify External vs Internal Dependencies</title>
                <action>Categorize all mocked dependencies</action>
                <external_apis>HTTP requests, database calls, third-party services</external_apis>
                <internal_components>UI components, hooks, utilities, stores</internal_components>
                <rule>Keep external mocks, remove internal mocks</rule>
            </step>
            
            <step number="3">
                <title>Remove Mock Component Definitions</title>
                <action>Delete mock components created inside test files</action>
                <before>
                    const MockButton = () => &lt;div&gt;Mock Button&lt;/div&gt;;
                </before>
                <after>
                    import { Button } from '../components/Button';
                    // Use the real Button component
                </after>
            </step>
            
            <step number="4">
                <title>Convert Integration Tests to Use Real Components</title>
                <action>Remove jest.mock() calls for child components</action>
                <before>
                    jest.mock('../components/ChildComponent');
                    test('parent renders child', () => {
                        render(&lt;ParentComponent /&gt;);
                        // Only tests that mock div is rendered
                    });
                </before>
                <after>
                    // No mocking of child components
                    test('parent renders child', () => {
                        render(&lt;ParentComponent /&gt;);
                        // Tests real parent-child interaction
                        expect(screen.getByTestId('child-content')).toBeInTheDocument();
                    });
                </after>
            </step>
            
            <step number="5">
                <title>Replace jest.fn() with Real Event Handlers</title>
                <action>Use real event handlers unless testing handler itself</action>
                <before>
                    const mockClick = jest.fn();
                    render(&lt;Button onClick={mockClick} /&gt;);
                    fireEvent.click(button);
                    expect(mockClick).toHaveBeenCalled();
                </before>
                <after>
                    render(&lt;Button onClick={() =&gt; setClicked(true)} /&gt;);
                    fireEvent.click(button);
                    expect(clicked).toBe(true);
                </after>
            </step>
            
            <step number="6">
                <title>Validate with Test Runner</title>
                <action>Run comprehensive tests to ensure migrations work</action>
                <command>python -m test_framework.test_runner --level integration</command>
                <expected_outcome>Tests still pass but now test real functionality</expected_outcome>
            </step>
        </step_by_step>
        
        <common_challenges>
            <challenge name="slow_tests">
                <problem>Real components make tests slower</problem>
                <solution>
                    Use test utilities like React Testing Library's cleanup,
                    optimize test setup/teardown, run tests in parallel
                </solution>
            </challenge>
            
            <challenge name="complex_setup">
                <problem>Real components require more complex setup</problem>
                <solution>
                    Create reusable test fixtures and helper functions,
                    use proper test data factories
                </solution>
            </challenge>
            
            <challenge name="flaky_tests">
                <problem>Real components can make tests more flaky</problem>
                <solution>
                    Use proper waiting strategies (waitFor, findBy queries),
                    ensure proper cleanup between tests
                </solution>
            </challenge>
        </common_challenges>
    </migration_guide>
    
    <enforcement_tools>
        <tool name="real_test_linter">
            <path>scripts/compliance/real_test_linter.py</path>
            <purpose>Detect violations in development workflow</purpose>
            <usage>
                <command>python scripts/compliance/real_test_linter.py</command>
                <pre_commit>Use as pre-commit hook to prevent violations</pre_commit>
                <ci_cd>Integrate into CI pipeline for continuous validation</ci_cd>
            </usage>
            <features>
                <feature>Detects mock component definitions in test files</feature>
                <feature>Calculates mock percentage (flags >30%)</feature>
                <feature>Identifies integration tests with excessive mocking</feature>
                <feature>Checks test file and function size limits</feature>
                <feature>Provides auto-fix suggestions</feature>
            </features>
        </tool>
        
        <tool name="real_test_validator">
            <path>scripts/compliance/real_test_validator.py</path>
            <purpose>Comprehensive validation for CI/CD pipeline</purpose>
            <usage>
                <command>python scripts/compliance/real_test_validator.py</command>
                <ci_integration>Returns non-zero exit code for critical violations</ci_integration>
            </usage>
            <features>
                <feature>AST-based analysis for accurate detection</feature>
                <feature>Severity-based violation classification</feature>
                <feature>Detailed violation reports with line numbers</feature>
                <feature>Suggestions for fixing violations</feature>
            </features>
        </tool>
    </enforcement_tools>
    
    <metrics_and_monitoring>
        <metric name="mock_percentage">
            <description>Percentage of imports that are mocked in each test file</description>
            <target>Less than 30% for all test files</target>
            <tracking>Measured by real_test_linter across all test files</tracking>
        </metric>
        
        <metric name="critical_violations">
            <description>Number of critical real test requirement violations</description>
            <target>Zero critical violations in main branch</target>
            <tracking>Enforced by CI pipeline using real_test_validator</tracking>
        </metric>
        
        <metric name="test_authenticity_score">
            <description>Percentage of tests that test real functionality vs mocks</description>
            <calculation>
                (Tests with real assertions / Total tests) * 100
            </calculation>
            <target>Greater than 80%</target>
        </metric>
        
        <reporting>
            <dashboard>Include real test metrics in CI/CD dashboard</dashboard>
            <alerts>Alert on regression in real test requirements compliance</alerts>
            <trends>Track improvement in test authenticity over time</trends>
        </reporting>
    </metrics_and_monitoring>
    
    <success_criteria>
        <criterion name="zero_critical_violations">
            <description>No critical real test requirement violations in codebase</description>
            <measurement>real_test_validator returns 0 critical violations</measurement>
            <timeline>Immediate (must be maintained)</timeline>
        </criterion>
        
        <criterion name="mock_percentage_compliance">
            <description>All test files have less than 30% mocked imports</description>
            <measurement>real_test_linter reports <30% for all files</measurement>
            <timeline>2 weeks for existing violations</timeline>
        </criterion>
        
        <criterion name="no_mock_components_in_tests">
            <description>No mock component definitions exist in test files</description>
            <measurement>Zero mock_component violations detected</measurement>
            <timeline>1 week (high priority)</timeline>
        </criterion>
        
        <criterion name="integration_test_authenticity">
            <description>Integration tests use real child components</description>
            <measurement>Zero excessive_mocking violations in integration tests</measurement>
            <timeline>2 weeks</timeline>
        </criterion>
    </success_criteria>
    
    <related_specifications>
        <spec path="SPEC/testing.xml">
            <relationship>Parent specification defining overall testing strategy</relationship>
            <section>real_test_requirements section contains core rules</section>
        </spec>
        
        <spec path="SPEC/learnings/frontend_test_paradox.xml">
            <relationship>Analysis that identified the real test requirements problem</relationship>
            <context>Contains detailed examples of violations found in frontend tests</context>
        </spec>
        
        <spec path="SPEC/conventions.xml">
            <relationship>Defines code quality standards including function/file size limits</relationship>
            <application>Real test requirements enforce same limits for test code</application>
        </spec>
    </related_specifications>
    
    <implementation_notes>
        <note type="priority">
            Critical violations (mock components, excessive integration mocking) must be
            fixed immediately as they provide false test confidence.
        </note>
        
        <note type="gradual_migration">
            For large codebases, implement real test requirements gradually:
            1. Fix critical violations first
            2. Focus on new tests meeting requirements
            3. Gradually migrate existing tests during regular maintenance
        </note>
        
        <note type="team_education">
            Ensure development team understands why real tests matter:
            - Run team training on real vs fake testing
            - Code review guidelines should check for real test compliance
            - Celebrate examples of good real test implementations
        </note>
    </implementation_notes>
</specification>