<?xml version="1.0" encoding="UTF-8"?>
<learnings>
  <learning id="database-url-centralization" date="2025-08-24">
    <title>Centralized Database URL Builder</title>
    <category>Database,Configuration,Architecture</category>
    <insight>
      Centralized all database URL construction logic into a single, comprehensive
      DatabaseURLBuilder class that handles all possible environment and configuration
      combinations. CRITICAL: All URL normalization must be done through DatabaseURLBuilder
      to prevent inconsistencies across services.
    </insight>
    
    <problem>
      Database URL construction logic was scattered across multiple services with:
      - Duplicate URL parsing and construction code in auth_service and netra_backend
      - Inconsistent handling of Cloud SQL, TCP, SSL, and different environments
      - Complex conditional logic repeated in multiple places
      - Difficult to maintain and prone to configuration errors
      - No clear way to see all possible URL patterns
    </problem>
    
    <solution>
      Created shared/database_url_builder.py with DatabaseURLBuilder class that:
      1. Provides clear, organized access to all URL patterns via sub-builders:
         - cloud_sql.async_url / cloud_sql.sync_url
         - tcp.async_url / tcp.sync_url / tcp.async_url_with_ssl
         - development.default_url / development.auto_url
         - test.memory_url / test.postgres_url
         - docker.compose_url
         - staging.auto_url / production.auto_url
      
      2. Handles all environment-specific logic in one place:
         - Staging/Production automatically add SSL for TCP connections
         - Cloud SQL Unix socket detection and formatting
         - Test environment can use memory or PostgreSQL
         - Development has sensible defaults
      
      3. Provides comprehensive validation:
         - Required variables per environment
         - Cloud SQL format validation
         - Empty string detection
      
      4. Includes safe logging utilities:
         - mask_url_for_logging() - masks credentials while preserving structure
         - get_safe_log_message() - formatted log message with context
         - debug_info() - detailed configuration status
    </solution>
    
    <implementation>
      ```python
      # Usage in any service:
      from shared.database_url_builder import DatabaseURLBuilder
      
      # Build from environment variables
      env_vars = {
          "ENVIRONMENT": "staging",
          "POSTGRES_HOST": "/cloudsql/project:region:instance",
          "POSTGRES_USER": "user",
          "POSTGRES_PASSWORD": "pass",
          "POSTGRES_DB": "db"
      }
      
      builder = DatabaseURLBuilder(env_vars)
      
      # Validate configuration
      is_valid, error_msg = builder.validate()
      if not is_valid:
          raise ConfigurationError(error_msg)
      
      # Get appropriate URL for environment
      url = builder.get_url_for_environment(sync=False)  # async URL
      sync_url = builder.get_url_for_environment(sync=True)  # for Alembic
      
      # Safe logging
      logger.info(builder.get_safe_log_message())
      # Output: "Database URL (staging/Cloud SQL): postgresql+asyncpg://***@/db?host=/cloudsql/..."
      
      # Direct access to specific URLs
      if builder.cloud_sql.is_cloud_sql:
          url = builder.cloud_sql.async_url
      elif builder.tcp.has_config:
          url = builder.tcp.async_url_with_ssl
      ```
    </implementation>
    
    <benefits>
      1. **Single Source of Truth**: All URL patterns in one place
      2. **Clear Organization**: Sub-builders make it obvious what URLs are available
      3. **Type Safety**: Proper return types and validation
      4. **Testability**: Easy to test all combinations
      5. **Maintainability**: Changes to URL patterns only need one update
      6. **Security**: Built-in credential masking for logs
      7. **Flexibility**: Can access specific URLs or use auto-selection
    </benefits>
    
    <patterns>
      - Builder pattern with sub-builders for organization
      - Properties for lazy evaluation
      - Validation separate from construction
      - Environment-aware auto-selection
      - Safe logging utilities built-in
    </patterns>
    
    <references>
      - shared/database_url_builder.py - The centralized builder
      - auth_service/auth_core/config.py - Updated to use builder
      - netra_backend/app/core/configuration/database.py - Updated to use builder
      - test_database_url_builder.py - Comprehensive test coverage
    </references>
    
    <tags>database, configuration, url-construction, centralization, builder-pattern</tags>
  </learning>
  
  <learning id="database-url-normalization-regression" date="2025-08-25">
    <title>URL Normalization Must Be Centralized</title>
    <category>Database,Configuration,Architecture,Regression</category>
    <insight>
      CRITICAL REGRESSION: AuthDatabaseManager had scattered URL normalization logic
      that was different from CoreDatabaseManager, causing staging deployment failures.
      ALL URL normalization MUST go through DatabaseURLBuilder.
    </insight>
    
    <problem>
      AuthDatabaseManager contained duplicate URL normalization logic:
      - Cloud SQL SSL parameter removal in get_base_database_url()
      - SSL to sslmode conversion in get_migration_url_sync_format()
      - Driver prefix handling scattered throughout
      - Validation logic that checked for sslmode in asyncpg URLs
      
      This duplication caused:
      - Inconsistent behavior between services
      - Staging deployment failures
      - Hard to maintain and debug
    </problem>
    
    <solution>
      Added comprehensive URL operations to DatabaseURLBuilder:
      1. normalize_postgres_url() - Single place for all normalization
      2. format_url_for_driver() - Driver-specific formatting
      3. validate_url_for_driver() - Driver-specific validation
      
      Updated AuthDatabaseManager to ONLY use DatabaseURLBuilder:
      - No inline URL manipulation
      - All normalization through DatabaseURLBuilder
      - All validation through DatabaseURLBuilder
    </solution>
    
    <antipattern>
      NEVER add URL manipulation logic outside DatabaseURLBuilder:
      - No inline regex for SSL parameters
      - No direct string replacement for drivers
      - No local normalization methods
      - No scattered validation logic
    </antipattern>
    
    <enforcement>
      - Architecture compliance must check for scattered URL logic
      - Any PR adding URL manipulation outside DatabaseURLBuilder must be rejected
      - Services should only import from DatabaseURLBuilder for URL operations
    </enforcement>
    
    <tags>database, regression, url-normalization, centralization, critical</tags>
  </learning>
  
  <learning id="no-fallback-url-handling" date="2025-08-25">
    <title>Fallback URL Handling is FORBIDDEN</title>
    <category>Database,Configuration,Architecture,Critical</category>
    <insight>
      CRITICAL: Fallback URL handling is absolutely forbidden. ALL database URL
      operations MUST go through DatabaseURLBuilder with NO EXCEPTIONS. Fallback
      logic creates inconsistencies that cause production failures.
    </insight>
    
    <problem>
      Fallback logic creates multiple critical issues:
      1. Inconsistent behavior between primary and fallback paths
      2. Incomplete implementations miss edge cases (SSL parameters, Cloud SQL)
      3. Multiple versions of the same logic diverge over time
      4. Staging/production failures when imports fail
      5. Impossible to maintain and test all code paths
      
      Real example: AuthDatabaseManager had fallback logic that:
      - Only changed driver prefix but missed SSL parameter conversion
      - Caused "unexpected keyword argument 'sslmode'" errors in staging
      - Was different from CoreDatabaseManager's fallback
      - Created impossible-to-debug inconsistencies
    </problem>
    
    <solution>
      NO FALLBACKS - ALL URL operations through DatabaseURLBuilder:
      
      ```python
      # CORRECT - No fallbacks
      from shared.database_url_builder import DatabaseURLBuilder
      url = DatabaseURLBuilder.format_url_for_driver(url, 'asyncpg')
      
      # WRONG - Never do this
      try:
          from shared.database_url_builder import DatabaseURLBuilder
          url = DatabaseURLBuilder.format_url_for_driver(url, 'asyncpg')
      except ImportError:
          # NO! This creates inconsistencies
          url = url.replace("postgresql://", "postgresql+asyncpg://")
      ```
      
      If DatabaseURLBuilder cannot be imported, the system should FAIL FAST
      rather than attempt to continue with partial functionality.
    </solution>
    
    <best_practices>
      <practice>
        <rule>NO FALLBACKS - DatabaseURLBuilder is mandatory</rule>
        <rationale>
          DatabaseURLBuilder is a core shared component. If it cannot be imported,
          the system has fundamental issues that must be fixed, not worked around.
        </rationale>
      </practice>
      <practice>
        <rule>Fail fast on import errors</rule>
        <rationale>
          Better to fail immediately with clear error than continue with
          partial functionality that will fail mysteriously later.
        </rationale>
      </practice>
      <practice>
        <rule>Use extension hooks for new requirements</rule>
        <rationale>
          DatabaseURLBuilder provides extension hooks (register_driver_handler,
          register_normalization_rule) for future needs without modifying core.
        </rationale>
      </practice>
    </best_practices>
    
    <driver_requirements>
      <driver name="asyncpg">
        <requirement>Uses 'ssl' parameter, NOT 'sslmode'</requirement>
        <requirement>Cloud SQL Unix sockets don't need SSL parameters</requirement>
      </driver>
      <driver name="psycopg2">
        <requirement>Uses 'sslmode' parameter, NOT 'ssl'</requirement>
        <requirement>Used by Alembic for migrations</requirement>
      </driver>
      <driver name="base">
        <requirement>Plain postgresql:// without driver prefix</requirement>
        <requirement>Used for URL normalization</requirement>
      </driver>
    </driver_requirements>
    
    <enforcement>
      <rule>
        Code review MUST reject any PR with try/except ImportError for DatabaseURLBuilder
      </rule>
      <rule>
        Architecture compliance check MUST fail if fallback URL logic is detected
      </rule>
      <rule>
        All services MUST import DatabaseURLBuilder directly with no fallbacks
      </rule>
    </enforcement>
    
    <extension_points>
      DatabaseURLBuilder provides hooks for future extensibility:
      - register_driver_handler(): Add support for new database drivers
      - register_normalization_rule(): Add custom normalization patterns
      - get_driver_requirements(): Retrieve driver-specific requirements
      
      These hooks ensure future needs can be met without creating fallback logic.
    </extension_points>
    
    <tags>database, no-fallbacks, centralization, critical, fail-fast</tags>
  </learning>
  
  <learning id="cloud-sql-none-check" date="2025-08-25">
    <title>Always Check for None Before String Operations</title>
    <category>Database,Configuration,BugFix</category>
    <insight>
      When checking if a configuration value contains a substring, ALWAYS check
      for None first to avoid AttributeError. This is especially critical for
      optional configuration values like postgres_host.
    </insight>
    
    <problem>
      DatabaseURLBuilder had a bug in Cloud SQL detection:
      ```python
      # WRONG - Causes AttributeError if postgres_host is None
      return "/cloudsql/" in self.parent.postgres_host
      ```
      
      This caused failures when postgres_host was None, which is common
      in test environments or when using #removed-legacydirectly.
    </problem>
    
    <solution>
      Always check for None before string operations:
      ```python
      # CORRECT - Safe check for None first
      return self.parent.postgres_host is not None and "/cloudsql/" in self.parent.postgres_host
      
      # Also correct for negation
      return bool(self.parent.postgres_host and not ("/cloudsql/" in self.parent.postgres_host))
      ```
    </solution>
    
    <best_practices>
      <practice>
        <rule>Check for None before string operations</rule>
        <rationale>
          Optional configuration values may be None. String operations on None
          cause AttributeError crashes.
        </rationale>
      </practice>
      <practice>
        <rule>Use explicit None checks for clarity</rule>
        <rationale>
          "is not None and" is clearer than relying on truthiness when
          the intent is to check for None specifically.
        </rationale>
      </practice>
      <practice>
        <rule>Test with missing configuration values</rule>
        <rationale>
          Tests should include cases where optional configuration values
          are not set to catch these bugs early.
        </rationale>
      </practice>
    </best_practices>
    
    <tags>database, none-check, bug-fix, cloud-sql</tags>
  </learning>
</learnings>