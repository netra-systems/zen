<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <metadata>
    <title>WebSocket ConnectionHandler Silent Failures in GCP Cloud Run</title>
    <date>2025-01-09</date>
    <severity>CRITICAL</severity>
    <category>websocket,gcp,error-handling</category>
    <github_issue>109</github_issue>
  </metadata>

  <problem>
    <description>
      ConnectionHandler was failing silently in GCP staging, returning success (True) even when
      unable to send WebSocket responses. This caused complete chat functionality breakdown
      with no visible errors.
    </description>
    <affected_user>105945141827451681156</affected_user>
    <error_location>netra_backend/app/websocket_core/handlers.py:119</error_location>
    <symptoms>
      - Users unable to send/receive messages
      - Handler returns True despite send failures
      - Error messages truncated (missing exception details)
      - Connection churning causing resource accumulation
    </symptoms>
  </problem>

  <root_causes>
    <cause priority="1">
      <title>Silent Failure Architecture</title>
      <description>
        ConnectionHandler returned True even when websocket.send_json() was skipped,
        creating the illusion of success while actually failing.
      </description>
    </cause>
    <cause priority="2">
      <title>Cloud Run WebSocket State Detection</title>
      <description>
        is_websocket_connected() incorrectly returned False in GCP Cloud Run due to
        proxy layer not exposing expected state attributes.
      </description>
    </cause>
    <cause priority="3">
      <title>Incomplete Error Logging</title>
      <description>
        Exception logging used basic string formatting ({e}) which returns empty
        strings for certain exception types, losing critical debugging information.
      </description>
    </cause>
    <cause priority="4">
      <title>Resource Accumulation</title>
      <description>
        Connection churning pattern created WebSocket manager accumulation,
        hitting 20-manager limit and causing cascading failures.
      </description>
    </cause>
  </root_causes>

  <solution>
    <change file="handlers.py">
      <before>
        try:
            # ... handler logic ...
            if is_websocket_connected(websocket):
                await websocket.send_json(response.model_dump(mode='json'))
            return True
        except Exception as e:
            logger.error(f"Error in ConnectionHandler for user {user_id}: {e}")
            return False
      </before>
      <after>
        try:
            # ... handler logic ...
            # Fail-fast validation
            success = await safe_websocket_send(websocket, response, user_id)
            if not success:
                logger.error(f"Failed to send response to user {user_id}")
                return False
            return True
        except Exception as e:
            # Enhanced error logging with full context
            import traceback
            logger.error(
                f"Error in ConnectionHandler for user {user_id}: {str(e)}\n"
                f"Exception type: {type(e).__name__}\n"
                f"Traceback: {traceback.format_exc()}\n"
                f"WebSocket state: {get_websocket_debug_info(websocket)}"
            )
            return False
      </after>
    </change>
    <change file="utils.py">
      <description>
        Added Cloud Run specific WebSocket detection methods including queue checking,
        scope validation, and method availability tests. Created safe_websocket_send()
        helper with explicit success validation and retry logic.
      </description>
    </change>
  </solution>

  <testing>
    <test_strategy>
      - E2E tests validating GCP staging WebSocket behavior
      - Integration tests for environment-specific state detection
      - Unit tests for error logging completeness
      - Mission critical golden path validation
    </test_strategy>
    <validation>
      All tests designed to FAIL in broken state and PASS after fixes.
      Tests use real authentication, no mocks in E2E.
    </validation>
  </testing>

  <lessons_learned>
    <lesson priority="HIGH">
      Silent failures are worse than loud failures. Always fail fast and explicitly.
    </lesson>
    <lesson priority="HIGH">
      Cloud environments have different WebSocket characteristics than local development.
      Must test in actual deployment environment.
    </lesson>
    <lesson priority="MEDIUM">
      Exception string representation can be empty. Always use str(e) and include
      type(e).__name__ for complete error context.
    </lesson>
    <lesson priority="MEDIUM">
      Resource accumulation patterns need explicit lifecycle management and cleanup.
    </lesson>
  </lessons_learned>

  <prevention>
    <recommendation>
      Always validate send operations explicitly. Never assume success without confirmation.
    </recommendation>
    <recommendation>
      Test WebSocket functionality in actual cloud environments, not just local.
    </recommendation>
    <recommendation>
      Use structured error logging with full context including traceback, state, and environment.
    </recommendation>
    <recommendation>
      Implement resource cleanup and limits for connection-based resources.
    </recommendation>
  </prevention>
</learning>