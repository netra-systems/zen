<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <title>Microservice Independence and Duplication Principles</title>
        <category>Architecture</category>
        <created>2025-08-23</created>
        <updated>2025-08-23</updated>
        <importance>CRITICAL</importance>
        <keywords>Microservices, Independence, Duplication, Service Boundaries, Architecture</keywords>
    </metadata>

    <learning>
        <title>Critical Misunderstanding: "Unique Concept = ONCE per service" Applies WITHIN Services, Not ACROSS</title>
        
        <problem>
            <description>
                During a major remediation effort, the principle "Unique Concept = ONCE per service" was misinterpreted to mean
                that concepts should exist only once across the ENTIRE platform, leading to aggressive consolidation that
                violated microservice independence.
            </description>
            <impact>
                - Forced auth_service to use backend's DatabaseManager, creating tight coupling
                - Violated microservice boundaries by sharing internal implementations
                - Made services unable to deploy independently
                - Created cascading failure risks between services
            </impact>
            <example>
                INCORRECT interpretation led to:
                - Deleting auth_service's AuthDatabaseManager
                - Forcing auth_service to import from netra_backend.app.db
                - Creating direct code dependencies between services
            </example>
        </problem>

        <root_cause>
            <analysis>
                The principle was interpreted too literally without considering microservice architecture principles.
                The confusion arose from not distinguishing between:
                1. Duplication WITHIN a service (bad - violates DRY)
                2. Similar implementations ACROSS services (good - maintains independence)
            </analysis>
        </root_cause>

        <solution>
            <correct_interpretation>
                "Unique Concept = ONCE per service" means:
                - WITHIN each service: No duplicate implementations
                - ACROSS services: Each service maintains its own implementations
                - Services communicate via APIs, not shared code
                
                See SPEC/acceptable_duplicates.xml for the canonical master list of acceptable duplicates.
            </correct_interpretation>

            <implementation>
                <within_service>
                    <!-- Within a single service, eliminate duplicates -->
                    <example service="netra_backend">
                        /netra_backend/app/
                        ├── db/database_manager.py (KEEP - primary)
                        ├── services/duplicate_db_manager.py (DELETE - duplicate)
                        └── utils/another_db_handler.py (DELETE - duplicate)
                    </example>
                </within_service>

                <across_services>
                    <!-- Across services, maintain independence -->
                    <example>
                        /netra_backend/app/db/database_manager.py (CORRECT - backend's own)
                        /auth_service/auth_core/database/database_manager.py (CORRECT - auth's own)
                        /frontend/src/utils/database.js (CORRECT - frontend's own if needed)
                    </example>
                </across_services>

                <communication>
                    <!-- Services communicate via APIs -->
                    <incorrect>
                        <!-- Auth service importing backend's internal code -->
                        from netra_backend.app.db import DatabaseManager
                    </incorrect>
                    <correct>
                        <!-- Auth service using its own implementation -->
                        from auth_service.auth_core.database import AuthDatabaseManager
                        
                        <!-- Backend calling auth service via API -->
                        from netra_backend.app.clients.auth_client_core import auth_client
                        result = await auth_client.validate_token(token)
                    </correct>
                </communication>
            </implementation>
        </solution>

        <principles>
            <principle name="Service Independence">
                Each microservice must be independently deployable, scalable, and maintainable.
                This requires each service to own its infrastructure code.
            </principle>
            
            <principle name="Bounded Contexts">
                Each service represents a bounded context with its own models, logic, and infrastructure.
                Similar concepts may exist in different contexts with different implementations.
            </principle>
            
            <principle name="API-First Communication">
                Services communicate through well-defined APIs (REST, gRPC, GraphQL).
                Direct code imports across service boundaries violate independence.
            </principle>
            
            <principle name="Shared Libraries vs Shared Code">
                - Shared libraries (published packages): OK
                - Direct imports across services: NOT OK
                - Copy similar patterns: OK (each service owns its copy)
            </principle>
        </principles>

        <examples>
            <example category="Database Management">
                <correct>
                    Each service has its own database manager:
                    - Backend: DatabaseManager for application data
                    - Auth: AuthDatabaseManager for auth data
                    - Analytics: AnalyticsDatabaseManager for metrics
                    
                    Each can have different:
                    - Connection pools
                    - Retry logic
                    - Schema management
                    - Performance tuning
                </correct>
            </example>

            <example category="Authentication">
                <correct>
                    - Auth Service: Owns all authentication logic (source of truth)
                    - Backend: Calls auth service via HTTP client
                    - Frontend: Calls auth service via API
                    - No service implements its own auth logic
                </correct>
            </example>

            <example category="Configuration">
                <correct>
                    Each service has its own configuration:
                    - Backend: BackendConfig
                    - Auth: AuthConfig
                    - Frontend: FrontendConfig
                    
                    Shared configuration through:
                    - Environment variables
                    - Configuration service
                    - Secret management service
                </correct>
            </example>

            <example category="Monitoring">
                <correct>
                    Each service has its own monitoring:
                    - Backend: BackendMonitor with business metrics
                    - Auth: AuthMonitor with security metrics
                    - Frontend: FrontendMonitor with UX metrics
                    
                    Aggregated through:
                    - Centralized metrics collector (Prometheus)
                    - Unified dashboards (Grafana)
                    - Distributed tracing (OpenTelemetry)
                </correct>
            </example>
        </examples>

        <anti_patterns>
            <anti_pattern name="Cross-Service Imports">
                <description>Importing internal code from another service</description>
                <why_bad>Creates tight coupling, prevents independent deployment</why_bad>
                <example>
                    <!-- NEVER DO THIS -->
                    from netra_backend.app.services import SomeBackendService
                </example>
            </anti_pattern>

            <anti_pattern name="Shared Database">
                <description>Multiple services accessing the same database directly</description>
                <why_bad>Violates data ownership, creates coupling through schema</why_bad>
                <fix>Each service owns its data, expose via API</fix>
            </anti_pattern>

            <anti_pattern name="Distributed Monolith">
                <description>Microservices that can't function independently</description>
                <why_bad>Loses all benefits of microservices while keeping complexity</why_bad>
                <fix>Ensure each service can run and test independently</fix>
            </anti_pattern>
        </anti_patterns>

        <checklist>
            <item>Can this service be deployed independently?</item>
            <item>Can this service be tested without other services running?</item>
            <item>Does this service own its data and expose it via API?</item>
            <item>Are all cross-service communications via API?</item>
            <item>Can this service scale independently?</item>
            <item>Does this service have its own CI/CD pipeline?</item>
            <item>Can different teams work on different services without conflicts?</item>
        </checklist>

        <business_impact>
            <benefit>Independent deployment reduces risk and increases velocity</benefit>
            <benefit>Service isolation prevents cascading failures</benefit>
            <benefit>Teams can work autonomously on their services</benefit>
            <benefit>Services can scale based on their specific needs</benefit>
            <benefit>Technology choices can be optimized per service</benefit>
        </business_impact>

        <key_takeaways>
            <takeaway priority="CRITICAL">
                "Unique Concept = ONCE per service" means no duplicates WITHIN a service,
                not across the entire platform.
            </takeaway>
            <takeaway priority="CRITICAL">
                Each microservice MUST maintain its own infrastructure code (database, config, monitoring)
                to preserve independence.
            </takeaway>
            <takeaway priority="HIGH">
                Services communicate via APIs, never through direct code imports across boundaries.
            </takeaway>
            <takeaway priority="HIGH">
                Similar code patterns across services is acceptable and often necessary for independence.
            </takeaway>
            <takeaway priority="MEDIUM">
                Shared functionality should be extracted to published packages, not shared via imports.
            </takeaway>
        </key_takeaways>
    </learning>

    <learning>
        <title>Shared Folder Anti-Pattern: Creating Cross-Service Dependencies (2025-08-24)</title>
        
        <problem>
            <description>
                A shared folder was created with modules like shared/health, shared/resilience, shared/serialization,
                and shared/database that were imported by multiple services, violating microservice independence.
            </description>
            <impact>
                - Created tight coupling between services through shared code
                - Services could not evolve independently
                - Breaking changes in shared modules affected all services
                - Violated the principle that services should communicate via APIs, not shared code
            </impact>
            <example>
                INCORRECT pattern:
                - /shared/health/unified_health_checker.py imported by both auth_service and netra_backend
                - /shared/database/core_database_manager.py used across all services
                - auth_service/health_check.py importing from shared.health
            </example>
        </problem>

        <root_cause>
            <analysis>
                Attempted to eliminate "duplication" by creating shared modules, but this violated
                microservice boundaries. Each service should maintain its own implementations of
                infrastructure code like health checks, database managers, and retry logic.
            </analysis>
        </root_cause>

        <solution>
            <correct_approach>
                1. Each service maintains its own health check implementation
                2. Each service has its own database manager
                3. Each service implements its own retry/resilience logic
                4. Only truly cross-cutting concerns like logging schemas can be shared
                5. Services communicate via well-defined APIs, not shared code
            </correct_approach>

            <acceptable_shared>
                <!-- What CAN be in shared folder -->
                - JSON schemas for API contracts
                - Logging configuration (read-only)
                - Type definitions for cross-service communication
            </acceptable_shared>

            <not_acceptable_shared>
                <!-- What CANNOT be in shared folder -->
                - Database managers or connection logic
                - Health check implementations
                - Retry/resilience handlers
                - Business logic of any kind
                - Service-specific utilities
            </not_acceptable_shared>
        </solution>

        <prevention>
            <rule>Before creating anything in /shared, verify it's in the acceptable list</rule>
            <rule>Each service should be deployable without any code from other services</rule>
            <rule>Run compliance checks regularly to detect violations</rule>
            <rule>Review SPEC/acceptable_duplicates.xml before consolidating "duplicate" code</rule>
        </prevention>

        <key_takeaways>
            <takeaway priority="CRITICAL">
                Shared folders should ONLY contain schemas and contracts, not implementation code
            </takeaway>
            <takeaway priority="CRITICAL">
                Infrastructure code (health, database, retry) must be owned by each service independently
            </takeaway>
        </key_takeaways>
    </learning>
</specification>