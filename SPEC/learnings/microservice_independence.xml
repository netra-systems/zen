<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <title>Microservice Independence and Duplication Principles</title>
        <category>Architecture</category>
        <created>2025-08-23</created>
        <updated>2025-08-23</updated>
        <importance>CRITICAL</importance>
        <keywords>Microservices, Independence, Duplication, Service Boundaries, Architecture</keywords>
    </metadata>

    <learning>
        <title>Critical Misunderstanding: "Unique Concept = ONCE per service" Applies WITHIN Services, Not ACROSS</title>
        
        <problem>
            <description>
                During a major remediation effort, the principle "Unique Concept = ONCE per service" was misinterpreted to mean
                that concepts should exist only once across the ENTIRE platform, leading to aggressive consolidation that
                violated microservice independence.
            </description>
            <impact>
                - Forced auth_service to use backend's DatabaseManager, creating tight coupling
                - Violated microservice boundaries by sharing internal implementations
                - Made services unable to deploy independently
                - Created cascading failure risks between services
            </impact>
            <example>
                INCORRECT interpretation led to:
                - Deleting auth_service's AuthDatabaseManager
                - Forcing auth_service to import from netra_backend.app.db
                - Creating direct code dependencies between services
            </example>
        </problem>

        <root_cause>
            <analysis>
                The principle was interpreted too literally without considering microservice architecture principles.
                The confusion arose from not distinguishing between:
                1. Duplication WITHIN a service (bad - violates DRY)
                2. Similar implementations ACROSS services (good - maintains independence)
            </analysis>
        </root_cause>

        <solution>
            <correct_interpretation>
                "Unique Concept = ONCE per service" means:
                - WITHIN each service: No duplicate implementations
                - ACROSS services: Each service maintains its own implementations
                - Services communicate via APIs, not shared code
            </correct_interpretation>

            <implementation>
                <within_service>
                    <!-- Within a single service, eliminate duplicates -->
                    <example service="netra_backend">
                        /netra_backend/app/
                        ├── db/database_manager.py (KEEP - primary)
                        ├── services/duplicate_db_manager.py (DELETE - duplicate)
                        └── utils/another_db_handler.py (DELETE - duplicate)
                    </example>
                </within_service>

                <across_services>
                    <!-- Across services, maintain independence -->
                    <example>
                        /netra_backend/app/db/database_manager.py (CORRECT - backend's own)
                        /auth_service/auth_core/database/database_manager.py (CORRECT - auth's own)
                        /frontend/src/utils/database.js (CORRECT - frontend's own if needed)
                    </example>
                </across_services>

                <communication>
                    <!-- Services communicate via APIs -->
                    <incorrect>
                        <!-- Auth service importing backend's internal code -->
                        from netra_backend.app.db import DatabaseManager
                    </incorrect>
                    <correct>
                        <!-- Auth service using its own implementation -->
                        from auth_service.auth_core.database import AuthDatabaseManager
                        
                        <!-- Backend calling auth service via API -->
                        from netra_backend.app.clients.auth_client_core import auth_client
                        result = await auth_client.validate_token(token)
                    </correct>
                </communication>
            </implementation>
        </solution>

        <principles>
            <principle name="Service Independence">
                Each microservice must be independently deployable, scalable, and maintainable.
                This requires each service to own its infrastructure code.
            </principle>
            
            <principle name="Bounded Contexts">
                Each service represents a bounded context with its own models, logic, and infrastructure.
                Similar concepts may exist in different contexts with different implementations.
            </principle>
            
            <principle name="API-First Communication">
                Services communicate through well-defined APIs (REST, gRPC, GraphQL).
                Direct code imports across service boundaries violate independence.
            </principle>
            
            <principle name="Shared Libraries vs Shared Code">
                - Shared libraries (published packages): OK
                - Direct imports across services: NOT OK
                - Copy similar patterns: OK (each service owns its copy)
            </principle>
        </principles>

        <examples>
            <example category="Database Management">
                <correct>
                    Each service has its own database manager:
                    - Backend: DatabaseManager for application data
                    - Auth: AuthDatabaseManager for auth data
                    - Analytics: AnalyticsDatabaseManager for metrics
                    
                    Each can have different:
                    - Connection pools
                    - Retry logic
                    - Schema management
                    - Performance tuning
                </correct>
            </example>

            <example category="Authentication">
                <correct>
                    - Auth Service: Owns all authentication logic (source of truth)
                    - Backend: Calls auth service via HTTP client
                    - Frontend: Calls auth service via API
                    - No service implements its own auth logic
                </correct>
            </example>

            <example category="Configuration">
                <correct>
                    Each service has its own configuration:
                    - Backend: BackendConfig
                    - Auth: AuthConfig
                    - Frontend: FrontendConfig
                    
                    Shared configuration through:
                    - Environment variables
                    - Configuration service
                    - Secret management service
                </correct>
            </example>

            <example category="Monitoring">
                <correct>
                    Each service has its own monitoring:
                    - Backend: BackendMonitor with business metrics
                    - Auth: AuthMonitor with security metrics
                    - Frontend: FrontendMonitor with UX metrics
                    
                    Aggregated through:
                    - Centralized metrics collector (Prometheus)
                    - Unified dashboards (Grafana)
                    - Distributed tracing (OpenTelemetry)
                </correct>
            </example>
        </examples>

        <anti_patterns>
            <anti_pattern name="Cross-Service Imports">
                <description>Importing internal code from another service</description>
                <why_bad>Creates tight coupling, prevents independent deployment</why_bad>
                <example>
                    <!-- NEVER DO THIS -->
                    from netra_backend.app.services import SomeBackendService
                </example>
            </anti_pattern>

            <anti_pattern name="Shared Database">
                <description>Multiple services accessing the same database directly</description>
                <why_bad>Violates data ownership, creates coupling through schema</why_bad>
                <fix>Each service owns its data, expose via API</fix>
            </anti_pattern>

            <anti_pattern name="Distributed Monolith">
                <description>Microservices that can't function independently</description>
                <why_bad>Loses all benefits of microservices while keeping complexity</why_bad>
                <fix>Ensure each service can run and test independently</fix>
            </anti_pattern>
        </anti_patterns>

        <checklist>
            <item>Can this service be deployed independently?</item>
            <item>Can this service be tested without other services running?</item>
            <item>Does this service own its data and expose it via API?</item>
            <item>Are all cross-service communications via API?</item>
            <item>Can this service scale independently?</item>
            <item>Does this service have its own CI/CD pipeline?</item>
            <item>Can different teams work on different services without conflicts?</item>
        </checklist>

        <business_impact>
            <benefit>Independent deployment reduces risk and increases velocity</benefit>
            <benefit>Service isolation prevents cascading failures</benefit>
            <benefit>Teams can work autonomously on their services</benefit>
            <benefit>Services can scale based on their specific needs</benefit>
            <benefit>Technology choices can be optimized per service</benefit>
        </business_impact>

        <key_takeaways>
            <takeaway priority="CRITICAL">
                "Unique Concept = ONCE per service" means no duplicates WITHIN a service,
                not across the entire platform.
            </takeaway>
            <takeaway priority="CRITICAL">
                Each microservice MUST maintain its own infrastructure code (database, config, monitoring)
                to preserve independence.
            </takeaway>
            <takeaway priority="HIGH">
                Services communicate via APIs, never through direct code imports across boundaries.
            </takeaway>
            <takeaway priority="HIGH">
                Similar code patterns across services is acceptable and often necessary for independence.
            </takeaway>
            <takeaway priority="MEDIUM">
                Shared functionality should be extracted to published packages, not shared via imports.
            </takeaway>
        </key_takeaways>
    </learning>
</specification>