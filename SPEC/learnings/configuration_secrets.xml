<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Learnings - Configuration/Secrets</name>
        <type>learnings</type>
        <category>Configuration/Secrets</category>
        <version>1.0</version>
        <last_updated>2025-08-16</last_updated>
        <description>Learnings and fixes for Configuration/Secrets</description>
    </metadata>
    
    <learnings>
        <learning id="staging-env-var-suffix-handling">
                    <title>Staging Environment Variables Suffix Handling</title>
                    <date>2025-08-16</date>
                    <category>Configuration/Secrets</category>
                    <description>
                        Staging deployment scripts pass environment variables with _STAGING suffix (e.g., GEMINI_API_KEY_STAGING),
                        but the application was only looking for regular names (e.g., GEMINI_API_KEY) when loading from environment.
                        This caused secrets to not be found when Google Secret Manager was unavailable.
                    </description>
                    <symptoms>
                        <symptom>Gemini API key not being loaded in staging environment</symptom>
                        <symptom>Deployment scripts setting GEMINI_API_KEY_STAGING but app looking for GEMINI_API_KEY</symptom>
                        <symptom>Secret Manager fallback to environment variables failing in staging</symptom>
                    </symptoms>
                    <root-causes>
                        <cause>Deployment scripts (deploy_staging_remote.sh/ps1) use _STAGING suffix for env vars</cause>
                        <cause>GitHub Actions workflow uses secrets with _STAGING suffix</cause>
                        <cause>SecretManager._load_from_environment() only checked regular env var names</cause>
                    </root-causes>
                    <solution>
                        <step>Updated SecretManager._load_from_environment() to check for _STAGING suffix when in staging</step>
                        <step>Logic: In staging environment, first try env_var + "_STAGING", then fall back to regular env_var</step>
                        <step>This allows both patterns to work: direct env vars and staging-suffixed vars</step>
                    </solution>
                    <files-modified>
                        <file>app/core/secret_manager.py - Updated _load_from_environment() to handle staging suffix</file>
                    </files-modified>
                    <code-example>
                        # Check if we're in staging environment
                        environment = os.environ.get("ENVIRONMENT", "development").lower()
                        k_service = os.environ.get("K_SERVICE")
                        is_staging = environment == "staging" or (k_service and "staging" in k_service.lower())

                        secrets = {}
                        for secret_name, env_var in env_mapping.items():
                            # Try staging-suffixed env var first if in staging
                            if is_staging:
                                staging_env_var = f"{env_var}_STAGING"
                                value = os.environ.get(staging_env_var)
                                if value:
                                    secrets[secret_name] = value
                                    continue
                            # Fall back to regular env var
                            value = os.environ.get(env_var)
                            if value:
                                secrets[secret_name] = value
                    </code-example>
                    <prevention>
                        <item>Always test secret loading in staging environment with actual deployment patterns</item>
                        <item>Ensure consistency between deployment scripts and application expectations</item>
                        <item>Document expected environment variable names clearly</item>
                    </prevention>
                </learning>

        <learning id="cors-devlauncher-middleware-configuration">
            <title>CORS Configuration with Dev Launcher as Middleware</title>
            <date>2025-08-16</date>
            <category>Configuration/Secrets</category>
            <description>
                Dev launcher acts as a middleware layer between the developer and the backend application,
                spawning the backend with specific environment variables. CORS configuration must be properly
                set at the dev launcher level to ensure the backend receives the correct allowed origins.
                Dynamic localhost ports require wildcard handling in development.
            </description>
            <symptoms>
                <symptom>CORS errors with dynamic localhost ports (e.g., http://localhost:51115)</symptom>
                <symptom>Backend rejecting requests from unexpected localhost ports</symptom>
                <symptom>Middleware debug logs showing "Origin not allowed" for valid development origins</symptom>
                <symptom>Terraform deployments overwriting CORS settings</symptom>
            </symptoms>
            <root-causes>
                <cause>Dev launcher not setting CORS_ORIGINS environment variable</cause>
                <cause>Backend defaulting to hardcoded localhost:3000 and localhost:8000 only</cause>
                <cause>Middleware wildcard logic incorrectly restricting development origins</cause>
                <cause>Environment variable not properly parsed when set to wildcard "*"</cause>
            </root-causes>
            <solution>
                <step>Updated dev_launcher/launcher.py to set CORS_ORIGINS="*" in _create_backend_env()</step>
                <step>Fixed middleware_setup.py to properly handle CORS_ORIGINS="*" without splitting</step>
                <step>Simplified is_origin_allowed() to return True for all origins in development with wildcard</step>
                <step>Ensured dev launcher passes environment variables correctly to backend process</step>
            </solution>
            <files-modified>
                <file>dev_launcher/launcher.py - Added CORS_ORIGINS="*" to backend environment</file>
                <file>app/core/middleware_setup.py - Fixed wildcard handling and origin checking logic</file>
            </files-modified>
            <code-example>
                # In dev_launcher/launcher.py
                def _create_backend_env(self, port: int) -> dict:
                    """Create backend environment variables."""
                    service_env_vars = self.services_config.get_all_env_vars()
                    return create_process_env(
                        BACKEND_PORT=str(port),
                        PYTHONPATH=str(self.config.project_root),
                        ENVIRONMENT="development",
                        CORS_ORIGINS="*",  # Allow all origins in development
                        **service_env_vars,
                        **self.config.env_overrides
                    )

                # In middleware_setup.py
                def _get_development_cors_origins() -> list[str]:
                    cors_origins_env = os.environ.get("CORS_ORIGINS", "")
                    if cors_origins_env:
                        # Handle wildcard separately - don't try to split it
                        if cors_origins_env == "*":
                            return ["*"]
                        return cors_origins_env.split(",")
                    return ["http://localhost:3000", "http://localhost:8000", "*"]
            </code-example>
            <architectural-insight>
                Dev launcher acts as a crucial middleware layer that controls the backend's runtime environment.
                Configuration must flow from dev launcher -> backend environment -> application middleware.
                Any environment-specific settings should be injected at the dev launcher level for consistency.
            </architectural-insight>
            <prevention>
                <item>Always configure CORS at the dev launcher level for development environments</item>
                <item>Test with dynamic ports to ensure wildcard handling works correctly</item>
                <item>Document that dev launcher is responsible for environment configuration</item>
                <item>Ensure Terraform deployments set appropriate CORS_ORIGINS for each environment</item>
            </prevention>
        </learning>

        <learning id="staging-cors-missing-env-var">
            <title>Staging CORS Configuration Missing Environment Variable</title>
            <date>2025-08-16</date>
            <category>Configuration/Secrets</category>
            <description>
                Staging environment backend was missing CORS_ORIGINS environment variable in Terraform configuration,
                causing CORS errors when frontend at app.staging.netrasystems.ai tried to access backend at
                backend-staging-*.a.run.app URLs. While the middleware supports pattern matching for Cloud Run URLs,
                the environment variable must be set to trigger proper CORS handling in staging.
            </description>
            <symptoms>
                <symptom>Access blocked by CORS policy: No 'Access-Control-Allow-Origin' header present</symptom>
                <symptom>Frontend at app.staging.netrasystems.ai cannot access backend-staging-*.a.run.app</symptom>
                <symptom>Health checks and API calls failing with CORS errors in staging environment</symptom>
                <symptom>Pattern matching for Cloud Run URLs not working despite being implemented</symptom>
            </symptoms>
            <root-causes>
                <cause>Terraform configuration missing CORS_ORIGINS environment variable for backend service</cause>
                <cause>Backend defaulting to minimal CORS origins without explicit configuration</cause>
                <cause>CustomCORSMiddleware not properly configured without CORS_ORIGINS variable</cause>
            </root-causes>
            <solution>
                <step>Added CORS_ORIGINS env var to terraform-gcp/main.tf backend service configuration</step>
                <step>Included explicit staging domains and wildcard for Cloud Run URL pattern matching</step>
                <step>Verified pattern matching for *.a.run.app URLs works correctly in middleware</step>
                <step>Created test script to validate CORS configuration for all expected origins</step>
            </solution>
            <files-modified>
                <file>terraform-gcp/main.tf - Added CORS_ORIGINS environment variable</file>
                <file>test_cors_staging.py - Created test script for CORS validation</file>
            </files-modified>
            <code-example>
                # In terraform-gcp/main.tf
                env {
                  name  = "CORS_ORIGINS"
                  value = "https://staging.netrasystems.ai,https://app.staging.netrasystems.ai,https://auth.staging.netrasystems.ai,https://backend.staging.netrasystems.ai,*"
                }
            </code-example>
            <architectural-insight>
                Terraform deployments must explicitly set all required environment variables for proper CORS handling.
                The wildcard (*) in CORS_ORIGINS triggers pattern matching logic in CustomCORSMiddleware,
                allowing Cloud Run URLs (*.a.run.app) and staging subdomains to be accepted dynamically.
            </architectural-insight>
            <prevention>
                <item>Always set CORS_ORIGINS in Terraform for all environments</item>
                <item>Include wildcard (*) for staging to enable pattern matching</item>
                <item>Test CORS configuration after any Terraform deployment changes</item>
                <item>Document that both explicit origins and wildcard are needed for staging</item>
            </prevention>
        </learning>

        <learning id="gemini-api-key-paradox">
            <title>GEMINI API Key Loading Paradox - Module Import Timing Issue</title>
            <date>2025-08-18</date>
            <category>Configuration/Secrets</category>
            <description>
                Dev launcher loads GEMINI_API_KEY successfully but backend reports "Required secrets missing: ['gemini-api-key']".
                Root cause: Configuration loading happens at module import time (app/config.py line 59) before subprocess
                environment is fully available. Also, unified logging wrapper doesn't preserve caller frame information.
            </description>
            <symptoms>
                <symptom>Dev launcher shows loading GEMINI_API_KEY successfully</symptom>
                <symptom>Backend reports "Required secrets missing: ['gemini-api-key']"</symptom>
                <symptom>Logging shows app.core.unified_logging instead of actual module locations</symptom>
                <symptom>Backend fails to start due to missing secrets that are actually present</symptom>
            </symptoms>
            <root-causes>
                <cause>app/config.py line 59 executes "settings = get_config()" at module import time</cause>
                <cause>Module-level code executes before subprocess environment is fully available</cause>
                <cause>Unified logging wrapper doesn't preserve caller frame information</cause>
                <cause>Console formatter uses wrapper location instead of actual caller location</cause>
            </root-causes>
            <solution>
                <step>Changed app/config.py from eager loading to lazy loading using __getattr__</step>
                <step>Settings now load on first access, not at module import time</step>
                <step>Added frame inspection to unified_logging.py to capture actual caller location</step>
                <step>Updated logging_formatters.py to use caller info from context</step>
            </solution>
            <files-modified>
                <file>app/config.py - Changed from eager to lazy loading of settings</file>
                <file>app/core/unified_logging.py - Added caller frame capture with inspect</file>
                <file>app/core/logging_formatters.py - Updated console format to use caller info</file>
            </files-modified>
            <code-example>
                # In app/config.py - Lazy loading pattern
                _settings_cache = None
                
                def __getattr__(name):
                    """Lazy load settings on first access."""
                    global _settings_cache
                    if name == "settings":
                        if _settings_cache is None:
                            _settings_cache = get_config()
                        return _settings_cache
                    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
                
                # In unified_logging.py - Caller frame capture
                frame = inspect.currentframe()
                caller_frame = frame.f_back.f_back.f_back if frame else None
                if caller_frame:
                    context['caller_module'] = caller_frame.f_globals.get('__name__', 'unknown')
                    context['caller_function'] = caller_frame.f_code.co_name
                    context['caller_line'] = caller_frame.f_lineno
            </code-example>
            <architectural-insight>
                Module-level code executes immediately on import, which happens before subprocess environment
                setup is complete. Always use lazy initialization for configuration that depends on environment.
                Logging wrappers must preserve caller information for effective debugging.
            </architectural-insight>
            <prevention>
                <item>NEVER load configuration at module import time - always use lazy loading</item>
                <item>Use __getattr__ or property decorators for lazy attribute access</item>
                <item>Test subprocess environment inheritance with timing scenarios</item>
                <item>When wrapping loggers, preserve caller frame information</item>
            </prevention>
        </learning>

        <learning id="unified-config-direct-env-access">
            <title>Unified Configuration System - Direct Environment Variable Access Issue</title>
            <date>2025-08-18</date>
            <category>Configuration/Secrets</category>
            <description>
                Multiple modules were directly accessing os.environ.get() with hardcoded defaults instead of using
                the unified configuration system, causing inconsistent configuration values and defaults being used
                instead of real values loaded by the unified config manager.
            </description>
            <symptoms>
                <symptom>Configuration values using hardcoded defaults instead of actual values</symptom>
                <symptom>Service modes (LLM_MODE, CLICKHOUSE_MODE) not properly detected</symptom>
                <symptom>ClickHouse using localhost with default passwords instead of real config</symptom>
                <symptom>Inconsistent configuration between different parts of the system</symptom>
            </symptoms>
            <root-causes>
                <cause>app/db/clickhouse.py:get_clickhouse_config() directly using os.environ.get()</cause>
                <cause>app/llm/llm_config_manager.py directly checking os.environ.get("LLM_MODE")</cause>
                <cause>Service mode configuration not centralized in AppConfig schema</cause>
                <cause>Unified configuration system not being used consistently</cause>
            </root-causes>
            <solution>
                <step>Updated app/db/clickhouse.py to use config.clickhouse_https from unified config</step>
                <step>Added service mode fields (redis_mode, clickhouse_mode, llm_mode) to AppConfig schema</step>
                <step>Updated ServiceConfigManager to populate service modes in config</step>
                <step>Fixed llm_config_manager.py to use settings.llm_mode instead of os.environ.get()</step>
                <step>Fixed clickhouse.py create_clickhouse_client to use config for mode detection</step>
            </solution>
            <files-modified>
                <file>app/db/clickhouse.py - Use unified config instead of os.environ.get()</file>
                <file>app/llm/llm_config_manager.py - Use settings.llm_mode from unified config</file>
                <file>app/schemas/Config.py - Added service mode fields to AppConfig</file>
                <file>app/core/configuration/services.py - Added _populate_service_modes method</file>
            </files-modified>
            <code-example>
                # Before - Direct environment access with defaults
                def get_clickhouse_config():
                    return ClickHouseHTTPSConfig(
                        host=os.environ.get("CLICKHOUSE_HOST", "localhost"),
                        port=int(os.environ.get("CLICKHOUSE_PORT", "8443")),
                        user=os.environ.get("CLICKHOUSE_USER", "default"),
                        password=os.environ.get("CLICKHOUSE_PASSWORD", "netra_dev_password")
                    )
                
                # After - Using unified config
                def get_clickhouse_config():
                    from app.config import get_config
                    config = get_config()
                    return config.clickhouse_https
                
                # AppConfig additions
                redis_mode: str = Field(default="shared", description="Redis service mode")
                clickhouse_mode: str = Field(default="shared", description="ClickHouse service mode")
                llm_mode: str = Field(default="shared", description="LLM service mode")
            </code-example>
            <architectural-insight>
                The unified configuration system exists to be the single source of truth. All configuration
                access MUST go through this system to ensure consistency. Direct os.environ.get() calls
                bypass the validation, population, and consistency checks provided by the unified system.
            </architectural-insight>
            <prevention>
                <item>ALWAYS use get_config() from app.config for configuration access</item>
                <item>NEVER use os.environ.get() directly in application code</item>
                <item>Add all configuration fields to AppConfig schema for type safety</item>
                <item>Test configuration loading with environment variables to ensure real values are used</item>
                <item>Run configuration integrity check on startup to detect issues early</item>
            </prevention>
        </learning>

    </learnings>
</specification>