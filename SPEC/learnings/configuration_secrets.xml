<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Learnings - Configuration/Secrets</name>
        <type>learnings</type>
        <category>Configuration/Secrets</category>
        <version>1.0</version>
        <last_updated>2025-08-16</last_updated>
        <description>Learnings and fixes for Configuration/Secrets</description>
    </metadata>
    
    <learnings>
        <learning id="staging-env-var-suffix-handling">
                    <title>Staging Environment Variables Suffix Handling</title>
                    <date>2025-08-16</date>
                    <category>Configuration/Secrets</category>
                    <description>
                        Staging deployment scripts pass environment variables with _STAGING suffix (e.g., GEMINI_API_KEY_STAGING),
                        but the application was only looking for regular names (e.g., GEMINI_API_KEY) when loading from environment.
                        This caused secrets to not be found when Google Secret Manager was unavailable.
                    </description>
                    <symptoms>
                        <symptom>Gemini API key not being loaded in staging environment</symptom>
                        <symptom>Deployment scripts setting GEMINI_API_KEY_STAGING but app looking for GEMINI_API_KEY</symptom>
                        <symptom>Secret Manager fallback to environment variables failing in staging</symptom>
                    </symptoms>
                    <root-causes>
                        <cause>Deployment scripts (deploy_staging_remote.sh/ps1) use _STAGING suffix for env vars</cause>
                        <cause>GitHub Actions workflow uses secrets with _STAGING suffix</cause>
                        <cause>SecretManager._load_from_environment() only checked regular env var names</cause>
                    </root-causes>
                    <solution>
                        <step>Updated SecretManager._load_from_environment() to check for _STAGING suffix when in staging</step>
                        <step>Logic: In staging environment, first try env_var + "_STAGING", then fall back to regular env_var</step>
                        <step>This allows both patterns to work: direct env vars and staging-suffixed vars</step>
                    </solution>
                    <files-modified>
                        <file>app/core/secret_manager.py - Updated _load_from_environment() to handle staging suffix</file>
                    </files-modified>
                    <code-example>
                        # Check if we're in staging environment
                        environment = os.environ.get("ENVIRONMENT", "development").lower()
                        k_service = os.environ.get("K_SERVICE")
                        is_staging = environment == "staging" or (k_service and "staging" in k_service.lower())

                        secrets = {}
                        for secret_name, env_var in env_mapping.items():
                            # Try staging-suffixed env var first if in staging
                            if is_staging:
                                staging_env_var = f"{env_var}_STAGING"
                                value = os.environ.get(staging_env_var)
                                if value:
                                    secrets[secret_name] = value
                                    continue
                            # Fall back to regular env var
                            value = os.environ.get(env_var)
                            if value:
                                secrets[secret_name] = value
                    </code-example>
                    <prevention>
                        <item>Always test secret loading in staging environment with actual deployment patterns</item>
                        <item>Ensure consistency between deployment scripts and application expectations</item>
                        <item>Document expected environment variable names clearly</item>
                    </prevention>
                </learning>

        <learning id="cors-devlauncher-middleware-configuration">
            <title>CORS Configuration with Dev Launcher as Middleware</title>
            <date>2025-08-16</date>
            <category>Configuration/Secrets</category>
            <description>
                Dev launcher acts as a middleware layer between the developer and the backend application,
                spawning the backend with specific environment variables. CORS configuration must be properly
                set at the dev launcher level to ensure the backend receives the correct allowed origins.
                Dynamic localhost ports require wildcard handling in development.
            </description>
            <symptoms>
                <symptom>CORS errors with dynamic localhost ports (e.g., http://localhost:51115)</symptom>
                <symptom>Backend rejecting requests from unexpected localhost ports</symptom>
                <symptom>Middleware debug logs showing "Origin not allowed" for valid development origins</symptom>
                <symptom>Terraform deployments overwriting CORS settings</symptom>
            </symptoms>
            <root-causes>
                <cause>Dev launcher not setting CORS_ORIGINS environment variable</cause>
                <cause>Backend defaulting to hardcoded localhost:3000 and localhost:8000 only</cause>
                <cause>Middleware wildcard logic incorrectly restricting development origins</cause>
                <cause>Environment variable not properly parsed when set to wildcard "*"</cause>
            </root-causes>
            <solution>
                <step>Updated dev_launcher/launcher.py to set CORS_ORIGINS="*" in _create_backend_env()</step>
                <step>Fixed middleware_setup.py to properly handle CORS_ORIGINS="*" without splitting</step>
                <step>Simplified is_origin_allowed() to return True for all origins in development with wildcard</step>
                <step>Ensured dev launcher passes environment variables correctly to backend process</step>
            </solution>
            <files-modified>
                <file>dev_launcher/launcher.py - Added CORS_ORIGINS="*" to backend environment</file>
                <file>app/core/middleware_setup.py - Fixed wildcard handling and origin checking logic</file>
            </files-modified>
            <code-example>
                # In dev_launcher/launcher.py
                def _create_backend_env(self, port: int) -> dict:
                    """Create backend environment variables."""
                    service_env_vars = self.services_config.get_all_env_vars()
                    return create_process_env(
                        BACKEND_PORT=str(port),
                        PYTHONPATH=str(self.config.project_root),
                        ENVIRONMENT="development",
                        CORS_ORIGINS="*",  # Allow all origins in development
                        **service_env_vars,
                        **self.config.env_overrides
                    )

                # In middleware_setup.py
                def _get_development_cors_origins() -> list[str]:
                    cors_origins_env = os.environ.get("CORS_ORIGINS", "")
                    if cors_origins_env:
                        # Handle wildcard separately - don't try to split it
                        if cors_origins_env == "*":
                            return ["*"]
                        return cors_origins_env.split(",")
                    return ["http://localhost:3000", "http://localhost:8000", "*"]
            </code-example>
            <architectural-insight>
                Dev launcher acts as a crucial middleware layer that controls the backend's runtime environment.
                Configuration must flow from dev launcher -> backend environment -> application middleware.
                Any environment-specific settings should be injected at the dev launcher level for consistency.
            </architectural-insight>
            <prevention>
                <item>Always configure CORS at the dev launcher level for development environments</item>
                <item>Test with dynamic ports to ensure wildcard handling works correctly</item>
                <item>Document that dev launcher is responsible for environment configuration</item>
                <item>Ensure Terraform deployments set appropriate CORS_ORIGINS for each environment</item>
            </prevention>
        </learning>

        <learning id="staging-cors-missing-env-var">
            <title>Staging CORS Configuration Missing Environment Variable</title>
            <date>2025-08-16</date>
            <category>Configuration/Secrets</category>
            <description>
                Staging environment backend was missing CORS_ORIGINS environment variable in Terraform configuration,
                causing CORS errors when frontend at app.staging.netrasystems.ai tried to access backend at
                backend-staging-*.a.run.app URLs. While the middleware supports pattern matching for Cloud Run URLs,
                the environment variable must be set to trigger proper CORS handling in staging.
            </description>
            <symptoms>
                <symptom>Access blocked by CORS policy: No 'Access-Control-Allow-Origin' header present</symptom>
                <symptom>Frontend at app.staging.netrasystems.ai cannot access backend-staging-*.a.run.app</symptom>
                <symptom>Health checks and API calls failing with CORS errors in staging environment</symptom>
                <symptom>Pattern matching for Cloud Run URLs not working despite being implemented</symptom>
            </symptoms>
            <root-causes>
                <cause>Terraform configuration missing CORS_ORIGINS environment variable for backend service</cause>
                <cause>Backend defaulting to minimal CORS origins without explicit configuration</cause>
                <cause>CustomCORSMiddleware not properly configured without CORS_ORIGINS variable</cause>
            </root-causes>
            <solution>
                <step>Added CORS_ORIGINS env var to terraform-gcp/main.tf backend service configuration</step>
                <step>Included explicit staging domains and wildcard for Cloud Run URL pattern matching</step>
                <step>Verified pattern matching for *.a.run.app URLs works correctly in middleware</step>
                <step>Created test script to validate CORS configuration for all expected origins</step>
            </solution>
            <files-modified>
                <file>terraform-gcp/main.tf - Added CORS_ORIGINS environment variable</file>
                <file>test_cors_staging.py - Created test script for CORS validation</file>
            </files-modified>
            <code-example>
                # In terraform-gcp/main.tf
                env {
                  name  = "CORS_ORIGINS"
                  value = "https://staging.netrasystems.ai,https://app.staging.netrasystems.ai,https://auth.staging.netrasystems.ai,https://backend.staging.netrasystems.ai,*"
                }
            </code-example>
            <architectural-insight>
                Terraform deployments must explicitly set all required environment variables for proper CORS handling.
                The wildcard (*) in CORS_ORIGINS triggers pattern matching logic in CustomCORSMiddleware,
                allowing Cloud Run URLs (*.a.run.app) and staging subdomains to be accepted dynamically.
            </architectural-insight>
            <prevention>
                <item>Always set CORS_ORIGINS in Terraform for all environments</item>
                <item>Include wildcard (*) for staging to enable pattern matching</item>
                <item>Test CORS configuration after any Terraform deployment changes</item>
                <item>Document that both explicit origins and wildcard are needed for staging</item>
            </prevention>
        </learning>

    </learnings>
</specification>