<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Learnings - Configuration/Secrets</name>
        <type>learnings</type>
        <category>Configuration/Secrets</category>
        <version>1.0</version>
        <last_updated>2025-08-16</last_updated>
        <description>Learnings and fixes for Configuration/Secrets</description>
    </metadata>
    
    <learnings>
        <learning id="staging-env-var-suffix-handling">
                    <title>Staging Environment Variables Suffix Handling</title>
                    <date>2025-08-16</date>
                    <category>Configuration/Secrets</category>
                    <description>
                        Staging deployment scripts pass environment variables with _STAGING suffix (e.g., GEMINI_API_KEY_STAGING),
                        but the application was only looking for regular names (e.g., GEMINI_API_KEY) when loading from environment.
                        This caused secrets to not be found when Google Secret Manager was unavailable.
                    </description>
                    <symptoms>
                        <symptom>Gemini API key not being loaded in staging environment</symptom>
                        <symptom>Deployment scripts setting GEMINI_API_KEY_STAGING but app looking for GEMINI_API_KEY</symptom>
                        <symptom>Secret Manager fallback to environment variables failing in staging</symptom>
                    </symptoms>
                    <root-causes>
                        <cause>Deployment scripts (deploy_staging_remote.sh/ps1) use _STAGING suffix for env vars</cause>
                        <cause>GitHub Actions workflow uses secrets with _STAGING suffix</cause>
                        <cause>SecretManager._load_from_environment() only checked regular env var names</cause>
                    </root-causes>
                    <solution>
                        <step>Updated SecretManager._load_from_environment() to check for _STAGING suffix when in staging</step>
                        <step>Logic: In staging environment, first try env_var + "_STAGING", then fall back to regular env_var</step>
                        <step>This allows both patterns to work: direct env vars and staging-suffixed vars</step>
                    </solution>
                    <files-modified>
                        <file>app/core/secret_manager.py - Updated _load_from_environment() to handle staging suffix</file>
                    </files-modified>
                    <code-example>
                        # Check if we're in staging environment
                        environment = os.environ.get("ENVIRONMENT", "development").lower()
                        k_service = os.environ.get("K_SERVICE")
                        is_staging = environment == "staging" or (k_service and "staging" in k_service.lower())

                        secrets = {}
                        for secret_name, env_var in env_mapping.items():
                            # Try staging-suffixed env var first if in staging
                            if is_staging:
                                staging_env_var = f"{env_var}_STAGING"
                                value = os.environ.get(staging_env_var)
                                if value:
                                    secrets[secret_name] = value
                                    continue
                            # Fall back to regular env var
                            value = os.environ.get(env_var)
                            if value:
                                secrets[secret_name] = value
                    </code-example>
                    <prevention>
                        <item>Always test secret loading in staging environment with actual deployment patterns</item>
                        <item>Ensure consistency between deployment scripts and application expectations</item>
                        <item>Document expected environment variable names clearly</item>
                    </prevention>
                </learning>

        <learning id="cors-wildcard-subdomain-not-supported">
            <title>CORS Wildcard Subdomains Are Not Supported</title>
            <date>2025-08-21</date>
            <category>Configuration/Secrets</category>
            <description>
                CORS specification does not support wildcard subdomains like *.staging.netrasystems.ai.
                The asterisk (*) in CORS only works as a standalone character meaning "all origins",
                not as a pattern matcher for subdomains. All staging subdomains must be explicitly listed.
            </description>
            <symptoms>
                <symptom>CORS errors when accessing from auth.staging.netrasystems.ai</symptom>
                <symptom>GitHub workflow using *.staging pattern that doesn't work</symptom>
                <symptom>Terraform configurations missing explicit auth.staging origin</symptom>
            </symptoms>
            <root-causes>
                <cause>Misunderstanding that CORS supports wildcard subdomain patterns</cause>
                <cause>Deployment scripts using https://*.staging.netrasystems.ai thinking it would match all subdomains</cause>
                <cause>Missing explicit auth.staging.netrasystems.ai in allowed origins lists</cause>
            </root-causes>
            <solution>
                <step>Replaced all wildcard subdomain patterns with explicit origin lists</step>
                <step>Added auth.staging.netrasystems.ai to all CORS configurations</step>
                <step>Updated GitHub workflow, Terraform, deployment scripts, and service configurations</step>
                <step>Documented that wildcard subdomains are not supported in CORS spec</step>
            </solution>
            <files-modified>
                <file>.github/workflows/deploy-auth-service.yml - Replaced wildcard with explicit origins</file>
                <file>auth_service/main.py - Added all staging subdomains explicitly</file>
                <file>terraform-gcp/auth-service.tf - Added explicit staging origins</file>
                <file>scripts/deploy_auth_service.py - Updated CORS origins list</file>
                <file>app/core/middleware_setup.py - Ensured consistent origins</file>
                <file>SPEC/cors_configuration.xml - Documented wildcard limitation</file>
            </files-modified>
            <code-example>
                # INCORRECT - This doesn't work:
                CORS_ORIGINS="https://*.staging.netrasystems.ai"
                
                # CORRECT - Must list explicitly:
                CORS_ORIGINS="https://app.staging.netrasystems.ai,https://auth.staging.netrasystems.ai,https://api.staging.netrasystems.ai,https://backend.staging.netrasystems.ai"
            </code-example>
            <prevention>
                <item>Always list CORS origins explicitly, never use wildcard subdomain patterns</item>
                <item>When adding new subdomains, update all CORS configurations</item>
                <item>Test CORS from all expected origins before deployment</item>
                <item>Use CustomCORSMiddleware with pattern matching for dynamic validation if needed</item>
            </prevention>
        </learning>

        <learning id="cors-devlauncher-middleware-configuration">
            <title>CORS Configuration with Dev Launcher as Middleware</title>
            <date>2025-08-16</date>
            <category>Configuration/Secrets</category>
            <description>
                Dev launcher acts as a middleware layer between the developer and the backend application,
                spawning the backend with specific environment variables. CORS configuration must be properly
                set at the dev launcher level to ensure the backend receives the correct allowed origins.
                Dynamic localhost ports require wildcard handling in development.
            </description>
            <symptoms>
                <symptom>CORS errors with dynamic localhost ports (e.g., http://localhost:51115)</symptom>
                <symptom>Backend rejecting requests from unexpected localhost ports</symptom>
                <symptom>Middleware debug logs showing "Origin not allowed" for valid development origins</symptom>
                <symptom>Terraform deployments overwriting CORS settings</symptom>
            </symptoms>
            <root-causes>
                <cause>Dev launcher not setting CORS_ORIGINS environment variable</cause>
                <cause>Backend defaulting to hardcoded localhost:3000 and localhost:8000 only</cause>
                <cause>Middleware wildcard logic incorrectly restricting development origins</cause>
                <cause>Environment variable not properly parsed when set to wildcard "*"</cause>
            </root-causes>
            <solution>
                <step>Updated dev_launcher/launcher.py to set CORS_ORIGINS="*" in _create_backend_env()</step>
                <step>Fixed middleware_setup.py to properly handle CORS_ORIGINS="*" without splitting</step>
                <step>Simplified is_origin_allowed() to return True for all origins in development with wildcard</step>
                <step>Ensured dev launcher passes environment variables correctly to backend process</step>
            </solution>
            <files-modified>
                <file>dev_launcher/launcher.py - Added CORS_ORIGINS="*" to backend environment</file>
                <file>app/core/middleware_setup.py - Fixed wildcard handling and origin checking logic</file>
            </files-modified>
            <code-example>
                # In dev_launcher/launcher.py
                def _create_backend_env(self, port: int) -> dict:
                    """Create backend environment variables."""
                    service_env_vars = self.services_config.get_all_env_vars()
                    return create_process_env(
                        BACKEND_PORT=str(port),
                        PYTHONPATH=str(self.config.project_root),
                        ENVIRONMENT="development",
                        CORS_ORIGINS="*",  # Allow all origins in development
                        **service_env_vars,
                        **self.config.env_overrides
                    )

                # In middleware_setup.py
                def _get_development_cors_origins() -> list[str]:
                    cors_origins_env = os.environ.get("CORS_ORIGINS", "")
                    if cors_origins_env:
                        # Handle wildcard separately - don't try to split it
                        if cors_origins_env == "*":
                            return ["*"]
                        return cors_origins_env.split(",")
                    return ["http://localhost:3000", "http://localhost:8000", "*"]
            </code-example>
            <architectural-insight>
                Dev launcher acts as a crucial middleware layer that controls the backend's runtime environment.
                Configuration must flow from dev launcher -> backend environment -> application middleware.
                Any environment-specific settings should be injected at the dev launcher level for consistency.
            </architectural-insight>
            <prevention>
                <item>Always configure CORS at the dev launcher level for development environments</item>
                <item>Test with dynamic ports to ensure wildcard handling works correctly</item>
                <item>Document that dev launcher is responsible for environment configuration</item>
                <item>Ensure Terraform deployments set appropriate CORS_ORIGINS for each environment</item>
            </prevention>
        </learning>

        <learning id="auth-service-cors-wildcard-handling">
            <title>Auth Service CORS Wildcard with Credentials</title>
            <date>2025-08-18</date>
            <category>Configuration/Secrets</category>
            <description>
                Auth service using FastAPI's standard CORSMiddleware fails to send Access-Control-Allow-Origin 
                header when configured with allow_origins=["*"] and allow_credentials=True. This is a security 
                feature - CORS spec prohibits using wildcard origin with credentials. In development with dynamic 
                localhost ports, a custom middleware is required to handle CORS dynamically.
            </description>
            <symptoms>
                <symptom>CORS errors from dynamic localhost ports (e.g., http://localhost:57199)</symptom>
                <symptom>Missing Access-Control-Allow-Origin header in auth service responses</symptom>
                <symptom>Frontend fetch requests to auth service endpoints blocked by CORS policy</symptom>
                <symptom>Auth service returns other CORS headers but not Allow-Origin</symptom>
            </symptoms>
            <root-causes>
                <cause>FastAPI CORSMiddleware won't send Allow-Origin header with wildcard and credentials</cause>
                <cause>Auth service configured with CORS_ORIGINS="*" but using standard middleware</cause>
                <cause>Dynamic localhost ports in development require per-request origin handling</cause>
            </root-causes>
            <solution>
                <step>Created DynamicCORSMiddleware class for auth service when CORS_ORIGINS="*"</step>
                <step>Middleware dynamically adds Allow-Origin header matching request origin</step>
                <step>Updated dev_launcher/auth_starter.py to set CORS_ORIGINS="*" environment variable</step>
                <step>Preserved standard CORSMiddleware for non-wildcard origin configurations</step>
            </solution>
            <files-modified>
                <file>auth_service/main.py - Added DynamicCORSMiddleware for wildcard handling</file>
                <file>dev_launcher/auth_starter.py - Added CORS_ORIGINS="*" to auth environment</file>
            </files-modified>
            <code-example>
                # In auth_service/main.py
                if cors_origins == ["*"]:
                    class DynamicCORSMiddleware(BaseHTTPMiddleware):
                        async def dispatch(self, request, call_next):
                            origin = request.headers.get("origin")
                            if request.method == "OPTIONS":
                                response = Response(status_code=200)
                                if origin:
                                    response.headers["Access-Control-Allow-Origin"] = origin
                                    response.headers["Access-Control-Allow-Credentials"] = "true"
                                return response
                            response = await call_next(request)
                            if origin:
                                response.headers["Access-Control-Allow-Origin"] = origin
                                response.headers["Access-Control-Allow-Credentials"] = "true"
                            return response
                    app.add_middleware(DynamicCORSMiddleware)
            </code-example>
            <architectural-insight>
                The CORS specification explicitly prohibits using wildcard origin with credentials for security.
                Development environments with dynamic ports require custom middleware to handle CORS dynamically
                while maintaining credentials support. Production should use explicit origin lists.
            </architectural-insight>
            <prevention>
                <item>Always use custom middleware for wildcard CORS with credentials in development</item>
                <item>Test auth service with dynamic localhost ports before deployment</item>
                <item>Document that wildcard with credentials requires special handling</item>
                <item>Use explicit origin lists in staging and production environments</item>
            </prevention>
        </learning>

        <learning id="staging-cors-missing-env-var">
            <title>Staging CORS Configuration Missing Environment Variable</title>
            <date>2025-08-16</date>
            <category>Configuration/Secrets</category>
            <description>
                Staging environment backend was missing CORS_ORIGINS environment variable in Terraform configuration,
                causing CORS errors when frontend at app.staging.netrasystems.ai tried to access backend at
                backend-staging-*.a.run.app URLs. While the middleware supports pattern matching for Cloud Run URLs,
                the environment variable must be set to trigger proper CORS handling in staging.
            </description>
            <symptoms>
                <symptom>Access blocked by CORS policy: No 'Access-Control-Allow-Origin' header present</symptom>
                <symptom>Frontend at app.staging.netrasystems.ai cannot access backend-staging-*.a.run.app</symptom>
                <symptom>Health checks and API calls failing with CORS errors in staging environment</symptom>
                <symptom>Pattern matching for Cloud Run URLs not working despite being implemented</symptom>
            </symptoms>
            <root-causes>
                <cause>Terraform configuration missing CORS_ORIGINS environment variable for backend service</cause>
                <cause>Backend defaulting to minimal CORS origins without explicit configuration</cause>
                <cause>CustomCORSMiddleware not properly configured without CORS_ORIGINS variable</cause>
            </root-causes>
            <solution>
                <step>Added CORS_ORIGINS env var to terraform-gcp/main.tf backend service configuration</step>
                <step>Included explicit staging domains and wildcard for Cloud Run URL pattern matching</step>
                <step>Verified pattern matching for *.a.run.app URLs works correctly in middleware</step>
                <step>Created test script to validate CORS configuration for all expected origins</step>
            </solution>
            <files-modified>
                <file>terraform-gcp/main.tf - Added CORS_ORIGINS environment variable</file>
                <file>test_cors_staging.py - Created test script for CORS validation</file>
            </files-modified>
            <code-example>
                # In terraform-gcp/main.tf
                env {
                  name  = "CORS_ORIGINS"
                  value = "https://app.staging.netrasystems.ai,https://app.staging.netrasystems.ai,https://auth.staging.netrasystems.ai,https://backend.staging.netrasystems.ai,*"
                }
            </code-example>
            <architectural-insight>
                Terraform deployments must explicitly set all required environment variables for proper CORS handling.
                The wildcard (*) in CORS_ORIGINS triggers pattern matching logic in CustomCORSMiddleware,
                allowing Cloud Run URLs (*.a.run.app) and staging subdomains to be accepted dynamically.
            </architectural-insight>
            <prevention>
                <item>Always set CORS_ORIGINS in Terraform for all environments</item>
                <item>Include wildcard (*) for staging to enable pattern matching</item>
                <item>Test CORS configuration after any Terraform deployment changes</item>
                <item>Document that both explicit origins and wildcard are needed for staging</item>
            </prevention>
        </learning>

        <learning id="gemini-api-key-paradox">
            <title>GEMINI API Key Loading Paradox - Module Import Timing Issue</title>
            <date>2025-08-18</date>
            <category>Configuration/Secrets</category>
            <description>
                Dev launcher loads GEMINI_API_KEY successfully but backend reports "Required secrets missing: ['gemini-api-key']".
                Root cause: Configuration loading happens at module import time (app/config.py line 59) before subprocess
                environment is fully available. Also, unified logging wrapper doesn't preserve caller frame information.
            </description>
            <symptoms>
                <symptom>Dev launcher shows loading GEMINI_API_KEY successfully</symptom>
                <symptom>Backend reports "Required secrets missing: ['gemini-api-key']"</symptom>
                <symptom>Logging shows app.core.unified_logging instead of actual module locations</symptom>
                <symptom>Backend fails to start due to missing secrets that are actually present</symptom>
            </symptoms>
            <root-causes>
                <cause>app/config.py line 59 executes "settings = get_config()" at module import time</cause>
                <cause>Module-level code executes before subprocess environment is fully available</cause>
                <cause>Unified logging wrapper doesn't preserve caller frame information</cause>
                <cause>Console formatter uses wrapper location instead of actual caller location</cause>
            </root-causes>
            <solution>
                <step>Changed app/config.py from eager loading to lazy loading using __getattr__</step>
                <step>Settings now load on first access, not at module import time</step>
                <step>Added frame inspection to unified_logging.py to capture actual caller location</step>
                <step>Updated logging_formatters.py to use caller info from context</step>
            </solution>
            <files-modified>
                <file>app/config.py - Changed from eager to lazy loading of settings</file>
                <file>app/core/unified_logging.py - Added caller frame capture with inspect</file>
                <file>app/core/logging_formatters.py - Updated console format to use caller info</file>
            </files-modified>
            <code-example>
                # In app/config.py - Lazy loading pattern
                _settings_cache = None
                
                def __getattr__(name):
                    """Lazy load settings on first access."""
                    global _settings_cache
                    if name == "settings":
                        if _settings_cache is None:
                            _settings_cache = get_config()
                        return _settings_cache
                    raise AttributeError(f"module '{__name__}' has no attribute '{name}'")
                
                # In unified_logging.py - Caller frame capture
                frame = inspect.currentframe()
                caller_frame = frame.f_back.f_back.f_back if frame else None
                if caller_frame:
                    context['caller_module'] = caller_frame.f_globals.get('__name__', 'unknown')
                    context['caller_function'] = caller_frame.f_code.co_name
                    context['caller_line'] = caller_frame.f_lineno
            </code-example>
            <architectural-insight>
                Module-level code executes immediately on import, which happens before subprocess environment
                setup is complete. Always use lazy initialization for configuration that depends on environment.
                Logging wrappers must preserve caller information for effective debugging.
            </architectural-insight>
            <prevention>
                <item>NEVER load configuration at module import time - always use lazy loading</item>
                <item>Use __getattr__ or property decorators for lazy attribute access</item>
                <item>Test subprocess environment inheritance with timing scenarios</item>
                <item>When wrapping loggers, preserve caller frame information</item>
            </prevention>
        </learning>

        <learning id="unified-config-direct-env-access">
            <title>Unified Configuration System - Direct Environment Variable Access Issue</title>
            <date>2025-08-18</date>
            <category>Configuration/Secrets</category>
            <description>
                Multiple modules were directly accessing os.environ.get() with hardcoded defaults instead of using
                the unified configuration system, causing inconsistent configuration values and defaults being used
                instead of real values loaded by the unified config manager.
            </description>
            <symptoms>
                <symptom>Configuration values using hardcoded defaults instead of actual values</symptom>
                <symptom>Service modes (LLM_MODE, CLICKHOUSE_MODE) not properly detected</symptom>
                <symptom>ClickHouse using localhost with default passwords instead of real config</symptom>
                <symptom>Inconsistent configuration between different parts of the system</symptom>
            </symptoms>
            <root-causes>
                <cause>app/db/clickhouse.py:get_clickhouse_config() directly using os.environ.get()</cause>
                <cause>app/llm/llm_config_manager.py directly checking os.environ.get("LLM_MODE")</cause>
                <cause>Service mode configuration not centralized in AppConfig schema</cause>
                <cause>Unified configuration system not being used consistently</cause>
            </root-causes>
            <solution>
                <step>Updated app/db/clickhouse.py to use config.clickhouse_https from unified config</step>
                <step>Added service mode fields (redis_mode, clickhouse_mode, llm_mode) to AppConfig schema</step>
                <step>Updated ServiceConfigManager to populate service modes in config</step>
                <step>Fixed llm_config_manager.py to use settings.llm_mode instead of os.environ.get()</step>
                <step>Fixed clickhouse.py create_clickhouse_client to use config for mode detection</step>
            </solution>
            <files-modified>
                <file>app/db/clickhouse.py - Use unified config instead of os.environ.get()</file>
                <file>app/llm/llm_config_manager.py - Use settings.llm_mode from unified config</file>
                <file>app/schemas/Config.py - Added service mode fields to AppConfig</file>
                <file>app/core/configuration/services.py - Added _populate_service_modes method</file>
            </files-modified>
            <code-example>
                # Before - Direct environment access with defaults
                def get_clickhouse_config():
                    return ClickHouseHTTPSConfig(
                        host=os.environ.get("CLICKHOUSE_HOST", "localhost"),
                        port=int(os.environ.get("CLICKHOUSE_PORT", "8443")),
                        user=os.environ.get("CLICKHOUSE_USER", "default"),
                        password=os.environ.get("CLICKHOUSE_PASSWORD", "netra_dev_password")
                    )
                
                # After - Using unified config
                def get_clickhouse_config():
                    from app.config import get_config
                    config = get_config()
                    return config.clickhouse_https
                
                # AppConfig additions
                redis_mode: str = Field(default="shared", description="Redis service mode")
                clickhouse_mode: str = Field(default="shared", description="ClickHouse service mode")
                llm_mode: str = Field(default="shared", description="LLM service mode")
            </code-example>
            <architectural-insight>
                The unified configuration system exists to be the single source of truth. All configuration
                access MUST go through this system to ensure consistency. Direct os.environ.get() calls
                bypass the validation, population, and consistency checks provided by the unified system.
            </architectural-insight>
            <prevention>
                <item>ALWAYS use get_config() from app.config for configuration access</item>
                <item>NEVER use os.environ.get() directly in application code</item>
                <item>Add all configuration fields to AppConfig schema for type safety</item>
                <item>Test configuration loading with environment variables to ensure real values are used</item>
                <item>Run configuration integrity check on startup to detect issues early</item>
            </prevention>
        </learning>

        <learning id="cors-comprehensive-fix-2025-08-20">
            <title>Comprehensive CORS Configuration Fix Across All Services</title>
            <date>2025-08-20</date>
            <category>Configuration/Secrets</category>
            <description>
                Resolved persistent CORS errors between frontend (localhost:3001) and auth service (localhost:8081)
                through comprehensive specification updates, implementation fixes, and regression test creation.
                The fix addresses wildcard with credentials issues and ensures consistency across all services.
            </description>
            <symptoms>
                <symptom>Access to fetch at 'http://localhost:8081/auth/config' blocked by CORS policy</symptom>
                <symptom>No 'Access-Control-Allow-Origin' header present on auth service responses</symptom>
                <symptom>Inconsistent CORS headers between main backend and auth service</symptom>
                <symptom>Dynamic localhost ports causing CORS failures</symptom>
            </symptoms>
            <root-causes>
                <cause>DynamicCORSMiddleware using wildcard (*) for methods/headers with credentials=true</cause>
                <cause>CORS specification prohibits wildcard with credentials for security</cause>
                <cause>Missing comprehensive CORS specification leading to implementation divergence</cause>
                <cause>No regression tests to catch CORS configuration issues</cause>
            </root-causes>
            <solution>
                <step>Updated SPEC/cors_configuration.xml with comprehensive requirements and patterns</step>
                <step>Fixed auth_service/main.py DynamicCORSMiddleware to use specific headers instead of wildcards</step>
                <step>Updated app/core/middleware_setup.py CustomCORSMiddleware for consistency</step>
                <step>Created 61-test regression prevention suite across unit/integration/e2e levels</step>
                <step>Verified dev_launcher properly sets CORS_ORIGINS=* for all services</step>
            </solution>
            <files-modified>
                <file>SPEC/cors_configuration.xml - Added implementation patterns and requirements</file>
                <file>auth_service/main.py - Fixed DynamicCORSMiddleware wildcard issues</file>
                <file>app/core/middleware_setup.py - Enhanced CustomCORSMiddleware consistency</file>
                <file>tests/test_cors_configuration.py - Created 30 unit tests</file>
                <file>tests/integration/test_cors_integration.py - Created 14 integration tests</file>
                <file>tests/e2e/test_cors_e2e.py - Created 17 e2e tests</file>
            </files-modified>
            <code-example>
                # Fixed DynamicCORSMiddleware pattern
                if request.method == "OPTIONS":
                    response = Response(status_code=200)
                    if origin:
                        response.headers["Access-Control-Allow-Origin"] = origin
                        response.headers["Access-Control-Allow-Credentials"] = "true"
                        # Use specific values, not wildcards with credentials
                        response.headers["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD"
                        response.headers["Access-Control-Allow-Headers"] = "Authorization, Content-Type, X-Request-ID, X-Trace-ID, Accept, Origin, Referer, X-Requested-With"
                        response.headers["Access-Control-Max-Age"] = "3600"
                    return response
            </code-example>
            <architectural-insight>
                CORS specification explicitly prohibits using wildcard values for Allow-Methods and Allow-Headers
                when Allow-Credentials is true. This is a security feature to prevent credential leakage.
                Development environments must use DynamicCORSMiddleware that echoes the requesting origin
                while using specific method and header lists. This pattern allows dynamic ports while
                maintaining security compliance.
            </architectural-insight>
            <prevention>
                <item>Always test CORS with actual cross-origin requests, not same-origin</item>
                <item>Run CORS regression test suite before any deployment</item>
                <item>Use DynamicCORSMiddleware pattern for development wildcard support</item>
                <item>Never use wildcard (*) for methods/headers with credentials enabled</item>
                <item>Ensure all services have consistent CORS header configurations</item>
                <item>Test with dynamic localhost ports to catch development issues early</item>
            </prevention>
            <test-command>
                python -m pytest tests/test_cors_configuration.py::test_auth_config_endpoint_cors_regression -v
            </test-command>
        </learning>

    </learnings>
</specification>