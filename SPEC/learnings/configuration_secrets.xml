<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Learnings - Configuration/Secrets</name>
        <type>learnings</type>
        <category>Configuration/Secrets</category>
        <version>1.0</version>
        <last_updated>2025-08-16</last_updated>
        <description>Learnings and fixes for Configuration/Secrets</description>
    </metadata>
    
    <learnings>
        <learning id="staging-env-var-suffix-handling">
                    <title>Staging Environment Variables Suffix Handling</title>
                    <date>2025-08-16</date>
                    <category>Configuration/Secrets</category>
                    <description>
                        Staging deployment scripts pass environment variables with _STAGING suffix (e.g., GEMINI_API_KEY_STAGING),
                        but the application was only looking for regular names (e.g., GEMINI_API_KEY) when loading from environment.
                        This caused secrets to not be found when Google Secret Manager was unavailable.
                    </description>
                    <symptoms>
                        <symptom>Gemini API key not being loaded in staging environment</symptom>
                        <symptom>Deployment scripts setting GEMINI_API_KEY_STAGING but app looking for GEMINI_API_KEY</symptom>
                        <symptom>Secret Manager fallback to environment variables failing in staging</symptom>
                    </symptoms>
                    <root-causes>
                        <cause>Deployment scripts (deploy_staging_remote.sh/ps1) use _STAGING suffix for env vars</cause>
                        <cause>GitHub Actions workflow uses secrets with _STAGING suffix</cause>
                        <cause>SecretManager._load_from_environment() only checked regular env var names</cause>
                    </root-causes>
                    <solution>
                        <step>Updated SecretManager._load_from_environment() to check for _STAGING suffix when in staging</step>
                        <step>Logic: In staging environment, first try env_var + "_STAGING", then fall back to regular env_var</step>
                        <step>This allows both patterns to work: direct env vars and staging-suffixed vars</step>
                    </solution>
                    <files-modified>
                        <file>app/core/secret_manager.py - Updated _load_from_environment() to handle staging suffix</file>
                    </files-modified>
                    <code-example>
                        # Check if we're in staging environment
                        environment = os.environ.get("ENVIRONMENT", "development").lower()
                        k_service = os.environ.get("K_SERVICE")
                        is_staging = environment == "staging" or (k_service and "staging" in k_service.lower())

                        secrets = {}
                        for secret_name, env_var in env_mapping.items():
                            # Try staging-suffixed env var first if in staging
                            if is_staging:
                                staging_env_var = f"{env_var}_STAGING"
                                value = os.environ.get(staging_env_var)
                                if value:
                                    secrets[secret_name] = value
                                    continue
                            # Fall back to regular env var
                            value = os.environ.get(env_var)
                            if value:
                                secrets[secret_name] = value
                    </code-example>
                    <prevention>
                        <item>Always test secret loading in staging environment with actual deployment patterns</item>
                        <item>Ensure consistency between deployment scripts and application expectations</item>
                        <item>Document expected environment variable names clearly</item>
                    </prevention>
                </learning>

        <learning id="cors-devlauncher-middleware-configuration">
            <title>CORS Configuration with Dev Launcher as Middleware</title>
            <date>2025-08-16</date>
            <category>Configuration/Secrets</category>
            <description>
                Dev launcher acts as a middleware layer between the developer and the backend application,
                spawning the backend with specific environment variables. CORS configuration must be properly
                set at the dev launcher level to ensure the backend receives the correct allowed origins.
                Dynamic localhost ports require wildcard handling in development.
            </description>
            <symptoms>
                <symptom>CORS errors with dynamic localhost ports (e.g., http://localhost:51115)</symptom>
                <symptom>Backend rejecting requests from unexpected localhost ports</symptom>
                <symptom>Middleware debug logs showing "Origin not allowed" for valid development origins</symptom>
                <symptom>Terraform deployments overwriting CORS settings</symptom>
            </symptoms>
            <root-causes>
                <cause>Dev launcher not setting CORS_ORIGINS environment variable</cause>
                <cause>Backend defaulting to hardcoded localhost:3000 and localhost:8000 only</cause>
                <cause>Middleware wildcard logic incorrectly restricting development origins</cause>
                <cause>Environment variable not properly parsed when set to wildcard "*"</cause>
            </root-causes>
            <solution>
                <step>Updated dev_launcher/launcher.py to set CORS_ORIGINS="*" in _create_backend_env()</step>
                <step>Fixed middleware_setup.py to properly handle CORS_ORIGINS="*" without splitting</step>
                <step>Simplified is_origin_allowed() to return True for all origins in development with wildcard</step>
                <step>Ensured dev launcher passes environment variables correctly to backend process</step>
            </solution>
            <files-modified>
                <file>dev_launcher/launcher.py - Added CORS_ORIGINS="*" to backend environment</file>
                <file>app/core/middleware_setup.py - Fixed wildcard handling and origin checking logic</file>
            </files-modified>
            <code-example>
                # In dev_launcher/launcher.py
                def _create_backend_env(self, port: int) -> dict:
                    """Create backend environment variables."""
                    service_env_vars = self.services_config.get_all_env_vars()
                    return create_process_env(
                        BACKEND_PORT=str(port),
                        PYTHONPATH=str(self.config.project_root),
                        ENVIRONMENT="development",
                        CORS_ORIGINS="*",  # Allow all origins in development
                        **service_env_vars,
                        **self.config.env_overrides
                    )

                # In middleware_setup.py
                def _get_development_cors_origins() -> list[str]:
                    cors_origins_env = os.environ.get("CORS_ORIGINS", "")
                    if cors_origins_env:
                        # Handle wildcard separately - don't try to split it
                        if cors_origins_env == "*":
                            return ["*"]
                        return cors_origins_env.split(",")
                    return ["http://localhost:3000", "http://localhost:8000", "*"]
            </code-example>
            <architectural-insight>
                Dev launcher acts as a crucial middleware layer that controls the backend's runtime environment.
                Configuration must flow from dev launcher -> backend environment -> application middleware.
                Any environment-specific settings should be injected at the dev launcher level for consistency.
            </architectural-insight>
            <prevention>
                <item>Always configure CORS at the dev launcher level for development environments</item>
                <item>Test with dynamic ports to ensure wildcard handling works correctly</item>
                <item>Document that dev launcher is responsible for environment configuration</item>
                <item>Ensure Terraform deployments set appropriate CORS_ORIGINS for each environment</item>
            </prevention>
        </learning>

    </learnings>
</specification>