<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <title>WebSocket Connection Loop - SSOT Fix for React Effects</title>
  <date>2025-01-03</date>
  <severity>CRITICAL</severity>
  <category>websocket,frontend,react,ssot</category>
  
  <problem>
    <description>
      Frontend WebSocket service creating continuous connection/disconnection loops in GCP staging.
      Multiple React effects in WebSocketProvider triggering simultaneous connection attempts when
      authentication state changes, causing rapid reconnection loops that overwhelm the backend.
    </description>
    <root_cause>
      Lack of Single Source of Truth (SSOT) for WebSocket connection lifecycle management.
      Two separate useEffect hooks responding to overlapping dependencies created race conditions.
    </root_cause>
    <impact>
      - Connection attempts: 10-50 per second (connection loop)
      - Backend overwhelmed with connection requests
      - User unable to use chat functionality
      - Staging environment unusable
    </impact>
  </problem>
  
  <discovery>
    <how_found>
      The bug was NOT a regression but a latent architectural flaw exposed when the auth system
      was fixed. Previously broken auth masked the issue by preventing proper token refresh.
      When auth started working correctly, it revealed that WebSocketProvider couldn't handle
      properly functioning authentication.
    </how_found>
    <key_insight>
      Success can expose hidden failures. The system "worked" through failure before.
      Fixing one core system (auth) exposed flaws in dependent systems (WebSocket).
    </key_insight>
  </discovery>
  
  <solution>
    <approach>SSOT - Single consolidated React effect for connection management</approach>
    <implementation>
      <file path="/frontend/providers/WebSocketProvider.tsx">
        <change>
          Consolidated two separate useEffect hooks into single coordinated effect with
          connection state management via connectionStateRef and lastProcessedTokenRef.
        </change>
      </file>
      <file path="/frontend/services/webSocketService.ts">
        <change>
          Added connection deduplication with connectionAttemptId, minimum interval
          enforcement (1 second), and auth-specific exponential backoff.
        </change>
      </file>
    </implementation>
    <key_components>
      - connectionStateRef: Tracks current connection state (disconnected/connecting/connected/updating)
      - lastProcessedTokenRef: Prevents reprocessing same token
      - Single useEffect: Evaluates state and determines action (connect/update/skip)
      - Connection throttling: Minimum 1-second interval between attempts
      - Auth backoff: Maximum 3 retries with 5-second cooldown
    </key_components>
  </solution>
  
  <architectural_principles>
    <principle name="SSOT">
      Single Source of Truth for connection lifecycle - one effect, one state machine
    </principle>
    <principle name="State_Management">
      Explicit state tracking prevents invalid transitions and duplicate operations
    </principle>
    <principle name="React_Effect_Coordination">
      Multiple related effects should be consolidated into single managed effect
    </principle>
    <principle name="Defensive_Programming">
      Multiple layers of deduplication and validation prevent edge cases
    </principle>
  </architectural_principles>
  
  <lessons_learned>
    <lesson>
      React effects with overlapping dependencies create race conditions.
      Always consolidate related effects into single coordinated effect.
    </lesson>
    <lesson>
      Integration testing is critical - unit tests wouldn't catch this interaction bug.
      Must test complete flows with rapid state changes.
    </lesson>
    <lesson>
      When fixing core systems (auth, security), review ALL consumers for
      implicit dependencies on broken behavior.
    </lesson>
    <lesson>
      Latent bugs can exist indefinitely until triggered by seemingly unrelated changes.
      Architecture reviews should consider "what if everything worked perfectly" scenarios.
    </lesson>
  </lessons_learned>
  
  <testing>
    <test_files>
      <file>/tests/frontend/test_websocket_connection_loop_regression.py</file>
      <file>/frontend/__tests__/providers/WebSocketProvider.test.tsx</file>
    </test_files>
    <test_scenarios>
      - Rapid auth state changes
      - Token refresh during active connection
      - Multiple simultaneous connection attempts
      - Auth failure retry logic
      - Network interruption recovery
    </test_scenarios>
  </testing>
  
  <monitoring>
    <metrics>
      <metric name="connection_attempts_per_second">Target: &lt;1</metric>
      <metric name="auth_retry_count">Target: &lt;=3</metric>
      <metric name="connection_stability">Target: Hours/Days</metric>
    </metrics>
    <alerts>
      <alert condition="connection_attempts > 2 per second">Connection loop detected</alert>
      <alert condition="auth_retries > 3">Auth failure requires user intervention</alert>
    </alerts>
  </monitoring>
  
  <related_issues>
    <issue>/WEBSOCKET_REQUEST_SPAM_FIVE_WHYS.md</issue>
    <issue>/reports/websocket_connection_loop_bug_report.md</issue>
    <issue>/WEBSOCKET_CONNECTION_LOOP_ROOT_CAUSE.md</issue>
    <issue>/WEBSOCKET_CONNECTION_LOOP_COMPLETE_ANALYSIS.md</issue>
  </related_issues>
  
  <future_improvements>
    <improvement>Add connection telemetry for production monitoring</improvement>
    <improvement>Implement circuit breaker for auth service failures</improvement>
    <improvement>Create performance dashboard for connection metrics</improvement>
    <improvement>Add feature flag for gradual rollout</improvement>
  </future_improvements>
  
  <compliance>
    <ssot_verified>true</ssot_verified>
    <tests_passing>true</tests_passing>
    <documentation_complete>true</documentation_complete>
    <ready_for_production>true</ready_for_production>
  </compliance>
</learning>