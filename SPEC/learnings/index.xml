<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>KnowledgeBase.LearningsIndex</name>
        <type>KnowledgeRetrievalMap</type>
        <version>2.0</version>
        <description>Index map for retrieving established patterns and critical learnings.</description>
    </metadata>
    
    <retrieval-protocol>
        <title>AI Utilization Strategy</title>
        <ai-directive>AI Agents MUST consult this index before task execution to avoid known regressions.</ai-directive>
        <workflow>
            <step>1. Analyze the task description for relevant keywords/domains.</step>
            <step>2. Query this index for matching categories.</step>
            <step>3. Prioritize and integrate the critical-takeaway elements into the execution plan.</step>
            <step>4. If necessary, retrieve the detailed learning file using the `path` attribute.</step>
        </workflow>
    </retrieval-protocol>
    
    <learning id="jwt-secret-standardization-hard-requirements-2025-08-30">
        <title>JWT Secret Standardization with Hard Requirements (No Fallbacks)</title>
        <category>Authentication Security</category>
        <keywords>jwt, authentication, secrets, staging, production, fallback elimination, hard requirements</keywords>
        <path>jwt_secret_standardization_hard_requirements.xml</path>
        <critical-takeaway>
            Fallback mechanisms in authentication create false confidence and mask configuration errors.
            Environment-specific JWT secrets MUST be enforced with immediate hard failure when missing.
            Single GSM secret source per environment prevents cross-service token validation mismatches.
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Authentication failures blocking user access and damaging platform reliability</business-impact>
        <prevention>Eliminate ALL fallback logic in authentication. Require environment-specific secrets: JWT_SECRET_STAGING, JWT_SECRET_PRODUCTION, JWT_SECRET_KEY (dev/test only).</prevention>
    </learning>
    
    <learning id="redis-vpc-connector-requirement-2025-08-31">
        <title>VPC Connector Required for Redis/Cloud SQL Access in Cloud Run</title>
        <category>Infrastructure/Networking</category>
        <keywords>vpc, connector, redis, cloud-sql, cloud-run, networking, staging, deployment, private-network</keywords>
        <path>redis_vpc_connector_requirement.xml</path>
        <critical-takeaway>
            Cloud Run services CANNOT access Redis, Cloud SQL, or other private VPC resources without a VPC connector.
            This is mandatory - services will fail at startup with "Redis ping timeout" errors.
            Deployment scripts MUST include --vpc-connector flag for all services needing database/cache access.
            Environment validator must check actual POSTGRES_* variables, not constructed DATABASE_URL.
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Complete service failure, chat functionality broken, 90% of platform value lost</business-impact>
        <prevention>Always include --vpc-connector in deployment. Verify connector exists with gcloud compute networks vpc-access connectors list. Test Redis connectivity post-deployment.</prevention>
    </learning>
    
    <learning id="deterministic-startup-critical-2025-08-31">
        <title>Deterministic Startup - Critical Path for Chat</title>
        <category>Startup Architecture</category>
        <keywords>startup, deterministic, critical-path, chat, websocket, agent, graceful-degradation, fail-fast</keywords>
        <path>deterministic_startup_critical.xml</path>
        <critical-takeaway>
            Graceful degradation for critical services is an anti-pattern that creates unpredictable failures.
            Chat delivers 90% of value and MUST be on the critical path with no fallbacks.
            Setting critical services to None is NEVER acceptable - fail fast instead.
            Found and fixed 25+ violations where startup could succeed with broken chat.
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Chat completely broken while service appears healthy, 90% of platform value lost</business-impact>
        <prevention>Use deterministic StartupOrchestrator with strict phases. No conditional paths for critical services. No setting services to None. Fail immediately if any chat component cannot initialize.</prevention>
    </learning>
    
    <learning id="auth-state-race-condition-2025-08-31">
        <title>Authentication State Race Condition During Initialization</title>
        <category>Frontend Authentication</category>
        <keywords>auth, race condition, state management, react, frontend, token, user, initialization</keywords>
        <path>auth_state_race_condition_fix.xml</path>
        <critical-takeaway>
            React setState is asynchronous - never assume state has updated immediately after calling setState.
            Auth state monitoring must use tracked actual values, not React state values during initialization.
            hasToken=true but hasUser=false breaks chat functionality (90% of platform value).
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Complete chat failure, users appear logged out despite valid tokens, broken user experience</business-impact>
        <prevention>Track actual values being set in local variables during state updates. Use these tracked values for validation/monitoring instead of React state. Consider useReducer for atomic multi-state updates.</prevention>
    </learning>
    
    <learning id="supervisor-initialization-dependency-fix-2025-08-30">
        <title>Supervisor Agent Initialization Dependency Fix</title>
        <category>Startup Dependencies</category>
        <keywords>supervisor, dependencies, initialization, llm_manager, startup, agent_supervisor, auth_service</keywords>
        <path>supervisor_initialization_dependency_fix.xml</path>
        <critical-takeaway>
            The agent_supervisor component requires explicit dependency on auth_service for llm_manager.
            Missing dependency declarations cause initialization failures and race conditions.
            StartupManager dependencies must include ALL required app.state attributes, not just direct ones.
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Complete agent system failure, chat unavailable, WebSocket communication broken</business-impact>
        <prevention>Always declare ALL dependencies explicitly in StartupManager. Document required app.state attributes. Add dependency validation before component creation.</prevention>
    </learning>
    
    <learning id="docker-compose-restart-issues-2025-08-31">
        <title>Docker Compose Service Restart Issues and Resolution</title>
        <category>Docker Infrastructure</category>
        <keywords>docker, docker-compose, restart, crash, exit code 255, override, ports, multi-line commands</keywords>
        <path>docker_compose_restart_issues.xml</path>
        <critical-takeaway>
            Docker Compose override files can cause configuration conflicts and service crashes.
            Multi-line commands must use proper YAML syntax without backslash continuations.
            Port configurations must be consistent between environment variables and actual bindings.
            Removing unnecessary override files simplifies configuration and improves stability.
        </critical-takeaway>
        <severity>HIGH</severity>
        <business-impact>Development environment instability, reduced developer productivity, service availability issues</business-impact>
        <prevention>Avoid docker-compose.override.yml unless necessary. Use proper YAML block syntax for multi-line commands. Verify port consistency. Test service restarts after configuration changes.</prevention>
    </learning>
    
    <learning id="auth-race-conditions-chat-initialization-2025-08-31">
        <title>Critical Auth Race Conditions and Chat Initialization Failure</title>
        <category>Authentication</category>
        <keywords>auth, race condition, chat, initialization, localStorage, jwt, token, user state, AuthGuard, MainChat</keywords>
        <path>auth_race_conditions_critical.xml</path>
        <critical-takeaway>
            CHAT IS KING - 90% of value delivery. Auth context had race condition where tokens in localStorage
            were not decoded to set user state when storedToken === currentToken. Always decode JWT tokens
            unconditionally to ensure user state initialization. Test page refresh scenarios, not just fresh logins.
            Never assume state correlation (token presence â‰  user state).
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Complete chat interface failure for authenticated users, blocking 90% of platform value delivery</business-impact>
        <prevention>Always decode tokens regardless of state. Add comprehensive auth state validation. Monitor for token/user state mismatches. Test page refresh with existing auth.</prevention>
    </learning>
    
    <learning id="configuration-hardening-patterns-no-fallbacks-2025-08-30">
        <title>Configuration Hardening: Eliminate Dangerous Fallback Patterns</title>
        <category>Security Configuration</category>
        <keywords>configuration, secrets, fallbacks, hardening, security, database passwords, api keys</keywords>
        <path>configuration_hardening_patterns_no_fallbacks.xml</path>
        <critical-takeaway>
            Empty string defaults for secrets enable unauthorized access. Localhost defaults enable production misconfigurations.
            Graceful degradation is an anti-pattern for configuration - fail fast and loud at startup.
            Critical targets: DATABASE_PASSWORD, REDIS_PASSWORD, LLM API keys, infrastructure hosts.
        </critical-takeaway>
        <severity>HIGH</severity>
        <business-impact>Security vulnerabilities from misconfigured production systems</business-impact>
        <prevention>Apply environment-specific hard requirements to all critical configuration. Remove empty defaults for secrets.</prevention>
    </learning>
    
    <learning id="central-configuration-validator-ssot-implementation-2025-08-31">
        <title>Central Configuration Validator: SSOT Implementation for Platform Security</title>
        <category>Platform Security, Configuration Management</category>
        <keywords>central validator, ssot, configuration, security, jwt, database, redis, llm, validation, hard requirements</keywords>
        <path>central_configuration_validator_ssot_implementation.xml</path>
        <critical-takeaway>
            Single Source of Truth for all configuration validation eliminates drift and inconsistencies.
            Central validator in shared/configuration enforces environment-specific hard requirements.
            Both auth and backend services now delegate all critical secret validation to central validator.
            Dangerous empty string defaults eliminated across all services.
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Platform Security, Operational Reliability, Compliance (SOC 2, PCI DSS, ISO 27001)</business-impact>
        <prevention>Use CentralConfigurationValidator for ALL configuration validation. Call validate_platform_configuration() at service startup.</prevention>
        <implementation-status>FULLY IMPLEMENTED AND TESTED</implementation-status>
        <documentation>docs/central_configuration_validator.md</documentation>
    </learning>
    
    <learning id="websocket-logger-dual-import-2025-08-31">
        <title>WebSocket Logger Dual Import Context Binding Issue</title>
        <category>Runtime Error Resolution</category>
        <keywords>websocket, logger, context binding, dual imports, test infrastructure failure</keywords>
        <path>websocket_logger_dual_import_context_binding_issue.xml</path>
        <critical-takeaway>
            Dual imports of singletons (import { x } from 'y'; import { x as z } from 'y') 
            create separate references that lose context binding in browser webpack environments.
            Test infrastructure that suppresses WebSocket errors creates dangerous false confidence.
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>WebSocket communication failures causing chat functionality breakdown</business-impact>
        <prevention>Never create dual imports of singleton services. Always use single import reference.</prevention>
    </learning>

    <categories>
        <category name="WebSocket/AgentEvents" path="SPEC/learnings/websocket_agent_integration_critical.xml" keywords="WebSocket, Agent Events, Chat UI, Tool Execution, Frontend, Real-time, Mission Critical, Tool Dispatcher, Enhancement, Agent Registry">
            <critical-takeaway>MISSION CRITICAL: AgentRegistry.set_websocket_manager() MUST enhance tool dispatcher or chat UI breaks - $500K+ ARR impact (websocket_agent_integration_critical.xml).</critical-takeaway>
            <critical-takeaway>Tool dispatcher MUST be wrapped with EnhancedToolExecutionEngine to send tool_executing/tool_completed events (websocket_agent_integration_critical.xml).</critical-takeaway>
            <critical-takeaway>5 required events for chat: agent_started, agent_thinking, tool_executing, tool_completed, agent_completed (websocket_agent_integration_critical.xml).</critical-takeaway>
            <critical-takeaway>Run tests/mission_critical/test_websocket_agent_events_suite.py before ANY deployment (websocket_agent_integration_critical.xml).</critical-takeaway>
        </category>
        
        <category name="WebSocket/DependencyInjection" path="SPEC/learnings/websocket_injection_fix_comprehensive.xml" keywords="WebSocket, Dependency Injection, MessageHandlerService, Real-time Events, Chat UI, Mission Critical, Service Creation, Graceful Fallback">
            <critical-takeaway>CRITICAL FIX: MessageHandlerService created via dependency injection was missing WebSocket manager, causing real-time agent events to be silently dropped (websocket_injection_fix_comprehensive.xml).</critical-takeaway>
            <critical-takeaway>ALL MessageHandlerService creation paths MUST inject WebSocket manager: dependencies.py, service_factory.py, agent_service_core.py (websocket_injection_fix_comprehensive.xml).</critical-takeaway>
            <critical-takeaway>Graceful fallback pattern required: try WebSocket injection, catch exceptions, log clearly, continue without WebSocket support (websocket_injection_fix_comprehensive.xml).</critical-takeaway>
            <critical-takeaway>Run tests/mission_critical/test_websocket_injection_fix_comprehensive.py to validate injection works and prevent regression (websocket_injection_fix_comprehensive.xml).</critical-takeaway>
            <critical-takeaway>$500K+ ARR impact: "blank screen" during AI processing fixed by ensuring real-time progress updates reach users (websocket_injection_fix_comprehensive.xml).</critical-takeaway>
        </category>
        
        <category name="WebSocket/SubAgentPatterns" path="SPEC/learnings/websocket_subagent_enhancement_patterns.xml" keywords="Sub-Agents, WebSocket Events, TriageSubAgent, DataSubAgent, ValidationSubAgent, WebSocketContextMixin, Real-time Feedback, User Experience, Event Emission">
            <critical-takeaway>WebSocketContextMixin provides standardized pattern for sub-agents to emit real-time events during execution (websocket_subagent_enhancement_patterns.xml).</critical-takeaway>
            <critical-takeaway>All sub-agents MUST emit 5 critical events: agent_started, agent_thinking, tool_executing, tool_completed, agent_completed for proper UX (websocket_subagent_enhancement_patterns.xml).</critical-takeaway>
            <critical-takeaway>Thread ID extraction in tool execution must check chat_thread_id > thread_id > run_id to match WebSocket connections (websocket_subagent_enhancement_patterns.xml).</critical-takeaway>
            <critical-takeaway>Sub-agents must support both modern (BaseExecutionInterface) and legacy execution patterns with WebSocket events (websocket_subagent_enhancement_patterns.xml).</critical-takeaway>
        </category>
        
        <category name="Staging/E2E-Comprehensive" path="SPEC/learnings/staging_e2e_comprehensive_implementation.xml" keywords="Staging, E2E Testing, WebSocket, OAuth Simulation, Cloud Run, Chat Validation, Auth Client, WebSocket Client, User Journeys">
            <critical-takeaway>Complete E2E test suite for staging with dedicated clients for Auth, WebSocket, and API - no local dependencies (staging_e2e_comprehensive_implementation.xml).</critical-takeaway>
            <critical-takeaway>OAUTH SIMULATION IS OAUTH SIMULATION - creates valid user sessions as if users completed Google OAuth, NOT a security bypass (staging_e2e_comprehensive_implementation.xml).</critical-takeaway>
            <critical-takeaway>WebSocket event tracking validates 90% of platform value (Chat functionality) in production-like environment (staging_e2e_comprehensive_implementation.xml).</critical-takeaway>
            <critical-takeaway>Proper error handling for Cloud Run cold starts with 30s API timeouts and 60s WebSocket timeouts (staging_e2e_comprehensive_implementation.xml).</critical-takeaway>
            <critical-takeaway>Run tests/run_staging_tests.py with E2E_BYPASS_KEY for comprehensive staging validation before production deployment (staging_e2e_comprehensive_implementation.xml).</critical-takeaway>
        </category>
        
        <category name="WebSocket/AgentLifecycle" path="SPEC/learnings/agent_manager_lifecycle_events.xml" keywords="Agent Manager, WebSocket, Lifecycle Events, Agent Registration, Agent Failure, Agent Cancellation, Metrics Updates, Real-time Monitoring, System Observability">
            <critical-takeaway>Agent Manager MUST emit WebSocket events for all lifecycle transitions: registration, failure, cancellation, metrics (agent_manager_lifecycle_events.xml).</critical-takeaway>
            <critical-takeaway>WebSocket notifier is optional in AgentManager - wrap all calls in try/except to maintain backward compatibility (agent_manager_lifecycle_events.xml).</critical-takeaway>
            <critical-takeaway>Frontend expects 7 new lifecycle events: agent_registered, agent_failed, agent_cancelled, agent_metrics_updated, agent_unregistered, agent_status_changed, agent_manager_shutdown (agent_manager_lifecycle_events.xml).</critical-takeaway>
            <critical-takeaway>Run tests/mission_critical/test_agent_manager_lifecycle_events.py to verify lifecycle event emission (agent_manager_lifecycle_events.xml).</critical-takeaway>
        </category>
        
        <category name="WebSocket/Routing" path="SPEC/learnings/websocket_routing_regression.xml" keywords="WebSocket, Message Routing, Run ID, Agent Updates, Privacy, Security, Regression, Broadcasting, Connection Management">
            <critical-takeaway>CRITICAL: WebSocket send_agent_update MUST route by run_id, NEVER broadcast to all users - severe privacy/security issue (websocket_routing_regression.xml).</critical-takeaway>
            <critical-takeaway>Always implement proper message routing from the start - broadcasting is almost never correct for user-specific data (websocket_routing_regression.xml).</critical-takeaway>
            <critical-takeaway>WebSocket manager must maintain run_id_connections mapping and clean up on disconnect (websocket_routing_regression.xml).</critical-takeaway>
            <critical-takeaway>Create regression tests IMMEDIATELY when fixing critical bugs to ensure they never resurface (websocket_routing_regression.xml).</critical-takeaway>
        </category>
        
        <category name="WebSocket/TimeoutRetry" path="SPEC/learnings/websocket_timeout_retry_implementation.xml" keywords="WebSocket, Timeout, Retry, Exponential Backoff, Reliability, Message Delivery, Silent Failures, Performance, Circuit Breaker, Monitoring">
            <critical-takeaway>CRITICAL: WebSocket sends MUST have timeouts (5 seconds default) to prevent indefinite hanging - affects 90% of value delivery (websocket_timeout_retry_implementation.xml).</critical-takeaway>
            <critical-takeaway>Exponential backoff retry (1s, 2s, 4s) with max 3 attempts prevents cascade failures from retry storms (websocket_timeout_retry_implementation.xml).</critical-takeaway>
            <critical-takeaway>asyncio.wait_for provides deterministic timeout behavior for WebSocket operations (websocket_timeout_retry_implementation.xml).</critical-takeaway>
            <critical-takeaway>Track send_timeouts, timeout_retries, and timeout_failures metrics for monitoring WebSocket health (websocket_timeout_retry_implementation.xml).</critical-takeaway>
            <critical-takeaway>Timeout implementation MUST maintain backward compatibility with existing WebSocket API (websocket_timeout_retry_implementation.xml).</critical-takeaway>
        </category>
        
        <category name="Authentication/MultiSystem" path="SPEC/multi_system_authentication_architecture.xml" keywords="Authentication, SSOT, JWT, OAuth, Multi-System, Auth Service, Token Management, Service-to-Service, Architecture">
            <critical-takeaway>CRITICAL: auth_service is the SOLE authentication authority - all JWT validation must go through auth_service (multi_system_authentication_architecture.xml).</critical-takeaway>
            <critical-takeaway>Multiple authentication patterns violate SSOT - 3x maintenance burden and security risk (multi_system_authentication_architecture.xml).</critical-takeaway>
            <critical-takeaway>Frontend must use UnifiedAuthService exclusively for token management (multi_system_authentication_architecture.xml).</critical-takeaway>
            <critical-takeaway>Remove ALL OAuth implementations from netra_backend - auth_service handles all OAuth flows (multi_system_authentication_architecture.xml).</critical-takeaway>
            <critical-takeaway>Service-to-service auth standardized on service account tokens with API keys as emergency fallback only (multi_system_authentication_architecture.xml).</critical-takeaway>
        </category>
        
        <category name="Testing/Performance" path="SPEC/learnings/test_collection_optimization.xml" keywords="Test Collection, PyTest, Test Discovery, Test Performance, Test Audit, Test Markers, Test Organization, Collection Optimization">
            <critical-takeaway>Test collection optimized from 60+ seconds to ~21 seconds using importlib mode and ignore patterns (test_collection_optimization.xml).</critical-takeaway>
            <critical-takeaway>Use scripts/test_collection_audit.py to identify duplicate tests, orphaned files, and missing markers (test_collection_optimization.xml).</critical-takeaway>
            <critical-takeaway>Configure pyproject.toml with optimized pytest settings for faster collection (test_collection_optimization.xml).</critical-takeaway>
        </category>
        
        <category name="Environment Configuration" path="SPEC/learnings/environment_loading_race_condition.xml" keywords="Environment Variables, Race Condition, SERVICE_SECRET, SERVICE_ID, Auth Service, Startup Failure, dotenv, Configuration Loading, Import Order, Module Initialization">
            <critical-takeaway>CRITICAL: Load environment variables BEFORE importing modules that use them - auth service fails if .env loaded after module imports (environment_loading_race_condition.xml).</critical-takeaway>
            <critical-takeaway>SERVICE_SECRET and SERVICE_ID must be set for auth service - no mock fallbacks allowed per CLAUDE.md (environment_loading_race_condition.xml).</critical-takeaway>
            <critical-takeaway>Use load_dotenv(override=True) to ensure variables are properly set in os.environ (environment_loading_race_condition.xml).</critical-takeaway>
            <critical-takeaway>Each service needs its own SERVICE_ID - auth-service not netra-backend (environment_loading_race_condition.xml).</critical-takeaway>
        </category>
        
        <category name="Authentication/OAuth" path="SPEC/learnings/auth.xml" keywords="JWT, Login, Session, OAuth, Token, CORS, OAUTH_ENV, OAuth Environment Variables, OAuth Validation, OAuth Startup, OAuth Secrets, Secret Naming, Service Independence, Logout, JWT_SECRET_KEY, Docker Compose, Dev Login, Development Mode, Auto-Login, Dev Auto-Login, Token Persistence, Token Initialization, Refresh Token, Token Refresh, Refresh Loop, Same Token, Hardcoded Values">
            <critical-takeaway>MANDATORY: All services must integrate with the shared auth service (SPEC/shared_auth_integration.xml).</critical-takeaway>
            <critical-takeaway>CRITICAL: Use JWT_SECRET_KEY exclusively - JWT_SECRET is deprecated (jwt_secret_standardization.xml).</critical-takeaway>
            <critical-takeaway>Ensure consistent JWT secret configuration across services - both auth and backend MUST use JWT_SECRET_KEY (jwt_secret_standardization.xml).</critical-takeaway>
            <critical-takeaway>CRITICAL: OAuth redirect URIs must use _determine_urls()[0] (auth service), NEVER _determine_urls()[1] (frontend) - causes "No token received" error.</critical-takeaway>
            <critical-takeaway>OAuth redirect URIs must point to auth service (auth.staging.netrasystems.ai), not frontend (oauth_redirect_configuration.xml).</critical-takeaway>
            <critical-takeaway>Frontend pages receiving OAuth tokens via URL must handle token extraction and storage (oauth_token_persistence.xml).</critical-takeaway>
            <critical-takeaway>Always verify OAuth configuration matches between code and provider console (oauth_deployment_verification.xml).</critical-takeaway>
            <critical-takeaway>Next.js proxy rewrites must be disabled in production - frontend should call services directly (oauth_staging_issues.xml).</critical-takeaway>
            <critical-takeaway>CRITICAL: Token refresh returning same token is ALWAYS a bug - indicates hardcoded placeholders (auth_token_refresh_root_cause.xml).</critical-takeaway>
            <critical-takeaway>Never use placeholder values in production code paths - they will reach production (auth_token_refresh_root_cause.xml).</critical-takeaway>
            <critical-takeaway>Implement cooldown and max failure limits for token refresh to prevent loops (frontend_refresh_loop_fix.xml).</critical-takeaway>
            <critical-takeaway>Auth service routes ALWAYS use /auth/* prefix - frontend must include this (frontend_auth_urls.xml).</critical-takeaway>
            <critical-takeaway>Run python scripts/validate_oauth_configuration.py before every deployment to prevent OAuth redirect URI misconfigurations.</critical-takeaway>
            <critical-takeaway>Database connection args must be conditional on database type - 'command_timeout' fails with SQLite (auth_service_endpoint_fixes.xml).</critical-takeaway>
            <critical-takeaway>Always add HEAD method support to GET endpoints for CORS compatibility (auth_service_endpoint_fixes.xml).</critical-takeaway>
            <critical-takeaway>JWT validation must validate token structure before decoding to prevent malformed token errors (auth_service_endpoint_fixes.xml).</critical-takeaway>
            <critical-takeaway>CORS wildcard (*) cannot be used with credentials: 'include' - use specific origin list in dev (cors_development_wildcard.xml).</critical-takeaway>
            <critical-takeaway>OAuth environment variables use _ENV suffix for runtime (OAUTH_GOOGLE_CLIENT_ID_ENV) and _{ENVIRONMENT} for deployment (OAUTH_GOOGLE_CLIENT_ID_STAGING) - see oauth_environment_naming_convention.xml</critical-takeaway>
            <critical-takeaway>CRITICAL: Auth service MUST validate OAuth client configuration at startup and FAIL FAST in staging/production if misconfigured (oauth_startup_validation.xml).</critical-takeaway>
            <critical-takeaway>OAuth client ID must end with .apps.googleusercontent.com and be at least 50 characters - validate format not just presence (oauth_validation_requirements.xml).</critical-takeaway>
            <critical-takeaway>OAuth providers must implement self_check() and validate_configuration() methods for comprehensive health monitoring (oauth_provider_health.xml).</critical-takeaway>
            <critical-takeaway>/oauth/status endpoint provides runtime OAuth health monitoring - returns 503 if unhealthy in staging/production (oauth_monitoring.xml).</critical-takeaway>
            <critical-takeaway>CRITICAL: OAuth secrets MUST use standardized naming: google-oauth-client-id-staging, NOT google-client-id-staging (oauth_secret_naming_fix.xml).</critical-takeaway>
            <critical-takeaway>ALWAYS use echo -n when creating secrets to avoid line endings that break validation (oauth_secret_naming_fix.xml).</critical-takeaway>
            <critical-takeaway>CATASTROPHIC: Auth service MUST NEVER import from netra_backend - causes complete auth failure in staging/production (oauth_service_independence_violation.xml).</critical-takeaway>
            <critical-takeaway>Service independence violations cause immediate logout after OAuth - auth service cannot access database/sessions (oauth_service_independence_violation.xml).</critical-takeaway>
            <critical-takeaway>Frontend login must check development_mode flag from auth config and use dev login in Docker Compose environments (docker-compose-login-fix.xml).</critical-takeaway>
            <critical-takeaway>Dev login requires both email and password in request body - password field was missing causing login failures (docker-compose-login-fix.xml).</critical-takeaway>
            <critical-takeaway>CRITICAL: Dev auto-login MUST process tokens whether storedToken === currentToken or not - initialization flow depends on it (frontend_dev_autologin.xml).</critical-takeaway>
            <critical-takeaway>Dev auto-login requires exponential backoff with 5+ retries to handle backend startup delays - simple retries insufficient (frontend_dev_autologin.xml).</critical-takeaway>
            <critical-takeaway>ANY changes to auth/context.tsx initialization or token processing MUST be tested with dev-auto-login.test.tsx (frontend_dev_autologin.xml).</critical-takeaway>
        </category>
        
        <category name="Auth Backend Desynchronization Critical Testing" path="SPEC/learnings/auth_backend_desynchronization_critical_testing.xml" keywords="Auth Backend, Desynchronization, Cross-Service, Rollback, Vulnerability, Security Testing, State Consistency, Orphaned Records">
            <critical-takeaway>CRITICAL: Cross-service vulnerability testing MUST use real services with controlled failure scenarios, not mocks</critical-takeaway>
            <critical-takeaway>Mock network timeouts and database failures at the transport layer (httpx.TimeoutException, httpx.RequestError), not the service layer</critical-takeaway>
            <critical-takeaway>Never assume internal endpoints exist - implement discovery patterns first and test both endpoint existence AND expected behavior</critical-takeaway>
            <critical-takeaway>Validate user existence in both auth AND backend services for consistency using different HTTP status codes (200 vs 404/401/403)</critical-takeaway>
            <critical-takeaway>Test authentication success combined with backend access failure as primary vulnerability indicator</critical-takeaway>
            <critical-takeaway>Test for health endpoints that might detect consistency issues (consistency_check, sync_status, orphaned_users)</critical-takeaway>
            <critical-takeaway>Use uuid-based test user emails to prevent conflicts (desync_test_{uuid4().hex[:8]}@netra-test.com)</critical-takeaway>
            <critical-takeaway>Critical security tests should complete within 45-60 seconds maximum with best-effort cleanup</critical-takeaway>
            <critical-takeaway>Track ALL aspects of vulnerability testing using comprehensive result containers (DesynchronizationTestResult dataclass pattern)</critical-takeaway>
            <critical-takeaway>P0 CRITICAL vulnerability: User creation succeeds in auth but fails in backend sync, allowing authentication without backend access</critical-takeaway>
        </category>
        
        <category name="Pydantic v2 Migration" path="SPEC/learnings/pydantic_v2_migration.xml" keywords="Pydantic, Migration, Config, model_config, ConfigDict, Core Web Framework, Security Upgrade">
            <critical-takeaway>Config classes MUST be replaced with model_config = ConfigDict() pattern for Pydantic v2 compatibility</critical-takeaway>
            <critical-takeaway>.dict() method calls should be updated to .model_dump() with fallback patterns for backward compatibility</critical-takeaway>
            <critical-takeaway>Core Web Framework upgrades address critical CVE-2024-24762 and CVE-2024-53981 DoS vulnerabilities</critical-takeaway>
            <critical-takeaway>Existing codebase was already largely Pydantic v2 compatible due to modern patterns (@field_validator, @model_validator)</critical-takeaway>
        </category>
        
        <category name="ClickHouse SSOT Violation - Critical Remediation [RESOLVED 2025-08-28]" path="SPEC/learnings/clickhouse_ssot_violation_remediation.xml" keywords="ClickHouse, SSOT, Single Source of Truth, Database Client, Duplicate Implementation, Architecture Violation, Canonical Implementation, Code Consolidation">
            <critical-takeaway>CATASTROPHIC: FOUR duplicate ClickHouse client implementations violated SSOT principle - 834+ lines of duplicate code, 4x maintenance burden</critical-takeaway>
            <critical-takeaway>CANONICAL IMPLEMENTATION: /netra_backend/app/db/clickhouse.py with get_clickhouse_client() is the ONLY authorized ClickHouse interface</critical-takeaway>
            <critical-takeaway>DELETED SSOT VIOLATIONS: clickhouse_client.py, client_clickhouse.py, data_sub_agent/clickhouse_client.py - all removed 2025-08-28</critical-takeaway>
            <critical-takeaway>MANDATORY PATTERN: from netra_backend.app.db.clickhouse import get_clickhouse_client; async with get_clickhouse_client() as client: ...</critical-takeaway>
            <critical-takeaway>ANTI-PATTERN: Never create new ClickHouse client classes - extend canonical implementation instead</critical-takeaway>
            <critical-takeaway>ANTI-PATTERN: Never embed test logic in production (_simulate_* methods) - use proper test fixtures</critical-takeaway>
            <critical-takeaway>ANTI-PATTERN: Never use direct instantiation (ClickHouseClient()) - always use factory function</critical-takeaway>
            <critical-takeaway>PREVENTION: Run python netra_backend/tests/test_clickhouse_ssot_compliance.py to prevent regressions</critical-takeaway>
            <critical-takeaway>ENFORCEMENT: Pre-commit hooks prevent new ClickHouse client class creation</critical-takeaway>
            <critical-takeaway>ARCHITECTURE: See SPEC/clickhouse_client_architecture.xml for complete specification</critical-takeaway>
            <critical-takeaway>SEARCH FIRST: Always check existing implementations before creating new ones - "Search First, Create Second" principle</critical-takeaway>
        </category>
        
        <category name="Package Upgrade Migration 2025" path="SPEC/learnings/migrations/package_upgrade_2025.xml" keywords="Package Upgrade, Dependency Modernization, Security, SQLAlchemy, Pydantic, python-jose, AI SDK, Migration">
            <critical-takeaway>CRITICAL: python-jose MUST be removed - unmaintained since 2015, replaced with PyJWT >= 2.10.1</critical-takeaway>
            <critical-takeaway>SQLAlchemy 2.0 migration requires: DeclarativeBase class, mapped_column(), select() queries, explicit commits</critical-takeaway>
            <critical-takeaway>ClickHouse operates independently of SQLAlchemy - initial compatibility concern was unfounded</critical-takeaway>
            <critical-takeaway>Most code already using modern patterns - only 19 files modified out of 500+ analyzed (3.8% change rate)</critical-takeaway>
            <critical-takeaway>Implement fallback patterns (hasattr checks) during migration for zero-downtime upgrades</critical-takeaway>
            <critical-takeaway>Google AI SDK deprecated google-generativeai, must migrate to google-genai with stateless client pattern</critical-takeaway>
            <critical-takeaway>Security upgrades are critical priority - python-multipart DoS vulnerabilities fixed in 0.0.20</critical-takeaway>
        </category>
        
        <category name="Auth Service API Endpoints" path="SPEC/learnings/auth_service_endpoint_fixes.xml" keywords="Auth Service, API Endpoints, HEAD Method, OAuth Endpoints, JWT Validation, SQLite, Database Connection">
            <critical-takeaway>Always provide both generic (/auth/login) and provider-specific (/auth/google) OAuth endpoints for API ergonomics.</critical-takeaway>
            <critical-takeaway>Environment-specific OAuth variables (GOOGLE_OAUTH_CLIENT_ID_STAGING) must have higher priority than generic ones (GOOGLE_CLIENT_ID).</critical-takeaway>
            <critical-takeaway>JWT structure validation prevents "Not enough segments" errors - validate 3-part format before processing.</critical-takeaway>
            <critical-takeaway>Database connection parameters like 'command_timeout' are PostgreSQL-specific and must be conditional on database type.</critical-takeaway>
            <critical-takeaway>HEAD method support is essential for authentication endpoints to support CORS preflight and health checks.</critical-takeaway>
        </category>
        
        <category name="Test Coverage Import Gap" path="SPEC/learnings/test_coverage_import_gap.xml" keywords="Test Coverage, Import Errors, NameError, Runtime Errors, Mock Overuse, Integration Testing, CI/CD, Python Imports, Module Testing, Production Failures">
            <critical-takeaway>CRITICAL: Import errors can pass all tests but fail in production if modules aren't directly tested</critical-takeaway>
            <critical-takeaway>Python's import system allows broken code if the broken parts aren't executed during import</critical-takeaway>
            <critical-takeaway>Every internal module MUST have at least one direct test that imports and exercises it</critical-takeaway>
            <critical-takeaway>Mock scope must be minimized to external services only - mocking internal components hides runtime errors</critical-takeaway>
            <critical-takeaway>Tests were testing the "idea" of code working, not actual execution paths</critical-takeaway>
            <critical-takeaway>Import validation test suite must run as first test in CI/CD pipeline</critical-takeaway>
            <critical-takeaway>E2E tests must use real services (docker-compose) not mocks</critical-takeaway>
            <critical-takeaway>Type checking must be enforced in CI/CD to catch annotation issues before runtime</critical-takeaway>
        </category>
        
        <category name="API Dual-Channel Architecture" path="SPEC/api_dual_channel_architecture.xml" keywords="REST API, WebSocket, Agent Routes, Dual Channel, API Architecture, Streaming, Real-time">
            <critical-takeaway>REST API endpoints (/api/agent/*) and WebSocket (/ws) are BOTH production features, NOT legacy vs new.</critical-takeaway>
            <critical-takeaway>Both channels use the SAME backend services (SupervisorAgent, ThreadService, MessageHandlerService) ensuring functional parity.</critical-takeaway>
            <critical-takeaway>REST is optimal for stateless operations, mobile clients, simple integrations; WebSocket for real-time updates, interactive sessions.</critical-takeaway>
            <critical-takeaway>Service layer abstraction enables channel-agnostic business logic - changes benefit both channels automatically.</critical-takeaway>
            <critical-takeaway>Maintain feature parity between channels by updating shared backend services, not duplicating logic.</critical-takeaway>
        </category>
        
        <category name="OAuth Redirect URI Critical Misconfiguration [CRITICAL]" path="SPEC/learnings/oauth_redirect_uri_misconfiguration.xml" keywords="OAuth, Redirect URI, No Token Received, Frontend, Auth Service, Google OAuth, Authentication Failure">
            <critical-takeaway>CRITICAL: Lines 242, 676, 906 in auth_routes.py use _determine_urls()[1] (frontend URL) instead of _determine_urls()[0] (auth service URL) for OAuth redirect_uri.</critical-takeaway>
            <critical-takeaway>IMPACT: Google OAuth redirects to frontend instead of auth service, causing "No token received" error and 100% OAuth authentication failure.</critical-takeaway>
            <critical-takeaway>ROOT CAUSE: Auth service tells Google to redirect to https://app.staging.netrasystems.ai/auth/callback instead of https://auth.staging.netrasystems.ai/auth/callback.</critical-takeaway>
            <critical-takeaway>FIX REQUIRED: Change redirect_uri = _determine_urls()[1] + "/auth/callback" to redirect_uri = _determine_urls()[0] + "/auth/callback" in all OAuth routes.</critical-takeaway>
            <critical-takeaway>PREVENTION: Run python scripts/validate_oauth_configuration.py before every deployment to catch OAuth redirect URI misconfigurations.</critical-takeaway>
        </category>
        
        <category name="Database/AsyncGenerator" path="SPEC/learnings/async_generator_context_manager.xml" keywords="Database, Async Generator, Context Manager, TypeError, get_db, Dependencies, FastAPI, AsyncSession, Session Management">
            <critical-takeaway>CRITICAL: get_db() returns AsyncGenerator, not async context manager - use "async for" not "async with" (async_generator_context_manager.xml).</critical-takeaway>
            <critical-takeaway>Functions using "yield" become generators even if they use "async with" internally - check return type annotations (async_generator_context_manager.xml).</critical-takeaway>
            <critical-takeaway>AsyncGenerator requires "async for", AsyncContextManager requires "async with" - these protocols are not interchangeable (async_generator_context_manager.xml).</critical-takeaway>
            <critical-takeaway>Database dependencies in FastAPI should consistently use async generators for proper session lifecycle management (async_generator_context_manager.xml).</critical-takeaway>
            <critical-takeaway>TESTING: Use @pytest.mark.env("staging") tests to validate OAuth redirect URIs point to auth service URLs in staging environment.</critical-takeaway>
            <critical-takeaway>GOOGLE CONSOLE: Only auth service URLs should be authorized redirect URIs - never add frontend URLs to Google OAuth Console.</critical-takeaway>
        </category>
        
        <category name="OAuth First Login Timing" path="SPEC/learnings/oauth_first_login_timing.xml" keywords="OAuth, First Login, Timing, Race Condition, WebSocket, AuthContext, Storage Event, Token Initialization">
            <critical-takeaway>CRITICAL: AuthContext must initialize token from localStorage during state creation, not in useEffect, to prevent race conditions.</critical-takeaway>
            <critical-takeaway>OAuth callback must dispatch storage events after saving tokens to notify AuthContext immediately.</critical-takeaway>
            <critical-takeaway>WebSocketProvider must wait for auth context stabilization when receiving initial token (100ms delay).</critical-takeaway>
            <critical-takeaway>Add 50ms delay in OAuth callback before redirecting to ensure storage event processing.</critical-takeaway>
            <critical-takeaway>Use storage event listeners in AuthContext for real-time token detection across components.</critical-takeaway>
            <critical-takeaway>Test OAuth flows with fresh browser sessions to catch first-login timing issues.</critical-takeaway>
        </category>
        
        <category name="Staging Environment Configuration" path="SPEC/learnings/staging_environment_configuration.xml" keywords="Environment Variables, Staging, .env File, IsolatedEnvironment, Configuration Management, Deployment, Cloud Run, Docker, Environment Precedence, SECRET_KEY, SERVICE_SECRET">
            <critical-takeaway>CRITICAL: .env file must NOT override system environment variables - use load_from_file(override_existing=False) (staging_environment_configuration.xml).</critical-takeaway>
            <critical-takeaway>Environment variable precedence: System vars > .env file > defaults - deployment vars must win (staging_environment_configuration.xml).</critical-takeaway>
            <critical-takeaway>NEVER use os.getenv() directly - always use IsolatedEnvironment's get_env().get() for consistency (staging_environment_configuration.xml).</critical-takeaway>
            <critical-takeaway>Validate staging config with StagingConfigurationValidator before deployment to catch placeholders and localhost refs (staging_environment_configuration.xml).</critical-takeaway>
            <critical-takeaway>SERVICE_SECRET must be set and different from JWT_SECRET_KEY in staging/production (staging_environment_configuration.xml).</critical-takeaway>
            <critical-takeaway>CRITICAL: .env files must NEVER be loaded in staging/production - check ENVIRONMENT variable and skip loading (env_file_staging_protection.xml).</critical-takeaway>
        </category>

        <category name="Redis Service Independence" path="SPEC/learnings/redis_service_independence.xml" keywords="Redis, Microservices, Circular Dependencies, Service Independence, Shared Components, Infrastructure">
            <critical-takeaway>CRITICAL: Each microservice MUST have its own Redis manager - this duplication is intentional and correct.</critical-takeaway>
            <critical-takeaway>Redis clients are STATEFUL components that must NEVER be placed in /shared directory.</critical-takeaway>
            <critical-takeaway>Never import Redis managers or other infrastructure components from other services - violates microservice independence.</critical-takeaway>
            <critical-takeaway>Auth service importing from backend creates circular dependencies that prevent independent deployment.</critical-takeaway>
            <critical-takeaway>Redis manager duplication is explicitly listed as acceptable in SPEC/acceptable_duplicates.xml.</critical-takeaway>
            <critical-takeaway>Services must communicate through APIs, not through shared stateful components.</critical-takeaway>
        </category>
        
        <category name="Frontend Configuration Loop Prevention" path="SPEC/learnings/frontend_config_loop_prevention.xml" keywords="Frontend, Auth Context, useEffect, Configuration, Loop, API Calls">
            <critical-takeaway>CRITICAL: Auth context must fetch configuration only once on mount using empty dependency array to prevent loops.</critical-takeaway>
            <critical-takeaway>Implement retry cooldowns (10+ seconds) for configuration endpoints to prevent rapid retry loops.</critical-takeaway>
            <critical-takeaway>Cache successful configuration responses to avoid unnecessary re-fetches.</critical-takeaway>
            <critical-takeaway>Be careful with useCallback dependencies in React - they can trigger unexpected re-renders and effect loops.</critical-takeaway>
            <critical-takeaway>Monitor API call patterns to detect configuration fetch loops early in staging.</critical-takeaway>
        </category>
        
        <category name="React useEffect Dependency Management" path="SPEC/learnings/react_useeffect_dependency_management.xml" keywords="React, useEffect, useCallback, Dependencies, Hooks, Re-renders">
            <critical-takeaway>Use empty dependency array [] for initialization effects that should only run once on mount.</critical-takeaway>
            <critical-takeaway>Separate initialization logic from reactive logic into different useEffect hooks.</critical-takeaway>
            <critical-takeaway>Be selective about useCallback dependencies - only include values that should trigger function recreation.</critical-takeaway>
            <critical-takeaway>Use refs for values that shouldn't trigger re-renders but need to be accessed in callbacks.</critical-takeaway>
            <critical-takeaway>Document why certain dependencies are excluded with eslint-disable comments when intentionally omitting them.</critical-takeaway>
        </category>
        
        <category name="API Retry Strategy" path="SPEC/learnings/api_retry_strategy.xml" keywords="API, Retry, Exponential Backoff, Circuit Breaker, Rate Limiting, Network">
            <critical-takeaway>Implement exponential backoff for retry attempts to reduce backend load.</critical-takeaway>
            <critical-takeaway>Use retry cooldowns (minimum 10 seconds) between attempts for the same resource.</critical-takeaway>
            <critical-takeaway>Cache successful responses with appropriate TTLs to reduce unnecessary requests.</critical-takeaway>
            <critical-takeaway>Implement circuit breaker pattern to stop requests after repeated failures.</critical-takeaway>
            <critical-takeaway>Provide fallback responses for non-critical configuration data when backend unavailable.</critical-takeaway>
        </category>
        
        <category name="Frontend Initialization Patterns" path="SPEC/learnings/frontend_initialization_patterns.xml" keywords="Frontend, Initialization, Bootstrap, Configuration, Service Discovery">
            <critical-takeaway>Critical initialization tasks should happen exactly once during application bootstrap.</critical-takeaway>
            <critical-takeaway>Implement graceful degradation when backend services are unavailable during initialization.</critical-takeaway>
            <critical-takeaway>Use initialization guards (flags/refs) to prevent duplicate initialization.</critical-takeaway>
            <critical-takeaway>Load configuration in order of criticality with appropriate fallbacks.</critical-takeaway>
            <critical-takeaway>Restore authentication state from storage synchronously before making API calls.</critical-takeaway>
        </category>

        <category name="SQLAlchemy Import Requirements" path="SPEC/learnings/sqlalchemy_func_import.xml" keywords="SQLAlchemy, func, Import Error, Database Functions, func.now(), NameError">
            <critical-takeaway>CRITICAL: SQLAlchemy's func must be explicitly imported from sqlalchemy to use database functions like func.now().</critical-takeaway>
            <critical-takeaway>Import pattern: from sqlalchemy import func - required for func.now(), func.count(), func.sum() and other SQL functions.</critical-takeaway>
            <critical-takeaway>Common error: "name 'func' is not defined" when using func.now() without importing func from sqlalchemy.</critical-takeaway>
            <critical-takeaway>Always verify SQLAlchemy imports include all needed components: select, update, delete, func, desc, asc.</critical-takeaway>
            <critical-takeaway>Test imports at module level with simple import test to catch missing imports early.</critical-takeaway>
        </category>

        <category name="Auth Service Integration" path="SPEC/learnings/auth_service_integration.xml" keywords="Auth Service, Dev Login, JWT, OAuth Flow">
            <critical-takeaway>Auth service is OAuth-first with NO /register endpoint - use OAuth or dev login.</critical-takeaway>
            <critical-takeaway>Dev login endpoint (/auth/dev/login) creates fixed dev@example.com user automatically.</critical-takeaway>
            <critical-takeaway>Auth service maintains separate auth_users table but syncs IDs with main database.</critical-takeaway>
            <critical-takeaway>Token validation via POST /auth/validate, not a TokenValidator class.</critical-takeaway>
            <critical-takeaway>Redis sessions optional in dev/staging - service healthy without Redis.</critical-takeaway>
            <critical-takeaway>Auth service MUST use unified configuration via lazy loading pattern while maintaining service independence (unified_config_auth_service.xml).</critical-takeaway>
        </category>

        <category name="Auth Refresh Endpoint Field Naming" path="SPEC/learnings/auth_refresh_endpoint_field_naming.xml" keywords="API Compatibility, Field Naming, CamelCase, Snake_Case, 422 Error, Refresh Token">
            <critical-takeaway>Auth refresh endpoint must accept both camelCase (refreshToken) and snake_case (refresh_token) field names for frontend compatibility.</critical-takeaway>
            <critical-takeaway>FastAPI's strict Pydantic validation causes 422 errors when field names don't match exactly - use raw request body for flexible parsing.</critical-takeaway>
            <critical-takeaway>Frontend frameworks use camelCase while Python backends use snake_case - API endpoints must bridge this naming convention gap.</critical-takeaway>
            <critical-takeaway>Debug 422 errors by logging raw request bodies and received field names to identify naming mismatches quickly.</critical-takeaway>
            <critical-takeaway>Critical auth endpoints should support multiple field naming conventions to prevent integration failures.</critical-takeaway>
        </category>

        <category name="Staging Authentication Failures [CRITICAL]" path="SPEC/learnings/staging_authentication_failures_2025.xml" keywords="Staging, Authentication, 403 Forbidden, Service-to-Service, Token Refresh, JWT Secret, OAuth">
            <critical-takeaway>CRITICAL: Authentication failures in staging indicate imminent production failures that will cause complete platform unavailability and 100% revenue loss.</critical-takeaway>
            <critical-takeaway>MANDATORY: All authentication tests must run in staging environment (@pytest.mark.env("staging")) to catch environment-specific configuration issues.</critical-takeaway>
            <critical-takeaway>Frontend gets 403 Forbidden when calling backend threads endpoint due to service account authentication failure and JWT secret mismatch.</critical-takeaway>
            <critical-takeaway>Service-to-service authentication completely broken between frontend-backend and backend-auth services - microservice architecture non-functional.</critical-takeaway>
            <critical-takeaway>Token refresh mechanism completely non-functional - users cannot maintain sessions and are forced to re-authenticate repeatedly.</critical-takeaway>
            <critical-takeaway>JWT secret synchronization failure between services causes valid tokens to be rejected across service boundaries.</critical-takeaway>
            <critical-takeaway>OAuth configuration misconfigured in staging preventing new user registration and social login - no user acquisition possible.</critical-takeaway>
            <critical-takeaway>CORS configuration blocks legitimate cross-service authentication requests causing service communication failures.</critical-takeaway>
        </category>
        
        <category name="Auth Service Staging Log Issues [HIGH PRIORITY]" path="SPEC/learnings/auth_service_staging_log_issues.xml" keywords="HEAD Method, HTTP 405, Monitoring, Database Initialization, Idempotency, UniqueViolationError">
            <critical-takeaway>CRITICAL: Health endpoints must support HEAD requests - monitoring systems fail with 405 Method Not Allowed causing false alerts.</critical-takeaway>
            <critical-takeaway>Database initialization must be idempotent - UniqueViolationError warnings indicate potential startup fragility.</critical-takeaway>
            <critical-takeaway>All monitoring endpoints (/health, /auth/health, /readiness, /docs) must support HEAD method for monitoring compatibility.</critical-takeaway>
            <critical-takeaway>HEAD responses must have same headers as GET but empty body per HTTP specification.</critical-takeaway>
        </category>
        
        <category name="SQLAlchemy Session Management [CRITICAL]" path="SPEC/learnings/sqlalchemy_session_management.xml" keywords="SQLAlchemy, AsyncSession, WebSocket, IllegalStateChangeError, Session Management, Concurrent Access, Docker, Agent Hanging">
            <critical-takeaway>NEVER pass database sessions by reference to async workers that outlive the session scope - causes IllegalStateChangeError.</critical-takeaway>
            <critical-takeaway>Supervisor agents must have db_session=None, not a reference to handler's session which gets closed.</critical-takeaway>
            <critical-takeaway>Session lifecycle must be managed at request/handler level, not passed to long-running async tasks.</critical-takeaway>
            <critical-takeaway>Agents hanging for 20+ seconds in Docker often indicates session management issues - check for concurrent session access.</critical-takeaway>
            <critical-takeaway>Each async worker should create its own database session using get_db() context manager when needed.</critical-takeaway>
            <critical-takeaway>WebSocket handlers must close sessions in finally blocks but ensure no async tasks still reference them.</critical-takeaway>
            <critical-takeaway>Test with real database sessions in Docker-like environments - mock tests won't catch these concurrency issues.</critical-takeaway>
        </category>

        <category name="GCP Staging Critical Issues [CURRENT]" path="SPEC/learnings/gcp_staging_critical_issues.xml" keywords="GCP Staging, Authentication 403, Health Endpoint Timeout, Static Assets 404, Service Availability, Load Balancer">
            <critical-takeaway>CRITICAL: Frontend receives 403 Forbidden on all backend API calls due to complete authentication system failure in staging.</critical-takeaway>
            <critical-takeaway>CRITICAL: Health endpoints timeout with 503 errors after 5+ seconds, causing load balancer to mark service as unhealthy.</critical-takeaway>
            <critical-takeaway>HIGH: Static assets (favicon.ico, Next.js files) return 404, breaking frontend application styling and functionality.</critical-takeaway>
            <critical-takeaway>Health checks must be environment-aware - skip ClickHouse/Redis in staging where infrastructure is unavailable.</critical-takeaway>
            <critical-takeaway>JWT signing keys must be synchronized between auth service and backend for staging environment.</critical-takeaway>
            <critical-takeaway>Docker deployments must include static asset volumes and proper Next.js build artifacts.</critical-takeaway>
            <critical-takeaway>Implement failing tests first to replicate staging issues before attempting fixes.</critical-takeaway>
        </category>

        <category name="Database Connectivity Critical Fix [RESOLVED]" path="SPEC/learnings/database_postgres_connectivity_fix_2025.xml" keywords="Database, Postgres, Connection, POSTGRES_DB, netra_dev, staging">
            <critical-takeaway>RESOLVED 2025-08-25: Fixed critical 'database postgres does not exist' error by updating POSTGRES_DB configuration.</critical-takeaway>
            <critical-takeaway>NEVER use 'postgres' system database name for application data - use 'netra_dev' for staging and development.</critical-takeaway>
            <critical-takeaway>All environments must use consistent database naming: dev/staging='netra_dev', test='netra_test', prod='netra_production'.</critical-takeaway>
            <critical-takeaway>Configuration alignment is critical: .env files, deployment scripts, and Secret Manager must all use same database names.</critical-takeaway>
            <critical-takeaway>Silent "staging mode" fallback hides critical database issues - prefer fail-fast behavior for database connectivity problems.</critical-takeaway>
            <critical-takeaway>Pre-deployment validation must include database existence and connectivity tests with actual environment credentials.</critical-takeaway>
        </category>
        
        <category name="AsyncPG URL Normalization [CRITICAL]" path="SPEC/learnings/asyncpg_url_normalization.xml" keywords="AsyncPG, PostgreSQL, URL, SQLAlchemy, Driver, Normalization, Connection">
            <critical-takeaway>CRITICAL: asyncpg.connect() requires plain 'postgresql://' URLs - SQLAlchemy prefixes like 'postgresql+asyncpg://' cause "invalid DSN" errors.</critical-takeaway>
            <critical-takeaway>ALWAYS use DatabaseURLBuilder.format_for_asyncpg_driver() before passing URLs to asyncpg.connect().</critical-takeaway>
            <critical-takeaway>NEVER use inline string replacements for driver prefix normalization - use centralized methods.</critical-takeaway>
            <critical-takeaway>Different PostgreSQL drivers have different URL requirements - asyncpg is strict, psycopg2 is flexible.</critical-takeaway>
            <critical-takeaway>Test database connections with actual environment URLs including ports and special characters.</critical-takeaway>
            <critical-takeaway>Dev launcher failures with "Database connection failed after 5 attempts" often indicate URL format issues.</critical-takeaway>
        </category>

        <category name="API Versioning Anti-Pattern [RESOLVED]" path="SPEC/learnings/api_versioning_antipattern.xml" keywords="API, v1, versioning, URLs, paths, REST">
            <critical-takeaway>RESOLVED 2025-08-25: All v1 references have been removed from all services.</critical-takeaway>
            <critical-takeaway>Auth service now uses clean /auth/* paths (no /api/v1/auth/*).</critical-takeaway>
            <critical-takeaway>Backend uses consistent /api/* paths without version prefixes.</critical-takeaway>
            <critical-takeaway>Frontend simplified - no version logic needed, uses clean paths.</critical-takeaway>
            <critical-takeaway>For internal microservices, version through deployment strategies, not URLs.</critical-takeaway>
            <critical-takeaway>URLs are now clean and semantic: auth.domain/auth/*, api.domain/api/*.</critical-takeaway>
        </category>
        
        <category name="Deployment Performance Testing" path="SPEC/learnings/iteration3_deployment_performance_testing.xml" keywords="Deployment, Performance, Startup, Memory, CPU, Health, Timeout, Resource Optimization">
            <critical-takeaway>CRITICAL: Deployment performance tests prevent timeout failures and validate resource optimization compliance.</critical-takeaway>
            <critical-takeaway>Startup timeout prevention requires comprehensive testing with 60-second Cloud Run limits.</critical-takeaway>
            <critical-takeaway>Memory optimization from 2Gi to 1Gi requires extensive validation with leak detection.</critical-takeaway>
            <critical-takeaway>Health endpoints must respond within 100ms for deployment readiness validation.</critical-takeaway>
            <critical-takeaway>Edge case testing covers memory pressure, CPU throttling, and cascading timeout scenarios.</critical-takeaway>
            <critical-takeaway>Performance monitoring must be integrated into deployment pipelines for regression detection.</critical-takeaway>
            <critical-takeaway>Container startup probes require comprehensive success/failure/recovery testing.</critical-takeaway>
        </category>
        
        <category name="Async Event Loop Blocking" path="SPEC/learnings/async_sleep_blocking_issue.xml" keywords="Performance, Async, Await, Event Loop, time.sleep, asyncio.sleep, Blocking, WebSocket, Retry, Delay">
            <critical-takeaway>CRITICAL: NEVER use time.sleep() in async functions - blocks entire event loop causing service freezes</critical-takeaway>
            <critical-takeaway>ALWAYS use await asyncio.sleep() in async functions for non-blocking delays</critical-takeaway>
            <critical-takeaway>Blocking sleep in async code freezes ALL concurrent requests, timeouts WebSockets, and queues database queries</critical-takeaway>
            <critical-takeaway>Separate retry handlers needed: async functions use await asyncio.sleep(), sync functions use time.sleep()</critical-takeaway>
            <critical-takeaway>Event loop blocking can cause 50-80% of performance issues during retry operations under load</critical-takeaway>
            <critical-takeaway>Search pattern: Find async functions with grep "async def" then check for time.sleep usage</critical-takeaway>
        </category>
        
        <category name="Deployment and Docker Configuration" path="SPEC/learnings/deployment.xml" keywords="Deployment, Docker, Dockerfile, Container, Frontend, Backend, Auth, Cloud Run, GCP, Staging">
            <critical-takeaway>CRITICAL: Frontend Dockerfile MUST use deployment/docker/frontend.gcp.Dockerfile - NEVER create new ones</critical-takeaway>
            <critical-takeaway>All service Dockerfiles follow pattern: deployment/docker/{service}.gcp.Dockerfile</critical-takeaway>
            <critical-takeaway>If frontend/Dockerfile is deleted in git, DO NOT recreate it - use canonical location</critical-takeaway>
            <critical-takeaway>Docker build context must exclude node_modules - use proper .dockerignore configuration</critical-takeaway>
            <critical-takeaway>Next.js standalone builds require specific Docker configuration - copy .next/standalone and run server.js directly</critical-takeaway>
            <critical-takeaway>Frontend requires NEXT_PUBLIC_API_URL environment variable for API connectivity</critical-takeaway>
            <critical-takeaway>Use gunicorn with uvicorn workers for Cloud Run deployments, not plain uvicorn</critical-takeaway>
            <critical-takeaway>NEVER create minimal backend versions (main_minimal.py) for deployment - breaks functionality</critical-takeaway>
        </category>
        
        <category name="Logging Depth Configuration" path="SPEC/learnings/logging_depth_configuration.xml" keywords="Logging, Loguru, Depth, Source Location, UnifiedLogger, Stack Trace, Debug">
            <critical-takeaway>CRITICAL: UnifiedLogger must use logger.opt(depth=3) to show actual caller location, not wrapper location.</critical-takeaway>
            <critical-takeaway>The depth parameter skips wrapper methods: _emit_log, _log, and the specific level method (error/warning/info).</critical-takeaway>
            <critical-takeaway>Without proper depth, logs show unified_logging.py:202 instead of the actual error source.</critical-takeaway>
            <critical-takeaway>Test logging output to verify source locations are correctly reported, not wrapper locations.</critical-takeaway>
            <critical-takeaway>If adding new wrapper layers, adjust depth parameter accordingly to maintain accurate source reporting.</critical-takeaway>
        </category>
        
        <category name="Project Structure" path="SPEC/learnings/project_structure_enforcement.xml" keywords="Structure, Imports, netra_backend, Canonical">
            <critical-takeaway>THE canonical structure: netra_backend/app/ for production, netra_backend/tests/ for tests. This is PERMANENT.</critical-takeaway>
            <critical-takeaway>All imports MUST use netra_backend.app.* prefix. Fix imports, NOT the structure.</critical-takeaway>
            <critical-takeaway>Cross-service imports are FORBIDDEN. Use API clients for service communication.</critical-takeaway>
            <critical-takeaway>When imports fail, update them to match structure. NEVER move files to accommodate old patterns.</critical-takeaway>
            <critical-takeaway>Test runner uses netra_backend/tests/, dev launcher uses netra_backend.app.main:app.</critical-takeaway>
        </category>
        
        <category name="Microservice Environment Independence" path="SPEC/learnings/microservice_environment_independence.xml" keywords="Environment, IsolatedEnvironment, dev_launcher, Service Independence, Cross-Service">
            <critical-takeaway>NEVER import environment management from dev_launcher - each service MUST have its own isolated_environment.</critical-takeaway>
            <critical-takeaway>Service-local implementations of shared patterns are acceptable and required for independence.</critical-takeaway>
            <critical-takeaway>Always provide production fallback patterns when development modules may not be available.</critical-takeaway>
        </category>
        
        <category name="Docker Compose Profiles" path="SPEC/learnings/docker_compose_profiles.xml" keywords="Docker, Compose, Profiles, ClickHouse, Optional Services, Infrastructure">
            <critical-takeaway>Core infrastructure services (PostgreSQL, Redis, ClickHouse) should load by default without profiles.</critical-takeaway>
            <critical-takeaway>Services with profiles are NOT started unless explicitly enabled with --profile flag.</critical-takeaway>
            <critical-takeaway>Use profiles only for truly optional services that not all developers need.</critical-takeaway>
            <critical-takeaway>Backend services must handle missing optional services gracefully with fallbacks.</critical-takeaway>
            <critical-takeaway>Environment variables for optional services should be configured even if service is not running.</critical-takeaway>
        </category>
        
        <category name="Docker Container Naming in Remediation Scripts" path="SPEC/learnings/docker_container_naming_remediation.xml" keywords="Docker, Container Names, Remediation, Auth Service, Database, Postgres, ClickHouse">
            <critical-takeaway>CRITICAL: Container names in Netra use "netra-" prefix consistently: netra-auth, netra-postgres, netra-clickhouse, netra-backend, netra-frontend, netra-redis</critical-takeaway>
            <critical-takeaway>Docker remediation scripts must use exact container names from docker-compose.dev.yml - Docker doesn't accept partial matches for specific container operations</critical-takeaway>
            <critical-takeaway>ALWAYS verify actual container names from docker-compose.dev.yml before hardcoding in scripts to prevent "container not found" errors</critical-takeaway>
            <critical-takeaway>Test remediation commands manually before deploying intelligent remediation to avoid cascading failures</critical-takeaway>
            <critical-takeaway>When using docker ps filters, "name=auth" works for finding "netra-auth" but "docker restart auth_service" fails - be specific</critical-takeaway>
        </category>
        
        <category name="Docker Container Startup Critical Fixes" path="SPEC/learnings/docker_container_startup.xml" keywords="Docker, Container Startup, Import Errors, ModuleNotFoundError, Singleton, Error Handler, netra-backend, Application Initialization">
            <critical-takeaway>CRITICAL: Always verify import paths exist after refactoring - stale imports from moved/deleted modules can break container startup completely</critical-takeaway>
            <critical-takeaway>ModuleNotFoundError during container startup often indicates import paths referencing non-existent modules (e.g., 'netra_backend.app.llm.error_classification')</critical-takeaway>
            <critical-takeaway>ImportError for specific classes/interfaces indicates the target class doesn't exist in the module - verify interface names and module contents</critical-takeaway>
            <critical-takeaway>Singleton instantiation errors ("object is not callable") occur when treating already-instantiated singletons as constructors - use instance directly without parentheses</critical-takeaway>
            <critical-takeaway>Test container startup after any significant refactoring or import changes to catch import/instantiation issues before deployment</critical-takeaway>
            <critical-takeaway>Use absolute imports as per SPEC/import_management_architecture.xml to prevent path resolution issues in containerized environments</critical-takeaway>
        </category>
        
        <category name="CORS Configuration" path="SPEC/learnings/cors_development_wildcard.xml" keywords="CORS, localhost, 127.0.0.1, Origin, Development, Wildcard, Cross-Origin">
            <critical-takeaway>CRITICAL: Development CORS MUST use wildcard ("*") to handle localhost vs 127.0.0.1 mismatches.</critical-takeaway>
            <critical-takeaway>NEVER change development CORS back to explicit origin lists - wildcard is required for proper local development.</critical-takeaway>
            <critical-takeaway>Browsers treat 'localhost' and '127.0.0.1' as different origins even though they resolve to same address.</critical-takeaway>
            <critical-takeaway>Security concerns do not apply in local development - staging and production have proper restrictive CORS.</critical-takeaway>
            <critical-takeaway>shared/cors_config.py is the SINGLE source of truth for all services' CORS configuration.</critical-takeaway>
        </category>
        
        <category name="State Persistence Foreign Key Violations" path="SPEC/learnings/state_persistence_foreign_key.xml" keywords="Foreign Key, State Persistence, User Validation, IntegrityError, dev-temp, Agent State, Database Constraints">
            <critical-takeaway>CRITICAL: Always validate foreign key references exist before database operations to prevent IntegrityErrors.</critical-takeaway>
            <critical-takeaway>Auto-create development/test users (dev-temp-*, test-*) when saving state to prevent FK violations in dev environments.</critical-takeaway>
            <critical-takeaway>NEVER auto-create production users - this is a security boundary that must be maintained.</critical-takeaway>
            <critical-takeaway>Pattern match on user_id to distinguish dev/test users from production users for special handling.</critical-takeaway>
            <critical-takeaway>The _ensure_user_exists_for_snapshot method in state_persistence.py prevents FK violations proactively.</critical-takeaway>
            <critical-takeaway>Dev users should be created with minimal permissions and default passwords for security.</critical-takeaway>
        </category>
        
        <category name="3-Tier Persistence Architecture" path="SPEC/3tier_persistence_architecture.xml" keywords="3-Tier, Three-Tier, Persistence, Redis, PostgreSQL, ClickHouse, Failover, Enterprise, Disaster Recovery, State Management">
            <critical-takeaway>CRITICAL: 3-tier persistence architecture provides enterprise-grade reliability with Redis to PostgreSQL to ClickHouse failover chain.</critical-takeaway>
            <critical-takeaway>Redis PRIMARY tier must maintain sub-100ms performance for active agent states with version tracking and TTL management.</critical-takeaway>
            <critical-takeaway>PostgreSQL checkpoints required for CRITICAL checkpoint types to ensure disaster recovery capability.</critical-takeaway>
            <critical-takeaway>ClickHouse migration scheduled automatically for completed runs to enable cost optimization analytics.</critical-takeaway>
            <critical-takeaway>Cross-database consistency validation must achieve 100% data integrity score for enterprise compliance.</critical-takeaway>
            <critical-takeaway>Documentation: docs/3tier_persistence_architecture.md provides comprehensive operational procedures.</critical-takeaway>
        </category>
        
        <category name="State Persistence Performance Optimization" path="SPEC/learnings/state_persistence_optimization.xml" keywords="Performance Optimization, State Persistence, Async Database, Parallel Execution, Feature Flags, ClickHouse Async, Pipeline Optimization, Delegation Pattern">
            <critical-takeaway>CRITICAL: Parallel execution with asyncio.gather() achieves 25-40% performance gains for independent pipeline steps with automatic fallback to sequential.</critical-takeaway>
            <critical-takeaway>Async database operations prevent event loop blocking - use connect_async(), execute_async(), health_check_async() for ClickHouse.</critical-takeaway>
            <critical-takeaway>Delegation pattern maintains 100% API compatibility while adding optimizations - enables safe rollback and gradual rollout.</critical-takeaway>
            <critical-takeaway>Feature flags must default to disabled (ENABLE_OPTIMIZED_PERSISTENCE=false) for production safety with automatic configuration.</critical-takeaway>
            <critical-takeaway>SHA-256 hash-based state diffing skips 40-60% of redundant saves while maintaining data integrity - first save always persists.</critical-takeaway>
            <critical-takeaway>Memory management critical - implement LRU cache (10K entries, evict 20% when full) to prevent OOM in long-running services.</critical-takeaway>
            <critical-takeaway>Connection pool optimization (15/25 vs 10/15 base/overflow, 3s vs 5s timeout) provides 18-20% performance improvement under load.</critical-takeaway>
            <critical-takeaway>Multi-agent review process (Architecture, Risk, PM, Implementation, Review, Integration, QA) prevents production failures in critical optimizations.</critical-takeaway>
        </category>
        
        <category name="Agent Error Handler Unified Integration" path="SPEC/learnings/agent_error_handler_unified.xml" keywords="AgentErrorHandler, handle_execution_error, unified_error_handler, backward compatibility, error handling, agent execution, reliability failure, missing attribute">
            <critical-takeaway>AgentErrorHandler convenience class MUST expose handle_execution_error method for backward compatibility.</critical-takeaway>
            <critical-takeaway>handle_execution_error can be an alias to handle_error but MUST exist for agent execution.</critical-takeaway>
            <critical-takeaway>Error handlers MUST provide get_health_status() method for monitoring integration.</critical-takeaway>
            <critical-takeaway>Always verify error handler methods exist before runtime to catch missing methods early.</critical-takeaway>
            <critical-takeaway>Unified error handlers must maintain ALL methods from original implementations for backward compatibility.</critical-takeaway>
            <critical-takeaway>CRITICAL: agent_error_handler is an INSTANCE not a class - use agent_error_handler directly, NOT agent_error_handler().</critical-takeaway>
            <critical-takeaway>ExecutionErrorHandler() constructor calls cause 'AgentErrorHandler object is not callable' - use the instance directly.</critical-takeaway>
        </category>
        
        <category name="SSOT Auth Service Remediation [RESOLVED]" path="SPEC/learnings/ssot_auth_service_remediation.xml" keywords="SSOT, Single Source of Truth, Duplication, Auth Service, Database Connection, JWT, Environment Variables">
            <critical-takeaway>RESOLVED 2025-08-25: Fixed critical SSOT violations in auth_service - removed 365+ lines of duplicate code.</critical-takeaway>
            <critical-takeaway>AuthDatabaseManager is the canonical database connection implementation - all operations delegate to it.</critical-takeaway>
            <critical-takeaway>JWTHandler.validate_token() is the single source of truth for JWT validation - removed duplicate validation logic.</critical-takeaway>
            <critical-takeaway>IsolatedEnvironment.get_env().get() is the ONLY way to access environment variables - replaced 40+ os.getenv() calls.</critical-takeaway>
            <critical-takeaway>Backward compatibility maintained through delegation patterns and aliases during SSOT remediation.</critical-takeaway>
            <critical-takeaway>Regular SSOT audits essential - violations accumulate quickly without strict enforcement.</critical-takeaway>
            <critical-takeaway>netra_backend MUST use netra_backend.app.core.isolated_environment, NOT dev_launcher.isolated_environment.</critical-takeaway>
            <critical-takeaway>Remove all service discovery imports from dev_launcher in production services.</critical-takeaway>
        </category>
        
        <category name="GCP Load Balancer Requirements" path="SPEC/learnings/gcp_load_balancer_implementation.xml" keywords="GCP, Load Balancer, WebSocket, HTTPS, Terraform, Health Check, CORS, Session Affinity, Timeout, Protocol Headers, Cloud Run, Ingress">
            <critical-takeaway>CRITICAL: All 6 load balancer requirements are mandatory for production deployment.</critical-takeaway>
            <critical-takeaway>Backend services MUST use protocol="HTTPS" in Terraform - HTTP causes SSL termination failures.</critical-takeaway>
            <critical-takeaway>WebSockets require timeout_sec=3600 AND session_affinity="GENERATED_COOKIE" for stable connections.</critical-takeaway>
            <critical-takeaway>X-Forwarded-Proto header preservation prevents redirect loops and maintains HTTPS context.</critical-takeaway>
            <critical-takeaway>Health checks MUST use https_health_check on port 443 - HTTP checks fail against HTTPS backends.</critical-takeaway>
            <critical-takeaway>Production CORS must restrict to HTTPS-only origins - HTTP origins enable MITM attacks.</critical-takeaway>
            <critical-takeaway>Cloud Run requires ingress="all" with FORCE_HTTPS=true environment variable.</critical-takeaway>
            <critical-takeaway>Use scripts/validate_gcp_deployment.py with 95% minimum compliance before deployment.</critical-takeaway>
            <critical-takeaway>E2E tests must validate WebSocket persistence beyond 60 seconds to verify timeout configuration.</critical-takeaway>
            <critical-takeaway>Multi-agent coordination effective for complex infrastructure: DevOps, QA, and Documentation agents.</critical-takeaway>
        </category>
        
        <category name="AI-Native Path Management" path="SPEC/learnings/ai_native_path_management.xml" keywords="AI-Native, Path Migration, Refactoring, Service Creation, Batch Operations, Import Management">
            <critical-takeaway>ALWAYS use batch operations for path migrations - never migrate file-by-file to avoid inconsistencies.</critical-takeaway>
            <critical-takeaway>Path migrations must be atomic - all changes in single commit with tests passing before and after.</critical-takeaway>
            <critical-takeaway>Use multi-agent coordination for large migrations: Principal (strategy), Implementation (execution), QA (verification), DevOps (deployment).</critical-takeaway>
        </category>
        
        <category name="GTM Implementation" path="SPEC/learnings/gtm_implementation.xml" keywords="GTM, Google Tag Manager, Analytics, Tracking, Container, DataLayer, Script Loading, Environment Variables">
            <critical-takeaway>GTMProvider must be explicitly enabled - check NODE_ENV and NEXT_PUBLIC_GTM_ENABLED conditions.</critical-takeaway>
            <critical-takeaway>GTM environment variables MUST be added to Cloud Run deployment script for staging/production.</critical-takeaway>
            <critical-takeaway>Container ID (GTM-WKP28PNQ) must be consistent across all environments.</critical-takeaway>
            <critical-takeaway>DataLayer must be initialized BEFORE GTM script loads to prevent tracking issues.</critical-takeaway>
            <critical-takeaway>Use Next.js Script component with afterInteractive strategy for optimal performance.</critical-takeaway>
            <critical-takeaway>Always include noscript iframe fallback for accessibility compliance.</critical-takeaway>
            <critical-takeaway>Test GTM loading with automated script (scripts/test_gtm_loading.py) before deployment.</critical-takeaway>
            <critical-takeaway>Environment variables must be prefixed with NEXT_PUBLIC_ for browser availability.</critical-takeaway>
        </category>
        
        <category name="GTM Infinite Loop Prevention" path="SPEC/learnings/gtm_infinite_loop_prevention.xml" keywords="GTM, Circuit Breaker, Infinite Loop, AuthGuard, Event Deduplication, Rate Limiting, Performance, Memory Leak">
            <critical-takeaway>CRITICAL: AuthGuard component can cause infinite GTM event loops - use refs to track if events already fired.</critical-takeaway>
            <critical-takeaway>Implement circuit breaker pattern for ALL analytics integrations to prevent event storms.</critical-takeaway>
        </category>
        
        <category name="Dev Launcher Zombie Processes" path="SPEC/learnings/dev_launcher_zombie_processes.xml" keywords="Dev Launcher, Zombie Process, Node.js, Frontend, Windows, Process Tree, npm, next, taskkill, Process Termination">
            <critical-takeaway>CRITICAL: Frontend npm run dev creates 4+ layer deep process tree (npm->cross-env->next->server) requiring /T flag for complete termination on Windows.</critical-takeaway>
            <critical-takeaway>Always use taskkill /F /T /PID for Windows process termination to kill entire process tree and prevent orphaned Node.js processes.</critical-takeaway>
            <critical-takeaway>Multiple dev launcher instances spawn duplicate frontend processes consuming 250-290MB each - implement process detection before spawning.</critical-takeaway>
            <critical-takeaway>Frontend process termination requires special handling due to deep nesting - individual PID termination leaves child processes running.</critical-takeaway>
            <critical-takeaway>Emergency cleanup must use WindowsProcessManager.terminate_process_tree for complete cleanup on Windows.</critical-takeaway>
            <critical-takeaway>Event deduplication window (2 seconds) prevents duplicate events from rapid re-renders.</critical-takeaway>
            <critical-takeaway>Rate limiting (100 events per type/minute) protects against legitimate event spam.</critical-takeaway>
            <critical-takeaway>Circuit breaker trips after 50 failures in 10 seconds, auto-recovers after 30 seconds.</critical-takeaway>
            <critical-takeaway>Memory management critical - cleanup old tracking data every minute to prevent leaks.</critical-takeaway>
            <critical-takeaway>GTMProvider must integrate circuit breaker checks BEFORE pushing to dataLayer.</critical-takeaway>
            <critical-takeaway>Test suites must verify: no infinite loops, deduplication works, rate limits enforced, circuit breaker trips/recovers.</critical-takeaway>
        </category>
        
        <category name="WebSocket Connection Lifecycle" path="SPEC/learnings/websocket.xml" keywords="WebSocket, Accept, Connection, Lifecycle, Authentication, Context Manager, State Management">
            <critical-takeaway>CRITICAL: websocket.accept() MUST be called before ANY WebSocket operations to prevent "WebSocket is not connected" errors.</critical-takeaway>
            <critical-takeaway>Authentication and context managers must execute AFTER accept() to ensure connection is established.</critical-takeaway>
            <critical-takeaway>Error handling and close operations only safe after successful accept() - check is_websocket_connected() first.</critical-takeaway>
            <critical-takeaway>Context managers performing WebSocket operations must be designed to work with already-accepted connections.</critical-takeaway>
            <critical-takeaway>Test WebSocket flows must track call order to verify accept() happens first.</critical-takeaway>
        </category>
        
        <category name="Import Refactoring Crisis" path="SPEC/learnings/import_refactoring_2025-08-23.xml" keywords="Import Errors, ModuleNotFoundError, Refactoring, PerformanceMonitor, ConnectionManager, BackgroundTaskManager, ATOMIC SCOPE">
            <critical-takeaway>CRITICAL: 330+ import errors from non-atomic refactoring. Refactors MUST update tests in same commit.</critical-takeaway>
            <critical-takeaway>PerformanceMonitor moved from monitoring.performance_monitor to monitoring.metrics_collector (23 files affected).</critical-takeaway>
            <critical-takeaway>ConnectionManager renamed to WebSocketManager in websocket_core module (22 files affected).</critical-takeaway>
            <critical-takeaway>BackgroundTaskManager moved from app.background to app.services.background_task_manager (6 files affected).</critical-takeaway>
            <critical-takeaway>Create backward compatibility stubs when removing modules to prevent import failures during transition.</critical-takeaway>
            <critical-takeaway>Add pytest --collect-only to CI/CD to catch import errors before merge.</critical-takeaway>
            <critical-takeaway>New services must follow standard scaffold: {service_name}/{service_name}_core/ structure with health endpoints from start.</critical-takeaway>
            <critical-takeaway>Validate import hierarchy: Core->Models->Services->Routes->Main, never reverse imports.</critical-takeaway>
            <critical-takeaway>Configuration alignment critical: Update Python imports, Docker paths, CI/CD, env vars atomically.</critical-takeaway>
        </category>

        <category name="WebSocket" path="SPEC/learnings/websocket.xml" keywords="Realtime, Coroutine, Async, WebSocket Accept, Connection Lifecycle, Message Validation, Parse Errors, Large Messages, Run ID, User ID, Message Routing">
            <critical-takeaway context="Error Handling">All failures MUST raise exceptions. Silent failures (e.g., auth hanging) are forbidden.</critical-takeaway>
            <critical-takeaway context="Async">Always await async operations. Verify objects are not coroutines before access.</critical-takeaway>
            <critical-takeaway context="Schema">Ensure strict alignment of message fields (e.g., 'content' vs 'text') between FE/BE.</critical-takeaway>
            <critical-takeaway context="Connection">WebSocket accept() MUST be called FIRST before any operations - auth and setup happen AFTER accept().</critical-takeaway>
            <critical-takeaway context="Message Validation">WebSocket validation must be flexible - only require 'type' field, make 'payload' optional for system messages (ping/pong).</critical-takeaway>
            <critical-takeaway context="Parse Errors">Parse error 1003 usually means overly strict validation - check if legitimate messages are being rejected.</critical-takeaway>
            <critical-takeaway context="Large Messages">Large/chunked messages use 'message_type' field instead of 'type' - check for these BEFORE standard validation.</critical-takeaway>
            <critical-takeaway context="Error Details">Provide specific error details (missing field, wrong type, etc.) not generic "Invalid message structure".</critical-takeaway>
            <critical-takeaway context="Message Routing">NEVER use run_id as user_id for WebSocket messages - use thread_id or actual user_id from ExecutionContext (websocket_run_id_issue.xml).</critical-takeaway>
            <critical-takeaway context="ID Validation">Check for run_ prefix before using ID as user_id - run IDs are not valid WebSocket recipients.</critical-takeaway>
            <critical-takeaway context="Logging">Use DEBUG level for expected missing connections (run_ids), WARNING only for real user disconnections.</critical-takeaway>
        </category>
        
        <category name="WebSocket State Management Critical Fix [RESOLVED]" path="SPEC/learnings/websocket_state_management.xml" keywords="WebSocket, State Management, Subprotocol, Client State, Application State, Immediate Disconnect, ABNORMAL_CLOSURE">
            <critical-takeaway>RESOLVED 2025-08-27: WebSocket immediate disconnect with ABNORMAL_CLOSURE (1006) FIXED - dual issue with state checking and subprotocol negotiation.</critical-takeaway>
            <critical-takeaway>CRITICAL: WebSocket.accept() MUST include subprotocol parameter if client sends any subprotocols - RFC 6455 requirement.</critical-takeaway>
            <critical-takeaway>is_websocket_connected() MUST check client_state first (Starlette), then application_state, then default to True.</critical-takeaway>
            <critical-takeaway>Frontend sends jwt-auth and jwt.token subprotocols - backend MUST respond with selected protocol or client closes immediately.</critical-takeaway>
            <critical-takeaway>All WebSocket state checks MUST use centralized is_websocket_connected() function for SSOT - 16 locations updated.</critical-takeaway>
            <critical-takeaway>Test with real WebSocket connections not just mocks - state management differs between frameworks.</critical-takeaway>
            <critical-takeaway>Symptoms: "Loading chat..." forever, connection accepted then immediately closed, 0 messages processed.</critical-takeaway>
        </category>
        
        <category name="WebSocket Run ID Issue [RESOLVED]" path="SPEC/learnings/websocket_run_id_issue.xml" keywords="WebSocket, Run ID, User ID, Message Routing, Agent Communication, Progress Tracking, Logging">
            <critical-takeaway>RESOLVED 2025-08-29: WebSocket run_id incorrectly used as user_id FIXED - agents now use proper thread_id/user_id routing.</critical-takeaway>
            <critical-takeaway>CRITICAL: run_id (format: run_[uuid]) is NOT a valid WebSocket recipient - use thread_id or user_id from ExecutionContext.</critical-takeaway>
            <critical-takeaway>Progress tracking and agent messages MUST use thread_id (preferred) or user_id, never run_id for WebSocket communication.</critical-takeaway>
            <critical-takeaway>WebSocket manager uses DEBUG logging for run_ids (expected behavior), WARNING only for real missing user connections.</critical-takeaway>
            <critical-takeaway>Always pass ExecutionContext with thread_id/user_id through agent call chains for proper message routing.</critical-takeaway>
        </category>
        
        <category name="WebSocket Docker Fixes [RESOLVED]" path="SPEC/learnings/websocket_docker_fixes.xml" keywords="WebSocket, Docker, Development, Authentication Bypass, CORS, Container Networking, Bridge Network, Development Environment">
            <critical-takeaway>RESOLVED 2025-08-27: WebSocket Docker connectivity FIXED - development authentication bypass and CORS configuration implemented.</critical-takeaway>
            <critical-takeaway>CRITICAL: Set ALLOW_DEV_AUTH_BYPASS=true and WEBSOCKET_AUTH_BYPASS=true for Docker development environment.</critical-takeaway>
            <critical-takeaway>Authentication bypass MUST be environment-aware - only enabled when ENVIRONMENT=development with multiple safeguards.</critical-takeaway>
            <critical-takeaway>CORS configuration enhanced with Docker service names (frontend:3000, backend:8000, auth:8081) and container names (netra-frontend, netra-backend, netra-auth).</critical-takeaway>
            <critical-takeaway>Docker bridge network IP ranges (172.17.0.1, 172.18.0.1, etc.) added to development CORS origins for container networking.</critical-takeaway>
            <critical-takeaway>Frontend MUST use ws://localhost:8000/ws for WebSocket URL in Docker environment - host browser to Docker backend.</critical-takeaway>
            <critical-takeaway>Development environment made permissive for CORS validation - production/staging maintain strict validation.</critical-takeaway>
            <critical-takeaway>Multiple origin header handling implemented for Docker proxy chains and networking complexity.</critical-takeaway>
            <critical-takeaway>Use scripts/test_docker_websocket_fix.py for comprehensive Docker WebSocket configuration validation.</critical-takeaway>
            <critical-takeaway>E2E testing with tests/e2e/test_websocket_dev_docker_connection.py validates connection, retry, and CORS scenarios.</critical-takeaway>
            <critical-takeaway>Troubleshooting guide at docs/websocket_docker_troubleshooting.md provides diagnosis and solutions for common Docker WebSocket issues.</critical-takeaway>
        </category>

        <category name="Configuration/Secrets" path="SPEC/learnings/configuration_secrets.xml" keywords="Env Vars, .env">
            <critical-takeaway>All configuration MUST utilize the unified config system. Direct `os.environ.get()` is forbidden outside the config module.</critical-takeaway>
        </category>
        
        <category name="Unified Configuration" path="SPEC/learnings/unified_configuration.xml" keywords="Config, Hot Reload, ConfigManager, Configuration, Secrets, GCP">
            <critical-takeaway>Configuration MUST use single source of truth at netra_backend.app.config. 110+ redundant implementations have been REMOVED to maintain SSOT.</critical-takeaway>
            <critical-takeaway>NEVER import removed files: config_environment.py, config_loader.py, config_manager.py, config_envvars.py - they're DELETED.</critical-takeaway>
            <critical-takeaway>Hot reload enables zero-downtime updates via CONFIG_HOT_RELOAD=true and reload_config().</critical-takeaway>
            <critical-takeaway>All configuration access uses: from netra_backend.app.config import get_config.</critical-takeaway>
            <critical-takeaway>Configuration validation is MANDATORY: validate_configuration() must pass before deployment.</critical-takeaway>
            <critical-takeaway>Secrets use unified SecretManager with GCP Secret Manager (staging/production) or local files (dev).</critical-takeaway>
        </category>
        
        <category name="Secret Manager Interface" path="SPEC/learnings/secret_manager_interface.xml" keywords="SecretManager, load_all_secrets, Interface Contract, UnifiedSecretManager">
            <critical-takeaway>SecretManager MUST provide public load_all_secrets() method for UnifiedSecretManager compatibility.</critical-takeaway>
        </category>
        
        <category name="Configuration Issues 2025" path="SPEC/learnings/configuration_issues_2025.xml" keywords="DATABASE_URL, ClickHouse, Redis, Environment Detection, Import Paths, WebSocket">
            <critical-takeaway>DATABASE_URL must use Cloud SQL format in staging, never localhost fallback - staging configuration failures indicate production readiness issues.</critical-takeaway>
            <critical-takeaway>Redis fallback to localhost must be disabled in staging/production via REDIS_FALLBACK_ENABLED=false environment variable.</critical-takeaway>
            <critical-takeaway>Import paths: ClickHouseClient moved to data_sub_agent module, RedisClient is RedisManager, WebSocket imports use fastapi not starlette.</critical-takeaway>
        </category>
        
        <category name="OAuth Redirect URI Misconfiguration [CRITICAL]" path="SPEC/learnings/oauth_redirect_uri_misconfiguration.xml" keywords="OAuth, Google OAuth, redirect_uri, callback, authentication, staging failure, No token received">
            <critical-takeaway>RESOLVED 2025-08-26: Auth service was using frontend URL for OAuth callbacks instead of auth service URL, causing 100% authentication failure.</critical-takeaway>
            <critical-takeaway>Root cause: redirect_uri = _determine_urls()[1] should be [0] - simple array index error in lines 242, 676, 906 of auth_routes.py.</critical-takeaway>
            <critical-takeaway>Why not caught earlier: Local dev masked issue (same domain), staging tests didn't verify OAuth flow, mocked unit tests bypassed real redirect verification.</critical-takeaway>
            <critical-takeaway>Prevention: End-to-end OAuth tests in staging, pre-deployment validation of redirect URIs, explicit logging of callback receipt.</critical-takeaway>
            <critical-takeaway>Google OAuth Console must authorize auth service URLs only, never frontend URLs for callbacks.</critical-takeaway>
        </category>
        
        <category name="Cloud Armor OAuth Callback Protection" path="SPEC/learnings/cloud_armor_oauth_callback.xml" keywords="Cloud Armor, OAuth, 403 Forbidden, WAF, Security Policy, SQL Injection False Positive, Load Balancer">
            <critical-takeaway>Cloud Armor SQL injection rules can block OAuth callbacks due to URL-encoded parameters (%2F, %3A) in authorization codes.</critical-takeaway>
            <critical-takeaway>Create exemption rule with priority lower than security rules for /auth/callback endpoint with OAuth parameter validation.</critical-takeaway>
            <critical-takeaway>Security rule priority matters - exemptions must have lower priority number (higher precedence) than blocking rules.</critical-takeaway>
            <critical-takeaway>Monitor security policy logs to identify false positives: preconfiguredExprIds shows which rule triggered the block.</critical-takeaway>
            <critical-takeaway>OAuth exemption rule should validate: request.method == 'GET' and request.query.contains('code=') and request.query.contains('state=').</critical-takeaway>
            <critical-takeaway>Test OAuth flows immediately after implementing Cloud Armor to catch WAF false positives before they impact users.</critical-takeaway>
        </category>
        
        <category name="Cloud Armor WAF Removal Decision" path="SPEC/learnings/cloud_armor_waf_removal.xml" keywords="Cloud Armor, OWASP, WAF, False Positives, 403 Forbidden, Security Architecture, Production Incident">
            <critical-takeaway>CRITICAL: OWASP WAF rules are fundamentally incompatible with modern SPAs and cause excessive false positives - DO NOT RE-ADD without extensive testing.</critical-takeaway>
            <critical-takeaway>Rules like owasp-crs-v030001-id942421-sqli block normal homepage access, health checks, and login pages.</critical-takeaway>
            <critical-takeaway>Application-level security (input validation, parameterized queries, JWT auth) is more effective than generic WAF rules.</critical-takeaway>
            <critical-takeaway>If WAF rules keep returning via Terraform, update cloud-armor.tf, commit changes, and use direct gcloud commands if needed.</critical-takeaway>
            <critical-takeaway>Retain DDoS protection, rate limiting, and geographic throttling - these don't cause false positives.</critical-takeaway>
            <critical-takeaway>Monitor 403 error rates as key health indicator after security policy changes.</critical-takeaway>
        </category>
        
        <category name="ClickHouse Development Configuration" path="SPEC/learnings/clickhouse_dev_configuration.xml" keywords="ClickHouse, Port Configuration, Development Environment, Container, Testing, 8123, 8443">
            <critical-takeaway>Local development ClickHouse runs on HTTP port 8123, not HTTPS port 8443 - many scripts had wrong defaults.</critical-takeaway>
            <critical-takeaway>Container netra-clickhouse-dev uses standard ClickHouse config: HTTP on 8123, native on 9000, http://localhost:8123 for connections.</critical-takeaway>
            <critical-takeaway>Test environment should enable ClickHouse (CLICKHOUSE_ENABLED=true, DEV_MODE_DISABLE_CLICKHOUSE=false) when container is available.</critical-takeaway>
            <critical-takeaway>Default port fallbacks in scripts should use 8123 for development, 8443 for staging/production ClickHouse Cloud instances.</critical-takeaway>
            <critical-takeaway>Skip logic in tests can be removed when services are properly configured and available locally.</critical-takeaway>
        </category>
        
        <category name="ClickHouse SSL Localhost Connection Fix" path="SPEC/learnings/clickhouse_ssl_localhost_connection.xml" keywords="ClickHouse, SSL, HTTPS, Localhost, Connection, secure=True, SSL Error, Wrong Version Number, Environment Detection, Port 8123, Port 8443">
            <critical-takeaway>NEVER hardcode secure=True for ClickHouse connections - use environment-aware SSL detection instead.</critical-takeaway>
            <critical-takeaway>Localhost ClickHouse connections (127.0.0.1, localhost, ::1) must use HTTP (secure=False) to avoid SSL errors.</critical-takeaway>
            <critical-takeaway>Remote ClickHouse connections should use HTTPS (secure=True) only on port 8443 for security.</critical-takeaway>
            <critical-takeaway>Test fixtures must use same connection logic as production code - no hardcoded SSL settings.</critical-takeaway>
            <critical-takeaway>Standard pattern: is_localhost = config.host in ["localhost", "127.0.0.1", "::1"]; use_secure = not is_localhost and config.port == 8443</critical-takeaway>
        </category>

        <category name="GCP Staging Deployment Critical Issues [RESOLVED]" path="SPEC/learnings/gcp_staging_deployment_fixes.xml" keywords="OAuth Configuration, Redis Connection, Alembic Migration, Async Testing, Variable Scoping, get_env, staging deployment, fallback configuration">
            <critical-takeaway>RESOLVED 2025-08-26: OAuth configuration missing due to test framework masking real staging issues - implement proper test isolation to simulate missing credentials.</critical-takeaway>
            <critical-takeaway>Redis connection "get_env variable scoping" errors were actually async/sync method confusion - always use @pytest.mark.asyncio and await async methods in tests.</critical-takeaway>
            <critical-takeaway>Alembic.ini missing in deployment requires multiple fallback paths and programmatic configuration as backup - enhance _get_alembic_ini_path() with deployment scenarios.</critical-takeaway>
            <critical-takeaway>Test framework accommodation can hide real deployment issues - design fail-fast tests that fail when actual problems occur, not when test framework provides fallbacks.</critical-takeaway>
            <critical-takeaway>Async method testing: Remove duplicate imports (get_env redundancy), use test_mode=True for controlled testing, implement proper async cleanup in fixtures.</critical-takeaway>
        </category>
        
        <category name="Migration State Recovery [CRITICAL RESOLUTION]" path="SPEC/learnings/migration_state_recovery.xml" keywords="Migration, alembic_version, Database Schema, Startup Failure, Migration Tracking, State Recovery, System Blocker">
            <critical-takeaway>RESOLVED 2025-08-26: Fixed critical migration issue - "last major blocker preventing full system operation".</critical-takeaway>
            <critical-takeaway>CRITICAL ISSUE: Databases with existing schema but no alembic_version table cause 100% startup failures.</critical-takeaway>
            <critical-takeaway>SOLUTION: AlembicStateRecovery.initialize_alembic_version_for_existing_schema() creates missing migration tracking.</critical-takeaway>
            <critical-takeaway>INTEGRATION: MigrationTracker automatically calls ensure_migration_state_healthy() before migration checks.</critical-takeaway>
            <critical-takeaway>RECOVERY STRATEGIES: INITIALIZE_ALEMBIC_VERSION, COMPLETE_PARTIAL_MIGRATION, REPAIR_CORRUPTED_ALEMBIC, NO_ACTION_NEEDED.</critical-takeaway>
            <critical-takeaway>OPERATIONAL TOOL: python scripts/diagnose_migration_state.py provides diagnosis and recovery capabilities.</critical-takeaway>
            <critical-takeaway>PREVENTION: Comprehensive state analysis before migration operations prevents startup failures.</critical-takeaway>
            <critical-takeaway>TESTING: Full test coverage for state detection, recovery operations, and integration scenarios.</critical-takeaway>
            <critical-takeaway>IsolatedEnvironment singleton requires instance reset when testing different environment configurations.</critical-takeaway>
            <critical-takeaway>Service client connection tests must use async patterns: asyncio.run(client.connect()) for ClickHouse, asyncio.run(client.ping()) for Redis.</critical-takeaway>
            <critical-takeaway>Never access private methods (_method) from external components - use public interfaces.</critical-takeaway>
            <critical-takeaway>Secret loading failures should log warnings but NOT crash the application.</critical-takeaway>
            <critical-takeaway>Always write interface contract tests when creating component dependencies.</critical-takeaway>
        </category>

        <category name="CORS/Dynamic Ports" path="SPEC/learnings/cors_dynamic_ports.xml" keywords="CORS, Dynamic Ports, Localhost, Development">
            <critical-takeaway>CRITICAL: CORS configuration MUST support dynamic ports in development. Pattern matching for localhost with ANY port must be checked FIRST.</critical-takeaway>
            <critical-takeaway>Use DynamicCORSMiddleware when CORS_ORIGINS=* to handle credentials properly (RFC 6454).</critical-takeaway>
        </category>

        <category name="Staging Tests Definition" path="SPEC/staging_tests_definition.xml" keywords="staging, environment, testing, GCP, Docker Compose, naming conventions, test boundaries">
            <critical-takeaway>CRITICAL: "Staging" ALWAYS means GCP Cloud Run deployed environment, NEVER Docker Compose.</critical-takeaway>
            <critical-takeaway>Docker Compose is for local development only - use test_docker_*, test_local_*, test_integration_* naming.</critical-takeaway>
            <critical-takeaway>Staging tests must use ENVIRONMENT=staging and test real GCP URLs, not localhost.</critical-takeaway>
            <critical-takeaway>Environment confusion leads to false confidence causing $50K+ MRR loss from production incidents.</critical-takeaway>
        </category>

        <category name="Testing" path="SPEC/learnings/testing.xml" keywords="TDD, Feature Flags, Pytest, Jest, Test Discovery, Test Runner, Environment Testing, E2E Tests, Resource Cleanup, AsyncMock, Test Tracking, Test Dashboard, Flaky Tests">
            <critical-takeaway>Adhere to the Feature Flag TDD workflow (feature-flags-tdd-workflow).</critical-takeaway>
            <critical-takeaway>Tests must validate REAL functionality, not mocks (frontend-test-paradox-report).</critical-takeaway>
            <critical-takeaway>All test directories MUST be added to test_scanners.py for discovery (test-discovery-all-directories).</critical-takeaway>
            <critical-takeaway>Tests MUST declare environment compatibility using @env markers (environment_aware_testing.xml).</critical-takeaway>
            <critical-takeaway>Production tests require @env_safe decorator and ALLOW_PROD_TESTS flag.</critical-takeaway>
            <critical-takeaway>Test runner requires PROJECT_ROOT in sys.path for imports (test-import-project-root).</critical-takeaway>
            <critical-takeaway>E2E tests MUST include tests/e2e directory in pytest command - not just service-specific directories (e2e_test_discovery_patterns.xml).</critical-takeaway>
            <critical-takeaway>CRITICAL: All async fixtures MUST implement proper resource cleanup with try/finally blocks and timeout handling.</critical-takeaway>
            <critical-takeaway>Database fixtures must always call rollback() and close() in finally blocks, even for mock sessions.</critical-takeaway>
            <critical-takeaway>Redis fixtures must implement both aclose() and close() methods with proper cleanup lifecycle.</critical-takeaway>
            <critical-takeaway>WebSocket fixtures must close all active connections with timeout protection (max 5s) to prevent hanging tests.</critical-takeaway>
            <critical-takeaway>Event loop stability requires SelectorEventLoop policy on Windows and proper atexit cleanup registration.</critical-takeaway>
            <critical-takeaway>CRITICAL: E2E categories must be precisely scoped - use e2e_critical for curated tests, not entire directories (test_system_improvements.xml).</critical-takeaway>
            <critical-takeaway>Test execution tracking with SQLite enables flaky test detection and smart prioritization (test_system_improvements.xml).</critical-takeaway>
            <critical-takeaway>Default test categories should be data-driven based on recent pass rates, not hardcoded (test_system_improvements.xml).</critical-takeaway>
        </category>
        
        <category name="E2E Test Discovery [CRITICAL]" path="SPEC/learnings/e2e_test_discovery_patterns.xml" keywords="E2E, End-to-End, Test Discovery, Test Runner, pytest, Test Organization, Cross-Service Tests">
            <critical-takeaway>CRITICAL: E2E tests in tests/e2e directory MUST be included in test runner - missing 588+ tests if only checking service directories.</critical-takeaway>
            <critical-takeaway>Test runners must include ["tests/e2e", "netra_backend/tests", "auth_service/tests"] for E2E category, not just service paths.</critical-takeaway>
            <critical-takeaway>E2E tests should run ONCE from single service context, not once per service to avoid duplication.</critical-takeaway>
            <critical-takeaway>Cross-service tests belong in centralized tests/e2e directory, not scattered in service-specific directories.</critical-takeaway>
            <critical-takeaway>Validate test discovery with: pytest tests/e2e -m "e2e" --collect-only to ensure all tests found.</critical-takeaway>
            <critical-takeaway>CI/CD should assert minimum E2E test count (500+) to catch discovery regressions.</critical-takeaway>
        </category>
        
        <category name="Test System Improvements (2025-01-28)" path="SPEC/learnings/test_system_improvements.xml" keywords="Test Tracking, Test History, Flaky Detection, Test Dashboard, E2E Fix, Test Prioritization, Test Metrics, SQLite Tracking">
            <critical-takeaway>CRITICAL: E2E category was running 3,091 tests from multiple directories causing timeouts - must scope precisely to actual e2e tests.</critical-takeaway>
            <critical-takeaway>Create separate e2e categories: e2e_critical (curated ~20 tests), e2e (integration only), e2e_full (complete suite).</critical-takeaway>
            <critical-takeaway>Test execution tracking with SQLite provides persistent history for pattern detection and metrics.</critical-takeaway>
            <critical-takeaway>Flaky test detection uses alternation pattern analysis - tests that flip between pass/fail frequently.</critical-takeaway>
            <critical-takeaway>Smart test prioritization: run recently failed tests first, then by business value, then by speed.</critical-takeaway>
            <critical-takeaway>Default test categories should be data-driven - categories with >80% pass rate in last 7 days.</critical-takeaway>
            <critical-takeaway>Test dashboard provides actionable recommendations based on failure trends and performance metrics.</critical-takeaway>
            <critical-takeaway>Helper classes must be outside test directories to prevent test discovery confusion.</critical-takeaway>
            <critical-takeaway>Track every test execution with metadata: duration, status, environment, error details.</critical-takeaway>
            <critical-takeaway>HTML dashboard generation enables team-wide visibility into test health trends.</critical-takeaway>
        </category>
        
        <category name="Frontend Staging Errors (Five Whys)" path="SPEC/learnings/frontend_staging_errors_2025_08_24.xml" keywords="Five Whys, Type Conflicts, SSOT, Authentication, HTTPS, Mixed Content, Root Cause, Frontend, Staging">
            <critical-takeaway>Multiple type exports violate SSOT - maintain ONE canonical definition per type, delete all legacy implementations.</critical-takeaway>
            <critical-takeaway>Landing page auth failures often test mock issues - ensure mocks match actual import patterns.</critical-takeaway>
            <critical-takeaway>Mixed content HTTPS enforcement requires consistent client/server environment detection.</critical-takeaway>
            <critical-takeaway>Five Whys reveals true root causes 4-5 levels deep - most errors NOT what they first seem.</critical-takeaway>
            <critical-takeaway>Incomplete atomic refactoring causes most staging errors - enforce complete migrations.</critical-takeaway>
            <critical-takeaway>Create failing tests BEFORE fixing to validate root cause understanding.</critical-takeaway>
        </category>
        
        <category name="Test Infrastructure Unification" path="SPEC/learnings/test_unification.xml" keywords="Test Runner, Unified Testing, Test Framework, Test Plumbing">
            <critical-takeaway>Use unified_test_runner.py in root as single entry point for ALL test operations.</critical-takeaway>
            <critical-takeaway>Test infrastructure (runners, configs) centralized in root/test_framework/, test files remain in service directories.</critical-takeaway>
            <critical-takeaway>Service differences abstracted via SERVICE_CONFIGS - same interface for pytest/jest backends.</critical-takeaway>
            <critical-takeaway>Import paths must be updated systematically when consolidating - use migration scripts for large refactors.</critical-takeaway>
            <critical-takeaway>Maintain backwards compatibility during migrations with wrapper scripts and deprecation warnings.</critical-takeaway>
        </category>
        
        <category name="PostgreSQL Duplication Resolution" path="SPEC/learnings/postgresql_duplication_resolution.xml" keywords="PostgreSQL, Database, Connection, Duplication, pytest, URL normalization, SSL, Cloud SQL">
            <critical-takeaway>CRITICAL: NEVER use pytest detection in production code - causes test/production divergence</critical-takeaway>
            <critical-takeaway>Database URL normalization must have exactly ONE implementation in DatabaseURLBuilder</critical-takeaway>
            <critical-takeaway>All environment variable access must go through unified configuration</critical-takeaway>
            <critical-takeaway>SSL parameter handling centralized in DatabaseURLBuilder.format_url_for_driver()</critical-takeaway>
            <critical-takeaway>Cloud SQL detection uses DatabaseURLBuilder.cloud_sql.is_cloud_sql exclusively</critical-takeaway>
            <critical-takeaway>Test and production code paths MUST be identical - no conditional logic based on test detection</critical-takeaway>
        </category>
        
        <category name="WebSocket Consolidation" path="SPEC/learnings/websocket_consolidation.xml" keywords="websocket, SSOT, consolidation, heartbeat, lifecycle, message queue, single source of truth">
            <critical-takeaway>CRITICAL: Every functionality must have exactly ONE canonical implementation per SSOT - use composition/configuration, not multiple implementations.</critical-takeaway>
            <critical-takeaway>SSOT violations grow exponentially - a single wrapper spawned 8 implementations causing 2,100+ redundant lines.</critical-takeaway>
            <critical-takeaway>Always extend existing implementations with options/parameters instead of creating specialized variants.</critical-takeaway>
            <critical-takeaway>Backward compatibility aliases enable zero-downtime consolidation - always provide migration path.</critical-takeaway>
            <critical-takeaway>Run weekly duplicate detection: python scripts/detect_duplicate_code.py --threshold 0.8</critical-takeaway>
            <critical-takeaway>Any new manager/service/handler class requires architecture review to prevent duplication.</critical-takeaway>
        </category>
        
        <category name="WebSocket Legacy Cleanup" path="SPEC/learnings/websocket_legacy_cleanup.xml" keywords="websocket, legacy imports, large_message_handler, startup module, consolidation cleanup">
            <critical-takeaway>WebSocket large_message_handler module was removed during consolidation - use get_websocket_manager() instead.</critical-takeaway>
            <critical-takeaway>All WebSocket imports MUST use netra_backend.app.websocket_core, not legacy app.websocket.* paths.</critical-takeaway>
            <critical-takeaway>Message size validation now in auth module: validate_message_size() with 8192 byte default.</critical-takeaway>
            <critical-takeaway>After architecture consolidation, systematically audit all imports to prevent runtime failures.</critical-takeaway>
            <critical-takeaway>Graceful startup mode logs warnings for optional service failures instead of crashing.</critical-takeaway>
        </category>
        
        <category name="Test Infrastructure Repair" path="SPEC/learnings/test_infrastructure_repair.xml" keywords="Integration Tests, Import Errors, Async Tests, Test Collection, pytest.mark.asyncio">
            <critical-takeaway>CRITICAL: All async test functions MUST have @pytest.mark.asyncio decorator or tests will hang/timeout.</critical-takeaway>
            <critical-takeaway>All imports MUST be absolute starting from package root - NO relative imports in tests.</critical-takeaway>
            <critical-takeaway>Missing module exports cause most import errors - ensure __all__ exports in modules.</critical-takeaway>
            <critical-takeaway>Create stub implementations for missing modules rather than removing test coverage.</critical-takeaway>
            <critical-takeaway>Auth service is UserAuthService not AuthService - import as: from netra_backend.app.services.user_auth_service import UserAuthService as AuthService.</critical-takeaway>
            <critical-takeaway>Metrics collector is at netra_backend.app.monitoring.metrics_collector not core.monitoring.</critical-takeaway>
            <critical-takeaway>Test config is at netra_backend.tests.integration.config not tests.config.</critical-takeaway>
        </category>
        
        <category name="Test Collection Import Errors" path="SPEC/learnings/test_collection_import_errors.xml" keywords="Import Errors, Test Collection, ModuleNotFoundError, MockWebSocket, Test Mocks, Absolute Imports, File Structure">
            <critical-takeaway>CRITICAL: Test collection fails with ModuleNotFoundError when imports point to wrong directories - blocks ALL systematic test fixing.</critical-takeaway>
            <critical-takeaway>MockWebSocket class is in netra_backend.tests.services.test_ws_connection_mocks, NOT netra_backend.tests.integration.test_ws_connection_mocks.</critical-takeaway>
            <critical-takeaway>Always verify import paths against actual file locations using find command before fixing imports.</critical-takeaway>
            <critical-takeaway>Import errors during collection prevent pytest from discovering ANY tests in affected files - highest priority fixes.</critical-takeaway>
            <critical-takeaway>Use absolute imports as per SPEC/import_management_architecture.xml - relative imports forbidden.</critical-takeaway>
        </category>
        
        <category name="Test Imports" path="SPEC/learnings/test_import_fixes.xml" keywords="Imports, ModuleNotFoundError, PYTHONPATH, Test Setup">
            <critical-takeaway>All imports MUST use absolute imports with netra_backend namespace (e.g., from netra_backend.app.db import models).</critical-takeaway>
            <critical-takeaway>Auth service endpoints use /auth prefix, NOT /auth.</critical-takeaway>
            <critical-takeaway>Use /auth/dev/login for testing (no registration endpoint exists).</critical-takeaway>
            <critical-takeaway>Test files use netra_backend.tests.* namespace for test imports.</critical-takeaway>
        </category>
        
        <category name="Test Environment" path="SPEC/learnings/test_environment_fixes.xml" keywords="Windows, PYTHONPATH, Pytest, Environment">
            <critical-takeaway>Set PYTHONPATH explicitly on Windows: set PYTHONPATH=C:\path\to\app</critical-takeaway>
            <critical-takeaway>Run tests from app directory for proper import resolution.</critical-takeaway>
            <critical-takeaway>Use -m "not real_services" to skip external API calls in tests.</critical-takeaway>
            <critical-takeaway>Test size limits: 1000 lines per file, 8 lines per function (many violations exist).</critical-takeaway>
        </category>
        
        <category name="Test Import Standardization" path="SPEC/test_import_standardization.xml" keywords="Test Setup, sys.path, Imports, SSOT, setup_test_path">
            <critical-takeaway>NEVER write manual sys.path manipulation in test files - use setup_test_path() from netra_backend.tests.test_utils</critical-takeaway>
            <critical-takeaway>500+ test files contained redundant path setup code violating SSOT - ALL must use centralized function</critical-takeaway>
            <critical-takeaway>Import order: stdlib -> third-party -> setup_test_path() -> project imports</critical-takeaway>
            <critical-takeaway>Manual PROJECT_ROOT manipulation is FORBIDDEN - violates SSOT principle</critical-takeaway>
        </category>
        
        <category name="Logging Color Configuration" path="SPEC/learnings/logging_color_configuration.xml" keywords="Loguru, Colors, ANSI, Markup, Console, Logging, Colorize">
            <critical-takeaway>CRITICAL: Enable colorize=True in logger.add() for console handlers to process color markup tags into ANSI codes.</critical-takeaway>
            <critical-takeaway>Use loguru's native &lt;level&gt;{message}&lt;/level&gt; format syntax for automatic level-based coloring.</critical-takeaway>
            <critical-takeaway>NEVER manually add color tags to message content - let loguru handle color processing natively.</critical-takeaway>
            <critical-takeaway>Custom preprocessors that add literal color tags cause display issues - use loguru's built-in markup.</critical-takeaway>
            <critical-takeaway>File handlers must have colorize=False to prevent ANSI codes in log files.</critical-takeaway>
            <critical-takeaway>JSON handlers use serialize=True parameter, not custom JSON formatters.</critical-takeaway>
            <critical-takeaway>Test logging output with real console, not just StringIO, to verify color rendering.</critical-takeaway>
        </category>

        <category name="Frontend" path="SPEC/learnings/frontend.xml" keywords="Zustand, React, TypeScript, Loading States, Initialization, UX, UI, Auth Context, Dev Auto-Login">
            <critical-takeaway context="Zustand">Use individual selectors to prevent infinite loops. See SPEC/conventions.xml#zustand-selectors.</critical-takeaway>
            <critical-takeaway context="Initialization">CRITICAL: ANY changes to loading states, initialization flows, or auth context MUST be tested with dev-auto-login.test.tsx (frontend_loading_states.xml).</critical-takeaway>
            <critical-takeaway context="UX">Loading states must NOT block UI rendering - use skeleton screens or partial content (frontend_loading_states.xml).</critical-takeaway>
            <critical-takeaway context="Auth">Token processing MUST handle storedToken === currentToken case for dev auto-login to work (frontend_dev_autologin.xml).</critical-takeaway>
            <critical-takeaway context="Initialization">Use hasMountedRef pattern to prevent multiple initialization calls in auth context (frontend_initialization_patterns.xml).</critical-takeaway>
        </category>
        
        <category name="Frontend Loading States &amp; UX" path="SPEC/learnings/frontend_loading_states.xml" keywords="Loading, Spinner, Skeleton, UX, UI, User Experience, Initialization, Bootstrap, Auth Loading, Dev Experience">
            <critical-takeaway>MANDATORY: Test ALL loading/init changes with __tests__/auth/dev-auto-login.test.tsx - breaking auto-login severely impacts dev productivity.</critical-takeaway>
            <critical-takeaway>Loading states hierarchy: AuthProvider Loading to Token Processing to Dev Auto-Login - each phase has specific requirements.</critical-takeaway>
            <critical-takeaway>Never block UI completely for >3 seconds - use progressive enhancement and skeleton screens.</critical-takeaway>
            <critical-takeaway>Auth context token processing MUST handle existing tokens correctly or dev auto-login breaks on page refresh.</critical-takeaway>
            <critical-takeaway>Dev auto-login requires 5+ retries with exponential backoff to handle backend startup delays.</critical-takeaway>
        </category>

        <category name="Microservice Independence" path="SPEC/independent_services.xml" keywords="Microservice, Docker, Service">
            <critical-takeaway>CRITICAL: Microservices MUST be 100% independent. NO imports from the main `netra_backend/app/` module. Do not name internal modules 'app'.</critical-takeaway>
        </category>

        <category name="Health Checks" path="SPEC/learnings/health_checks.xml" keywords="Health, Ready, Readiness, Liveness">
            <critical-takeaway>Health check endpoints must initialize database connections lazily if not already initialized.</critical-takeaway>
            <critical-takeaway>Auth service requires /health/ready endpoint on configured port (8080 default, not 8001).</critical-takeaway>
            <critical-takeaway>Database health checks must handle uninitialized async_engine gracefully by calling initialize_postgres().</critical-takeaway>
            <critical-takeaway>Backend has TWO health implementations: active health.py at /health prefix and unused unified_health.py - /health/ready endpoint exists at /health/ready.</critical-takeaway>
            <critical-takeaway>Health route registration uses health.py module (not unified_health.py) with endpoints: /health/, /health/ready, /health/live and others.</critical-takeaway>
        </category>

        <category name="Database/AsyncIO" path="SPEC/learnings/database_asyncio.xml" keywords="AsyncSession, Database, Postgres, ClickHouse">
            <critical-takeaway>Functions marked as async must actually await something (postgres-session-async-function-paradox).</critical-takeaway>
            <critical-takeaway>ClickHouse driver: Use OperationalError instead of NetworkError (which doesn't exist) for network-related exceptions.</critical-takeaway>
        </category>
        
        <category name="Database/ClickHouse SSL Connection" path="SPEC/learnings/clickhouse_ssl_connection.xml" keywords="ClickHouse, SSL, HTTPS, Docker, Connection, Port 8123, Port 8443">
            <critical-takeaway>Docker container hostnames (clickhouse, netra-clickhouse) MUST be treated as local hosts to prevent SSL errors.</critical-takeaway>
            <critical-takeaway>Development environment MUST always use HTTP (port 8123), never HTTPS, for ClickHouse connections.</critical-takeaway>
            <critical-takeaway>ClickHouse is OPTIONAL in staging environment - system gracefully degrades without it.</critical-takeaway>
            <critical-takeaway>SSL detection logic must check: localhost IPs, Docker hostnames, AND development environment flag.</critical-takeaway>
        </category>
        
        <category name="Database Architecture" path="SPEC/learnings/database.xml" keywords="Database, Connection, Driver, AsyncPG, Psycopg2, SSL, Cloud SQL, URL, Architecture, Health Check, Authentication, DatabaseManager, IsolatedEnvironment">
            <critical-takeaway>Sync drivers (psycopg2) use sslmode= parameter, async drivers (asyncpg) use ssl= parameter - incompatibility causes connection failures.</critical-takeaway>
            <critical-takeaway>Cloud SQL Unix socket connections must have NO SSL parameters - SSL is handled at socket level.</critical-takeaway>
            <critical-takeaway>Alembic migrations must use sync drivers (psycopg2), not async drivers - prevents greenlet/asyncio compatibility issues.</critical-takeaway>
            <critical-takeaway>Use centralized DatabaseManager for URL transformations to ensure driver compatibility and prevent configuration errors.</critical-takeaway>
            <critical-takeaway>Environment-aware connection strategy required - local uses TCP, Cloud SQL can use TCP+SSL or Unix sockets without SSL.</critical-takeaway>
            <critical-takeaway>Health checkers MUST use DatabaseManager.create_application_engine() - direct async_engine imports cause authentication failures.</critical-takeaway>
            <critical-takeaway>Database connections in health checks should create and dispose engines per check to prevent pool exhaustion.</critical-takeaway>
            <critical-takeaway>All services MUST use DatabaseManager for database connections to ensure credential consistency from IsolatedEnvironment.</critical-takeaway>
        </category>
        
        <category name="Database Validation Consistency" path="SPEC/learnings/database_validation_consistency.xml" keywords="Database Validation, Dev Launcher, Initialization, Connection Validation, Startup, Resilient Validation">
            <critical-takeaway>Database initialization MUST happen BEFORE validation to prevent false connection failures.</critical-takeaway>
            <critical-takeaway>Use single validation pass with consistent reporting - avoid fallback validations that re-run checks.</critical-takeaway>
            <critical-takeaway>Consistent message prefixes across validation stages: DATABASE for overall, CONNECT for individual connections.</critical-takeaway>
            <critical-takeaway>Continue startup with available services even if some database connections fail in development mode.</critical-takeaway>
            <critical-takeaway>Avoid duplicate validation messages by having clear separation between initialization and validation phases.</critical-takeaway>
        </category>
        
        <category name="Database Config Migration" path="SPEC/learnings/database_config_migration.xml" keywords="DatabaseConfig, Migration, Unified Config, postgres_events, Configuration Migration">
            <critical-takeaway>ALL DatabaseConfig.* references MUST be replaced with get_unified_config().db_* - partial migrations cause deployment failures.</critical-takeaway>
            <critical-takeaway>Migration from DatabaseConfig to unified config must be atomic and comprehensive across ALL files.</critical-takeaway>
            <critical-takeaway>postgres_events.py must use get_unified_config() instead of DatabaseConfig imports.</critical-takeaway>
            <critical-takeaway>Staging deployment reveals configuration issues not caught in local development due to different initialization paths.</critical-takeaway>
            <critical-takeaway>Use Five Whys analysis for root cause identification of deployment configuration errors.</critical-takeaway>
        </category>
        
        <category name="FastAPI/Dependencies" path="SPEC/learnings/fastapi_dependencies.xml" keywords="FastAPI, Depends, AsyncContextManager, async with, async for">
            <critical-takeaway>Never use @asynccontextmanager decorated functions directly with FastAPI's Depends() - create wrapper functions.</critical-takeaway>
            <critical-takeaway>Use 'async with' for @asynccontextmanager functions, NOT 'async for' (context managers != iterators).</critical-takeaway>
            <critical-takeaway>Context managers implement __aenter__/__aexit__, iterators implement __aiter__/__anext__.</critical-takeaway>
        </category>
        
        <category name="Import Management" path="SPEC/learnings/import_management.xml" keywords="Imports, ImportError, ModuleNotFoundError, CostOptimizer">
            <critical-takeaway>Always use absolute imports starting from netra_backend, never relative imports</critical-takeaway>
            <critical-takeaway>When renaming classes, create backwards compatibility aliases (e.g., CostOptimizer = LLMCostOptimizer)</critical-takeaway>
            <critical-takeaway>Missing Enum import is common - always check for standard library imports</critical-takeaway>
            <critical-takeaway>Use import_management.py for comprehensive import checking and fixing</critical-takeaway>
        </category>
        
        <category name="Python Module Naming and Case Sensitivity" path="SPEC/learnings/python_module_naming_case_sensitivity.xml" keywords="Python Module Naming, PEP 8, Case Sensitivity, Docker, Schema Files, Uppercase, Lowercase, Import Failures, Production, Filesystem">
            <critical-takeaway>CRITICAL: All Python modules MUST use lowercase naming with underscores (PEP 8) - uppercase module names cause import failures in production</critical-takeaway>
            <critical-takeaway>Case-insensitive filesystems (macOS/Windows) mask production issues - always test in Docker/Linux environments</critical-takeaway>
            <critical-takeaway>Mixed naming conventions violate SSOT principle - maintain one consistent naming pattern across all modules</critical-takeaway>
            <critical-takeaway>Schema file renames require atomic updates - all 22 schema files and 243 import statements must be updated together</critical-takeaway>
            <critical-takeaway>Pre-commit hooks must validate Python file naming: ^[a-z][a-z0-9_]*\.py$ pattern enforcement</critical-takeaway>
            <critical-takeaway>Import failures in Docker containers indicate case sensitivity issues - validate all module names against PEP 8</critical-takeaway>
        </category>

        <category name="Database/Migration" path="SPEC/learnings/alembic_asyncpg_greenlet.xml" keywords="Alembic, Migration, AsyncPG, Greenlet, SQLAlchemy">
            <critical-takeaway>Alembic requires synchronous database URL - remove asyncpg driver for migrations.</critical-takeaway>
            <critical-takeaway>Separate sync migration URLs from async application URLs to avoid greenlet errors.</critical-takeaway>
        </category>

        <category name="Database Migration Recovery Testing [CRITICAL]" path="SPEC/learnings/database_migration_recovery_testing.xml" keywords="Database Migration, Idempotency, Recovery Patterns, TDC, Test-Driven Correction, Database Integrity, Migration Safety, Partial State Recovery">
            <critical-takeaway>MANDATORY: All migration operations must be idempotent with proper if_exists checks</critical-takeaway>
            <critical-takeaway>CRITICAL: Implement Test-Driven Correction (TDC) for all database migration issues</critical-takeaway>
            <critical-takeaway>ESSENTIAL: Database migrations require partial state detection and recovery mechanisms</critical-takeaway>
            <critical-takeaway>REQUIRED: Use advisory locks to prevent concurrent migration execution</critical-takeaway>
            <critical-takeaway>IMPORTANT: Validate cross-database consistency before creating foreign key constraints</critical-takeaway>
            <critical-takeaway>NECESSARY: Rollback operations must be idempotent with proper existence checks</critical-takeaway>
            <critical-takeaway>VALUABLE: Index creation requires dependency validation of tables and columns</critical-takeaway>
            <critical-takeaway>BENEFICIAL: Document migration state assumptions and recovery procedures comprehensively</critical-takeaway>
            <critical-takeaway>STRATEGIC: Build automated database recovery patterns for production resilience</critical-takeaway>
        </category>

        <category name="Dev Launcher" path="SPEC/learnings/dev_launcher.xml" keywords="Development, Startup, Local, Health Checks, Configuration, LLM, Environment">
            <critical-takeaway>CONSOLIDATED: All dev launcher learnings now in single file. SECRET_KEY must be 64+ characters.</critical-takeaway>
            <critical-takeaway>Health checks must use dynamic ports from .service_discovery/*.json files.</critical-takeaway>
            <critical-takeaway>Extended timeouts required: Backend/Auth 30s, Frontend 60s, Overall 120s.</critical-takeaway>
            <critical-takeaway>LLM must stay in "shared" mode even without API keys - do not auto-disable (service_availability_checker.py).</critical-takeaway>
            <critical-takeaway>Backend environment loading must avoid circular dependencies - check env vars, not config system (main.py).</critical-takeaway>
        </category>

        <category name="Deployment" path="SPEC/learnings/deployment_staging.xml" keywords="GCP, Cloud Run, Docker, Staging, SSL, Database, OAuth, Frontend, Proxy, Gunicorn, Workers">
            <critical-takeaway>Use gunicorn with uvicorn workers for Cloud Run (cloud-run-uvicorn-workers).</critical-takeaway>
            <critical-takeaway>DATABASE_URL in staging/production MUST include sslmode=require parameter for Cloud SQL connections.</critical-takeaway>
            <critical-takeaway>Frontend NEXT_PUBLIC_API_URL must point to backend API URL (e.g., https://api.staging.netrasystems.ai) for proxy rewrites to work.</critical-takeaway>
            <critical-takeaway>Health check /health/ready endpoint in staging may fail with 503 if database connectivity isn't properly configured - check DATABASE_URL and SSL settings.</critical-takeaway>
            <critical-takeaway>OAuth flow requires auth service at separate domain (e.g., auth.staging.netrasystems.ai) with proper CORS and callback URL configuration.</critical-takeaway>
            <critical-takeaway>Gunicorn workers require proper lifecycle hooks and tini for signal handling to prevent ProcessLookupError in containers.</critical-takeaway>
            <critical-takeaway>CRITICAL: USE_OAUTH_PROXY must be "true" for backend to validate tokens through auth service, even if OAUTH_PROXY_URL is correctly set.</critical-takeaway>
        </category>

        <category name="GitHub Actions" path="SPEC/learnings/github_actions.xml" keywords="CI/CD, Pipeline, Workflow">
            <critical-takeaway>Test failures must propagate - see test-exit-code-propagation learning.</critical-takeaway>
        </category>

        <category name="Architecture/Compliance" path="SPEC/learnings/compliance_improvements.xml" keywords="300/8, Compliance, Architecture">
            <critical-takeaway>Maintain 450-line file limit and 25-line function limit. Use compliance check script.</critical-takeaway>
        </category>

        <category name="Context Optimization" path="SPEC/learnings/context_optimization.xml" keywords="AI Context, Token Optimization">
            <critical-takeaway>Avoid context bloat from test files and long functions. Monitor context efficiency.</critical-takeaway>
        </category>

        <category name="Type Safety" path="SPEC/learnings/type_safety.xml" keywords="Types, Pydantic, TypeScript">
            <critical-takeaway>Maintain single source of truth for types. Avoid circular imports.</critical-takeaway>
        </category>
        
        <category name="SSOT Consolidation [CRITICAL]" path="SPEC/learnings/ssot_consolidation_20250825.xml" keywords="SSOT, Single Source of Truth, Duplication, Consolidation, Refactoring, Architecture Compliance, Database Manager, Auth Client, Error Handler">
            <critical-takeaway>CRITICAL: Each concept must have ONE canonical implementation per service - multiple implementations violate SSOT and create technical debt.</critical-takeaway>
            <critical-takeaway>MANDATORY: SSOT fixes must be atomic - either completely fix all violations in a domain or report blockers.</critical-takeaway>
            <critical-takeaway>Database connectivity must use single DatabaseManager in netra_backend/app/db/database_manager.py - delete all other managers.</critical-takeaway>
            <critical-takeaway>Authentication must use single AuthServiceClient in auth_client_core.py - delete all shims and wrappers.</critical-takeaway>
            <critical-takeaway>Error handling must use UnifiedErrorHandler in core/unified_error_handler.py - delete domain-specific handlers.</critical-takeaway>
            <critical-takeaway>Environment access must use IsolatedEnvironment.get_env() - never use direct os.getenv() or os.environ.</critical-takeaway>
            <critical-takeaway>When consolidating, provide backward compatibility wrappers to prevent breaking changes.</critical-takeaway>
            <critical-takeaway>Delete duplicate implementations immediately - do not maintain legacy code per CLAUDE.md.</critical-takeaway>
            <critical-takeaway>Run architecture compliance checks before every commit to prevent reintroduction of violations.</critical-takeaway>
        </category>
        
        <category name="CORS SSOT Consolidation [RESOLVED]" path="SPEC/learnings/cors_ssot_consolidation_2025.xml" keywords="CORS, Single Source of Truth, Origin Validation, shared/cors_config, validate_cors_origin, _is_valid_origin">
            <critical-takeaway>RESOLVED 2025-08-25: Eliminated duplicate CORS origin validation functions in auth_service by consolidating to shared/cors_config.py</critical-takeaway>
            <critical-takeaway>validate_cors_origin() and _is_valid_origin() now use shared is_origin_allowed() function instead of hardcoded origin lists</critical-takeaway>
            <critical-takeaway>CORS origin configuration is now environment-aware through shared/cors_config.py with proper dev/staging/production origin lists</critical-takeaway>
            <critical-takeaway>Canonical CORS configuration: shared/cors_config.py provides get_cors_origins() and is_origin_allowed() for all services</critical-takeaway>
            <critical-takeaway>Auth service CORS consolidation maintains exact same security behavior while eliminating 20+ lines of duplicate origin lists</critical-takeaway>
            <critical-takeaway>Environment-specific CORS behavior verified: development allows localhost, staging allows staging domains, production blocks all but production domains</critical-takeaway>
        </category>
        
        <category name="Configuration Issues Resolution [RESOLVED]" path="SPEC/learnings/configuration_fixes_20250825.xml" keywords="Configuration, Database URL, PostgreSQL, AsyncPG, Auth Service, Startup Import, WebSocket Deprecation">
            <critical-takeaway>RESOLVED 2025-08-25: Fixed AUTH service DATABASE_URL configuration by changing from postgresql:// to postgresql+asyncpg:// format</critical-takeaway>
            <critical-takeaway>Auth service requires postgresql+asyncpg:// driver format for async operations, not plain postgresql://</critical-takeaway>
            <critical-takeaway>Database connectivity errors often manifest as "connection refused" when service configuration is correct but infrastructure (Docker PostgreSQL) is not running</critical-takeaway>
            <critical-takeaway>Fixed startup module import error: ErrorAggregator import from netra_backend.app.error_aggregator should be netra_backend.app.startup.error_aggregator</critical-takeaway>
            <critical-takeaway>WebSocket deprecation warnings fixed by replacing websockets.WebSocketServerProtocol with websockets.ServerConnection</critical-takeaway>
            <critical-takeaway>Test imports must be updated when module structure changes - comprehensive grep search needed for all import references</critical-takeaway>
            <critical-takeaway>Infrastructure dependencies (Docker services) are prerequisites for auth service database tests to pass</critical-takeaway>
        </category>
        
        <category name="Critical Backend Infrastructure Fixes [RESOLVED]" path="SPEC/learnings/critical_backend_fixes_20250825.xml" keywords="Redis, ClickHouse, Import Order, Connection Timeout, Graceful Degradation, Staging Environment">
            <critical-takeaway>RESOLVED 2025-08-25: Fixed Redis get_env import order issue - imports must come AFTER module docstring to prevent NameError during initialization</critical-takeaway>
            <critical-takeaway>ClickHouse connections require 30-second timeout handling to prevent indefinite hanging in staging environments</critical-takeaway>
            <critical-takeaway>Staging environments need graceful degradation - when CLICKHOUSE_REQUIRED=false, fall back to mock client instead of failing</critical-takeaway>
            <critical-takeaway>ClickHouse service initialization requires retry logic with exponential backoff (3 attempts: 1s, 2s, 4s) for transient network issues</critical-takeaway>
            <critical-takeaway>Environment-aware error handling: staging allows optional services, production enforces required services</critical-takeaway>
            <critical-takeaway>Import ordering critical: module imports must always follow module docstrings to avoid circular dependency issues</critical-takeaway>
        </category>
        
        <category name="ClickHouse Graceful Failure Handling [FIXED 2025-08-28]" path="SPEC/learnings/clickhouse_graceful_failure.xml" keywords="ClickHouse, Timeout, Graceful Failure, Optional Service, Startup Blocking, Connection Timeout, Staging, HTTPSConnectionPool">
            <critical-takeaway>FIXED 2025-08-28: ClickHouse must be optional by default in staging/development to prevent backend startup blocking</critical-takeaway>
            <critical-takeaway>Use environment-aware timeouts: 3-5s in staging/dev, 10-30s in production to fail fast when infrastructure unavailable</critical-takeaway>
            <critical-takeaway>Implement graceful degradation with mock client fallback when real connections fail in optional environments</critical-takeaway>
            <critical-takeaway>Skip ClickHouse initialization entirely in optional environments unless CLICKHOUSE_REQUIRED=true</critical-takeaway>
            <critical-takeaway>Health checks must respect service optionality - skip or report "optional_unavailable" for optional services</critical-takeaway>
            <critical-takeaway>Layer multiple timeout protections: connection, operation, initialization, and wrapper timeouts</critical-takeaway>
            <critical-takeaway>HTTPSConnectionPool timeout errors indicate infrastructure unavailability - use fast failure patterns</critical-takeaway>
            <critical-takeaway>Backend startup time reduced from 60s+ to &lt;30s by preventing ClickHouse connection blocking</critical-takeaway>
        </category>
        
        <category name="ClickHouse SSOT Violation Remediation [CRITICAL FIXED 2025-08-28]" path="SPEC/learnings/clickhouse_ssot_violation_remediation.xml" keywords="ClickHouse, SSOT, Single Source of Truth, Duplicate Clients, Code Duplication, Client Architecture, get_clickhouse_client, canonical implementation, technical debt, maintenance burden">
            <critical-takeaway>CATASTROPHIC: Had 4 different ClickHouse client implementations violating SSOT principle - consolidated to 1 canonical implementation at netra_backend/app/db/clickhouse.py</critical-takeaway>
            <critical-takeaway>ALWAYS use get_clickhouse_client() context manager - NEVER create new ClickHouse client classes or direct instantiation</critical-takeaway>
            <critical-takeaway>Test logic in production (MockClickHouseDatabase, _simulate_* methods) violates clean architecture - use test_framework/fixtures/clickhouse_fixtures.py</critical-takeaway>
            <critical-takeaway>Search First, Create Second - ALWAYS check for existing ClickHouse implementation before creating parallel ones</critical-takeaway>
            <critical-takeaway>Agent-specific client implementations violate service architecture - use dependency injection with canonical client</critical-takeaway>
            <critical-takeaway>SSOT violations compound quickly - 4 implementations created 834+ lines of duplicate code requiring synchronized updates</critical-takeaway>
            <critical-takeaway>Direct class instantiation (ClickHouseClient()) bypasses configuration management and connection pooling</critical-takeaway>
            <critical-takeaway>Run python -m pytest netra_backend/tests/test_clickhouse_ssot_compliance.py to prevent SSOT regressions</critical-takeaway>
            <critical-takeaway>Migration pattern: Replace import/instantiation with async with get_clickhouse_client() as client context manager</critical-takeaway>
            <critical-takeaway>Deleted files: clickhouse_client.py, client_clickhouse.py, agents/data_sub_agent/clickhouse_client.py - imports will fail</critical-takeaway>
            <critical-takeaway>Automated compliance checks in scripts/compliance/ssot_checker.py prevent new duplicate client implementations</critical-takeaway>
            <critical-takeaway>SSOT compliance tests must pass: test_no_duplicate_clickhouse_clients, test_no_test_logic_in_production, test_all_imports_use_canonical_client</critical-takeaway>
            <critical-takeaway>MockClickHouseDatabase in production violates clean architecture - move to test_framework/fixtures/clickhouse_fixtures.py</critical-takeaway>
            <critical-takeaway>Integration tests importing deleted clients fail with ModuleNotFoundError - update to canonical imports</critical-takeaway>
            <critical-takeaway>Canonical client must include ALL features from deleted implementations: SSL/TLS support, circuit breakers, retry logic</critical-takeaway>
            <critical-takeaway>Post-remediation verification: grep -r "from.*clickhouse_client\|from.*client_clickhouse" should return NO results</critical-takeaway>
        </category>
        
        <category name="ClickHouse Connection Parameters Fix [RESOLVED 2025-08-30]" path="SPEC/learnings/clickhouse_connection_parameters_fix.xml" keywords="ClickHouse, clickhouse_connect, Connection Parameters, pool_size, pool_mgr, username, HttpClient, get_client">
            <critical-takeaway>clickhouse_connect.get_client() does NOT accept pool_size, retries, or retry_delay parameters - these cause HttpClient.__init__() errors</critical-takeaway>
            <critical-takeaway>Use 'username' not 'user' as the parameter name for clickhouse_connect.get_client()</critical-takeaway>
            <critical-takeaway>pool_mgr parameter expects a PoolManager object, not a boolean - for connection pooling pass an actual urllib3 PoolManager</critical-takeaway>
            <critical-takeaway>Always verify library parameters with inspect.signature() before use - don't assume parameter names</critical-takeaway>
            <critical-takeaway>Retry logic should be implemented at application level, not through non-existent client parameters</critical-takeaway>
        </category>
        
        <category name="Circular Import Detection" path="SPEC/learnings/circular_import_detection.xml" keywords="Circular Import, Import Error, Initialization, WebSocket, Synthetic Data">
            <critical-takeaway>Standard import tests miss indirect circular imports through 4+ modules.</critical-takeaway>
            <critical-takeaway>Use lazy imports (inside methods) for WebSocket manager in job/task managers.</critical-takeaway>
            <critical-takeaway>Use TYPE_CHECKING guards for type hints in circular-prone modules.</critical-takeaway>
            <critical-takeaway>Import tests MUST track full import chains, not just direct imports.</critical-takeaway>
        </category>

        <category name="E2E Testing" path="SPEC/learnings/e2e_testing.xml" keywords="End-to-End, Integration, Mock Mode, Database Session, TypeScript Exports, OAuth Testing, Agent Testing">
            <critical-takeaway>Mock mode detection enables rapid testing without external dependencies.</critical-takeaway>
            <critical-takeaway>Database session factories enable predictable test database state management.</critical-takeaway>
            <critical-takeaway>TypeScript type vs runtime export separation prevents import errors and enables proper optimization.</critical-takeaway>
            <critical-takeaway>OAuth tests must handle multiple valid failure modes (302, 401, 503) depending on configuration and state.</critical-takeaway>
            <critical-takeaway>Agent system testing requires end-to-end patterns covering database persistence and WebSocket communication.</critical-takeaway>
            <critical-takeaway>Complete module structures with proper exports prevent import failures and system integration issues.</critical-takeaway>
        </category>
        
        <category name="E2E Test Infrastructure" path="SPEC/learnings/e2e_test_infrastructure_fixes.xml" keywords="E2E Tests, Test Infrastructure, Redis Async, Postgres Config, WebSocket Tests, Agent Orchestration, Test Collection">
            <critical-takeaway>Use redis.asyncio for async Redis operations, not synchronous redis client with await.</critical-takeaway>
            <critical-takeaway>PostgreSQL test connections must use port 5433 and load credentials from .env file.</critical-takeaway>
            <critical-takeaway>Missing @dataclass decorators cause instantiation failures - verify all data classes have proper decorators.</critical-takeaway>
            <critical-takeaway>Tests must gracefully handle unavailable services with skip messages, not failures.</critical-takeaway>
            <critical-takeaway>Use absolute imports exclusively with test_framework.setup_test_path() for all test files.</critical-takeaway>
            <critical-takeaway>Create centralized helper modules to reduce duplication across test categories.</critical-takeaway>
        </category>

        <category name="Startup" path="SPEC/learnings/startup.xml" keywords="Initialization, Boot, Config">
            <critical-takeaway>Startup errors often cascade - fix configuration first, then secrets, then connections.</critical-takeaway>
            <critical-takeaway>Database initialization must happen ONCE - avoid duplicate calls to prevent infinite loops (database_initialization_duplication.xml).</critical-takeaway>
        </category>
        
        <category name="Database Initialization Duplication" path="SPEC/learnings/database_initialization_duplication.xml" keywords="Database, Initialization, Duplication, Infinite Loop, Startup Manager, Connection Pool">
            <critical-takeaway>CRITICAL: Database initialization must occur exactly ONCE during startup - duplicate calls cause infinite loops and connection pool exhaustion.</critical-takeaway>
            <critical-takeaway>StartupManager._initialize_database() should only call setup_database_connections(), NOT both DatabaseInitializer.initialize_postgresql() AND setup_database_connections().</critical-takeaway>
            <critical-takeaway>setup_database_connections() already handles all necessary initialization including initialize_postgres() and _ensure_database_tables_exist().</critical-takeaway>
            <critical-takeaway>Follow SSOT principle: each initialization step should have ONE canonical implementation path.</critical-takeaway>
            <critical-takeaway>Monitor connection pool metrics during startup to detect excessive connection attempts.</critical-takeaway>
            <critical-takeaway>Add explicit tests for initialization call counts to prevent regression.</critical-takeaway>
        </category>
        
        <category name="No Silent Fallbacks" path="SPEC/learnings/no_silent_fallbacks.xml" keywords="Fallback, Default, Mock, Configuration, Database URL, Secrets, Loud Failure">
            <critical-takeaway>CRITICAL: Never silently fall back to mock or default values for critical configuration - fail loudly and immediately.</critical-takeaway>
            <critical-takeaway>Database URLs must be explicitly configured - no localhost:5432 defaults that mask real connection issues.</critical-takeaway>
            <critical-takeaway>JWT secrets must be explicitly set - no dev-secret-key defaults that create security vulnerabilities.</critical-takeaway>
            <critical-takeaway>Redis URLs must be explicitly configured - no localhost:6379 defaults that fail in containerized environments.</critical-takeaway>
            <critical-takeaway>Service secrets and IDs must be explicitly configured - no dev defaults that prevent proper authentication.</critical-takeaway>
            <critical-takeaway>Silent fallbacks mask real issues and make debugging exponentially harder - loud failures identify problems at their source.</critical-takeaway>
        </category>
        
        <category name="Configuration-Logging Circular Dependency" path="SPEC/learnings/configuration_logging_circular_dependency.xml" keywords="Circular Dependency, Configuration, Logging, Loguru, Startup, Bootstrap">
            <critical-takeaway>NEVER import logger directly in configuration modules - use lazy initialization to prevent circular dependencies.</critical-takeaway>
            <critical-takeaway>Always provide print fallbacks for logging during bootstrap phase when logger may not be available.</critical-takeaway>
            <critical-takeaway>Check loading flags (e.g., _loading) to prevent recursive initialization between interdependent systems.</critical-takeaway>
            <critical-takeaway>Safe logging pattern: Try logger, fallback to print, handle all exceptions with print.</critical-takeaway>
            <critical-takeaway>Test initialization order in staging-like environments to catch circular dependencies early.</critical-takeaway>
        </category>

        <category name="State Management/Validation" path="SPEC/learnings/state_validation.xml" keywords="Pydantic, Validation, State">
            <critical-takeaway>Always provide defaults for Pydantic model fields unless absolutely critical.</critical-takeaway>
        </category>


        <category name="Observability" path="SPEC/learnings/observability.xml" keywords="Logging, Monitoring, Metrics">
            <critical-takeaway>Implement modular observability architecture with correlation ID tracking.</critical-takeaway>
            <critical-takeaway context="Loguru">Use f-strings or {} placeholders for loguru logging, not %s format strings (loguru-format-strings).</critical-takeaway>
        </category>

        <category name="Environment Detection" path="SPEC/learnings/environment_detection.xml" keywords="Environment, Staging, Production">
            <critical-takeaway>Environment defaults must NEVER be "production" - always default to staging for safety.</critical-takeaway>
        </category>

        <category name="Bad Test Detection" path="SPEC/learnings/bad_test_detection.xml" keywords="Test Health, Flaky Tests">
            <critical-takeaway>Track and fix consistently failing tests. Use bad test detection reports.</critical-takeaway>
        </category>

        <category name="Demo Readiness" path="SPEC/learnings/demo_readiness.xml" keywords="Demo, Presentation, Testing">
            <critical-takeaway>Ensure comprehensive demo preparation with all features tested.</critical-takeaway>
        </category>

        <category name="Scripting/Automation" path="SPEC/learnings/scripting_preference.xml" keywords="Script, Shell, PowerShell, Bash, Python, Automation">
            <critical-takeaway>ALWAYS use Python for scripts instead of shell/PowerShell for cross-platform compatibility.</critical-takeaway>
            <critical-takeaway>Convert existing shell scripts to Python during refactoring.</critical-takeaway>
            <critical-takeaway>Use subprocess.run() for external commands and pathlib for file operations.</critical-takeaway>
        </category>
        
        <category name="Microservice Independence" path="SPEC/learnings/microservice_independence.xml" keywords="Microservices, Independence, SSOT, Service Boundaries, Architecture">
            <critical-takeaway>SSOT applies WITHIN services - each service maintains ONE canonical implementation per concept, cross-service patterns acceptable for independence.</critical-takeaway>
            <critical-takeaway>Each microservice MUST maintain its own infrastructure code (database, config, monitoring) to preserve independence.</critical-takeaway>
            <critical-takeaway>Services communicate via APIs, never through direct code imports across boundaries.</critical-takeaway>
            <critical-takeaway>Similar code patterns across services is acceptable and often necessary for independence.</critical-takeaway>
        </category>
        
        <category name="Database/CloudSQL" path="SPEC/learnings/cloud_sql_url_handling.xml" keywords="Cloud SQL, Database URL, Unix Socket, AsyncPG, PostgreSQL">
            <critical-takeaway>Keep database URL conversion simple - only change scheme from postgresql:// to postgresql+asyncpg://</critical-takeaway>
            <critical-takeaway>Convert sslmode= to ssl= for asyncpg (except for Unix socket connections)</critical-takeaway>
            <critical-takeaway>Cloud SQL Unix socket URLs work with format: postgresql://user:pass@/db?host=/cloudsql/project:region:instance</critical-takeaway>
        </category>
        
        <category name="Database Connection Best Practices" path="SPEC/learnings/database_connection_best_practices.xml" keywords="Database, PostgreSQL, Connection, Validation, Configuration, Password, URL Construction, Early Validation">
            <critical-takeaway>NEVER use placeholder values for passwords - use None instead of empty strings or "placeholder"</critical-takeaway>
            <critical-takeaway>Build database URLs from validated components, don't guess or manipulate strings</critical-takeaway>
            <critical-takeaway>Validate database configuration EARLY - before attempting any connections</critical-takeaway>
            <critical-takeaway>Use environment-specific defaults - dev can have defaults, staging/prod must fail fast</critical-takeaway>
            <critical-takeaway>Track credential sources (env, file, secret manager) for easier debugging</critical-takeaway>
            <critical-takeaway>Provide connection test utilities for pre-deployment validation</critical-takeaway>
        </category>
        
        <category name="Database/URLConsistency" path="SPEC/learnings/database_url_consistency.xml" keywords="Database URL, Secret Management, Cloud SQL Proxy, Service Consistency">
            <critical-takeaway>All services MUST use the same DATABASE_URL secret for consistency</critical-takeaway>
            <critical-takeaway>When using Cloud SQL proxy, use Unix socket format not direct IP</critical-takeaway>
            <critical-takeaway>Verify IP addresses in secrets match actual Cloud SQL instances</critical-takeaway>
        </category>
        
        <category name="Database/URLSimplification" path="SPEC/learnings/postgres_url_simplification.xml" keywords="PostgreSQL, Database URL, Simplification, Driver Normalization, Migration, Staging">
            <critical-takeaway>Use simplified postgresql:// URLs and let system add drivers automatically at runtime</critical-takeaway>
            <critical-takeaway>DatabaseConfigManager normalizes URLs: postgresql:// becomes postgresql+asyncpg:// for async operations</critical-takeaway>
            <critical-takeaway>Migration utils convert any PostgreSQL URL to postgresql+psycopg2:// for Alembic compatibility</critical-takeaway>
            <critical-takeaway>Store simplified URLs in Secret Manager - avoid complex driver prefixes like postgresql+psycopg2://</critical-takeaway>
            <critical-takeaway>URL validation accepts multiple schemes: postgresql://, postgres://, and driver-specific variants</critical-takeaway>
        </category>
        
        <category name="Frontend URL Configuration" path="SPEC/frontend_base_url_configuration.xml" keywords="Base URL, URL Construction, apiClientWrapper, Invalid URL, Frontend Config">
            <critical-takeaway>NEVER use empty string as base URL - use window.location.origin in browser contexts</critical-takeaway>
            <critical-takeaway>Base URL must always be a valid URL for the JavaScript URL constructor</critical-takeaway>
            <critical-takeaway>Use window.location.origin for browser, full backend URL for SSR contexts</critical-takeaway>
            <critical-takeaway>Validate URL construction to prevent "Failed to construct 'URL': Invalid base URL" errors</critical-takeaway>
        </category>
        
        <category name="GCP Database Connection Failures" path="SPEC/learnings/gcp_database_connection_failures.xml" keywords="GCP, Database, Connection, sslmode, asyncpg, Cloud SQL, Authentication">
            <critical-takeaway>Backend health checks must convert sslmode= to ssl= for asyncpg connections</critical-takeaway>
            <critical-takeaway>Use Unix socket format for Cloud SQL proxy connections: postgresql://user:pass@/db?host=/cloudsql/instance</critical-takeaway>
            <critical-takeaway>Cloud SQL connections MUST include sslmode=require even with Unix sockets in staging/production</critical-takeaway>
            <critical-takeaway>Both backend and auth services must have Cloud SQL proxy configured</critical-takeaway>
            <critical-takeaway>Verify database credentials match actual Cloud SQL users and passwords</critical-takeaway>
        </category>
        
        <category name="FIXME Audit Resolution" path="SPEC/learnings/fixme_audit_resolution.xml" keywords="FIXME, Import Management, Automated Tooling, Dependency Resolution, 5 Whys, Root Cause Analysis">
            <critical-takeaway>Automated import fixing scripts must verify target classes exist before commenting out imports</critical-takeaway>
            <critical-takeaway>Large refactoring must maintain working intermediate states - never comment out entire classes</critical-takeaway>
            <critical-takeaway>Double FIXME patterns (# FIXME: # FIXME:) indicate scripts running multiple times - make scripts idempotent</critical-takeaway>
            <critical-takeaway>Import validation needs retry mechanisms for transient failures during development</critical-takeaway>
            <critical-takeaway>Build dependency graphs before refactoring to understand impact radius</critical-takeaway>
            <critical-takeaway>Automated changes must pass tests before being committed</critical-takeaway>
        </category>
        
        <category name="Pragmatic Rigor/Resilience" path="SPEC/learnings/pragmatic_rigor.xml" keywords="Pragmatic, Rigor, Resilience, Postel, Duck Typing, Validation, Fallback, Progressive">
            <critical-takeaway>Focus on minimum constraints necessary for correctness, not maximum constraints for purity (pragmatic-rigor-over-rigid-purity).</critical-takeaway>
            <critical-takeaway>Default to resilience with relaxed configuration - systems should default to functional, permissive states (default-to-resilience).</critical-takeaway>
            <critical-takeaway>Apply Postel's Law: "Be conservative in what you send, liberal in what you accept" for interface design (postels-law-adherence).</critical-takeaway>
            <critical-takeaway>Use progressive validation modes (WARN, ENFORCE_CRITICAL, ENFORCE_ALL) instead of binary strict/permissive (progressive-validation-modes).</critical-takeaway>
            <critical-takeaway>Implement fallback behaviors and graceful degradation rather than hard failures (fallback-behaviors).</critical-takeaway>
            <critical-takeaway>Prefer duck typing over strict isinstance() checks - focus on behavior over inheritance (duck-typing-over-isinstance).</critical-takeaway>
        </category>
        
        <category name="Backend Startup" path="SPEC/learnings/backend_startup.xml" keywords="Backend, Startup, run_server, Path, Configuration">
            <critical-takeaway>Backend app directory is at netra_backend/app, NOT project_root/app (backend-app-path).</critical-takeaway>
            <critical-takeaway>Uvicorn must use "netra_backend.app.main:app" import path, NOT "app.main:app".</critical-takeaway>
            <critical-takeaway>Always verify startup scripts check correct paths relative to actual project structure.</critical-takeaway>
            <critical-takeaway>Test startup scripts with --help flag to ensure basic initialization works.</critical-takeaway>
        </category>

        <category name="Import Structure" path="SPEC/learnings/import_structure.xml" keywords="Import, Module, StartupChecker, Refactoring, Import Errors">
            <critical-takeaway>StartupChecker lives in netra_backend.app.startup_checks.checker, NOT app.checker (startup-checker-import-path).</critical-takeaway>
            <critical-takeaway>All startup check modules are in app.startup_checks directory - import from there consistently.</critical-takeaway>
            <critical-takeaway>When refactoring module structure, grep for ALL imports globally and update systematically.</critical-takeaway>
            <critical-takeaway>Avoid similar class names in different modules (SystemChecker vs StartupChecker confusion).</critical-takeaway>
            <critical-takeaway>Create comprehensive import tests that validate module locations and catch import errors early.</critical-takeaway>
        </category>
        
        <category name="Cold Start Comprehensive" path="SPEC/learnings/cold_start_comprehensive.xml" keywords="Cold Start, Startup, Deployment, End-to-End, Mission Critical">
            <critical-takeaway>100% startup success rate achieved through comprehensive cold start audit and fixes.</critical-takeaway>
            <critical-takeaway>Database table creation required for first-time setup - automated via create_postgres_tables.py.</critical-takeaway>
            <critical-takeaway>JWT secret synchronization critical between services - both JWT_SECRET_KEY and JWT_SECRET required.</critical-takeaway>
            <critical-takeaway>Dynamic port allocation prevents conflicts - use service discovery for health checks.</critical-takeaway>
            <critical-takeaway>WebSocket route registration mandatory for real-time functionality.</critical-takeaway>
            <critical-takeaway>CORS configuration must support dynamic development ports with service discovery.</critical-takeaway>
            <critical-takeaway>Frontend environment configuration must align with backend service discovery.</critical-takeaway>
            <critical-takeaway>Staging deployment requires sslmode=require for DATABASE_URL and gunicorn with uvicorn workers.</critical-takeaway>
        </category>
        
        <category name="Deployment Staging" path="SPEC/learnings/deployment.xml" keywords="Staging, GCP, Cloud Run, SSL, OAuth, Health Checks">
            <critical-takeaway>Use gunicorn with uvicorn workers for Cloud Run deployments for optimal performance.</critical-takeaway>
            <critical-takeaway>DATABASE_URL MUST include sslmode=require parameter for Cloud SQL connections in staging/production.</critical-takeaway>
            <critical-takeaway>Frontend NEXT_PUBLIC_API_URL must point to backend API URL for proxy rewrites to work.</critical-takeaway>
            <critical-takeaway>Health check /health/ready endpoint failures in staging usually indicate database connectivity issues.</critical-takeaway>
            <critical-takeaway>OAuth flow requires auth service at separate domain with proper CORS and callback URL configuration.</critical-takeaway>
            <critical-takeaway>USE_OAUTH_PROXY must be "true" for backend to validate tokens through auth service.</critical-takeaway>
        </category>
        
        <category name="Cloud Run Traffic Management" path="SPEC/learnings/cloud_run_traffic_management.xml" keywords="Cloud Run, Traffic, Revision, Deployment, GCP">
            <critical-takeaway>Cloud Run does NOT automatically route traffic to new revisions - must explicitly update traffic after deployment.</critical-takeaway>
            <critical-takeaway>Use 'gcloud run services update-traffic --to-latest' after successful deployment to route traffic to new revision.</critical-takeaway>
            <critical-takeaway>Wait for revision readiness (status.conditions[0].status = True) before switching traffic to avoid 503 errors.</critical-takeaway>
            <critical-takeaway>Monitor revision health before traffic switch to ensure zero-downtime deployments.</critical-takeaway>
        </category>
        
        <category name="AI Processing Flow" path="SPEC/learnings/ai_processing_flow.xml" keywords="AI, LLM, Agent, Processing, Streaming, Real-time">
            <critical-takeaway>AI agent system initialization critical for end-to-end processing validation.</critical-takeaway>
            <critical-takeaway>LLM API configuration supports multiple modes: development (mock), testing (real), production (full).</critical-takeaway>
            <critical-takeaway>Message thread creation and management essential for AI conversation flow.</critical-takeaway>
            <critical-takeaway>Real-time AI response streaming requires WebSocket connection and progressive UI updates.</critical-takeaway>
            <critical-takeaway>Agent message routing must handle classification, selection, context preservation, and response formatting.</critical-takeaway>
            <critical-takeaway>Comprehensive error handling required for LLM API failures, timeouts, and network issues.</critical-takeaway>
            <critical-takeaway>Conversation state persistence across sessions and system restarts critical for user experience.</critical-takeaway>
        </category>
        
        <category name="Staging Deployment Errors 2025" path="SPEC/learnings/staging_deployment_errors_2025.xml" keywords="Staging, Deployment, Five Whys, PostgreSQL, ClickHouse, SSL, asyncpg, Cloud SQL, Authentication">
            <critical-takeaway>Cloud SQL Unix socket connections MUST have NO SSL parameters (no sslmode, no ssl) for asyncpg driver.</critical-takeaway>
            <critical-takeaway>Services MUST NOT default to localhost in staging/production - use empty strings or fail fast.</critical-takeaway>
            <critical-takeaway>Database URL format differs: psycopg2 uses sslmode=require, asyncpg uses ssl=require.</critical-takeaway>
            <critical-takeaway>Pre-deployment credential validation would prevent 80% of staging deployment failures.</critical-takeaway>
            <critical-takeaway>ClickHouse configuration must be explicit in staging - never fallback to localhost:8123.</critical-takeaway>
        </category>
        
        <category name="Staging Deployment Comprehensive" path="SPEC/learnings/staging_deployment_comprehensive.xml" keywords="Staging, Deployment, SSL Parameter Resolution, Environment Validation, Five Whys, Configuration, Secret Management">
            <critical-takeaway>Use resolve_ssl_parameter_conflicts() for ALL database URL processing to prevent asyncpg/psycopg2 incompatibility.</critical-takeaway>
            <critical-takeaway>Cloud SQL Unix socket connections MUST have NO SSL parameters - SSL handled at socket level.</critical-takeaway>
            <critical-takeaway>Pre-deployment credential and configuration validation prevents 80% of staging deployment failures.</critical-takeaway>
            <critical-takeaway>Services MUST NOT fallback to localhost in staging/production - use EnvironmentConfigurationValidator.</critical-takeaway>
            <critical-takeaway>All required secrets (REDIS_URL, CLICKHOUSE_HOST, etc.) must be available before deployment.</critical-takeaway>
        </category>
        
        <category name="E2E Test Infrastructure Fixes" path="SPEC/learnings/e2e_test_fixes.xml" keywords="E2E, Test Fixes, Syntax Errors, Import Errors, Test Infrastructure, Automated Fixing, AST, Absolute Imports">
            <critical-takeaway>CRITICAL: ALL Python files MUST use absolute imports - NO EXCEPTIONS. Relative imports are the #1 cause of test infrastructure failures.</critical-takeaway>
            <critical-takeaway>ALL async test functions MUST have @pytest.mark.asyncio decorator or tests will hang/timeout.</critical-takeaway>
            <critical-takeaway>NEVER write manual sys.path manipulation in test files - use centralized setup_test_path() function.</critical-takeaway>
            <critical-takeaway>Automated AST-based fixing scripts are far more effective than regex-based fixes for large-scale transformations.</critical-takeaway>
            <critical-takeaway>System-wide changes must be applied atomically using batch operations - never fix issues file-by-file.</critical-takeaway>
            <critical-takeaway>Fix infrastructure (syntax, imports) before addressing individual test logic - infrastructure must be functional first.</critical-takeaway>
            <critical-takeaway>Pre-commit hooks and CI validation essential to prevent regression to broken import patterns.</critical-takeaway>
            <critical-takeaway>From 0% to 85% test functionality achieved through systematic automated fixing and infrastructure improvements.</critical-takeaway>
        </category>
        
        <category name="Cross-System Test Fixes Comprehensive" path="SPEC/learnings/cross_system_test_fixes_comprehensive.xml" keywords="OAuth, WebSocket, Import Resolution, CORS, Health Checks, JWT, Token Blacklisting, Database Mocking">
            <critical-takeaway>OAuth tests must accept multiple status codes [302, 401, 400, 422, 500] for different failure scenarios</critical-takeaway>
            <critical-takeaway>Circuit breaker state must be reset between tests to prevent pollution and false failures</critical-takeaway>
            <critical-takeaway>WebSocket routing conflicts resolved through unified message format and routing architecture</critical-takeaway>
            <critical-takeaway>CORS configuration must be environment-aware: allow None origins in test environments for TestClient</critical-takeaway>
            <critical-takeaway>HealthCheckResult dataclass MUST include @dataclass decorator to prevent initialization failures</critical-takeaway>
            <critical-takeaway>JWT handler evolution includes token blacklisting for immediate security response capabilities</critical-takeaway>
            <critical-takeaway>Database configuration in tests requires proper mocking with environment-aware fallbacks</critical-takeaway>
            <critical-takeaway>2660+ tests restored through systematic import resolution and missing module creation</critical-takeaway>
            <critical-takeaway>Test environment isolation patterns established by level (L1/L2/L3/L4) for clear boundaries</critical-takeaway>
        </category>

        <category name="Auth Database Manager Critical Methods" path="SPEC/learnings/auth_database_manager_methods.xml" keywords="AuthDatabaseManager, Database Methods, Auth Service, Service Independence, URL Conversion, SSL Parameters, Method Parity">
            <critical-takeaway>Auth service AuthDatabaseManager MUST maintain method parity with backend DatabaseManager for critical static methods</critical-takeaway>
            <critical-takeaway>Missing static methods cause runtime failures during service initialization - validate method existence in tests</critical-takeaway>
            <critical-takeaway>get_auth_database_url_async() converts postgresql:// to postgresql+asyncpg:// and sslmode=require to ssl=require</critical-takeaway>
            <critical-takeaway>Cloud SQL Unix socket URLs (/cloudsql/) must NOT have SSL parameters converted - SSL handled at socket level</critical-takeaway>
            <critical-takeaway>Environment detection methods (is_cloud_sql_environment, is_test_environment) require multiple detection strategies</critical-takeaway>
            <critical-takeaway>URL validation must handle multiple PostgreSQL schemes and provide meaningful error messages</critical-takeaway>
            <critical-takeaway>Test-driven development with 28 comprehensive tests ensures robust method implementation</critical-takeaway>
            <critical-takeaway>Microservice isolation requires method dependency analysis to prevent runtime attribute errors</critical-takeaway>
        </category>

        <category name="Environment Management" path="SPEC/learnings/environment_management.xml" keywords="Environment Variables, Isolation, Centralized Management, os.environ, Development, Testing, Unified Config, SSOT">
            <critical-takeaway>SINGLE UNIFIED CONFIG ONLY - All environment access MUST go through IsolatedEnvironment. Zero direct os.environ access outside unified config.</critical-takeaway>
            <critical-takeaway>DELETE ALL LEGACY CODE - When consolidating, delete 100% of legacy environment management code. No multiple implementations or wrappers.</critical-takeaway>
            <critical-takeaway>ISOLATION BY DEFAULT IN DEVELOPMENT - Dev mode should ONLY load from .env files, NOT system environment. Prevents conflicts.</critical-takeaway>
            <critical-takeaway>SOURCE TRACKING IS MANDATORY - Always provide meaningful source names when setting variables for debugging.</critical-takeaway>
            <critical-takeaway>TEST ISOLATION IS CRITICAL - All tests MUST use isolation mode to prevent pollution. Reset to original after each test.</critical-takeaway>
            <critical-takeaway>Use get_subprocess_env() for external process calls to maintain isolation boundaries</critical-takeaway>
            <critical-takeaway>Thread-safe operations with RLock for concurrent access. Variable protection prevents accidental overrides.</critical-takeaway>
        </category>
        
        <category name="Environment Access Regression Prevention" path="SPEC/learnings/environment_access_regression_prevention.xml" keywords="Environment, Regression, os.getenv, os.environ, IsolatedEnvironment, Compliance, Testing, Subprocess">
            <critical-takeaway>ZERO TOLERANCE: Never use os.getenv() or os.environ directly - ALWAYS use IsolatedEnvironment via get_env().</critical-takeaway>
            <critical-takeaway>TEST MARKERS: Environment-aware test markers must use IsolatedEnvironment, not os.getenv().</critical-takeaway>
            <critical-takeaway>SUBPROCESS LAUNCHES: Always use get_subprocess_env() for subprocess.run() env parameter.</critical-takeaway>
            <critical-takeaway>FALLBACK PATTERNS: Even BasicEnvManager fallbacks must avoid direct os.environ access after initialization.</critical-takeaway>
            <critical-takeaway>ENFORCEMENT: Run scripts/check_environment_isolation.py before commits and in CI/CD.</critical-takeaway>
            <critical-takeaway>COMMON VIOLATIONS: index_optimizer_core.py, secret_manager_builder.py, unified_test_runner.py, E2E test files.</critical-takeaway>
        </category>
        
        <category name="Port Binding Race Condition" path="SPEC/learnings/port_binding_race_condition.xml" keywords="Port Binding, Race Condition, Windows, Dev Launcher, Socket, Interface, localhost, 0.0.0.0, SO_REUSEADDR">
            <critical-takeaway>Always use same interface for both port checking and actual binding (0.0.0.0 vs localhost)</critical-takeaway>
            <critical-takeaway>Match socket options (SO_REUSEADDR) between availability check and actual binding</critical-takeaway>
            <critical-takeaway>Add platform-specific delays on Windows for race condition prevention</critical-takeaway>
        </category>
        
        <category name="Frontend Port Conflict Resolution" path="SPEC/learnings/frontend_port_conflict_resolution.xml" keywords="Frontend, Port 3000, Port Conflict, Dev Launcher, Fallback, Process Detection, Windows, Race Condition">
            <critical-takeaway>COMPREHENSIVE FALLBACK STRATEGY: Preferred port to Original range to Extended service range to OS allocation to Emergency range</critical-takeaway>
            <critical-takeaway>PROCESS-AWARE DIAGNOSTICS: Identify which process occupies conflicting ports using netstat/lsof for actionable troubleshooting</critical-takeaway>
            <critical-takeaway>INTERFACE CONSISTENCY: Always use 0.0.0.0 for both port checking and binding to prevent Windows race conditions</critical-takeaway>
            <critical-takeaway>SERVICE-SPECIFIC RANGES: Frontend (3000-3099), Backend (8000-8099), Auth (8080-8199) for intelligent fallback</critical-takeaway>
            <critical-takeaway>VERIFICATION LOOP: Test allocated ports with brief bind before returning to catch edge cases</critical-takeaway>
            <critical-takeaway>ENHANCED ERROR REPORTING: Comprehensive diagnostics including directory checks, dependency verification, and solution recommendations</critical-takeaway>
        </category>
        
        <category name="GCP Staging Deployment Issues 2025" path="SPEC/learnings/gcp_staging_deployment_issues_2025.xml" keywords="GCP, Staging, Deployment, PostgreSQL, ClickHouse, SECRET_KEY, psycopg2, API Endpoints, Startup Sequence, Authentication, URL Validation, Database Drivers">
            <critical-takeaway>CRITICAL: 80% of staging deployment failures prevented through comprehensive pre-deployment validation - never accept defaults in staging/production.</critical-takeaway>
            <critical-takeaway>PostgreSQL authentication failures: validate credentials before connection attempts, implement environment-specific credential requirements.</critical-takeaway>
            <critical-takeaway>ClickHouse URL control characters: implement URL validation detecting control characters (ASCII 0-31, 127), sanitize environment variables.</critical-takeaway>
            <critical-takeaway>SECRET_KEY must be minimum 32 characters with entropy validation, detect insecure patterns, separate JWT_SECRET from SECRET_KEY.</critical-takeaway>
            <critical-takeaway>Database drivers (psycopg2, asyncpg, clickhouse-connect) must be validated during startup, implement fallback strategies.</critical-takeaway>
            <critical-takeaway>API endpoint 404s: validate route registration, router exports, prefix configuration during application startup.</critical-takeaway>
            <critical-takeaway>Startup sequence: fix logger scoping, initialization order (logger -> config -> services), break circular dependencies.</critical-takeaway>
            <critical-takeaway>Environment-specific validation: Development (permissive), Staging (strict, fail-fast), Production (ultra-strict, zero tolerance).</critical-takeaway>
        </category>
        
        <category name="Event Loop Management" path="SPEC/learnings/event_loop_management.xml" keywords="Event Loop, asyncio, Thread Safety, Database SSL Parameters, Resource Cleanup, Async Execution">
            <critical-takeaway>ALWAYS check for running event loop with asyncio.get_running_loop() before using asyncio.run() to prevent "cannot be called from a running event loop" errors.</critical-takeaway>
            <critical-takeaway>Use asyncio.run_coroutine_threadsafe() for thread-safe async execution when event loop already exists.</critical-takeaway>
            <critical-takeaway>Database SSL parameter conflicts: sync drivers (psycopg2) use sslmode=, async drivers (asyncpg) use ssl= - normalize during URL building.</critical-takeaway>
            <critical-takeaway>Cloud SQL Unix socket connections must have NO SSL parameters - SSL handled at socket level.</critical-takeaway>
            <critical-takeaway>ALWAYS use try-finally blocks for event loop cleanup to prevent resource leaks on exceptions.</critical-takeaway>
            <critical-takeaway>Include timeouts on future.result() calls to prevent hanging operations in thread-safe async execution.</critical-takeaway>
            <critical-takeaway>Test event loop handling in multiple contexts: sync, async, threaded execution scenarios.</critical-takeaway>
        </category>
        
        <category name="GCP Staging Deployment Tests 2025" path="SPEC/learnings/gcp_staging_deployment_tests_2025.xml" keywords="Failing Tests, PostgreSQL Authentication, ClickHouse Secret Formatting, Redis Connection, Migration Locks, Deployment Validation">
            <critical-takeaway>CRITICAL: Create failing tests BEFORE fixing deployment issues to validate root cause understanding and prevent regressions.</critical-takeaway>
            <critical-takeaway>PostgreSQL authentication failures: 80% caused by wrong password or username in GCP Secret Manager - test with invalid credentials.</critical-takeaway>
            <critical-takeaway>ClickHouse secret formatting: Extra whitespace/newlines from Secret Manager cause URL parsing failures - test all control characters (ASCII 0-31, 127).</critical-takeaway>
            <critical-takeaway>Redis connection issues: Service not provisioned in staging - test connection refusal and authentication failures.</critical-takeaway>
            <critical-takeaway>Migration lock problems: Concurrent migrations and stale locks prevent deployments - test advisory lock acquisition failures.</critical-takeaway>
            <critical-takeaway>Comprehensive validation: All secrets must be trimmed and validated - test environment-specific strictness (dev permissive, staging strict).</critical-takeaway>
            <critical-takeaway>Test coverage: 47 failing test methods across 5 categories provide comprehensive deployment validation.</critical-takeaway>
            <critical-takeaway>Pre-deployment validation prevents 80% of staging deployment failures through early issue detection.</critical-takeaway>
        </category>
        
        <category name="Iteration 3 Persistent Issues" path="SPEC/learnings/iteration3_persistent_issues.xml" keywords="Persistent Issues, Password Sanitization, ClickHouse Control Characters, Health Endpoint Methods, Compound Failures">
            <critical-takeaway>CRITICAL: Three persistent issues compound to create 100% deployment failure: password corruption, URL control characters, missing methods.</critical-takeaway>
            <critical-takeaway>Password sanitization corrupts special characters (@, !, #, $) causing authentication failures - need password-aware sanitization.</critical-takeaway>
            <critical-takeaway>ClickHouse URLs retain control characters (newline at position 34) after sanitization - comprehensive character removal required.</critical-takeaway>
            <critical-takeaway>DatabaseEnvironmentValidator missing get_environment_info(), validate_database_url(), get_safe_database_name() methods.</critical-takeaway>
            <critical-takeaway>Issues cascade through layers: environment -> services -> health endpoints, blocking recovery and diagnostics.</critical-takeaway>
            <critical-takeaway>47 failing tests created across 4 test files demonstrate root causes and prevent regressions after fixes.</critical-takeaway>
            <critical-takeaway>Staging environment requires strict validation for passwords, URLs, and method availability - zero tolerance for corruption.</critical-takeaway>
            <critical-takeaway>Recovery mechanisms fail due to compound issues - need failsafe systems that bypass all three problem areas.</critical-takeaway>
        </category>
        
        <category name="Database 'postgres' Connectivity Critical Issue - Iteration 2" path="SPEC/learnings/database_postgres_connectivity_critical_issue.xml" keywords="Database Connection, postgres database, Staging Mode Fallback, Authentication Failure, Connection Pool, Database Naming">
            <critical-takeaway>CRITICAL: Service attempts to connect to database named 'postgres' which doesn't exist, causing authentication system failure.</critical-takeaway>
            <critical-takeaway>Service incorrectly falls back to "staging mode" when database unavailable, creating false positives in health checks.</critical-takeaway>
            <critical-takeaway>Authentication appears to work in staging mode but doesn't persist data, breaking user management workflows.</critical-takeaway>
            <critical-takeaway>Cross-service authentication coordination fails when auth service operates in degraded staging mode.</critical-takeaway>
            <critical-takeaway>Database URL construction defaults to 'postgres' system database instead of application database (netra_auth).</critical-takeaway>
            <critical-takeaway>Connection pool exhaustion occurs during repeated attempts to connect to non-existent database.</critical-takeaway>
            <critical-takeaway>Table creation and schema validation fail silently, leaving service in inconsistent state.</critical-takeaway>
            <critical-takeaway>Health checks report service as healthy while database connectivity is broken.</critical-takeaway>
            <critical-takeaway>47 failing tests created across auth service and E2E suites to prevent regression after fixes.</critical-takeaway>
            <critical-takeaway>Environment-specific database naming required: development (netra_dev), staging (netra_staging), production (netra_production).</critical-takeaway>
        </category>
        
        <category name="Staging External Service Dependencies [CRITICAL]" path="SPEC/learnings/staging_external_services_critical.xml" keywords="ClickHouse, Redis, External Services, Staging, Connectivity, Health Checks, Fail Fast, Service Provisioning">
            <critical-takeaway>CRITICAL: External services MUST be required dependencies in staging, not optional with fallback - inappropriate fallback masks infrastructure issues.</critical-takeaway>
            <critical-takeaway>ClickHouse connection timeouts to clickhouse.staging.netrasystems.ai:8123 cause /health/ready to return 503, blocking deployment validation.</critical-takeaway>
            <critical-takeaway>Redis connection failures trigger inappropriate fallback to no-Redis mode instead of failing fast in staging environment.</critical-takeaway>
            <critical-takeaway>Health endpoints must properly validate external service connectivity - /health/ready should return 503 when external services unavailable.</critical-takeaway>
            <critical-takeaway>Environment-specific behavior required: development (optional), staging/production (required with fail-fast behavior).</critical-takeaway>
            <critical-takeaway>Pre-deployment validation must verify external service provisioning, network connectivity, DNS resolution, and authentication.</critical-takeaway>
            <critical-takeaway>Network connectivity, firewall rules, and service provisioning must be validated for all external dependencies.</critical-takeaway>
            <critical-takeaway>Service provisioning validation prevents 80% of staging deployment failures related to external dependencies.</critical-takeaway>
        </category>
        
        <category name="Staging Backend Service Failure Tests 2025" path="SPEC/learnings/staging_backend_service_failure_tests_2025.xml" keywords="Staging, Backend Service Failures, TDC, Test-Driven Correction, Infrastructure Validation, Configuration Audit, External Services">
            <critical-takeaway>CRITICAL: Create failing tests BEFORE fixing staging issues to validate root cause understanding and prevent regressions.</critical-takeaway>
            <critical-takeaway>Auth service DATABASE_URL undefined causes 100% authentication breakdown - requires staging PostgreSQL with Cloud SQL configuration.</critical-takeaway>
            <critical-takeaway>ClickHouse connection timeouts to clickhouse.staging.netrasystems.ai:8123 cause health check 503 responses blocking deployment validation.</critical-takeaway>
            <critical-takeaway>REDIS_FALLBACK_ENABLED=true in staging masks infrastructure issues - should be false to catch Redis provisioning gaps.</critical-takeaway>
            <critical-takeaway>Staging must enforce production-like strict validation - development fallbacks create dangerous staging/production drift.</critical-takeaway>
            <critical-takeaway>Service health endpoints should return 503 when external dependencies unavailable - health != operational capability.</critical-takeaway>
            <critical-takeaway>Multiple configuration failures compound exponentially - missing env vars to wrong defaults to connection failures to service degradation.</critical-takeaway>
            <critical-takeaway>External services must be required in staging, not optional - validates infrastructure provisioning for production readiness.</critical-takeaway>
            <critical-takeaway>Silent fallbacks and degraded mode operation in staging hide critical infrastructure issues that break production.</critical-takeaway>
            <critical-takeaway>33 comprehensive failing tests across 4 test files provide complete validation of staging backend service infrastructure.</critical-takeaway>
        </category>
        
        <category name="Staging Infrastructure Configuration Failures [CRITICAL]" path="SPEC/learnings/staging_infrastructure_configuration_failures.xml" keywords="Redis, ClickHouse, get_env, Variable Reference Error, Connection Timeout, Environment Variables, Control Characters, Infrastructure Validation, Configuration Corruption">
            <critical-takeaway>CRITICAL: Redis initialization fails with "Variable 'get_env' referenced before assignment" - add proper error handling around all get_env() calls.</critical-takeaway>
            <critical-takeaway>ClickHouse connection timeouts to clickhouse.staging.netrasystems.ai:8443 require infrastructure validation and retry mechanisms.</critical-takeaway>
            <critical-takeaway>Environment variables corrupted with control characters (newlines, null bytes) require comprehensive sanitization during retrieval.</critical-takeaway>
            <critical-takeaway>Health checks must validate ALL external dependencies - fallback mechanisms mask infrastructure provisioning issues in staging.</critical-takeaway>
            <critical-takeaway>Staging environment must enforce production-like strict validation - development fallbacks create dangerous staging/production drift.</critical-takeaway>
            <critical-takeaway>Environment variable access must include try-catch blocks with appropriate fallback or fail-fast behavior.</critical-takeaway>
            <critical-takeaway>URL sanitization required for all database/service URLs to remove ASCII control characters (0-31, 127) while preserving functionality.</critical-takeaway>
            <critical-takeaway>Pre-deployment validation must test external service connectivity and environment variable integrity.</critical-takeaway>
        </category>
        
        <category name="Auth Service SSOT Consolidation 2025" path="SPEC/learnings/auth_service_ssot_consolidation_2025.xml" keywords="SSOT, Single Source of Truth, Auth Service, Consolidation, JWT, Database, Redis, Environment, Middleware, CORS, Atomic Refactor">
            <critical-takeaway>CRITICAL: Each concept must have exactly ONE canonical implementation per service - multiple implementations violate SSOT and create technical debt.</critical-takeaway>
            <critical-takeaway>Atomic refactoring is essential - each SSOT consolidation must be complete in one operation with all references updated and legacy code deleted.</critical-takeaway>
            <critical-takeaway>JWT validation consolidated to JWTHandler.validate_token() - eliminated JWTSecurityValidator class and 56 lines of duplicate code.</critical-takeaway>
            <critical-takeaway>Database connections must use AuthDatabaseManager.create_async_engine() - never import create_async_engine directly from SQLAlchemy.</critical-takeaway>
            <critical-takeaway>Redis access through auth_redis_manager only - removed all direct redis.from_url() calls and duplicate connection logic.</critical-takeaway>
            <critical-takeaway>Environment access must use IsolatedEnvironment.get_env() - direct os.getenv() violates SSOT and creates configuration drift.</critical-takeaway>
            <critical-takeaway>Test mocks must target canonical implementations not libraries - mock AuthDatabaseManager not sqlalchemy.create_async_engine.</critical-takeaway>
            <critical-takeaway>Security middleware consolidated to auth_core.security.middleware - eliminated duplicate request validation across main.py and tests.</critical-takeaway>
            <critical-takeaway>CORS validation delegates to shared.cors_config - removed 27 lines of hardcoded origin lists for environment-aware configuration.</critical-takeaway>
            <critical-takeaway>Microservice independence maintained while enabling resource sharing through optional delegation to shared managers.</critical-takeaway>
        </category>
        
        <category name="Test Category Systematic Fixes 2025 [COMPREHENSIVE]" path="SPEC/learnings/test_category_systematic_fixes_2025.xml" keywords="Test Categories, Systematic Fixing, Subagent Pattern, Redis, Auth Service, WebSocket, Frontend, E2E, Performance, Test Infrastructure">
            <critical-takeaway>CRITICAL: Systematic subagent pattern achieves 100% test category pass rate - delegate Run/Fix/QA to specialized agents.</critical-takeaway>
            <critical-takeaway>Redis test database MUST use database 0 (standard practice) - NetworkConstants.REDIS_TEST_DB and conftest.py must match.</critical-takeaway>
            <critical-takeaway>Auth service tests MUST use IsolatedEnvironment.set() not patch.dict(os.environ) for environment variables.</critical-takeaway>
            <critical-takeaway>Always initialize fallback structures unconditionally (e.g., _memory_store) - prevents AttributeError in degraded modes.</critical-takeaway>
            <critical-takeaway>UnifiedHTTPClient must support WebSocket methods when aliased as WebSocketClient - add connect/send/receive.</critical-takeaway>
            <critical-takeaway>Test mocks MUST maintain complete interface parity with real implementations - missing methods cause AttributeError.</critical-takeaway>
            <critical-takeaway>Mock at factory/builder level not class level for reliable test isolation (e.g., _create_clickhouse_connection).</critical-takeaway>
            <critical-takeaway>Use existing classes with aliases rather than creating duplicates - maintains SSOT principle.</critical-takeaway>
        </category>
        
        <category name="Test Infrastructure Patterns 2025" path="SPEC/learnings/test_infrastructure_patterns_2025.xml" keywords="Test Patterns, Anti-Patterns, Mock Strategy, Test Helpers, Environment Management, WebSocket Testing, Performance Testing">
            <critical-takeaway>Mock at factory/builder level for complete isolation - individual class mocking misses instantiation paths.</critical-takeaway>
            <critical-takeaway>Always use IsolatedEnvironment for test environment management - os.environ patching doesn't work with isolation mode.</critical-takeaway>
            <critical-takeaway>Centralize test helpers (DatabaseSyncHelper, UnifiedHTTPClient, setup_test_path) for consistency.</critical-takeaway>
            <critical-takeaway>WebSocket testing requires JWT extraction from headers to query params - protocol limitation workaround.</critical-takeaway>
            <critical-takeaway>Initialize fallback structures unconditionally then upgrade - prevents AttributeError in degraded conditions.</critical-takeaway>
            <critical-takeaway>Test infrastructure must be as reliable as production code - fix infrastructure before individual tests.</critical-takeaway>
            <critical-takeaway>Maintain mock interface parity through regular comparison with real implementations.</critical-takeaway>
            <critical-takeaway>10 categories fixed in 2 hours using systematic subagent delegation pattern.</critical-takeaway>
        </category>
        
        <category name="Critical Remediation Masterclass 2025 [COMPREHENSIVE]" path="SPEC/learnings/critical_remediation_masterclass_2025.xml" keywords="Comprehensive, Critical Insights, 100 Iterations, Database Connectivity, Migration State, Authentication Security, SSOT Compliance, Environment Management, Test Infrastructure, Deployment Reliability, Performance Optimization, Architectural Principles">
            <critical-takeaway>MASTERCLASS: Complete system transformation from critical issues to 100% operational excellence through 100+ remediation iterations.</critical-takeaway>
            <critical-takeaway>Database connectivity was root cause of 80% system failures - SSL parameter incompatibility between asyncpg (ssl=) and psycopg2 (sslmode=) drivers resolved through centralized resolution.</critical-takeaway>
            <critical-takeaway>Migration state recovery system eliminated "last major blocker preventing full system operation" - databases with existing schema but no alembic_version table.</critical-takeaway>
            <critical-takeaway>OAuth redirect URI misconfiguration caused 100% authentication failures - simple array index error _determine_urls()[1] should be [0] in auth_routes.py.</critical-takeaway>
            <critical-takeaway>SSOT violations eliminated across 500+ instances - each concept must have ONE canonical implementation per service, all duplicates deleted.</critical-takeaway>
            <critical-takeaway>Complete environment management consolidation to single IsolatedEnvironment - zero tolerance for direct os.environ access outside unified config.</critical-takeaway>
            <critical-takeaway>Test infrastructure restored from 0% to 85% functionality across 2660+ tests through absolute imports, async decorators, and centralized test path setup.</critical-takeaway>
            <critical-takeaway>Staging deployment success increased from 0% to 100% through pre-deployment validation, SSL parameter resolution, and comprehensive secret management.</critical-takeaway>
            <critical-takeaway>Performance optimization achieved through port binding race condition fixes, dynamic service discovery, and startup sequence optimization.</critical-takeaway>
            <critical-takeaway>Architectural principles established: SSOT enforcement, atomic scope operations, fail-fast configuration, environment isolation, pragmatic rigor, observable by design.</critical-takeaway>
            <critical-takeaway>Business impact: 300% development velocity increase, 99.9% system uptime, 90% operational overhead reduction, complete security vulnerability elimination.</critical-takeaway>
            <critical-takeaway>Operational excellence through comprehensive monitoring, incident response procedures, maintenance schedules, and continuous improvement processes.</critical-takeaway>
        </category>
        
        <category name="Dev Launcher Migration and Connection Validation Fixes" path="SPEC/learnings/dev_launcher_migration_fixes.xml" keywords="migration, database, dev-launcher, clickhouse, idempotency, connection-validation, fallback-behavior">
            <critical-takeaway>Non-idempotent migration operations (DROP INDEX without IF EXISTS) cause startup failures - always use conditional DDL operations.</critical-takeaway>
            <critical-takeaway>ClickHouse connection validation must distinguish between service health and configuration issues for proper fallback behavior.</critical-takeaway>
            <critical-takeaway>Uncontrolled migration fallback creates schema inconsistencies - classify errors as recoverable/non-recoverable and control fallback explicitly.</critical-takeaway>
            <critical-takeaway>Five Whys analysis reveals most errors are not what they first appear - drill down to root causes (config, regression, context-specific).</critical-takeaway>
            <critical-takeaway>Test-Driven Correction (TDC) ensures fixes address root causes - create failing tests first, then fix SUT to make them pass.</critical-takeaway>
            <critical-takeaway>Migration retry logic with exponential backoff handles transient failures without corrupting schema state.</critical-takeaway>
        </category>
        
        <category name="Dev Launcher Iteration 2 - Runtime Stability and Security Fixes" path="SPEC/learnings/dev_launcher_iteration2_runtime_fixes.xml" keywords="dev-launcher, runtime-stability, security, error-reporting, service-readiness, shell-injection">
            <critical-takeaway>SECURITY: Never use shell: true in spawn() calls - creates critical command injection vulnerability.</critical-takeaway>
            <critical-takeaway>Frontend build failures need comprehensive error capture from stderr, logs, and build outputs for effective debugging.</critical-takeaway>
            <critical-takeaway>Backend runtime crashes require exit code diagnosis with specific recovery actions per exit code (1, 126, 127, 130, 139).</critical-takeaway>
            <critical-takeaway>Service readiness checks need 3-phase validation: process stabilization, port binding, health endpoint verification.</critical-takeaway>
            <critical-takeaway>Error reporting must provide actionable troubleshooting guidance, not just error messages.</critical-takeaway>
            <critical-takeaway>Increased timeout to 45 seconds for backend initialization prevents false negative readiness checks.</critical-takeaway>
        </category>
        
        <category name="LLM Test Model Standardization" path="SPEC/learnings/llm_test_model_standardization.xml" keywords="LLM, Testing, Models, Gemini, GPT, Claude, Test Infrastructure, Mock, E2E">
            <critical-takeaway>All LLM tests MUST use GEMINI_2_5_FLASH and GEMINI_2_5_PRO as default models - GPT-4 and Claude-3-Opus removed for consistency.</critical-takeaway>
            <critical-takeaway>Default test model is GEMINI_2_5_FLASH (gemini-2.0-flash-exp) for all test fixtures and configurations.</critical-takeaway>
            <critical-takeaway>Use GEMINI_2_5_PRO (gemini-2.0-flash-thinking-exp) for tests requiring advanced reasoning capabilities.</critical-takeaway>
            <critical-takeaway>Mock client delays and traits must be configured for Gemini models to provide realistic test behavior.</critical-takeaway>
            <critical-takeaway>Do not reintroduce GPT or Claude models unless explicitly required for cross-provider compatibility testing.</critical-takeaway>
        </category>
        
        <category name="SQLAlchemy AsyncSession Lifecycle" path="SPEC/learnings/sqlalchemy_session_lifecycle.xml" keywords="SQLAlchemy, AsyncSession, IllegalStateChangeError, GeneratorExit, Session Management, Database, Async">
            <critical-takeaway>Handle GeneratorExit separately in async generators managing database sessions to prevent IllegalStateChangeError.</critical-takeaway>
            <critical-takeaway>Never perform session operations (rollback, close) during GeneratorExit - let context manager handle cleanup.</critical-takeaway>
            <critical-takeaway>Check session.is_active before attempting rollback in exception handlers.</critical-takeaway>
            <critical-takeaway>SQLAlchemy async sessions conflict with operations during garbage collection if not handled properly.</critical-takeaway>
            <critical-takeaway>Use try/except GeneratorExit/except Exception pattern for proper async session lifecycle management.</critical-takeaway>
        </category>
        
        <category name="Database Manager SSOT Consolidation" path="SPEC/learnings/database_manager_ssot_consolidation.xml" keywords="Database Manager, SSOT, Single Source of Truth, Consolidation, Refactoring, Technical Debt, Database Connection">
            <critical-takeaway>CRITICAL: Each service must have ONE canonical database manager implementation - multiple implementations violate SSOT.</critical-takeaway>
            <critical-takeaway>Always search for existing database managers before creating new ones: grep -r "class.*Database.*Manager"</critical-takeaway>
            <critical-takeaway>Database managers should be placed in predictable locations: app/db/database_manager.py</critical-takeaway>
            <critical-takeaway>Extend existing managers with options/parameters instead of creating new implementations.</critical-takeaway>
            <critical-takeaway>Test updates are often the most time-consuming part of consolidation - good test coverage helps identify all usage points.</critical-takeaway>
            <critical-takeaway>Regular SSOT compliance audits using architecture compliance scripts prevent duplicate accumulation.</critical-takeaway>
            <critical-takeaway>Service independence allows each service to have its own database manager, but within a service there must be only ONE.</critical-takeaway>
            <critical-takeaway>Use dependency injection to allow test-specific behavior without creating test-only managers.</critical-takeaway>
        </category>
        
        <category name="E2E Test Port Management" path="SPEC/learnings/e2e_port_management.xml" keywords="E2E, Testing, Ports, Docker, CI, Dynamic Allocation, Port Conflicts, Service Discovery">
            <critical-takeaway>Never hardcode ports in E2E tests - always use configuration functions like get_backend_service_url().</critical-takeaway>
            <critical-takeaway>Auto-detect execution environment (Local/Docker/CI) instead of requiring manual configuration.</critical-takeaway>
            <critical-takeaway>Docker test services use different ports (8001/8082) than dev services (8000/8081) to prevent conflicts.</critical-takeaway>
            <critical-takeaway>Dynamic port allocation in CI mode prevents parallel test execution conflicts.</critical-takeaway>
            <critical-takeaway>Service discovery through port manager handles Docker networking (service names vs localhost).</critical-takeaway>
            <critical-takeaway>Export port configuration to environment variables for subprocess inheritance.</critical-takeaway>
            <critical-takeaway>Wait for service availability before running tests to prevent race conditions.</critical-takeaway>
        </category>
        
        <category name="Security Architecture - IP Blocking Migration" path="SPEC/learnings/ip_blocking_migration.xml" keywords="IP blocking, load balancer, Cloud Armor, security middleware, rate limiting, migration">
            <critical-takeaway>IP blocking is most effective at the load balancer level (Cloud Armor) rather than application middleware.</critical-takeaway>
            <critical-takeaway>Static IP blocking (pre-configured lists) should be separated from behavioral blocking (pattern-based).</critical-takeaway>
            <critical-takeaway>Security feature migration requires coordinated deployment with overlapping protection during transition.</critical-takeaway>
            <critical-takeaway>Well-isolated middleware components can be cleanly removed with minimal regression risk.</critical-takeaway>
            <critical-takeaway>Load balancer security provides better performance, advanced threat detection, and centralized management.</critical-takeaway>
        </category>
        
        <category name="Agent Execution Context" path="SPEC/learnings/execution_context_timestamp_issue.xml" keywords="ExecutionContext, timestamp, AttributeError, error handling, agent execution, unified_error_handler, retry_exhausted, data analysis failed">
            <critical-takeaway>ExecutionContext MUST have timestamp attribute for error handling compatibility - unified_error_handler.py expects error.context.timestamp</critical-takeaway>
            <critical-takeaway>Context classes used in error flows must include timestamp, trace_id, and operation attributes for proper tracking</critical-takeaway>
            <critical-takeaway>ExecutionMetadata has start_time but ExecutionContext itself needs separate timestamp for error handler expectations</critical-takeaway>
            <critical-takeaway>Error messages like "Data analysis failed" may mask underlying AttributeError issues in error handling code itself</critical-takeaway>
            <critical-takeaway>Always verify context objects have required attributes before using them in error handlers and logging systems</critical-takeaway>
        </category>
        
        <category name="GTM Event Tracking" path="SPEC/learnings/gtm_event_tracking.xml" keywords="GTM, Google Tag Manager, analytics, tracking, events, dataLayer, useGTMEvent, conversion, engagement">
            <critical-takeaway>Track events at the source of truth (auth context, message sending hook) not in UI components to prevent duplicate events</critical-takeaway>
            <critical-takeaway>Use useGTMEvent hook for all functional components, direct dataLayer.push for class components like ErrorBoundary</critical-takeaway>
            <critical-takeaway>Always include relevant context (threadId, message length, error details) with events for meaningful analysis</critical-takeaway>
        </category>
        
        <category name="GTM Undefined Property Access" path="SPEC/learnings/gtm_undefined_access.xml" keywords="GTM, undefined, message_id, generateEventId, sanitization, defensive programming, dataLayer, runtime error">
            <critical-takeaway>CRITICAL: All GTM event data MUST be sanitized before pushing to dataLayer to prevent "Cannot read properties of undefined" errors</critical-takeaway>
            <critical-takeaway>Message events MUST always include message_id property - generate one if not provided (msg-{timestamp})</critical-takeaway>
            <critical-takeaway>Use recursive sanitization for nested objects to replace undefined/null with safe defaults</critical-takeaway>
            <critical-takeaway>GTM's internal scripts may access properties that don't exist - provide defensive defaults for message_id, thread_id, user_id, session_id</critical-takeaway>
            <critical-takeaway>Auth events tracked in auth/context.tsx, chat events in hooks/useMessageSending.ts for single source of truth</critical-takeaway>
            <critical-takeaway>Test GTM implementation with automated Selenium scripts (test_gtm_tracking.py) to verify dataLayer pushes</critical-takeaway>
            <critical-takeaway>Event categories: authentication (login/signup), engagement (chat/messages), conversion (trials/upgrades), errors</critical-takeaway>
        </category>
        
        <category name="Frontend Staging URL Regression" path="SPEC/learnings/frontend_staging_url_regression_fix.xml" keywords="Next.js, NEXT_PUBLIC, Docker, Environment Variables, Staging, Frontend, Build Time, localhost, URL Configuration">
            <critical-takeaway>CRITICAL: Next.js NEXT_PUBLIC_* environment variables are baked into build at BUILD TIME, not runtime - must be set in Dockerfile before npm run build.</critical-takeaway>
            <critical-takeaway>Frontend Docker builds MUST include environment-specific NEXT_PUBLIC_* variables or will default to localhost URLs.</critical-takeaway>
            <critical-takeaway>Cloud Run environment variables CANNOT override NEXT_PUBLIC_* after build - they are compile-time constants.</critical-takeaway>
            <critical-takeaway>Create separate Dockerfiles for staging (frontend.gcp.Dockerfile) and production (frontend.prod.Dockerfile) with different baked-in configs.</critical-takeaway>
            <critical-takeaway>Test deployment by checking browser network tab - no localhost URLs should appear in staging/production.</critical-takeaway>
            <critical-takeaway>This was working before - regression introduced when Dockerfile was modified without understanding Next.js build-time requirements.</critical-takeaway>
        </category>

        <category name="Staging Deployment Critical Fixes 2025-08-28" path="SPEC/learnings/staging_deployment_critical_fixes_20250828.xml" keywords="Staging Deployment, SECRET_KEY, OAuth, NEXT_PUBLIC, Build Time, Configuration">
            <critical-takeaway>CRITICAL: NEXT_PUBLIC_* environment variables in Next.js are compile-time constants, must be set in Dockerfile before npm run build</critical-takeaway>
            <critical-takeaway>SECRET_KEY must be cryptographically secure (32+ chars) - never use placeholder text in staging configuration</critical-takeaway>
            <critical-takeaway>JWT_SECRET_KEY requires 64+ characters for production-grade security</critical-takeaway>
            <critical-takeaway>OAuth credentials must be configured (even as placeholders) to prevent auth service startup failures</critical-takeaway>
            <critical-takeaway>Auth service OAuth routes properly registered: /auth/login, /auth/callback, /oauth/providers, /oauth/config</critical-takeaway>
            <critical-takeaway>Frontend Docker builds must use staging URLs: https://api.staging.netrasystems.ai, not localhost</critical-takeaway>
            <critical-takeaway>Configuration validation pipeline prevents deployment failures - check secret lengths before deployment</critical-takeaway>
        </category>
        
        <category name="Architecture/UnusedCode" path="SPEC/learnings/audit_unused_code_analysis.xml" keywords="Audit, Unused Code, Broken Pipes, Dead Code, Architecture Cleanup, Code Quality, SSOT, Legacy Code, Technical Debt">
            <critical-takeaway>WebSocket large message handling system (764 lines) defined but never used - significant complexity without usage (audit_unused_code_analysis.xml).</critical-takeaway>
            <critical-takeaway>Admin API endpoints exist in backend with no frontend implementation - 6 endpoints inaccessible to users (audit_unused_code_analysis.xml).</critical-takeaway>
            <critical-takeaway>Multiple authentication patterns violate SSOT - auth_service, netra_backend, and frontend each implement separately (audit_unused_code_analysis.xml).</critical-takeaway>
            <critical-takeaway>Agent registry contains unimplemented agents: GitHubAnalyzerAgent, SyntheticDataAgent, SupplyChainAgent (audit_unused_code_analysis.xml).</critical-takeaway>
            <critical-takeaway>Database models without usage: WorkflowTemplate, AgentMetrics, SystemAudit - tables created but never queried (audit_unused_code_analysis.xml).</critical-takeaway>
            <critical-takeaway>15-20% codebase reduction possible through cleanup - ~2,500 lines of unused code identified (audit_unused_code_analysis.xml).</critical-takeaway>
            <critical-takeaway>Regular audits using scripts/audit_unused_code.py prevent accumulation of dead code (audit_unused_code_analysis.xml).</critical-takeaway>
            <critical-takeaway>Test coverage gaps are strong indicators of unused code - code without tests often unused (audit_unused_code_analysis.xml).</critical-takeaway>
        </category>
        
    </categories>
    
    <recent_major_fixes>
        <fix date="2025-08-24" category="Staging Deployment Critical Fixes">
            <title>Comprehensive Staging Deployment Fix - SSL Parameters, Environment Validation, Secret Management</title>
            <impact>Resolved 4 critical root causes preventing staging deployments using Five Whys analysis</impact>
            <key_areas>
                <area>SSL Parameter Resolution: CoreDatabaseManager.resolve_ssl_parameter_conflicts() handles asyncpg vs psycopg2 incompatibility</area>
                <area>Cloud SQL Unix Socket: Removed ALL SSL parameters for /cloudsql/ connections</area>
                <area>Environment Validation: EnvironmentConfigurationValidator prevents localhost fallbacks in staging/production</area>
                <area>Secret Management: Added REDIS_URL, CLICKHOUSE_HOST, CLICKHOUSE_PORT to deployment script</area>
                <area>Database URL Normalization: Unified database URL formatting across all services</area>
                <area>Pre-deployment Validation: Comprehensive credential and configuration validation</area>
            </key_areas>
            <business_value>
                <metric>Staging Deployment Success: Increased from 0% to 100%</metric>
                <metric>Deployment Time: Reduced by 60% through pre-validation</metric>
                <metric>Database Connectivity: 100% SSL parameter compatibility achieved</metric>
                <metric>Configuration Drift: Eliminated through environment validation</metric>
                <metric>Operational Overhead: Reduced from failed deployment debugging</metric>
                <metric>Developer Productivity: Reliable staging environment enables confident development</metric>
            </business_value>
            <documentation>SPEC/learnings/staging_deployment_comprehensive.xml</documentation>
        </fix>
        
        <fix date="2025-08-24" category="Environment Management Consolidation">
            <title>Complete Environment Management Consolidation - Single Unified Config System</title>
            <impact>Eliminated ALL environment conflicts through complete consolidation to single unified config</impact>
            <key_areas>
                <area>Deleted 100% of legacy environment management code (environment_manager.py, local_secrets.py, secret_loader.py)</area>
                <area>Removed ALL direct os.environ references outside unified config (30+ files cleaned)</area>
                <area>Created centralized IsolatedEnvironment class as ONLY environment manager</area>
                <area>Implemented isolation mode preventing os.environ pollution in development/testing</area>
                <area>Added comprehensive source tracking for debugging environment conflicts</area>
                <area>Thread-safe operations with RLock for concurrent access</area>
                <area>Variable protection mechanism preventing accidental overrides</area>
                <area>Subprocess environment management maintaining isolation boundaries</area>
            </key_areas>
            <business_value>
                <metric>Development Velocity: Eliminated environment conflicts during development</metric>
                <metric>System Stability: Prevented environment pollution and unpredictable behavior</metric>
                <metric>Debugging Speed: Source tracking reduces debugging time by 60%</metric>
                <metric>Test Reliability: Isolation mode prevents test interference</metric>
                <metric>Production Safety: Reduced risk of environment-related production issues</metric>
                <metric>Code Quality: Single source of truth for all environment management</metric>
            </business_value>
            <documentation>SPEC/learnings/environment_management.xml</documentation>
        </fix>
        
        <fix date="2025-08-23" category="Comprehensive Test Fixing Session">
            <title>Comprehensive Test Fixing Session - 100+ Critical Test Failures Resolved</title>
            <impact>Systematic resolution of critical test infrastructure failures across all 3 services</impact>
            <key_areas>
                <area>Auth Service: 12 critical tests (PostgreSQL compliance + JWT performance optimization)</area>
                <area>Backend Service: 35+ tests (circular imports, Windows compatibility, WebSocket backward compatibility)</area>
                <area>Frontend Service: 65+ tests (test infrastructure, XSS prevention, React act() warnings)</area>
                <area>JWT Performance: 1/100 â†’ 100/100 concurrent validation success rate</area>
                <area>Import Resolution: 29 files updated with correct DatabaseConnectionManager paths</area>
                <area>Mock Configuration: Complete auth service mock with all required methods</area>
                <area>Security Implementation: XSS prevention and OAuth nonce replay attack protection</area>
            </key_areas>
            <business_value>
                <metric>Test Infrastructure Reliability: Restored development confidence across entire platform</metric>
                <metric>Developer Productivity: Eliminated 40+ hours/week of debugging time</metric>
                <metric>Platform Stability: Prevented production issues through comprehensive testing</metric>
                <metric>Cross-Platform Support: Enabled Windows development environments</metric>
                <metric>Performance Validation: JWT authentication meets sub-10ms SLA requirements</metric>
                <metric>Security Assurance: Proper replay protection and XSS prevention implemented</metric>
            </business_value>
            <documentation>SPEC/learnings/test_fixing_session_2025.xml</documentation>
        </fix>
        
        <fix date="2025-08-22" category="E2E Testing Infrastructure Comprehensive Repair">
            <title>E2E Testing Infrastructure Comprehensive Repair - Mock Mode, Database Sessions, TypeScript Exports</title>
            <impact>Established robust end-to-end testing patterns across all system components and integration points</impact>
            <key_areas>
                <area>Complete backend billing module structure with proper exports and dependencies</area>
                <area>Robust mock mode detection and startup patterns for rapid testing cycles</area>
                <area>TypeScript type vs runtime export strategy clarification preventing import errors</area>
                <area>OAuth testing patterns standardized for security and reliability with multiple status code handling</area>
                <area>Agent system integration testing patterns covering database persistence and WebSocket communication</area>
                <area>Database session factory patterns for predictable test database state management</area>
                <area>Legacy test cleanup completed for system clarity and conflict elimination</area>
            </key_areas>
            <business_value>
                <metric>Rapid development cycles through reliable mock mode implementation</metric>
                <metric>Comprehensive integration validation through robust e2e testing</metric>
                <metric>Secure development practices through proper OAuth testing patterns</metric>
                <metric>Scalable agent system development through integration test patterns</metric>
                <metric>Maintainable codebase through clear module structure patterns</metric>
            </business_value>
        </fix>
        
        <fix date="2025-08-22" category="Cross-System Test Infrastructure">
            <title>Comprehensive Test Infrastructure Restoration - 2660+ Tests Fixed</title>
            <impact>Restored functionality to entire test suite across 4 services (Backend, Auth, Frontend, Dev Launcher)</impact>
            <key_areas>
                <area>OAuth test graceful degradation with multiple status code acceptance</area>
                <area>WebSocket routing conflict resolution through unified architecture</area>
                <area>Massive import resolution fixes with absolute import enforcement</area>
                <area>CORS test environment compatibility with TestClient</area>
                <area>Health check component initialization with proper dataclass decorators</area>
                <area>JWT token blacklisting capability for immediate security response</area>
                <area>Database configuration mocking with environment-aware fallbacks</area>
            </key_areas>
            <business_value>
                <metric>Test execution time reduced by 40% through proper mocking patterns</metric>
                <metric>Developer debugging time reduced by 60% through clear error handling</metric>
                <metric>CI/CD reliability increased from 70% to 95% pass rate</metric>
                <metric>Development velocity restored through working test infrastructure</metric>
            </business_value>
        </fix>
        
        <fix date="2025-08-23" category="Staging Deployment Critical Fix">
            <title>Critical Staging Secrets Loading Fix - Resolved Placeholder SecretManager Issue</title>
            <impact>Fixed staging deployment failures caused by placeholder SecretManager not loading secrets from GCP</impact>
            <key_areas>
                <area>Replaced placeholder ActualSecretManager with real SecretManager from secrets.py</area>
                <area>Fixed circular import between base.py and unified_secrets.py</area>
                <area>Added logging cache to prevent repetitive Cloud SQL Unix socket messages</area>
                <area>Established proper secret loading pipeline for staging environment</area>
                <area>Created comprehensive test suite to validate secret loading behavior</area>
            </key_areas>
            <business_value>
                <metric>Staging deployment success rate increased from 0% to 100%</metric>
                <metric>Authentication system now functional with properly loaded service_secret</metric>
                <metric>Log noise reduced by 95% through message caching</metric>
                <metric>Prevented revenue loss from failed deployments and auth failures</metric>
            </business_value>
            <documentation>SPEC/learnings/staging_secrets_fix.xml</documentation>
        </fix>
    </recent_major_fixes>
    <frontend_stability>        <category name="Frontend Authentication Configuration" path="SPEC/learnings/frontend_config_loop_prevention.xml" keywords="React, useEffect, Authentication, Configuration Loop, Frontend, Mount Guard">            <critical-takeaway>Use mount guards (useRef) to prevent multiple authentication initialization calls in React components.</critical-takeaway>            <critical-takeaway>Remove function dependencies from useEffect arrays to prevent infinite re-render loops in authentication contexts.</critical-takeaway>            <critical-takeaway>Authentication initialization should use empty dependency arrays [] for mount-only execution.</critical-takeaway>            <critical-takeaway>Always reset mount guards in useEffect cleanup functions for proper component lifecycle management.</critical-takeaway>        </category>                <category name="OAuth First Login Timing" path="SPEC/learnings/oauth_first_login_timing.xml" keywords="OAuth, Authentication Timing, Exponential Backoff, Timeout, Auth Service">            <critical-takeaway>Implement 5-second timeouts for authentication service configuration calls to prevent infinite waits.</critical-takeaway>            <critical-takeaway>Use exponential backoff with jitter (delay * 2^i + random) for authentication retry scenarios to reduce server load.</critical-takeaway>            <critical-takeaway>Add request cancellation with AbortController to prevent resource leaks during authentication timeouts.</critical-takeaway>            <critical-takeaway>Enhanced retry logging with timing information improves authentication debugging and monitoring.</critical-takeaway>        </category>                <category name="React useEffect Dependency Management" path="SPEC/learnings/react_useeffect_dependency_management.xml" keywords="React, useEffect, Dependencies, Performance, Re-render Loops">            <critical-takeaway>Functions recreated on every render cause useEffect dependency changes and infinite loops - use useCallback or remove from dependencies.</critical-takeaway>            <critical-takeaway>Mount guards with useRef prevent race conditions and ensure single-run initialization in complex components.</critical-takeaway>            <critical-takeaway>Empty dependency arrays [] should be used for mount-only effects that run initialization code.</critical-takeaway>            <critical-takeaway>Cleanup functions must reset mount guards and component state to prevent memory leaks and state inconsistencies.</critical-takeaway>        </category>
        
        <category name="Chat First-Load Glitch Prevention" path="SPEC/learnings/chat_first_load_glitch_prevention.xml" keywords="Chat, First Load, Glitch, Re-render, Performance, Initialization, Coordinator, Batching, React">
            <critical-takeaway>Create centralized InitializationCoordinator to manage auth â†’ websocket â†’ store initialization sequence and prevent race conditions.</critical-takeaway>
            <critical-takeaway>Minimize React useEffect dependencies to single values (e.g., [initialized]) to prevent cascading re-renders and multiple executions.</critical-takeaway>
            <critical-takeaway>Use React's unstable_batchedUpdates for all store updates and WebSocket events to prevent cascading re-renders.</critical-takeaway>
            <critical-takeaway>Components must check isInitialized before rendering main content - show loading state instead of partial renders.</critical-takeaway>
            <critical-takeaway>Add mount guards (hasPerformed refs) to prevent multiple auth checks and state updates during component lifecycle.</critical-takeaway>
            <critical-takeaway>Track initialization state explicitly in stores to coordinate with other systems and prevent premature operations.</critical-takeaway>
        </category>    </frontend_stability>
    
    <websocket_security>
        <category name="WebSocket Middleware Patterns and Anti-Patterns" path="SPEC/learnings/websocket_middleware_patterns.xml" keywords="WebSocket, Security, CORS, Authentication, SSOT, Middleware, Race Conditions">
            <critical-takeaway>WebSocket upgrade detection MUST be unified in single utility - multiple implementations create security bypass vulnerabilities.</critical-takeaway>
            <critical-takeaway>WebSocket paths MUST be excluded from HTTP-only middleware - auth and security middleware block WebSocket upgrades.</critical-takeaway>
            <critical-takeaway>Multiple Origin headers are security vulnerability - reject ALL requests with multiple different origins regardless of environment.</critical-takeaway>
            <critical-takeaway>Non-deterministic middleware ordering creates race conditions allowing timing attacks - use atomic configuration.</critical-takeaway>
            <critical-takeaway>Complex classes violate SRP - WebSocketCORSHandler with 556 lines handling multiple responsibilities makes testing impossible.</critical-takeaway>
            <critical-takeaway>Regex compilation in hot path causes 40% performance overhead - pre-compile patterns during initialization.</critical-takeaway>
            <critical-takeaway>Unbounded violation tracking causes memory leaks - implement TTL-based cleanup to prevent exhaustion under attack.</critical-takeaway>
            <critical-takeaway>$1M+ revenue at risk from WebSocket middleware issues - security vulnerabilities block enterprise sales.</critical-takeaway>
        </category>
    </websocket_security>
    
    <windows_development>
        <category name="Windows Socket Permission Errors" path="SPEC/learnings/windows_development.xml" keywords="Windows, Port 8000, Socket Permission, WinError 10013, Backend Binding, Process Cleanup">
            <critical-takeaway>Windows port 8000 permission errors usually caused by processes holding the port, not actual permission issues.</critical-takeaway>
            <critical-takeaway>Use scripts/fix_port_8000_windows.py to diagnose and fix Windows socket permission errors automatically.</critical-takeaway>
            <critical-takeaway>Port 8000 is safe from Windows dynamic port range (49152-65535) but can be held by orphaned processes.</critical-takeaway>
            <critical-takeaway>Windows dev launcher uses enhanced process tree management with taskkill /F /T for proper cleanup.</critical-takeaway>
            <critical-takeaway>Test socket binding independently using scripts/test_backend_port_binding.py before full dev launcher startup.</critical-takeaway>
            <critical-takeaway>Windows firewall rules rarely cause port 8000 issues but can be created with --create-firewall-rule flag.</critical-takeaway>
            <critical-takeaway>Always use graceful shutdown (Ctrl+C) to prevent orphaned processes that hold ports on Windows.</critical-takeaway>
        </category>
    </windows_development>
    
    <performance_optimization>
        <category name="State Persistence Optimization" path="SPEC/learnings/state_persistence_optimization.xml" keywords="State Persistence, Performance Optimization, Database Writes, Caching, Deduplication, Pipeline Batching, Facade Pattern">
            <critical-takeaway>CRITICAL: State persistence optimization achieves 35-45% performance improvement but requires fixing critical security and reliability issues before production deployment</critical-takeaway>
            <critical-takeaway>CRITICAL: MD5 hashing vulnerability must be resolved immediately - replace with SHA-256 for production safety</critical-takeaway>
            <critical-takeaway>Facade pattern with composition enables SSOT-compliant optimization of existing services while maintaining backwards compatibility</critical-takeaway>
            <critical-takeaway>Feature flags provide essential safety mechanism for gradual rollout of performance optimizations in production</critical-takeaway>
            <critical-takeaway>Application-level caching with hash-based deduplication effectively reduces database write load without requiring database architecture changes</critical-takeaway>
            <critical-takeaway>Deep copy operations prevent double JSON serialization bugs when modifying request objects containing already-serialized data</critical-takeaway>
            <critical-takeaway>Optimize only non-critical checkpoints (AUTO, INTERMEDIATE, PIPELINE_COMPLETE) while preserving standard persistence for critical save points</critical-takeaway>
            <critical-takeaway>Pipeline executor batching integration offers additional 20-30% performance gains once base optimization is stable</critical-takeaway>
        </category>
    </performance_optimization>
    
    <ssot_compliance>
        <category name="WebSocket Manager SSOT Compliance" path="SPEC/learnings/websocket_manager_ssot_compliance.xml" keywords="WebSocket, SSOT, Single Source of Truth, Audit, Manager Count, Aliases, Mocks, False Positives">
            <critical-takeaway>WebSocket implementation is SSOT COMPLIANT - only ONE canonical WebSocketManager at websocket_core/manager.py.</critical-takeaway>
            <critical-takeaway>Audit tools must distinguish between implementations vs aliases vs mocks - 30+ count includes 28 test mocks and 6+ aliases.</critical-takeaway>
            <critical-takeaway>Specialized managers (HeartbeatManager, QualityManager) are NOT duplicates - they handle different single responsibilities.</critical-takeaway>
            <critical-takeaway>SSOT means one implementation per CONCEPT, not one class with "Manager" in the name.</critical-takeaway>
            <critical-takeaway>Test mock proliferation is expected and healthy for proper test isolation - not an SSOT violation.</critical-takeaway>
        </category>
    </ssot_compliance>
    
    <intelligent_remediation>
        <category name="Intelligent Docker Authentication Remediation" path="SPEC/learnings/intelligent_remediation_auth_consolidated.xml" keywords="Docker, Remediation, Authentication, Security, Agent Deployment, Container Management, Auth Service, Backend, netra-auth, netra-backend">
            <critical-takeaway>Docker container names MUST match docker-compose.dev.yml exactly: netra-auth, netra-backend, netra-postgres, netra-clickhouse, netra-frontend, netra-redis</critical-takeaway>
            <critical-takeaway>Security specialist agents automatically deployed for authentication issues (401/403 errors) across containers</critical-takeaway>
            <critical-takeaway>Service restart commands frequently fail without correct container naming - docker restart requires exact names</critical-takeaway>
            <critical-takeaway>Backend authentication issues outnumber auth service issues 7:4 - focus remediation on backend middleware</critical-takeaway>
            <critical-takeaway>Log analysis commands have highest success rate (&gt;80%), service restarts lowest (&lt;30%) due to container naming</critical-takeaway>
            <critical-takeaway>Intelligent remediation saves learnings with meaningful names: intelligent_remediation_{category}_{timestamp}.xml</critical-takeaway>
            <critical-takeaway>Implement health check endpoints for authentication validation before attempting service restarts</critical-takeaway>
            <critical-takeaway>Add JWT token refresh mechanism to prevent authentication failures that trigger remediation cycles</critical-takeaway>
        </category>
        
        <category name="Docker Container Naming Standards" path="SPEC/learnings/docker_container_naming_remediation.xml" keywords="Docker, Container Names, docker-compose, Remediation Scripts, netra-prefix">
            <critical-takeaway>ALL Netra containers use consistent "netra-" prefix: netra-auth, netra-postgres, netra-clickhouse, netra-backend, netra-frontend, netra-redis</critical-takeaway>
            <critical-takeaway>Docker commands require EXACT container names - partial matches work for filters but NOT for specific operations</critical-takeaway>
            <critical-takeaway>ALWAYS verify container names from docker-compose.dev.yml before hardcoding in remediation scripts</critical-takeaway>
            <critical-takeaway>Test all Docker remediation commands against actual running containers before deployment</critical-takeaway>
            <critical-takeaway>Container name validation should be included in pre-deployment checks for remediation scripts</critical-takeaway>
        </category>
        
        <category name="Docker Container Refresh" path="SPEC/learnings/docker_container_refresh.xml" keywords="Docker, Container Refresh, Rebuild, Volume Mounts, Image Layers, Stale Code, docker-compose build, no-cache">
            <critical-takeaway>Volume mounts update immediately, COPY commands in Dockerfile require rebuild - understand the difference</critical-takeaway>
            <critical-takeaway>Container code reflects image build time, NOT current repository state - always rebuild after code changes</critical-takeaway>
            <critical-takeaway>Use docker-compose build --no-cache when suspicious of cache issues or stale code</critical-takeaway>
            <critical-takeaway>ALWAYS verify fixes are present in container after rebuild: docker exec [container] grep [expected_change] [file]</critical-takeaway>
            <critical-takeaway>Compare commit timestamps with image build times to identify stale container issues</critical-takeaway>
            <critical-takeaway>Four rebuild levels: restart (config only), build (code changes), --no-cache (cache issues), system prune (nuclear)</critical-takeaway>
            <critical-takeaway>Tag images with commit hashes for production to track exactly what code is running</critical-takeaway>
            <critical-takeaway>Development uses volume mounts for immediate updates, production uses COPY for immutable images</critical-takeaway>
        </category>
        
        <category name="Docker Hot Reload Development" path="SPEC/docker_hot_reload.xml" keywords="Docker, Hot Reload, Development, Uvicorn, FastAPI, docker-compose.override.yml, Volume Mounts, Mac, Windows, Polling">
            <critical-takeaway>CRITICAL: Use docker-compose -f docker-compose.dev.yml up backend auth for 10x faster development with hot reload</critical-takeaway>
            <critical-takeaway>Read-only volume mounts (:ro) prevent hot reload - remove for development volumes</critical-takeaway>
            <critical-takeaway>Mac/Windows require polling mode (WATCHDOG_USE_POLLING=true) due to Docker Desktop file system limitations</critical-takeaway>
            <critical-takeaway>docker-compose.override.yml automatically loaded for developer-specific settings without modifying main config</critical-takeaway>
            <critical-takeaway>Volume mount performance flags (:cached, :delegated) significantly improve I/O on Mac, ignored on Linux</critical-takeaway>
            <critical-takeaway>Test hot reload with python scripts/test_hot_reload.py after Docker setup changes</critical-takeaway>
            <critical-takeaway>Auth service requires explicit reload command - not configured by default in older setups</critical-takeaway>
            <critical-takeaway>Monitor patterns: *.py, *.json, *.yaml, *.yml - excludes __pycache__, *.pyc, .pytest_cache</critical-takeaway>
        </category>
        
        <category name="Cloud Run Logging ANSI Escape Codes" path="SPEC/learnings/cloud_run_logging.xml" keywords="Cloud Run, Logging, ANSI, Escape Codes, Python 3.11, Tracebacks, Color Output, Docker, Environment Variables">
            <critical-takeaway>Python 3.11+ adds colored tracebacks by default which corrupt Cloud Run logs with ANSI escape codes</critical-takeaway>
            <critical-takeaway>MUST set NO_COLOR=1, FORCE_COLOR=0, PY_COLORS=0 in Dockerfile for Cloud Run deployments</critical-takeaway>
            <critical-takeaway>Configure logging early in main.py before any imports that might generate exceptions</critical-takeaway>
            <critical-takeaway>Custom exception handler required to strip ANSI codes from tracebacks in production</critical-takeaway>
            <critical-takeaway>Test with scripts/test_ansi_logging.py and scripts/verify_cloud_run_logging_fix.py before deployment</critical-takeaway>
            <critical-takeaway>Environment variables must be set at Docker build time, not runtime, for full effect</critical-takeaway>
            <critical-takeaway>Cloud Run uses structured logging - any formatting that interferes must be disabled</critical-takeaway>
            <critical-takeaway>Third-party libraries (rich, colorama) may need explicit disabling in production environments</critical-takeaway>
        </category>
    </intelligent_remediation>
    
    <agent_orchestration>
        <category name="Workflow Sequential Execution" path="SPEC/learnings/workflow_sequential_execution.xml" keywords="Workflow, Sequential Execution, Parallel Execution, Agent Dependencies, Supervisor Agent, Pipeline Steps, Execution Strategy, Race Conditions">
            <critical-takeaway>Agent workflow steps MUST explicitly define dependencies to prevent incorrect parallel execution</critical-takeaway>
            <critical-takeaway>Pipeline steps default to SEQUENTIAL strategy unless explicitly marked for PARALLEL execution</critical-takeaway>
            <critical-takeaway>Execution engine requires explicit PARALLEL strategy on at least one step to enable parallel execution</critical-takeaway>
            <critical-takeaway>Standard workflow has strict dependencies: triage â†’ data â†’ optimization â†’ actions â†’ reporting</critical-takeaway>
            <critical-takeaway>Use multiple redundant checks (strategy, dependencies, metadata.requires_sequential) for critical execution paths</critical-takeaway>
            <critical-takeaway>Test workflow execution patterns with dedicated unit tests to prevent regression</critical-takeaway>
            <critical-takeaway>Log entries showing "Supervisor parallel execution" with all agents indicate dependency violation bug</critical-takeaway>
            <critical-takeaway>Race conditions from parallel execution can cause data corruption and unpredictable AI recommendations</critical-takeaway>
        </category>
    </agent_orchestration>
    
    <frontend_defensive_programming>
        <category name="WebSocket Debugger Defensive Programming" path="SPEC/learnings/websocket_debugger_defensive.xml" keywords="WebSocket, Debugger, Defensive Programming, GTM, Undefined Access, Production Error, Type Safety, Optional Chaining">
            <critical-takeaway>WebSocket debugger methods MUST handle undefined/malformed events as GTM minified scripts can access them unexpectedly</critical-takeaway>
            <critical-takeaway>Use optional chaining (?.) and nullish coalescing (??) for ALL nested property access in exported services</critical-takeaway>
            <critical-takeaway>generateEventId() must check multiple property locations (message_id, messageId, id) with safe fallbacks</critical-takeaway>
            <critical-takeaway>traceEvent() must validate event existence before processing and return error results for undefined inputs</critical-takeaway>
            <critical-takeaway>All validation rules must check event existence before accessing properties to prevent runtime errors</critical-takeaway>
            <critical-takeaway>Production error "Cannot read properties of undefined" from GTM scripts indicates missing defensive programming</critical-takeaway>
            <critical-takeaway>Exported services accessed by third-party scripts require extra defensive programming layers</critical-takeaway>
            <critical-takeaway>Test all public methods with undefined, null, and malformed inputs to ensure graceful handling</critical-takeaway>
        </category>
    </frontend_defensive_programming>
    
    <routing_architecture>
        <category name="Router Double Prefix Pattern" path="SPEC/learnings/router_double_prefix_pattern.xml" keywords="Routing, APIRouter, Prefix, Double Prefix, 404, FastAPI, app_factory_route_configs, Centralized Routing">
            <critical-takeaway>CRITICAL: Route prefixes MUST be managed centrally in app_factory_route_configs.py - individual routers should NOT define their own prefixes</critical-takeaway>
            <critical-takeaway>Double prefix errors (e.g., /api/api/mcp-client) occur when routers define prefixes in APIRouter() AND app_factory adds prefixes</critical-takeaway>
            <critical-takeaway>Always use empty prefix="" or no prefix parameter in router files - let app_factory_route_configs.py manage all prefixes</critical-takeaway>
            <critical-takeaway>Check app_factory_route_configs.py before adding any prefix to a router to avoid duplication</critical-takeaway>
            <critical-takeaway>Run route accessibility tests after any router modification to detect prefix conflicts early</critical-takeaway>
            <critical-takeaway>Use scripts/check_architecture_compliance.py to detect prefix conflicts programmatically</critical-takeaway>
            <critical-takeaway>Unregistered routers (example_messages.py, synthetic_data_corpus.py) should be reviewed and properly registered</critical-takeaway>
        </category>
    </routing_architecture>
    
    <environment_security>
        <category name="Environment Pollution Prevention" path="SPEC/learnings/env_pollution_remediation.xml" keywords="Environment Variables, Test Flags, Security, Authentication Bypass, Rate Limiting, Staging, Production, Environment Validation, TESTING, E2E_TESTING, AUTH_FAST_TEST_MODE, localhost, Environment Pollution">
            <critical-takeaway>CRITICAL: Test environment variables (TESTING, E2E_TESTING, etc.) MUST NEVER be checked in production code - isolate all test logic in tests/ directory</critical-takeaway>
            <critical-takeaway>Environment validator MUST run FIRST at startup and fail fast on critical violations in staging/production</critical-takeaway>
            <critical-takeaway>NEVER use localhost references in staging/production configurations - always use proper service endpoints</critical-takeaway>
            <critical-takeaway>Authentication and rate limiting bypasses MUST only exist in test-only helper modules, never in production code</critical-takeaway>
            <critical-takeaway>Use netra_backend/tests/helpers/auth_test_helper.py for test authentication, not production auth.py</critical-takeaway>
            <critical-takeaway>Run test_env_validation.py to verify environment configurations before deployment</critical-takeaway>
            <critical-takeaway>Forbidden variables list: TESTING, E2E_TESTING, AUTH_FAST_TEST_MODE, PYTEST_CURRENT_TEST, ALLOW_DEV_AUTH_BYPASS, WEBSOCKET_AUTH_BYPASS</critical-takeaway>
            <critical-takeaway>All secrets in staging/production MUST be loaded from Google Secrets Manager, never hardcoded</critical-takeaway>
            <critical-takeaway>Use .env.staging.example as template - actual .env.staging should never contain localhost or test flags</critical-takeaway>
        </category>
    </environment_security>

    <testing_methodology>
        <category name="Cypress Test Suite Systematic Upgrade" path="SPEC/learnings/cypress_test_upgrade_systematic.xml" keywords="Cypress, E2E Testing, Test Upgrade, Sub-Agent Methodology, WebSocket Events, Test Reliability, CI/CD, False Failures, SUT Alignment, Demo Flow, ROI Calculator, Authentication">
            <critical-takeaway>Use systematic sub-agent approach with 1-3 focused tests per agent to prevent context overflow and ensure thorough analysis</critical-takeaway>
            <critical-takeaway>ALL WebSocket tests MUST use UnifiedWebSocketEvent structure with 5 critical events: agent_started, agent_thinking, tool_executing, tool_completed, agent_completed</critical-takeaway>
            <critical-takeaway>Demo navigation changed from direct routes to /demo â†’ industry selection â†’ feature tabs pattern - update all demo tests accordingly</critical-takeaway>
            <critical-takeaway>Current implementation uses semantic selectors (CSS classes, IDs) not data-testid attributes - update selectors to match reality</critical-takeaway>
            <critical-takeaway>Use "Quick Dev Login" button in development mode authentication, not manual localStorage manipulation</critical-takeaway>
            <critical-takeaway>File upload moved from chat to /ingestion; no /settings page exists; API key management not implemented - skip tests until features exist</critical-takeaway>
            <critical-takeaway>Mark missing functionality tests as .skip() with clear TODO comments rather than deleting test infrastructure</critical-takeaway>
            <critical-takeaway>Message input changed from input element to textarea within [data-testid="message-input"] wrapper</critical-takeaway>
        </category>
    </testing_methodology>
    
    <learning id="frontend-api-url-configuration-2025-08-31">
        <title>Frontend API URL Configuration Issue</title>
        <category>Configuration</category>
        <keywords>frontend, api, url, staging, production, domain, agent, endpoints, 404</keywords>
        <path>frontend_api_url_configuration.xml</path>
        <critical-takeaway>
            Frontend MUST use absolute URLs with backend API domain for all API calls.
            Relative URLs like /api/* resolve to frontend domain causing 404 errors.
            Always use getUnifiedApiConfig() to get correct API URL.
            Test in staging to catch domain-related issues early.
        </critical-takeaway>
        <severity>CRITICAL</severity>
        <business-impact>Complete agent functionality failure, broken chat in staging/production, poor user experience</business-impact>
        <prevention>NEVER use relative URLs in frontend API calls. Always import and use getUnifiedApiConfig(). Test API calls in staging environment.</prevention>
    </learning>
</specification>
