<?xml version='1.0' encoding='utf-8'?>
<learnings>
  <metadata>
    <category>Environment Loading</category>
    <version>1.0</version>
    <last_updated>2025-01-17</last_updated>
    <last_edited>2025-08-21T08:47:29.249655</last_edited>
    <legacy_status is_legacy="true" identified_date="2025-08-21T08:47:29.249655">
      <reasons>
        <reason>Content contains: old</reason>
      </reasons>
    </legacy_status>
  </metadata>
  <learning id="simplified-single-source-loading">
    <date>2025-01-17</date>
    <category>Environment Loading</category>
    <title>Simplified Single-Source Environment Loading</title>
    <problem>
      <description>Environment loader was too complex with multiple file sources</description>
      <symptoms>
        <symptom>Loading from .env, .env.development, .env.development.local</symptom>
        <symptom>Confusing precedence rules</symptom>
        <symptom>System could overwrite user configurations</symptom>
        <symptom>All secrets fetched from remote even if available locally</symptom>
      </symptoms>
      <impact>
        <item>User confusion about which file takes precedence</item>
        <item>Loss of user control over configurations</item>
        <item>Unnecessary remote API calls</item>
        <item>Complex debugging when values come from multiple sources</item>
      </impact>
    </problem>
    <solution>
      <description>Simplified to single .env file with optional remote fallback</description>
      <implementation>
        <step>Load ONLY from user-controlled .env file</step>
        <step>Never auto-generate or modify .env file</step>
        <step>Use remote secrets only for missing variables</step>
        <step>Clear priority: OS &gt; .env &gt; Remote &gt; Defaults</step>
      </implementation>
      <code_changes>
        <file>dev_launcher/env_file_loader.py</file>
        <file>dev_launcher/secret_loader.py</file>
      </code_changes>
    </solution>
    <result>
      <outcome>Cleaner, simpler environment loading</outcome>
      <benefits>
        <benefit>User maintains full control of .env file</benefit>
        <benefit>Clear, predictable priority order</benefit>
        <benefit>Reduced remote API calls</benefit>
        <benefit>Better observability of variable sources</benefit>
      </benefits>
    </result>
    <prevention>
      <practice>Keep loading logic simple - one primary source</practice>
      <practice>Make user files strictly user-controlled</practice>
      <practice>Use remote services only as fallback</practice>
      <practice>Provide clear logging of sources</practice>
    </prevention>
    <related>
      <spec>SPEC/environment_loading.xml</spec>
      <doc>docs/ENVIRONMENT_LOADER.md</doc>
    </related>
  </learning>
  <learning id="env-file-user-control">
    <date>2025-01-17</date>
    <category>Environment Loading</category>
    <title>User Control Over Environment Files</title>
    <problem>
      <description>System could overwrite or auto-generate user .env files</description>
      <symptoms>
        <symptom>.env files being modified by system</symptom>
        <symptom>User changes being overwritten</symptom>
        <symptom>Auto-generated markers in files</symptom>
      </symptoms>
      <impact>
        <item>Loss of user configuration</item>
        <item>Confusion about file ownership</item>
        <item>Difficulty maintaining local development settings</item>
      </impact>
    </problem>
    <solution>
      <description>Made .env files strictly user-controlled</description>
      <implementation>
        <step>Never modify existing .env files</step>
        <step>Detect and warn about auto-generated files</step>
        <step>Provide help for creating .env files</step>
        <step>Support copying from .env.example or .env.local</step>
      </implementation>
    </solution>
    <result>
      <outcome>Users maintain full control of their environment</outcome>
      <benefits>
        <benefit>No unexpected configuration changes</benefit>
        <benefit>Clear ownership of .env file</benefit>
        <benefit>Predictable local development</benefit>
      </benefits>
    </result>
    <prevention>
      <practice>Never programmatically modify user configuration files</practice>
      <practice>Provide templates but let users create actual files</practice>
      <practice>Validate that user files are user-controlled</practice>
    </prevention>
  </learning>
  <learning id="remote-fallback-optimization">
    <date>2025-01-17</date>
    <category>Environment Loading</category>
    <title>Optimized Remote Secret Fallback</title>
    <problem>
      <description>All secrets fetched from remote even when available locally</description>
      <symptoms>
        <symptom>Slow startup due to remote API calls</symptom>
        <symptom>Unnecessary network dependencies</symptom>
        <symptom>Fetching secrets already in .env file</symptom>
      </symptoms>
      <impact>
        <item>Slower application startup</item>
        <item>Unnecessary cloud API usage</item>
        <item>Requires network for local development</item>
      </impact>
    </problem>
    <solution>
      <description>Fetch only missing secrets from remote</description>
      <implementation>
        <step>Check what's already loaded from .env and OS</step>
        <step>Identify missing required secrets</step>
        <step>Fetch ONLY missing secrets from Google Secret Manager</step>
        <step>Make remote fallback optional via parameter</step>
      </implementation>
    </solution>
    <result>
      <outcome>Efficient secret loading with minimal remote calls</outcome>
      <benefits>
        <benefit>Faster startup times</benefit>
        <benefit>Reduced API usage and costs</benefit>
        <benefit>Works offline when all secrets in .env</benefit>
        <benefit>Optional complete offline mode</benefit>
      </benefits>
    </result>
    <prevention>
      <practice>Always check local sources first</practice>
      <practice>Only fetch what's missing from remote</practice>
      <practice>Make remote dependencies optional</practice>
      <practice>Cache remote results when appropriate</practice>
    </prevention>
  </learning>
  <learning id="observability-in-loading">
    <date>2025-01-17</date>
    <category>Environment Loading</category>
    <title>Comprehensive Loading Observability</title>
    <problem>
      <description>Unclear where environment variables were coming from</description>
      <symptoms>
        <symptom>Difficult to debug configuration issues</symptom>
        <symptom>Unknown source of variable values</symptom>
        <symptom>No visibility into loading process</symptom>
      </symptoms>
      <impact>
        <item>Hard to troubleshoot configuration problems</item>
        <item>Confusion about value precedence</item>
        <item>Time wasted debugging</item>
      </impact>
    </problem>
    <solution>
      <description>Added comprehensive logging and tracking</description>
      <implementation>
        <step>Log each step of loading process</step>
        <step>Track and display source of each variable</step>
        <step>Show summary statistics by source</step>
        <step>Mask sensitive values in logs</step>
        <step>Organize variables by category</step>
      </implementation>
    </solution>
    <result>
      <outcome>Full visibility into environment loading</outcome>
      <benefits>
        <benefit>Easy to see where each value comes from</benefit>
        <benefit>Clear understanding of precedence</benefit>
        <benefit>Quick identification of missing variables</benefit>
        <benefit>Safe logging with masked values</benefit>
      </benefits>
    </result>
    <prevention>
      <practice>Always provide detailed logging for configuration</practice>
      <practice>Track source of each configuration value</practice>
      <practice>Mask sensitive values in all logs</practice>
      <practice>Provide summary statistics for overview</practice>
    </prevention>
  </learning>
  <learning id="config-placeholder-replacement-paradox">
    <date>2025-08-18</date>
    <category>Environment Loading</category>
    <title>Configuration Placeholder Replacement Paradox - Inheritance Issue</title>
    <problem>
      <description>PARADOX: Configuration had placeholder replacement code that never executed due to inheritance model</description>
      <symptoms>
        <symptom>ClickHouse connection failing with "clickhouse_host_url_placeholder"</symptom>
        <symptom>Redis connection failing with placeholder values</symptom>
        <symptom>Environment variables present in .env but not used</symptom>
        <symptom>Previous fix attempts failed despite appearing correct</symptom>
      </symptoms>
      <root_cause>
        <item>AppConfig parent class defines clickhouse_native with placeholder defaults</item>
        <item>DevelopmentConfig.__init__ checked "if 'clickhouse_native' not in data"</item>
        <item>This condition was ALWAYS False because parent class already set the attribute</item>
        <item>Environment variable loading code was NEVER executed</item>
        <item>Additionally, UnifiedConfigManager creates config with no arguments</item>
        <item>Service modes weren't being set in data dict, only enabled flags</item>
      </root_cause>
      <impact>
        <item>Services unable to start due to invalid connection strings</item>
        <item>Development environment broken despite correct .env file</item>
        <item>Multiple fix attempts failed due to misunderstanding root cause</item>
        <item>SSL errors when trying to use HTTPS with local HTTP-only services</item>
      </impact>
    </problem>
    <solution>
      <description>Fixed inheritance paradox by ALWAYS overriding configs and setting all mode fields</description>
      <implementation>
        <step>Removed conditional checks - ALWAYS override clickhouse/redis configs</step>
        <step>Handle empty data dict when called from UnifiedConfigManager</step>
        <step>Set mode fields (clickhouse_mode, redis_mode) not just enabled flags</step>
        <step>Ensure environment variables are loaded BEFORE parent init</step>
      </implementation>
      <code_changes>
        <file>app/configuration/schemas.py - DevelopmentConfig.__init__ - removed conditionals</file>
        <file>app/configuration/schemas.py - _configure_service_flags - added mode field setting</file>
      </code_changes>
    </solution>
    <result>
      <outcome>Configuration properly loads from environment variables</outcome>
      <benefits>
        <benefit>Services connect to correct hosts specified in .env</benefit>
        <benefit>Local mode uses HTTP, shared mode uses HTTPS correctly</benefit>
        <benefit>Development environment works with local Docker services</benefit>
        <benefit>Clear precedence: env vars override default placeholders</benefit>
      </benefits>
    </result>
    <prevention>
      <practice>NEVER conditionally check for field existence when overriding parent defaults</practice>
      <practice>ALWAYS override configuration values unconditionally in child classes</practice>
      <practice>Set ALL related fields (modes AND flags) when configuring services</practice>
      <practice>Test with actual UnifiedConfigManager flow, not just direct instantiation</practice>
      <practice>Ensure .env is loaded into os.environ before config creation</practice>
      <practice>Watch for inheritance paradoxes where parent defaults prevent child overrides</practice>
    </prevention>
    <related>
      <spec>SPEC/configuration.xml</spec>
      <file>app/configuration/schemas.py</file>
      <file>app/core/configuration/base.py</file>
      <file>app/db/clickhouse.py</file>
    </related>
  </learning>
</learnings>