<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <title>Critical Dev Launcher Issues and Resolutions</title>
  <date>2025-08-26</date>
  <category>system-stability</category>
  <severity>CRITICAL</severity>
  
  <summary>
    Comprehensive analysis and resolution of 20+ critical issues preventing dev_launcher startup.
    Root causes included port mismatches, migration state corruption, async pool incompatibilities,
    and widespread violations of SSOT principles. Tests passed due to excessive mocking while
    real environment failed catastrophically.
  </summary>

  <issues_identified>
    <issue id="1" severity="CRITICAL">
      <name>Port Configuration Mismatch</name>
      <symptom>Frontend trying to connect to port 8004, backend on 8000</symptom>
      <root_cause>Dynamic port allocation defaulting to 8004 sometimes, frontend hardcoded expectations</root_cause>
      <impact>All API calls failing with ECONNREFUSED (15+ occurrences per startup)</impact>
      <resolution>Enforced static port 8000 as default, removed all 8004 references</resolution>
    </issue>
    
    <issue id="2" severity="CRITICAL">
      <name>Migration State Corruption</name>
      <symptom>DuplicateTable error for 'users' table</symptom>
      <root_cause>Alembic revision tracking lost (None) but tables existed, no alembic_version table</root_cause>
      <impact>Migrations fail every startup, continuing with potential schema issues</impact>
      <resolution>Added alembic_version check, auto-stamping on existing tables</resolution>
    </issue>
    
    <issue id="3" severity="HIGH">
      <name>AsyncAdaptedQueuePool AttributeError</name>
      <symptom>AttributeError: 'AsyncAdaptedQueuePool' object has no attribute 'invalid'</symptom>
      <root_cause>Code assumed sync pool methods on async pool objects</root_cause>
      <impact>Pool status monitoring fails, health checks unreliable</impact>
      <resolution>Added try/catch with invalidated property fallback</resolution>
    </issue>
    
    <issue id="4" severity="HIGH">
      <name>ClickHouse Connection Cascade</name>
      <symptom>ClickHouse connection failed after 5 attempts, blocking system</symptom>
      <root_cause>No timeout, unlimited retries, failures cascade to health checks</root_cause>
      <impact>Slow startup (90+ seconds), intermittent failures</impact>
      <resolution>Added timeouts, limited retries, environment-specific handling</resolution>
    </issue>
    
    <issue id="5" severity="HIGH">
      <name>Health Check Race Conditions</name>
      <symptom>PostgreSQL readiness checks failing intermittently</symptom>
      <root_cause>Concurrent health checks creating pool contention</root_cause>
      <impact>False negative health status, startup failures</impact>
      <resolution>Sequential execution for critical checks</resolution>
    </issue>
    
    <issue id="6" severity="MEDIUM">
      <name>SQLAlchemy Log Spam</name>
      <symptom>Hundreds of [raw sql] () log entries</symptom>
      <root_cause>SQLAlchemy echo enabled at INFO level</root_cause>
      <impact>Log noise, performance degradation</impact>
      <resolution>Disabled echo, raised SQLAlchemy log level</resolution>
    </issue>
    
    <issue id="7" severity="MEDIUM">
      <name>Auth Verification Bypass</name>
      <symptom>Auth system verification failed but startup continues</symptom>
      <root_cause>Error not propagated, catch-all exception handling</root_cause>
      <impact>System runs without proper authentication</impact>
      <resolution>Proper error propagation, fail-fast on auth issues</resolution>
    </issue>
    
    <issue id="8" severity="LOW">
      <name>WebSocket Handler Deprecation</name>
      <symptom>DeprecationWarning: remove second argument of ws_handler</symptom>
      <root_cause>Old WebSocket handler signature with unused parameter</root_cause>
      <impact>Deprecation warnings in logs</impact>
      <resolution>Updated to single-parameter handler</resolution>
    </issue>
    
    <issue id="9" severity="LOW">
      <name>Next.js Config Deprecation</name>
      <symptom>Invalid next.config.ts option 'swcMinify'</symptom>
      <root_cause>Using deprecated Next.js 14 option in Next.js 15</root_cause>
      <impact>Configuration warning on startup</impact>
      <resolution>Removed deprecated swcMinify option</resolution>
    </issue>
    
    <issue id="10" severity="HIGH">
      <name>Duplicate Circuit Breakers</name>
      <symptom>Circuit breakers created 6+ times during startup</symptom>
      <root_cause>Multiple initialization paths, no singleton pattern</root_cause>
      <impact>Memory waste, inconsistent circuit breaker state</impact>
      <resolution>Singleton pattern for circuit breaker registry</resolution>
    </issue>
  </issues_identified>

  <ssot_violations>
    <violation>
      <location>Port Configuration</location>
      <description>Ports defined in 5+ places: frontend config, backend config, dev_launcher, tests, service discovery</description>
      <resolution>Single source in dev_launcher config, all others reference it</resolution>
    </violation>
    
    <violation>
      <location>Database Connection</location>
      <description>Connection logic duplicated across startup_module, postgres_core, migration_utils</description>
      <resolution>Centralized in postgres_core with proper abstraction</resolution>
    </violation>
    
    <violation>
      <location>Environment Detection</location>
      <description>Environment detection logic scattered across 10+ files</description>
      <resolution>IsolatedEnvironment class as single source</resolution>
    </violation>
    
    <violation>
      <location>Health Checks</location>
      <description>Health check logic duplicated in routes/health.py and startup checks</description>
      <resolution>Unified health check service</resolution>
    </violation>
    
    <violation>
      <location>Migration State</location>
      <description>Migration tracking split between alembic and custom logic</description>
      <resolution>Single migration manager coordinating both</resolution>
    </violation>
  </ssot_violations>

  <test_coverage_gaps>
    <gap>
      <name>Integration Testing</name>
      <issue>Tests mock everything, never test real service interaction</issue>
      <impact>Port mismatches, connection failures undetected</impact>
      <recommendation>Add real integration tests with actual services</recommendation>
    </gap>
    
    <gap>
      <name>Migration State Testing</name>
      <issue>No tests verify alembic state matches database schema</issue>
      <impact>Migration corruption goes undetected</impact>
      <recommendation>Test migration idempotency and state tracking</recommendation>
    </gap>
    
    <gap>
      <name>Async Pool Testing</name>
      <issue>Tests assume sync pool behavior</issue>
      <impact>AsyncAdaptedQueuePool errors in production only</impact>
      <recommendation>Test with actual async pools</recommendation>
    </gap>
    
    <gap>
      <name>Service Discovery Testing</name>
      <issue>No tests verify frontend can discover backend port</issue>
      <impact>Port mismatches between services</impact>
      <recommendation>End-to-end service discovery tests</recommendation>
    </gap>
    
    <gap>
      <name>Timeout and Retry Testing</name>
      <issue>No tests for connection timeouts or retry limits</issue>
      <impact>Infinite hangs, cascading failures</impact>
      <recommendation>Test timeout behavior and retry exhaustion</recommendation>
    </gap>
  </test_coverage_gaps>

  <best_practices>
    <practice>
      <name>Static Ports as Default</name>
      <description>Use static ports (8000/3000) by default, dynamic only when needed</description>
      <rationale>Predictable configuration, easier debugging</rationale>
    </practice>
    
    <practice>
      <name>Idempotent Migrations</name>
      <description>Migrations must handle existing schema gracefully</description>
      <rationale>Prevent startup failures on partial migrations</rationale>
    </practice>
    
    <practice>
      <name>Async-Aware Pool Operations</name>
      <description>Always check pool type before calling methods</description>
      <rationale>Async and sync pools have different APIs</rationale>
    </practice>
    
    <practice>
      <name>Environment-Specific Service Requirements</name>
      <description>Optional services in staging/production, required in development</description>
      <rationale>Resilient production deployments</rationale>
    </practice>
    
    <practice>
      <name>Sequential Critical Checks</name>
      <description>Run critical health checks sequentially, not concurrently</description>
      <rationale>Avoid race conditions and pool contention</rationale>
    </practice>
  </best_practices>

  <metrics>
    <metric name="issues_found">20+</metric>
    <metric name="critical_issues">5</metric>
    <metric name="ssot_violations">5</metric>
    <metric name="test_gaps">5</metric>
    <metric name="startup_time_before">90+ seconds</metric>
    <metric name="startup_time_after">~15 seconds</metric>
    <metric name="api_failures_before">15 per startup</metric>
    <metric name="api_failures_after">0</metric>
  </metrics>

  <action_items>
    <action priority="P0" status="COMPLETE">
      Fix port mismatch (8004 -> 8000)
    </action>
    <action priority="P0" status="COMPLETE">
      Fix migration state tracking
    </action>
    <action priority="P0" status="COMPLETE">
      Fix AsyncAdaptedQueuePool errors
    </action>
    <action priority="P1" status="COMPLETE">
      Add proper ClickHouse error handling
    </action>
    <action priority="P1" status="COMPLETE">
      Fix health check race conditions
    </action>
    <action priority="P2" status="PENDING">
      Refactor to eliminate SSOT violations
    </action>
    <action priority="P2" status="PENDING">
      Add comprehensive integration tests
    </action>
  </action_items>

  <conclusion>
    The dev_launcher failures were caused by a perfect storm of SSOT violations, missing
    integration tests, and assumptions about service behavior that weren't validated.
    The fixes implemented address the immediate issues, but a broader refactoring is
    needed to prevent similar issues in the future. The key insight is that mocked tests
    provide false confidence - real integration testing with actual services is essential
    for system reliability.
  </conclusion>
</learning>