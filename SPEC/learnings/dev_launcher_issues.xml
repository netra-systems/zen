<?xml version="1.0" encoding="UTF-8"?>
<spec>
  <metadata>
    <title>Dev Launcher Issues Analysis and Remediation</title>
    <description>Root cause analysis and fixes for critical dev launcher issues discovered in comprehensive audit</description>
    <version>1.0.0</version>
    <created>2025-08-26</created>
    <priority>CRITICAL</priority>
    <tags>startup, database, logging, auth, websocket, performance</tags>
  </metadata>

  <issues_discovered>
    <issue id="clickhouse-connection-failure">
      <title>ClickHouse Connection Failures</title>
      <severity>HIGH</severity>
      <root_cause>
        ClickHouse is optional but treated as critical. Connection failures after 5 attempts block startup flow.
      </root_cause>
      <fix_implemented>
        - Added fallback behavior for ClickHouse unavailability
        - System continues with mock/local mode for analytics
        - Clear communication about reduced analytics capabilities
      </fix_implemented>
      <prevention>
        Always treat ClickHouse as optional analytics layer, not critical infrastructure
      </prevention>
    </issue>

    <issue id="migration-duplicate-tables">
      <title>Database Migration Duplicate Table Errors</title>
      <severity>HIGH</severity>
      <root_cause>
        Migrations attempt to create tables that already exist, causing "relation 'users' already exists" errors.
        Migration state tracking is not idempotent.
      </root_cause>
      <fix_implemented>
        - Added idempotent handling for DuplicateTable errors
        - Stamp database to current head revision when tables exist
        - Continue gracefully in development environments
      </fix_implemented>
      <prevention>
        Use IF NOT EXISTS in migration scripts and maintain proper alembic version tracking
      </prevention>
    </issue>

    <issue id="sqlalchemy-logging-spam">
      <title>SQLAlchemy Verbose Logging Spam</title>
      <severity>MEDIUM</severity>
      <root_cause>
        SQLAlchemy echo was enabled in DEBUG mode, causing 300+ SQL query logs during startup.
        This violated the principle of minimal logging for development.
      </root_cause>
      <fix_implemented>
        - Changed echo to only enable in TRACE mode with explicit enable_sql_logging flag
        - Suppressed SQLAlchemy loggers to WARNING level by default
        - Reduced noise from 334 SQL logs to essential ones only
      </fix_implemented>
      <prevention>
        Never enable SQL echo by default. Require explicit opt-in for SQL logging.
      </prevention>
    </issue>

    <issue id="asyncadaptedqueuepool-invalid">
      <title>AsyncAdaptedQueuePool Invalid Attribute Error</title>
      <severity>HIGH</severity>
      <root_cause>
        Code attempted to access pool.invalid() and pool.invalidated() methods on AsyncAdaptedQueuePool.
        These methods only exist on synchronous pools, not async pools.
      </root_cause>
      <fix_implemented>
        - Removed calls to invalid() and invalidated() methods
        - Added pool_type to stats for debugging
        - Properly handle async pool limitations
      </fix_implemented>
      <ssot_violation>
        Multiple implementations of pool status checking across database_manager.py, connection_pool_manager.py, and postgres_core.py
      </ssot_violation>
      <prevention>
        Understand SQLAlchemy async pool API differences. Don't assume sync pool methods exist on async pools.
      </prevention>
    </issue>

    <issue id="auth-service-port-mismatch">
      <title>Auth Service Port Configuration Mismatch</title>
      <severity>HIGH</severity>
      <root_cause>
        Frontend expects auth service on port 8004, but auth service runs on port 8081.
        Service discovery not properly coordinating port information.
      </root_cause>
      <fix_needed>
        - Fix service discovery to properly communicate auth service port
        - Frontend should read from service discovery, not hardcode ports
        - Ensure consistent port allocation across environments
      </fix_needed>
      <prevention>
        Never hardcode service ports. Always use service discovery for inter-service communication.
      </prevention>
    </issue>

    <issue id="websocket-auth-errors">
      <title>WebSocket Authentication Failures</title>
      <severity>MEDIUM</severity>
      <root_cause>
        WebSocket connections attempt without proper JWT authentication headers.
        This is correct security behavior, but clients aren't configured properly.
      </root_cause>
      <fix_needed>
        - Update WebSocket clients to include JWT in Authorization header or subprotocol
        - Add clear documentation for WebSocket authentication requirements
      </fix_needed>
      <prevention>
        Always include authentication in WebSocket connection examples and documentation
      </prevention>
    </issue>

    <issue id="slow-startup-performance">
      <title>Slow Startup Performance</title>
      <severity>HIGH</severity>
      <root_cause>
        - Oversized connection pools (25 + 35 overflow = 60 connections per service)
        - Multiple redundant database connection attempts
        - Serial execution of independent startup tasks
        - Excessive health checks during startup
      </root_cause>
      <fix_implemented>
        - Reduced pool sizes: 10 + 15 overflow = 25 max connections
        - Reduced timeouts: 60s instead of 120s for faster failure detection
        - Deduplicated database connection testing
      </fix_implemented>
      <fix_needed>
        - Parallelize independent startup tasks
        - Skip redundant health checks after successful connection
        - Implement proper startup dependency ordering
      </fix_needed>
      <prevention>
        Design startup for speed. Minimize connection pool sizes. Parallelize independent operations.
      </prevention>
    </issue>

    <issue id="configuration-spam">
      <title>Configuration Endpoint Spam</title>
      <severity>LOW</severity>
      <root_cause>
        Frontend configuration endpoint called 24+ times during startup.
        Each call prints useWebSocketSecure configuration.
      </root_cause>
      <fix_needed>
        - Implement request deduplication for configuration endpoint
        - Cache configuration responses
        - Reduce logging verbosity for repeated configuration requests
      </fix_needed>
      <prevention>
        Cache configuration responses. Implement request deduplication for idempotent endpoints.
      </prevention>
    </issue>

    <issue id="duplicate-connection-logic">
      <title>Duplicate Database Connection Logic (SSOT Violation)</title>
      <severity>HIGH</severity>
      <root_cause>
        Multiple implementations of database connection and pool management across:
        - DatabaseManager
        - ConnectionPoolManager
        - PostgresCore
        - startup_module
      </root_cause>
      <ssot_violation>
        Each service has its own connection logic instead of one canonical implementation
      </ssot_violation>
      <fix_needed>
        - Consolidate all database connection logic into DatabaseManager
        - Remove duplicate implementations
        - Single source of truth for pool management
      </fix_needed>
      <prevention>
        Follow SSOT principle strictly. One concept = one implementation per service.
      </prevention>
    </issue>

    <issue id="test-mocking-gaps">
      <title>Test Coverage Gaps - Mocks vs Reality</title>
      <severity>CRITICAL</severity>
      <root_cause>
        Tests use mocks extensively, missing real connection failures and configuration issues.
        Tests pass but real environment fails due to:
        - Mocked database connections don't test pool behavior
        - Mocked auth service doesn't test port binding
        - Mocked WebSocket doesn't test authentication flow
      </root_cause>
      <fix_needed>
        - Add integration tests with real services
        - Test actual connection failures and recovery
        - Test service discovery and port allocation
        - Test WebSocket with real authentication
      </fix_needed>
      <prevention>
        Prefer integration tests with real services over unit tests with mocks.
        Real > Mock. E2E > Integration > Unit.
      </prevention>
    </issue>
  </issues_discovered>

  <key_learnings>
    <learning>
      AsyncAdaptedQueuePool has different API than synchronous pools. Methods like invalid() and invalidated() don't exist on async pools.
    </learning>
    <learning>
      SQLAlchemy logging should be opt-in, not automatic. DEBUG mode shouldn't enable SQL echo by default.
    </learning>
    <learning>
      Service discovery must be the single source of truth for service ports. Never hardcode port assumptions.
    </learning>
    <learning>
      Connection pool sizes directly impact startup time. Smaller pools = faster startup.
    </learning>
    <learning>
      ClickHouse should always be treated as optional analytics infrastructure, not critical for application functionality.
    </learning>
    <learning>
      Migration scripts must be idempotent. Always handle "table already exists" scenarios gracefully.
    </learning>
    <learning>
      Tests with mocks can pass while real systems fail. Integration tests with real services are essential.
    </learning>
  </key_learnings>

  <metrics>
    <metric name="sql_log_reduction">From 334 logs to ~10 essential logs</metric>
    <metric name="startup_time_improvement">Target: From 2+ minutes to 30-45 seconds</metric>
    <metric name="connection_pool_reduction">From 60 to 25 max connections per service</metric>
    <metric name="ssot_violations_found">10+ duplicate implementations of same concepts</metric>
  </metrics>

  <next_steps>
    <step priority="1">Complete parallelization of startup tasks</step>
    <step priority="2">Fix service discovery for auth service port</step>
    <step priority="3">Consolidate duplicate database connection logic (SSOT)</step>
    <step priority="4">Add comprehensive integration tests with real services</step>
    <step priority="5">Document WebSocket authentication requirements</step>
  </next_steps>
</spec>