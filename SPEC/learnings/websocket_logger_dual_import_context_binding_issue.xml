<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <metadata>
    <title>WebSocket Logger Dual Import Context Binding Issue</title>
    <date>2025-08-31</date>
    <category>Runtime Error Resolution</category>
    <severity>CRITICAL</severity>
    <status>RESOLVED</status>
    <investigation_duration>2_hours</investigation_duration>
  </metadata>

  <problem_statement>
    <original_error>
      TypeError: Cannot read properties of undefined (reading 'log')
      at error (logger.ts:215:10)
      at WebSocketProvider.useEffect.connectWithDelay.connectToWebSocket [as onError] (WebSocketProvider.tsx:165:15)
      at ws.onerror (webSocketService.ts:930:9)
    </original_error>
    
    <context>
      Error occurred in browser environment during WebSocket error handling.
      Issue was reported as recurring despite previous "fixes" indicating
      systematic test infrastructure failure.
    </context>
    
    <business_impact>
      - Users experiencing WebSocket connection crashes
      - Chat functionality broken during error conditions
      - Loss of real-time communication capabilities
    </business_impact>
  </problem_statement>

  <investigation_methodology>
    <approach>5 Whys Root Cause Analysis</approach>
    
    <why_1>
      <question>Why is the error occurring?</question>
      <answer>Logger is undefined when logger.error() is called</answer>
    </why_1>
    
    <why_2>
      <question>Why is the logger undefined?</question>
      <answer>Logger method lost its 'this' context when assigned to variables</answer>
    </why_2>
    
    <why_3>
      <question>Why did the logger method lose context despite constructor binding?</question>
      <answer>Dual import pattern created separate references that bypass singleton binding</answer>
    </why_3>
    
    <why_4>
      <question>Why wasn't this caught by the regression test?</question>
      <answer>Test infrastructure systematically suppresses WebSocket errors</answer>
    </why_4>
    
    <why_5>
      <question>Why does test infrastructure suppress the exact errors we need to catch?</question>
      <answer>Mock-first culture and error suppression for "clean" test output</answer>
    </why_5>
  </investigation_methodology>

  <root_cause_analysis>
    <primary_cause>
      <description>Dual Logger Import Pattern</description>
      <technical_details>
        Two files contained problematic import patterns:
        
        WebSocketProvider.tsx:
        ```javascript
        import { logger } from '@/lib/logger';           // Line 6
        import { logger as debugLogger } from '@/lib/logger'; // Line 7 - PROBLEMATIC
        ```
        
        webSocketService.ts:
        ```javascript  
        import { logger } from '@/lib/logger';           // Line 5
        import { logger as debugLogger } from '@/lib/logger'; // Line 6 - PROBLEMATIC
        ```
      </technical_details>
      
      <mechanism>
        In browser environments with webpack bundling, the dual import creates
        two separate references to the same singleton. One reference may lose
        proper 'this' context binding, causing undefined access when methods
        are used as callbacks or assigned to variables.
      </mechanism>
    </primary_cause>
    
    <secondary_causes>
      <test_infrastructure_failure>
        <cause>Error Suppression in jest.setup.js</cause>
        <evidence>
          Lines 2351-2352:
          ```javascript
          args[0].includes('Error parsing WebSocket message') ||
          args[0].includes('WebSocket error occurred') ||
          ```
        </evidence>
        <impact>Tests pass while runtime crashes are masked</impact>
      </test_infrastructure_failure>
      
      <mock_api_mismatch>
        <cause>Mock API doesn't match real implementation</cause>
        <evidence>
          Test expects: webSocketService.connect(url, token, options)
          Reality is: webSocketService.connect(url, options)
        </evidence>
        <impact>Regression test fails before testing actual issue</impact>
      </mock_api_mismatch>
      
      <environment_divergence>
        <cause>Node.js test environment vs Browser runtime</cause>
        <evidence>
          Original error shows "intercept-console-error.js:57" suggesting
          browser DevTools interception not present in test environment
        </evidence>
        <impact>Browser-specific bundling issues not caught by tests</impact>
      </environment_divergence>
    </secondary_causes>
  </root_cause_analysis>

  <solution_implemented>
    <fix_description>
      Removed dual logger imports and consolidated to single logger reference
      throughout WebSocket-related files.
    </fix_description>
    
    <changes_made>
      <file>frontend/providers/WebSocketProvider.tsx</file>
      <change type="removal">
        - import { logger as debugLogger } from '@/lib/logger';
      </change>
      <change type="replacement">
        - All debugLogger.* calls replaced with logger.*
      </change>
      
      <file>frontend/services/webSocketService.ts</file>
      <change type="removal">
        - import { logger as debugLogger } from '@/lib/logger';
      </change>
      <change type="replacement">
        - All debugLogger.* calls replaced with logger.*
      </change>
    </changes_made>
    
    <verification>
      <test_result>Integration test websocket-auth-headers.test.tsx passes</test_result>
      <stack_trace_evidence>
        Console shows proper logger stack traces:
        "at FrontendLogger.error [as log] (lib/logger.ts:166:19)"
        No more "Cannot read properties of undefined" errors
      </stack_trace_evidence>
    </verification>
  </solution_implemented>

  <systemic_issues_discovered>
    <test_infrastructure_blindness>
      <description>
        Test suite systematically hides the exact class of errors
        that cause production failures
      </description>
      <evidence>
        - 23+ files mock webSocketService with wrong API signatures
        - jest.setup.js suppresses WebSocket error messages
        - Tests pass green while runtime would crash
      </evidence>
      <risk>Critical bugs reach production undetected</risk>
    </test_infrastructure_blindness>
    
    <import_pattern_vulnerability>
      <description>
        Dual imports of singletons can cause context binding issues
        in browser environments that don't occur in Node.js tests
      </description>
      <pattern_to_avoid>
        ```javascript
        import { service } from '@/lib/service';
        import { service as debugService } from '@/lib/service';
        ```
      </pattern_to_avoid>
      <safe_pattern>
        ```javascript
        import { service } from '@/lib/service';
        // Use service.method() for all calls
        ```
      </safe_pattern>
    </import_pattern_vulnerability>
  </systemic_issues_discovered>

  <prevention_measures>
    <immediate>
      <measure>ESLint rule to detect dual imports of same module</measure>
      <measure>Remove WebSocket error suppression from jest.setup.js</measure>
      <measure>Fix regression test API signature mismatch</measure>
    </immediate>
    
    <architectural>
      <measure>Real Services by Default testing policy</measure>
      <measure>Browser environment integration tests</measure>
      <measure>Production parity test environments</measure>
    </architectural>
    
    <monitoring>
      <measure>Runtime error tracking in production</measure>
      <measure>Logger context validation in CI</measure>
      <measure>WebSocket connection health monitoring</measure>
    </monitoring>
  </prevention_measures>

  <lessons_learned>
    <technical>
      <lesson>
        Singleton imports should never be duplicated, even with aliases,
        as webpack bundling can create separate references that lose context binding
      </lesson>
      <lesson>
        Constructor method binding in singletons only works if all references
        use the same import path and instance
      </lesson>
      <lesson>
        Browser environment behavior differs significantly from Node.js tests,
        especially around context binding and error handling
      </lesson>
    </technical>
    
    <process>
      <lesson>
        Error suppression in tests creates dangerous false confidence
        and should be eliminated in favor of proper error handling
      </lesson>
      <lesson>
        Mock-first testing culture can mask critical integration issues
        that only surface in production
      </lesson>
      <lesson>
        Regression tests that don't actually test the regression
        provide no protection and waste resources
      </lesson>
    </process>
    
    <business>
      <lesson>
        Test infrastructure failures have direct business impact
        through increased production incidents and reduced reliability
      </lesson>
      <lesson>
        Systematic testing blindness is more dangerous than no tests
        because it creates false confidence in code quality
      </lesson>
    </business>
  </lessons_learned>

  <follow_up_actions>
    <immediate priority="1">
      <action>Verify fix in staging environment</action>
      <timeline>24 hours</timeline>
    </immediate>
    
    <immediate priority="2">
      <action>Remove error suppression from jest.setup.js</action>
      <timeline>48 hours</timeline>
    </immediate>
    
    <medium_term priority="3">
      <action>Audit all dual import patterns across codebase</action>
      <timeline>1 week</timeline>
    </medium_term>
    
    <long_term priority="4">
      <action>Implement Real Services by Default testing strategy</action>
      <timeline>1 month</timeline>
    </long_term>
  </follow_up_actions>

  <success_criteria>
    <criteria>No "Cannot read properties of undefined" errors in WebSocket handling</criteria>
    <criteria>All WebSocket integration tests use real implementations</criteria>
    <criteria>Error suppression removed from test setup</criteria>
    <criteria>ESLint rules prevent dual import patterns</criteria>
    <criteria>Production error monitoring shows decreased WebSocket failures</criteria>
  </success_criteria>
</learning>