<?xml version="1.0" encoding="UTF-8"?>
<learning>
  <metadata>
    <title>WebSocket Sub-Agent Enhancement Patterns</title>
    <date>2025-08-30</date>
    <severity>HIGH</severity>
    <business_value>$200K+ ARR - Improved user experience</business_value>
    <tags>websocket, sub-agents, real-time, ui-feedback, patterns</tags>
  </metadata>

  <problem_statement>
    <description>
      Sub-agents (TriageSubAgent, DataSubAgent, etc.) were not emitting WebSocket events during execution,
      causing the UI to appear unresponsive during sub-agent processing. Users had no visibility into:
      - When sub-agents started processing
      - Sub-agent thinking/reasoning steps
      - Progress updates during multi-step operations
      - Tool execution within sub-agents
      - Sub-agent completion status
    </description>
    <root_cause>
      Sub-agents lacked a standardized pattern for WebSocket event emission and context management.
      Each sub-agent would need custom WebSocket integration code, leading to inconsistent behavior.
    </root_cause>
  </problem_statement>

  <solution>
    <pattern_created file="netra_backend/app/agents/base/websocket_context.py">
      <description>
        Created WebSocketContextMixin to provide standardized WebSocket capabilities to all sub-agents.
        This mixin encapsulates all WebSocket event emission logic in a reusable component.
      </description>
      <key_features>
        - Graceful fallback when WebSocket context not available
        - Standardized event emission methods (emit_thinking, emit_progress, etc.)
        - Proper context setup and cleanup
        - Support for both modern and legacy execution patterns
      </key_features>
    </pattern_created>

    <enhanced_agents>
      <agent name="TriageSubAgent" file="netra_backend/app/agents/triage_sub_agent.py">
        <enhancements>
          - Added WebSocketContextMixin inheritance
          - Enhanced execute_core_logic() with event emissions
          - Added WebSocket context setup methods
          - Maintains backward compatibility with legacy execute()
        </enhancements>
        <events_emitted>
          - agent_started: When triage analysis begins
          - agent_thinking: During request categorization
          - progress updates: Entity extraction, intent detection
          - agent_completed: With triage results
        </events_emitted>
      </agent>

      <agent name="DataSubAgent" file="netra_backend/app/agents/data_sub_agent/data_sub_agent.py">
        <enhancements>
          - Added WebSocketContextMixin inheritance
          - Enhanced execute() method with comprehensive events
          - Enhanced execute_core_logic() for BaseExecutionInterface
          - Added WebSocket context setup for both patterns
        </enhancements>
        <events_emitted>
          - agent_started: When data analysis begins
          - agent_thinking: Parameter extraction and analysis planning
          - progress updates: Analysis execution, insights generation
          - agent_completed: With analysis results and metrics
          - error events: For validation and execution failures
        </events_emitted>
      </agent>

      <agent name="ValidationSubAgent" file="netra_backend/app/agents/validation_sub_agent.py">
        <description>Created as example implementation showing comprehensive WebSocket patterns</description>
        <enhancements>
          - Full WebSocketContextMixin integration from start
          - Demonstrates all 5 critical event types
          - Shows tool execution event patterns
          - Includes error handling and fallback patterns
        </enhancements>
        <events_emitted>
          - agent_started: Validation process initiation
          - agent_thinking: Validation rule analysis
          - tool_executing/tool_completed: For each validation rule
          - progress updates: Step-by-step validation progress
          - agent_completed: With comprehensive validation results
        </events_emitted>
      </agent>
    </enhanced_agents>

    <tool_execution_fix file="netra_backend/app/agents/enhanced_tool_execution.py">
      <description>
        Fixed thread_id extraction in enhanced tool execution to properly match WebSocket connections.
        The issue was that state.thread_id didn't match the connection ID used in WebSocket manager.
      </description>
      <fix_details>
        - Enhanced thread_id extraction to check multiple state attributes
        - Priority order: chat_thread_id > thread_id > run_id
        - Ensures tool events reach the correct WebSocket connection
      </fix_details>
    </tool_execution_fix>
  </solution>

  <implementation_pattern>
    <mixin_usage>
      <step1>Add WebSocketContextMixin to class inheritance</step1>
      <step2>Initialize mixin in __init__(): WebSocketContextMixin.__init__(self)</step2>
      <step3>Add WebSocket context setup methods for both execution patterns</step3>
      <step4>Emit events at key execution points using mixin methods</step4>
    </mixin_usage>

    <context_setup>
      <modern_execution>
        async def _setup_websocket_context_if_available(self, context: ExecutionContext):
          - Extract websocket_manager from self
          - Create WebSocketNotifier and AgentExecutionContext
          - Call self.set_websocket_context(notifier, ws_context)
      </modern_execution>
      
      <legacy_execution>
        async def _setup_websocket_context_for_legacy(self, run_id: str):
          - Same pattern but creates minimal context from run_id
          - Uses run_id as thread_id for backward compatibility
      </legacy_execution>
    </context_setup>

    <event_emission_pattern>
      <code><![CDATA[
# At start of execution
await self.emit_agent_started("Description of what agent is starting")

# During thinking/analysis phases
await self.emit_thinking("Current reasoning step...", step_number=1)

# For progress updates
await self.emit_progress("Current operation status...")

# For tool usage (if applicable)
await self.emit_tool_executing("tool_name")
# ... tool execution ...
await self.emit_tool_completed("tool_name", result_dict)

# At completion
duration_ms = (time.time() - start_time) * 1000
await self.emit_agent_completed(result_dict, duration_ms)
      ]]></code>
    </event_emission_pattern>
  </implementation_pattern>

  <critical_requirements>
    <requirement>All sub-agents MUST emit the 5 critical events: agent_started, agent_thinking, tool_executing, tool_completed, agent_completed</requirement>
    <requirement>Events must be emitted even when WebSocket context is not available (graceful fallback)</requirement>
    <requirement>Thread ID extraction must properly match WebSocket connection IDs</requirement>
    <requirement>Both modern (BaseExecutionInterface) and legacy execution patterns must be supported</requirement>
    <requirement>Error conditions must emit appropriate error events</requirement>
  </critical_requirements>

  <testing_verification>
    <unit_tests>All WebSocket component unit tests pass (TestUnitWebSocketComponents)</unit_tests>
    <integration_tests>Enhanced tool execution properly sends events with correct thread IDs</integration_tests>
    <mission_critical>Core WebSocket event flow continues to work without regression</mission_critical>
  </testing_verification>

  <architectural_benefits>
    <reusability>WebSocketContextMixin provides consistent pattern for all sub-agents</reusability>
    <maintainability>Centralized WebSocket logic reduces code duplication</maintainability>
    <extensibility>Easy to add new event types or enhance existing ones</extensibility>
    <backward_compatibility>Legacy execution patterns continue to work unchanged</backward_compatibility>
    <user_experience>Real-time feedback keeps users engaged during long operations</user_experience>
  </architectural_benefits>

  <usage_guidelines>
    <when_to_use>
      - Any sub-agent that performs multi-step operations
      - Operations that may take more than a few seconds
      - Complex analysis or validation workflows
      - Tool-heavy sub-agents with multiple external calls
    </when_to_use>
    
    <best_practices>
      - Always emit agent_started at the beginning of execution
      - Use thinking events for reasoning transparency
      - Progress events should be informative and specific
      - Tool events should wrap actual tool execution
      - Completion events should include meaningful results
      - Handle errors gracefully with appropriate error events
    </best_practices>
  </usage_guidelines>

  <future_enhancements>
    <streaming_support>Extend pattern to support streaming responses for long-running operations</streaming_support>
    <progress_tracking>Add percentage-based progress tracking for operations with known steps</progress_tracking>
    <sub_agent_nesting>Support nested sub-agent execution with hierarchical event context</sub_agent_nesting>
  </future_enhancements>
</learning>