<?xml version='1.0' encoding='utf-8'?>
<specification>
  <metadata>
    <name>Microservice.IndependenceProtocol</name>
    <version>2.1.0</version>
    <priority>CRITICAL</priority>
    <description>
      MANDATORY protocol for designing and validating independent backend microservices. 
      Ensures zero coupling with the main application monolith.
      NOTE: This protocol applies to backend services only. Frontend is excluded from these isolation requirements.
    </description>
    <last_edited>2025-08-21T08:47:28.493818</last_edited>
    <cross_references>
      <spec>shared_component_architecture.xml</spec>
      <spec>acceptable_duplicates.xml</spec>
    </cross_references>
  </metadata>
  <critical-principle id="MS-P1">
    <title>Absolute Independence (Backend Services Only)</title>
    <instruction>Ensure each backend microservice is 100% self-contained. ZERO direct code dependencies (imports) on the main application (`app/`) or other services. This principle applies to backend services only - frontend is excluded.</instruction>
    <clarification>
      Each service MAY have its own implementations of similar infrastructure (e.g., DatabaseManager, Config, Monitoring).
      This is NOT duplication but necessary for service independence. 
      See SPEC/learnings/microservice_independence.xml for detailed explanation of "Unique Concept = ONCE per service" principle.
      See SPEC/acceptable_duplicates.xml for the canonical list of acceptable cross-service duplicates.
    </clarification>
    <shared_library_pattern>
      <title>The Shared Library Pattern</title>
      <principle>
        Services MAY import from /shared for infrastructure libraries that would otherwise
        be external pip packages. Think of /shared as "internal pip packages" - pure utilities
        with no business logic.
      </principle>
      <good_examples>
        <example>from shared.isolated_environment import get_env  # Like python-dotenv</example>
        <example>from shared.database_url_builder import build_url  # Like a URL utility</example>
        <example>from shared.schemas import WebSocketMessage  # Like API specs</example>
      </good_examples>
      <critical_distinction>
        These are NOT service boundary violations because:
        - They contain ZERO business logic
        - They're stateless utilities (or per-process singletons)
        - They could literally be external pip packages
        - Each service still owns its configuration and business logic
      </critical_distinction>
      <reference>See SPEC/shared_component_architecture.xml for complete criteria</reference>
    </shared_library_pattern>
    <violation_example date="2025-08-28">
      CATASTROPHIC FAILURE: Auth service importing from netra_backend caused complete authentication failure 
      in staging. Auth service database manager was delegating to netra_backend's DatabaseManager, but in 
      deployed environments the auth service container doesn't have netra_backend code, causing immediate 
      logout after OAuth login. See SPEC/learnings/oauth_service_independence_violation.xml
    </violation_example>
  </critical-principle>
  <scope-clarification id="MS-SCOPE-001">
    <title>Backend-Only Application</title>
    <instruction>This specification applies exclusively to backend microservices (e.g., auth_service). The frontend is NOT considered a microservice for the purposes of this protocol and is exempt from these isolation requirements.</instruction>
    <backend-services>
      <service>auth_service</service>
      <service>Main Backend (/app)</service>
    </backend-services>
    <excluded>
      <component>Frontend (/frontend)</component>
    </excluded>
  </scope-clarification>
  <section title="Architectural Constraints (Backend Services)">
    <constraint id="MS-ARC-001" priority="CRITICAL">
      <title>Service-Based Namespace Pattern</title>
      <instruction>Backend services must use the pattern `{top_level_service_name}.{app|tests}` for their namespace. Main backend uses `netra_backend.app` and `netra_backend.tests`. This constraint does not apply to the frontend.</instruction>
      <code-example language="directory-structure">
        <before description="VIOLATION: Old namespace pattern">
auth_service/
├── app/
└── tests/
# Imports: from netra_backend.app.core import ...
        </before>
        <after description="CORRECT: Service-based namespace">
auth_service/
├── app/
└── tests/
# Imports: from auth_service.app.core import ...

netra_backend/
├── app/
└── tests/
# Imports: from netra_backend.app.core import ...
        </after>
      </code-example>
    </constraint>
    <constraint id="MS-ARC-002" priority="CRITICAL">
      <title>Forbidden Cross-Service Imports</title>
      <instruction>Backend services must not import code directly from other services without the service namespace prefix. Frontend is exempt from this restriction.</instruction>
      <forbidden-import-pattern>from app\. (without service prefix)</forbidden-import-pattern>
      <correct-import-pattern>from {service_name}.app</correct-import-pattern>
      <exemption>Frontend may import from app/ as needed</exemption>
    </constraint>
  </section>
  <section title="Dockerfile Standardization">
    <guideline id="MS-DOCKER-001">
      <title>Optimized Multi-Stage Build Template</title>
      <instruction>Use the following multi-stage build pattern optimized for Cloud Run deployment.</instruction>
      <code-block language="dockerfile">

# Stage 1: Builder
FROM python:3.11-slim AS builder
WORKDIR /app
# Install build dependencies (gcc, g++, etc.)
RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends gcc g++ &amp;&amp; rm -rf /var/lib/apt/lists/*
# Build wheels
COPY service_name/requirements.txt .
RUN pip wheel --no-cache-dir --no-deps --wheel-dir /app/wheels -r requirements.txt

# Stage 2: Runtime
FROM python:3.11-slim
WORKDIR /app
# Install from wheels
COPY --from=builder /app/wheels /wheels
RUN pip install --no-cache-dir /wheels/* &amp;&amp; rm -rf /wheels

# Copy service code - CRITICAL STEP
COPY service_name/ ./

# Security: Non-root user
RUN useradd -m -u 1000 appuser &amp;&amp; chown -R appuser:appuser /app
USER appuser

# Cloud Run Optimization
ENV PYTHONUNBUFFERED=1 PYTHONDONTWRITEBYTECODE=1 PORT=8080 WORKERS=1

# Execution Command
CMD exec gunicorn main:app --bind 0.0.0.0:$PORT --workers $WORKERS --worker-class uvicorn.workers.UvicornWorker

      </code-block>
    </guideline>
  </section>
  <section title="Validation and Regression Prevention">
    <protocol id="MS-VAL-001">
      <title>Automated Independence Validation (Backend Services Only)</title>
      <instruction>AI Agents must execute this validation protocol when creating or modifying a backend microservice before finalizing the task. Frontend is excluded from this validation.</instruction>
      <validation-steps language="bash">

SERVICE_DIR=$1
cd $SERVICE_DIR

# Skip validation for frontend
if [ "$SERVICE_DIR" == "frontend" ]; then 
  echo "INFO: Frontend is exempt from isolation validation."; 
  exit 0; 
fi

# Backend service validation only
# 1. Check for forbidden 'app' directory (MS-ARC-001)
if [ -d "app" ]; then echo "ERROR: 'app' directory found in backend service."; exit 1; fi

# 2. Check for imports from main app (MS-ARC-002)
if grep -r "from app\." . --exclude-dir=venv; then echo "ERROR: Imports from main app found in backend service."; exit 1; fi

# 3. Test isolation import
python -c "from main import app" || (echo "ERROR: Isolated startup failed for backend service."; exit 1)

      </validation-steps>
    </protocol>
    <protocol id="MS-VAL-002">
      <title>Cross-Service Import Prevention</title>
      <instruction>Services must NEVER import code from other services. This includes infrastructure components like Redis managers and database connections.</instruction>
      <forbidden-patterns>
        <pattern service="auth_service">from netra_backend</pattern>
        <pattern service="netra_backend">from auth_service (except in tests)</pattern>
        <pattern description="Redis manager sharing">Importing redis_manager from another service</pattern>
      </forbidden-patterns>
      <acceptable-duplicates>
        <duplicate>Redis managers - Each service has its own</duplicate>
        <duplicate>Database managers - Each service has its own</duplicate>
        <duplicate>Configuration loaders - Each service has its own</duplicate>
        <duplicate>Environment managers - Each service has its own</duplicate>
      </acceptable-duplicates>
    </protocol>
  </section>
</specification>