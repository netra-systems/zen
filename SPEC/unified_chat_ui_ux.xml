<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Unified Chat UI/UX Specification</name>
        <type>unified_chat_ui_ux</type>
        <version>5.0</version>
        <created>2025-08-11</created>
        <updated>2025-08-11</updated>
        <description>Complete unified chat interface overhaul, adding proper thread management, overflow panel, agent deduplication, and modern visual design</description>
    </metadata>
    
    <primary-goal>Enterprise-grade chat interface with isolated thread management, real-time WebSocket streaming, intelligent agent deduplication, modern glassmorphic design (NO BLUE BARS), comprehensive developer debugging panel, and seamless multi-chat navigation</primary-goal>
    
    <core-principles>
        <principle id="real-data-only">
            <name>Real Data Only</name>
            <description>ALL displayed data must come from backend WebSocket messages. No fake or placeholder data except single presence indicator</description>
            <enforcement>TypeScript types must match backend schemas exactly</enforcement>
        </principle>
        <principle id="single-source-truth">
            <name>Single Source of Truth</name>
            <description>Each piece of information appears exactly once in its relevant context. No duplicates across UI</description>
        </principle>
        <principle id="persistent-response">
            <name>Persistent Response Card</name>
            <description>Single evolving response card that updates with fast/medium/slow data as it arrives</description>
        </principle>
        <principle id="backend-driven">
            <name>Backend-Driven UI State</name>
            <description>UI state transitions based on WebSocket events, not timers or fake data</description>
        </principle>
        <principle id="chat-isolation">
            <name>Chat Session Isolation</name>
            <description>Only one chat thread is active at a time. Switching chats loads complete thread history and context</description>
        </principle>
        <principle id="agent-deduplication">
            <name>Agent Display Deduplication</name>
            <description>Each sub-agent appears exactly once in the UI, even if called multiple times. Show latest status only</description>
        </principle>
        <principle id="component-consolidation">
            <name>Single Component Architecture</name>
            <description>One MainChat component, not multiple versions. Retire legacy components like UltraMainChat, ResponsiveMainChat</description>
            <enforcement>All chat routes must use the unified MainChat component</enforcement>
        </principle>
    </core-principles>
    
    <regression-fixes>
        <fix id="consolidate-components" priority="high">
            <issue>Multiple competing chat components causing confusion - RESOLVED</issue>
            <solution>Now using only MainChat.tsx, legacy variants archived</solution>
            <migration-status>
                <step>✅ MainChat confirmed as primary component</step>
                <step>✅ All legacy components moved to archive/</step>
                <step>✅ Test references commented out</step>
            </migration-status>
        </fix>
        <fix id="add-thread-sidebar" priority="critical">
            <issue>Missing thread sidebar for chat navigation</issue>
            <solution>Implement ChatSidebar component with thread list, new chat button, and thread switching</solution>
        </fix>
        <fix id="implement-overflow-panel" priority="high">
            <issue>No developer debugging panel for WebSocket events and performance</issue>
            <solution>Create OverflowPanel with event viewer, timeline, metrics, and error details</solution>
        </fix>
        <fix id="proper-deduplication" priority="medium">
            <issue>Duplicate agent displays when same agent runs multiple times</issue>
            <solution>Track agent executions in Map, show iteration count for reruns</solution>
        </fix>
    </regression-fixes>

    <chat-session-management>
        <thread-model>
            <description>Each chat corresponds to one Thread in backend with unique thread_id</description>
            <states>
                <state name="active">Currently visible chat with WebSocket connection</state>
                <state name="inactive">Previously created chats shown in sidebar</state>
                <state name="new">Fresh chat with no messages yet</state>
            </states>
        </thread-model>
        
        <automatic-renaming>
            <description>Conversations automatically get renamed based on first user message</description>
            <trigger>After first user message is sent</trigger>
            <implementation>
                <step>User sends first message in new thread</step>
                <step>Backend analyzes message content using LLM</step>
                <step>Generate concise 3-5 word title summarizing topic</step>
                <step>Update thread metadata with generated title</step>
                <step>Send thread_renamed WebSocket event to update UI</step>
            </implementation>
            <fallback>If title generation fails, use "Chat {timestamp}" format</fallback>
            <ui-update>Sidebar immediately reflects new title with smooth animation</ui-update>
        </automatic-renaming>
        
        <navigation-behavior>
            <rule id="new-chat">
                <trigger>Click "New Chat" button or press Ctrl+N</trigger>
                <action>Create new Thread via API, clear message area, reset state</action>
                <websocket>Disconnect from old thread, connect to new thread_id</websocket>
            </rule>
            <rule id="switch-chat">
                <trigger>Click existing chat in sidebar</trigger>
                <action>Load thread messages via API, populate message history</action>
                <websocket>Disconnect current, connect to selected thread_id</websocket>
            </rule>
            <rule id="example-click">
                <trigger>Click any example prompt</trigger>
                <action>Create new Thread, send example as first message</action>
                <note>Examples ALWAYS start new chats, never append to existing</note>
            </rule>
        </navigation-behavior>
    </chat-session-management>
    
    <backend-frontend-contract>
        <websocket-events>
            <!-- Fast Layer Events (0-100ms) -->
            <event type="agent_started">
                <payload>
                    <field name="agent_name" type="string">Current agent name</field>
                    <field name="timestamp" type="number">Unix timestamp</field>
                    <field name="run_id" type="string">Unique run identifier</field>
                </payload>
                <ui-update>Show agent name in response card header</ui-update>
            </event>
            
            <event type="tool_executing">
                <payload>
                    <field name="tool_name" type="string">Tool being executed</field>
                    <field name="agent_name" type="string">Agent using the tool</field>
                    <field name="timestamp" type="number">Start timestamp</field>
                </payload>
                <ui-update>Add tool badge to fast layer</ui-update>
            </event>
            
            <!-- Medium Layer Events (100ms-1s) -->
            <event type="agent_thinking">
                <payload>
                    <field name="thought" type="string">Current thinking/status</field>
                    <field name="agent_name" type="string">Agent name</field>
                    <field name="step_number" type="number">Current step</field>
                    <field name="total_steps" type="number">Estimated total steps</field>
                </payload>
                <ui-update>Update medium layer with thought text</ui-update>
            </event>
            
            <event type="partial_result">
                <payload>
                    <field name="content" type="string">Partial markdown content</field>
                    <field name="agent_name" type="string">Source agent</field>
                    <field name="is_complete" type="boolean">Whether this completes the section</field>
                </payload>
                <ui-update>Stream content to medium layer</ui-update>
            </event>
            
            <!-- Slow Layer Events (1s+) -->
            <event type="agent_completed">
                <payload>
                    <field name="agent_name" type="string">Completed agent</field>
                    <field name="duration_ms" type="number">Execution duration</field>
                    <field name="result" type="object">Agent-specific result data</field>
                    <field name="metrics" type="object">Performance metrics</field>
                    <field name="iteration" type="number">Which iteration if agent called multiple times</field>
                </payload>
                <ui-update>Move agent data to slow layer, deduplicate if same agent</ui-update>
            </event>
            
            <event type="final_report">
                <payload>
                    <field name="report" type="object">Complete analysis report with rich visualizations</field>
                    <field name="total_duration_ms" type="number">Total execution time</field>
                    <field name="agent_metrics" type="array">Per-agent metrics with timing breakdowns</field>
                    <field name="recommendations" type="array">Prioritized optimization recommendations with impact scores</field>
                    <field name="action_plan" type="array">Step-by-step implementation guide with effort estimates</field>
                    <field name="cost_analysis" type="object">Current vs projected costs with savings calculations</field>
                    <field name="performance_comparison" type="object">Before/after metrics with improvement percentages</field>
                    <field name="confidence_scores" type="object">Confidence levels for each recommendation</field>
                    <field name="executive_summary" type="string">High-level summary for stakeholders</field>
                    <field name="technical_details" type="object">Deep dive analysis for engineers</field>
                </payload>
                <ui-update>Populate slow layer with comprehensive, interactive report</ui-update>
            </event>
            
            <event type="error">
                <payload>
                    <field name="error_message" type="string">Error description</field>
                    <field name="error_code" type="string">Error identifier</field>
                    <field name="agent_name" type="string">Agent where error occurred</field>
                    <field name="recoverable" type="boolean">Whether processing can continue</field>
                    <field name="stack_trace" type="string">Full stack trace for debugging</field>
                </payload>
                <ui-update>Show error in appropriate layer, full trace in overflow</ui-update>
            </event>
            
            <!-- Thread Management Events -->
            <event type="thread_created">
                <payload>
                    <field name="thread_id" type="string">New thread identifier</field>
                    <field name="user_id" type="string">User who created thread</field>
                    <field name="created_at" type="number">Creation timestamp</field>
                </payload>
                <ui-update>Add to chat sidebar, mark as active</ui-update>
            </event>
            
            <event type="thread_loaded">
                <payload>
                    <field name="thread_id" type="string">Loaded thread ID</field>
                    <field name="messages" type="array">Historical messages</field>
                    <field name="metadata" type="object">Thread metadata</field>
                </payload>
                <ui-update>Populate message history, update sidebar selection</ui-update>
            </event>
            
            <!-- Run and Step Events -->
            <event type="run_started">
                <payload>
                    <field name="run_id" type="string">Unique run identifier</field>
                    <field name="thread_id" type="string">Associated thread</field>
                    <field name="assistant_id" type="string">Assistant being used</field>
                    <field name="model" type="string">Model name</field>
                </payload>
                <ui-update>Show in overflow debug panel</ui-update>
            </event>
            
            <event type="step_created">
                <payload>
                    <field name="step_id" type="string">Step identifier</field>
                    <field name="run_id" type="string">Parent run</field>
                    <field name="type" type="string">Step type (tool_call, message, etc)</field>
                    <field name="details" type="object">Step-specific details</field>
                </payload>
                <ui-update>Add to overflow timeline view</ui-update>
            </event>
        </websocket-events>
        
        <data-flow>
            <rule>Frontend NEVER generates status messages - only displays what backend sends</rule>
            <rule>Timing data comes from backend timestamps, not frontend timers</rule>
            <rule>Agent names, tool names, and status messages are backend-provided strings</rule>
            <rule>Progress percentages calculated by backend based on actual work done</rule>
            <rule>Presence indicator is the ONLY frontend-generated visual (simple spinner)</rule>
        </data-flow>
        <enhanced-websocket-handling>
            <connection-management>
                <rule>Maintain single WebSocket connection per active thread</rule>
                <rule>Clean disconnect when switching threads</rule>
                <rule>Automatic reconnection with exponential backoff</rule>
                <rule>Queue messages during reconnection</rule>
            </connection-management>
            
            <event-buffering>
                <rule>Buffer last 1000 events for overflow panel</rule>
                <rule>Circular buffer to prevent memory leaks</rule>
                <rule>Timestamp all events with high precision</rule>
                <rule>Track event source (agent, system, user)</rule>
            </event-buffering>
            
            <performance-optimizations>
                <rule>Batch UI updates within 50ms window</rule>
                <rule>Use requestAnimationFrame for smooth animations</rule>
                <rule>Debounce rapid status updates</rule>
                <rule>Virtual scrolling for large message lists</rule>
            </performance-optimizations>
        </enhanced-websocket-handling>
    </backend-frontend-contract>
    
    <comprehensive-reporting>
        <description>Rich, interactive reporting interface that transforms raw data into actionable insights</description>
        
        <report-sections>
            <section id="executive-summary">
                <position>Top of report, always visible</position>
                <content>
                    <item>One-paragraph executive summary</item>
                    <item>Key metrics dashboard with KPIs</item>
                    <item>Overall optimization potential percentage</item>
                    <item>Estimated monthly/annual savings</item>
                </content>
                <visualization>Card layout with metric tiles and trend indicators</visualization>
            </section>
            
            <section id="cost-analysis">
                <position>Below executive summary</position>
                <content>
                    <item>Current cost breakdown by service/model</item>
                    <item>Projected costs after optimizations</item>
                    <item>Interactive cost calculator</item>
                    <item>Historical cost trends chart</item>
                </content>
                <visualization>
                    <chart type="bar">Cost comparison chart</chart>
                    <chart type="pie">Cost distribution by component</chart>
                    <chart type="line">Cost trends over time</chart>
                    <calculator>Interactive sliders to adjust parameters</calculator>
                </visualization>
            </section>
            
            <section id="performance-metrics">
                <position>Major section after cost analysis</position>
                <content>
                    <item>Response time improvements</item>
                    <item>Throughput increases</item>
                    <item>Quality metrics (accuracy, relevance)</item>
                    <item>Resource utilization efficiency</item>
                </content>
                <visualization>
                    <chart type="radar">Multi-dimensional performance comparison</chart>
                    <chart type="gauge">Performance score indicators</chart>
                    <table>Detailed metrics breakdown with sparklines</table>
                </visualization>
            </section>
            
            <section id="recommendations">
                <position>Central section with high prominence</position>
                <content>
                    <item>Prioritized list of optimizations</item>
                    <item>Impact score for each recommendation</item>
                    <item>Implementation complexity rating</item>
                    <item>Quick win vs strategic initiative categorization</item>
                </content>
                <visualization>
                    <cards>Individual recommendation cards with expand/collapse</cards>
                    <matrix>Impact vs Effort matrix plot</matrix>
                    <timeline>Implementation roadmap visualization</timeline>
                </visualization>
                <interactivity>
                    <action>Click to see detailed implementation steps</action>
                    <action>Hover for impact preview</action>
                    <action>Drag to reorder priorities</action>
                </interactivity>
            </section>
            
            <section id="action-plan">
                <position>Following recommendations</position>
                <content>
                    <item>Step-by-step implementation guide</item>
                    <item>Dependencies and prerequisites</item>
                    <item>Effort estimates (hours/days)</item>
                    <item>Risk assessment and mitigation</item>
                </content>
                <visualization>
                    <stepper>Interactive step-by-step wizard</stepper>
                    <gantt>Project timeline with dependencies</gantt>
                    <checklist>Actionable checklist with progress tracking</checklist>
                </visualization>
            </section>
            
            <section id="agent-timeline">
                <position>Technical details section</position>
                <content>
                    <item>Complete agent execution timeline</item>
                    <item>Parallel vs sequential execution paths</item>
                    <item>Bottleneck identification</item>
                    <item>Agent performance metrics</item>
                </content>
                <visualization>
                    <timeline>Interactive Gantt chart of agent executions</timeline>
                    <flowchart>Agent dependency graph</flowchart>
                    <heatmap>Performance bottleneck heatmap</heatmap>
                </visualization>
            </section>
            
            <section id="technical-deep-dive">
                <position>Expandable section at bottom</position>
                <content>
                    <item>Detailed technical analysis</item>
                    <item>Code snippets and examples</item>
                    <item>API response samples</item>
                    <item>Configuration recommendations</item>
                </content>
                <format>Collapsible accordion with syntax-highlighted code</format>
            </section>
        </report-sections>
        
        <interactive-features>
            <feature id="export">
                <formats>PDF, JSON, CSV, PowerPoint</formats>
                <customization>Select sections to include</customization>
                <branding>Company logo and colors support</branding>
            </feature>
            
            <feature id="share">
                <options>Generate shareable link, email report</options>
                <permissions>View-only or interactive modes</permissions>
            </feature>
            
            <feature id="compare">
                <capability>Compare multiple optimization runs</capability>
                <visualization>Side-by-side comparison view</visualization>
            </feature>
            
            <feature id="simulate">
                <capability>What-if analysis with parameter adjustment</capability>
                <realtime>Live update of projections as parameters change</realtime>
            </feature>
        </interactive-features>
        
        <visual-enhancements>
            <enhancement>Smooth animations for data transitions</enhancement>
            <enhancement>Loading skeletons for progressive rendering</enhancement>
            <enhancement>Interactive tooltips with additional context</enhancement>
            <enhancement>Confidence indicators (high/medium/low) with visual cues</enhancement>
            <enhancement>Print-friendly layout option</enhancement>
            <enhancement>Dark mode support for reports</enhancement>
        </visual-enhancements>
    </comprehensive-reporting>
    
    <persistent-response-card>
        <structure>
            <layer id="fast" update-frequency="0-100ms">
                <name>Fast Layer - Immediate Feedback</name>
                <position>Top of card</position>
                <height>48px</height>
                <elements>
                    <element>Current agent name (from agent_started event)</element>
                    <element>Active tool badges (from tool_executing events)</element>
                    <element>Presence indicator (spinning icon, only non-data element)</element>
                </elements>
                <transitions>
                    <transition>Instant updates, no animation</transition>
                    <transition>Tool badges appear/disappear immediately</transition>
                </transitions>
            </layer>
            
            <layer id="medium" update-frequency="100ms-1s">
                <name>Medium Layer - Progressive Updates</name>
                <position>Middle of card</position>
                <height>Dynamic (min 100px, max 400px)</height>
                <elements>
                    <element>Streaming thought text (from agent_thinking events)</element>
                    <element>Partial results markdown (from partial_result events)</element>
                    <element>Step progress (X of Y steps from backend)</element>
                </elements>
                <transitions>
                    <transition>Smooth text streaming with cursor</transition>
                    <transition>Fade in for new content blocks</transition>
                </transitions>
            </layer>
            
            <layer id="slow" update-frequency="1s+">
                <name>Slow Layer - Complete Results</name>
                <position>Bottom of card</position>
                <height>Dynamic (expands as needed)</height>
                <elements>
                    <element>Completed agent results (from agent_completed events)</element>
                    <element>Final report sections (from final_report event)</element>
                    <element>Metrics and timings (from backend calculations)</element>
                    <element>Recommendations and action plans (from backend analysis)</element>
                </elements>
                <transitions>
                    <transition>Slide down animation when section completes</transition>
                    <transition>Smooth height expansion</transition>
                </transitions>
            </layer>
        </structure>
        
        <agent-deduplication>
            <rule>Track unique agent names in Set to prevent duplicates</rule>
            <rule>If agent re-runs, update existing card section rather than add new</rule>
            <rule>Show iteration count if agent runs multiple times (e.g., "Triage (2nd run)")</rule>
            <rule>Latest agent status always overwrites previous in same layer</rule>
            <known-agents>
                <agent>TriageSubAgent</agent>
                <agent>DataSubAgent</agent>
                <agent>OptimizationsCoreSubAgent</agent>
                <agent>ActionsToMeetGoalsSubAgent</agent>
                <agent>ReportingSubAgent</agent>
                <agent>CorpusAdminSubAgent</agent>
                <agent>SyntheticDataSubAgent</agent>
            </known-agents>
        </agent-deduplication>
        
        <behavior>
            <rule>Card persists throughout entire conversation</rule>
            <rule>Layers build up progressively - fast appears first, then medium, then slow</rule>
            <rule>Previous layer content moves down as new layers populate</rule>
            <rule>Completed content in slow layer becomes static and scrollable</rule>
            <rule>Card collapses to summary view after completion (expandable)</rule>
        </behavior>
    </persistent-response-card>
    
    <store-architecture>
        <store id="UnifiedChatStore">
            <description>Single source of truth for all chat state using Zustand</description>
            <location>store/unified-chat.ts</location>
            <state>
                <field name="activeThreadId" type="string | null">Currently active thread</field>
                <field name="threads" type="Map<string, Thread>">All loaded threads</field>
                <field name="messages" type="Map<string, Message[]>">Messages by thread ID</field>
                <field name="executedAgents" type="Map<string, AgentExecution>">Deduplication tracking</field>
                <field name="fastLayerData" type="FastLayerData | null">Current fast layer state</field>
                <field name="mediumLayerData" type="MediumLayerData | null">Current medium layer state</field>
                <field name="slowLayerData" type="SlowLayerData | null">Current slow layer state</field>
                <field name="isProcessing" type="boolean">Global processing state</field>
                <field name="wsEventBuffer" type="CircularBuffer<WSEvent>">Event history for debugging</field>
            </state>
            <actions>
                <action name="switchThread">Change active thread and load messages</action>
                <action name="createThread">Create new thread and set as active</action>
                <action name="updateLayerData">Update specific layer based on WS events</action>
                <action name="trackAgentExecution">Record agent run for deduplication</action>
                <action name="bufferWSEvent">Add event to circular buffer</action>
            </actions>
        </store>
    </store-architecture>
    
    <component-architecture>
        <component id="MainChat">
            <description>Root chat component - single import in app/chat</description>
            <location>components/chat/MainChat.tsx</location>
            <responsibilities>
                <item>WebSocket connection management</item>
                <item>Message history rendering</item>
                <item>Response card container</item>
            </responsibilities>
            <children>
                <child>ChatHeader</child>
                <child>MessageList</child>
                <child>PersistentResponseCard</child>
                <child>ChatInput</child>
                <child>ChatSidebar</child>
                <child>OverflowPanel</child>
            </children>
        </component>
        
        <component id="ChatSidebar">
            <description>Thread navigation sidebar with chat history</description>
            <location>components/chat/ChatSidebar.tsx</location>
            <responsibilities>
                <item>Display all user threads from database</item>
                <item>Show active thread highlight</item>
                <item>New chat button at top</item>
                <item>Thread preview with last message</item>
                <item>Timestamp and message count</item>
            </responsibilities>
            <data-source>GET /api/threads endpoint</data-source>
            <behavior>
                <rule>Load threads on mount and after new chat creation</rule>
                <rule>Show max 50 threads, paginate rest</rule>
                <rule>Sort by last_updated descending</rule>
            </behavior>
        </component>
        
        <component id="OverflowPanel">
            <description>Developer/curious user debug panel (collapsible)</description>
            <location>components/chat/OverflowPanel.tsx</location>
            <trigger>Keyboard shortcut (Ctrl+Shift+D) or settings toggle</trigger>
            <sections>
                <section name="WebSocket Events">
                    <content>Raw WebSocket event stream with timestamps</content>
                    <filter>Filter by event type, agent name</filter>
                </section>
                <section name="Run Timeline">
                    <content>Visual timeline of runs, steps, and agent executions</content>
                    <features>Gantt-style view with durations</features>
                </section>
                <section name="Backend State">
                    <content>Current thread, run, assistant IDs and metadata</content>
                    <content>User secrets status (not values)</content>
                    <content>Active supply options and models</content>
                </section>
                <section name="Performance Metrics">
                    <content>Token usage, latency by agent, cache hits</content>
                    <content>WebSocket reconnection count</content>
                    <content>Memory usage and component render counts</content>
                </section>
                <section name="Error Details">
                    <content>Full stack traces for errors</content>
                    <content>Failed API calls with request/response</content>
                    <content>Agent retry attempts</content>
                </section>
            </sections>
            <styling>
                <position>Bottom drawer or right sidebar</position>
                <height>Resizable, default 300px, max 50% viewport</height>
                <theme>Dark theme for contrast with main UI</theme>
                <font>Monospace for logs and data</font>
            </styling>
        </component>
        
        <component id="PersistentResponseCard">
            <description>Three-layer response card that evolves with real data</description>
            <location>components/chat/PersistentResponseCard.tsx</location>
            <props>
                <prop name="fastLayerData" type="FastLayerData | null">From agent_started, tool_executing</prop>
                <prop name="mediumLayerData" type="MediumLayerData | null">From agent_thinking, partial_result</prop>
                <prop name="slowLayerData" type="SlowLayerData | null">From agent_completed, final_report</prop>
                <prop name="isProcessing" type="boolean">Show presence indicator</prop>
            </props>
            <state-management>
                <rule>Props are derived from WebSocket message store</rule>
                <rule>No local state except UI-only concerns (expand/collapse)</rule>
            </state-management>
        </component>
        
        <component id="FastLayer">
            <location>components/chat/layers/FastLayer.tsx</location>
            <data-source>WebSocket events: agent_started, tool_executing</data-source>
            <update-strategy>Immediate replacement, no buffering</update-strategy>
        </component>
        
        <component id="MediumLayer">
            <location>components/chat/layers/MediumLayer.tsx</location>
            <data-source>WebSocket events: agent_thinking, partial_result</data-source>
            <update-strategy>Stream with 100ms debounce for smooth text flow</update-strategy>
        </component>
        
        <component id="SlowLayer">
            <location>components/chat/layers/SlowLayer.tsx</location>
            <data-source>WebSocket events: agent_completed, final_report</data-source>
            <update-strategy>Append completed sections, never update existing</update-strategy>
        </component>
    </component-architecture>
    
    <information-hierarchy>
        <rule id="no-duplicates">
            <description>Each piece of information appears exactly once</description>
            <examples>
                <example>Agent name: Only in FastLayer header, not repeated elsewhere</example>
                <example>Execution time: Only in SlowLayer metrics, not in header</example>
                <example>Error messages: Only in relevant layer, not duplicated</example>
            </examples>
        </rule>
        
        <rule id="progressive-disclosure">
            <description>Information revealed as it becomes available from backend</description>
            <flow>
                <step>Fast: Agent name and current tool</step>
                <step>Medium: Thinking process and partial results</step>
                <step>Slow: Complete results and metrics</step>
            </flow>
        </rule>
        
        <rule id="context-relevance">
            <description>Information shown only where contextually relevant</description>
            <placement>
                <item>Tools: Fast layer (immediate feedback needed)</item>
                <item>Thoughts: Medium layer (progressive understanding)</item>
                <item>Reports: Slow layer (complete analysis)</item>
            </placement>
        </rule>
    </information-hierarchy>
    
    <type-definitions>
        <typescript-types>
            ```typescript
            // Store architecture for proper state management
            interface UnifiedChatStore {
                // Thread Management
                activeThreadId: string | null;
                threads: Map<string, Thread>;
                messages: Map<string, Message[]>;
                
                // Layer Data (from WebSocket events)
                fastLayerData: FastLayerData | null;
                mediumLayerData: MediumLayerData | null;
                slowLayerData: SlowLayerData | null;
                
                // Agent Deduplication
                executedAgents: Map<string, AgentExecution>;
                agentIterations: Map<string, number>;
                
                // Processing State
                isProcessing: boolean;
                currentRunId: string | null;
                
                // Developer Tools
                wsEventBuffer: CircularBuffer<WSEvent>;
                performanceMetrics: PerformanceMetrics;
                
                // Actions
                switchThread: (threadId: string) => Promise<void>;
                createThread: () => Promise<string>;
                handleWSMessage: (event: WSEvent) => void;
                trackAgentExecution: (agentName: string, status: string) => void;
                resetResponseCard: () => void;
            }
            
            // Circular buffer for WebSocket events
            class CircularBuffer<T> {
                private buffer: T[];
                private maxSize: number;
                private pointer: number;
                
                constructor(maxSize: number = 1000) {
                    this.maxSize = maxSize;
                    this.buffer = [];
                    this.pointer = 0;
                }
                
                push(item: T): void {
                    if (this.buffer.length < this.maxSize) {
                        this.buffer.push(item);
                    } else {
                        this.buffer[this.pointer] = item;
                        this.pointer = (this.pointer + 1) % this.maxSize;
                    }
                }
                
                getAll(): T[] {
                    return [...this.buffer.slice(this.pointer), ...this.buffer.slice(0, this.pointer)];
                }
            }
            
            // Exact match with backend WebSocket event payloads
            interface FastLayerData {
                agentName: string;        // From agent_started event
                activeTools: string[];    // From tool_executing events
                timestamp: number;        // From backend
                runId: string;           // From backend
            }
            
            interface MediumLayerData {
                thought: string;          // From agent_thinking event
                partialContent: string;   // From partial_result events
                stepNumber: number;       // From backend
                totalSteps: number;       // From backend
                agentName: string;        // From backend
            }
            
            interface SlowLayerData {
                completedAgents: AgentResult[];     // From agent_completed events
                finalReport: FinalReport | null;    // From final_report event
                totalDuration: number;               // From backend
                metrics: ExecutionMetrics;          // From backend
            }
            
            interface AgentResult {
                agentName: string;
                duration: number;
                result: any;  // Agent-specific, from backend
                metrics: any; // Agent-specific, from backend
            }
            
            interface FinalReport {
                report: any;                        // Complete report object
                recommendations: Recommendation[];   // From backend
                actionPlan: ActionStep[];           // From backend
                agentMetrics: AgentMetric[];       // From backend
            }
            
            // Thread and Session Types (aligned with backend models)
            interface Thread {
                id: string;                         // Thread UUID
                object: 'thread';
                created_at: number;                 // Unix timestamp
                metadata: Record<string, any>;
                messages?: Message[];               // Loaded on demand
                last_message?: string;              // For sidebar preview
                message_count?: number;
                updated_at?: number;
            }
            
            interface Run {
                id: string;                         // Run UUID
                object: 'thread.run';
                thread_id: string;
                assistant_id: string;
                status: 'queued' | 'in_progress' | 'completed' | 'failed' | 'cancelled';
                created_at: number;
                started_at?: number;
                completed_at?: number;
                model?: string;
                tools: any[];
                metadata: Record<string, any>;
            }
            
            interface Step {
                id: string;                         // Step UUID
                object: 'thread.run.step';
                run_id: string;
                type: 'message_creation' | 'tool_calls';
                status: string;
                step_details: any;
                created_at: number;
                completed_at?: number;
            }
            
            interface Assistant {
                id: string;
                object: 'assistant';
                name?: string;
                description?: string;
                model: string;
                instructions?: string;
                tools: any[];
            }
            
            // Agent Deduplication Tracking
            interface AgentExecution {
                name: string;                       // Agent name
                iteration: number;                  // 1 for first run, 2+ for reruns
                status: 'running' | 'completed' | 'failed';
                start_time: number;
                end_time?: number;
                result?: any;
            }
            
            interface ChatSession {
                activeThreadId: string | null;
                threads: Thread[];                  // All user threads
                currentRun?: Run;
                executedAgents: Map<string, AgentExecution>;  // Dedup tracking
                isProcessing: boolean;
            }
            ```
        </typescript-types>
    </type-definitions>
    
    <visual-design>
        <persistent-card-styling>
            <fast-layer>
                <background>Modern glassmorphic: rgba(255, 255, 255, 0.95) with backdrop-blur-md, subtle border</background>
                <text-color>#27272A (zinc-800)</text-color>
                <height>48px fixed</height>
                <padding>12px horizontal</padding>
                <elements>
                    <agent-name>Font-weight: 600, font-size: 14px, text-zinc-800</agent-name>
                    <tool-badges>Modern pills with colored borders matching agent type, white background with subtle shadow</tool-badges>
                    <presence>Modern pulse animation with subtle green dot, 8px size</presence>
                </elements>
            </fast-layer>
            
            <medium-layer>
                <background>White with soft inset shadow for depth</background>
                <text-color>#27272A</text-color>
                <padding>16px</padding>
                <min-height>100px</min-height>
                <max-height>400px with internal scroll</max-height>
                <streaming-cursor>Smooth fade-in-out cursor with 0.5s animation</streaming-cursor>
            </medium-layer>
            
            <slow-layer>
                <background>White with subtle gradient to #FAFAFA</background>
                <border-top>1px solid #E4E4E7</border-top>
                <padding>20px</padding>
                <sections>
                    <section-header>Font-weight: 600, font-size: 16px, margin-bottom: 12px</section-header>
                    <content>Font-size: 14px, line-height: 1.6</content>
                    <metrics>Monospace font, background: white, border: 1px solid #E4E4E7</metrics>
                </sections>
            </slow-layer>
        </persistent-card-styling>
        
        <animations>
            <animation id="layer-transition">
                <description>Smooth transition as layers populate</description>
                <duration>300ms</duration>
                <easing>ease-out</easing>
                <effect>Height expansion with opacity fade-in</effect>
            </animation>
            
            <animation id="content-streaming">
                <description>Text appears character by character in medium layer</description>
                <speed>30 characters per second</speed>
                <smooth>RequestAnimationFrame for 60fps</smooth>
            </animation>
            
            <animation id="completion-collapse">
                <description>Card collapses to summary after completion</description>
                <delay>2000ms after final_report</delay>
                <duration>400ms</duration>
                <maintains>Expandable state for full view</maintains>
            </animation>
        </animations>
        <modern-ui-patterns>
            <pattern id="glassmorphism">
                <description>Consistent glassmorphic design throughout</description>
                <properties>
                    <backdrop-filter>blur(12px)</backdrop-filter>
                    <background>rgba(255, 255, 255, 0.85)</background>
                    <border>1px solid rgba(255, 255, 255, 0.18)</border>
                    <box-shadow>0 8px 32px 0 rgba(31, 38, 135, 0.07)</box-shadow>
                </properties>
            </pattern>
            <pattern id="micro-interactions">
                <hover-effects>Subtle scale(1.02) with 200ms transition</hover-effects>
                <click-feedback>Scale(0.98) for 100ms on click</click-feedback>
                <focus-states>2px offset outline in brand color</focus-states>
            </pattern>
            <pattern id="color-system">
                <primary>Emerald-500 (#10B981) for success and primary actions</primary>
                <secondary>Zinc color palette for text and borders</secondary>
                <accent>Purple-500 for AI/agent indicators</accent>
                <error>Red-500 with red-50 background</error>
                <warning>Amber-500 with amber-50 background</warning>
            </pattern>
        </modern-ui-patterns>
    </visual-design>
    
    <performance-requirements>
        <requirement id="websocket-efficiency">
            <description>Efficient WebSocket message handling</description>
            <strategies>
                <strategy>Message batching with 50ms window</strategy>
                <strategy>Selective component updates using React.memo</strategy>
                <strategy>Virtual scrolling for message history</strategy>
            </strategies>
        </requirement>
        
        <requirement id="render-performance">
            <description>60fps during all interactions</description>
            <strategies>
                <strategy>CSS transforms for animations (GPU accelerated)</strategy>
                <strategy>RequestAnimationFrame for content streaming</strategy>
                <strategy>Debounced updates for rapid events</strategy>
            </strategies>
        </requirement>
        
        <requirement id="memory-management">
            <description>Efficient memory usage for long conversations</description>
            <strategies>
                <strategy>Message pagination (load 50 at a time)</strategy>
                <strategy>Clear old WebSocket event data after processing</strategy>
                <strategy>Lazy load historical messages</strategy>
            </strategies>
        </requirement>
    </performance-requirements>
    
    <example-behaviors>
        <example id="new-chat-flow">
            <scenario>User clicks "New Chat" button</scenario>
            <steps>
                <step>Frontend calls POST /api/threads to create new thread</step>
                <step>Backend returns thread_id</step>
                <step>Frontend clears message area</step>
                <step>WebSocket disconnects from old thread_id</step>
                <step>WebSocket connects with new thread_id</step>
                <step>Sidebar updates to show new thread at top</step>
                <step>Input field gets focus</step>
            </steps>
        </example>
        
        <example id="example-prompt-flow">
            <scenario>User clicks "Optimize my LLM costs" example</scenario>
            <steps>
                <step>Frontend creates new thread (same as new-chat-flow)</step>
                <step>Example text auto-populates in input</step>
                <step>Message sends automatically</step>
                <step>New thread appears in sidebar with example as first message</step>
                <step>Previous chat remains in sidebar but inactive</step>
            </steps>
        </example>
        
        <example id="switch-chat-flow">
            <scenario>User clicks different chat in sidebar</scenario>
            <steps>
                <step>Frontend calls GET /api/threads/{thread_id}/messages</step>
                <step>Message history loads and displays</step>
                <step>WebSocket switches to new thread_id</step>
                <step>Sidebar highlights selected thread</step>
                <step>Scroll to bottom of message history</step>
                <step>Any in-progress responses in old thread continue in background</step>
            </steps>
        </example>
        
        <example id="agent-deduplication-flow">
            <scenario>TriageSubAgent runs twice in same request</scenario>
            <steps>
                <step>First agent_started event for TriageSubAgent</step>
                <step>Fast layer shows "TriageSubAgent" badge</step>
                <step>Agent completes, moves to slow layer</step>
                <step>Second agent_started event for TriageSubAgent</step>
                <step>Fast layer shows "TriageSubAgent (2)" badge</step>
                <step>On completion, slow layer updates existing section</step>
                <step>Only one TriageSubAgent section visible in final view</step>
            </steps>
        </example>
        
        <example id="overflow-debug-flow">
            <scenario>Developer presses Ctrl+Shift+D</scenario>
            <steps>
                <step>Overflow panel slides up from bottom</step>
                <step>Shows last 100 WebSocket events in scrollable list</step>
                <step>Timeline view shows current run with agent durations</step>
                <step>Click event to see full JSON payload</step>
                <step>Filter events by type or search by content</step>
                <step>Export debug data as JSON for issue reporting</step>
            </steps>
        </example>
        <example id="modern-ui-interaction">
            <scenario>User hovers over agent badge in fast layer</scenario>
            <steps>
                <step>Badge scales up slightly (1.02) with smooth transition</step>
                <step>Tooltip appears showing agent description and current task</step>
                <step>Subtle shadow deepens to indicate interactivity</step>
            </steps>
        </example>
        
        <example id="overflow-panel-usage">
            <scenario>Developer presses Ctrl+Shift+D during active chat</scenario>
            <steps>
                <step>Overflow panel slides up from bottom with smooth animation</step>
                <step>Dark theme automatically applied for contrast</step>
                <step>WebSocket events stream shows last 100 events</step>
                <step>Timeline shows current run with agent execution times</step>
                <step>Performance metrics update in real-time</step>
                <step>Developer can filter events by type or search content</step>
                <step>Click 'Export Debug Data' to download JSON log</step>
            </steps>
        </example>
        
        <example id="thread-management-flow">
            <scenario>User has 5 active chats and switches between them</scenario>
            <steps>
                <step>ChatSidebar shows all 5 threads with last message preview</step>
                <step>Current thread highlighted with emerald-500 accent</step>
                <step>User clicks different thread in sidebar</step>
                <step>Smooth fade transition as message history loads</step>
                <step>WebSocket reconnects to new thread_id</step>
                <step>Previous thread continues processing in background</step>
                <step>Notification badge appears when background thread completes</step>
            </steps>
        </example>
    </example-behaviors>
    
    <testing-requirements>
        <unit-tests>
            <test>PersistentResponseCard renders correct layers based on props</test>
            <test>Layers update only with matching WebSocket events</test>
            <test>No duplicate information across layers</test>
            <test>Type safety between backend events and frontend types</test>
        </unit-tests>
        
        <integration-tests>
            <test>WebSocket events trigger correct UI updates</test>
            <test>Fast/medium/slow layers populate in correct order</test>
            <test>Error events handled appropriately per layer</test>
            <test>Complete flow from agent_started to final_report</test>
        </integration-tests>
        
        <e2e-tests>
            <test>Full conversation with real backend data</test>
            <test>Response card persists across component re-renders</test>
            <test>Performance remains smooth with 100+ messages</test>
            <test>Graceful handling of WebSocket disconnection/reconnection</test>
        </e2e-tests>
        <regression-tests>
            <test priority="critical">Test proper thread isolation - messages don't leak between threads</test>
            <test priority="critical">Verify agent deduplication - same agent shows once with iteration count</test>
            <test priority="high">Test ChatSidebar thread switching with 50+ threads</test>
            <test priority="high">Verify overflow panel shows accurate WebSocket events</test>
            <test priority="high">Test performance with 1000+ messages in single thread</test>
            <test priority="medium">Verify glassmorphic styling renders correctly</test>
            <test priority="medium">Test keyboard shortcuts for developer tools</test>
        </regression-tests>
    </testing-requirements>
    
    <implementation-checklist>
        <phase number="1" name="Type Alignment">
            <task priority="critical">Create TypeScript interfaces for Thread, Run, Step, Assistant models</task>
            <task priority="critical">Add WebSocket event types for thread management</task>
            <task>Generate types from backend Pydantic schemas</task>
            <task>Validate no type mismatches between frontend and backend</task>
            <task>Add ChatSession state interface with deduplication tracking</task>
        </phase>
        
        <phase number="2" name="Chat Session Management">
            <task priority="critical">Implement ChatSidebar component with thread list</task>
            <task priority="critical">Add thread switching logic with WebSocket reconnection</task>
            <task priority="critical">Implement "New Chat" button creating fresh threads</task>
            <task>Add example prompts that auto-create new chats</task>
            <task>Store active thread_id in localStorage for persistence</task>
            <task>Implement thread pagination for users with many chats</task>
        </phase>
        
        <phase number="3" name="Agent Deduplication">
            <task priority="critical">Create Map to track executed agents per thread</task>
            <task priority="critical">Implement deduplication logic in PersistentResponseCard</task>
            <task>Show iteration count for re-executed agents</task>
            <task>Update only latest agent status in UI layers</task>
            <task>Add visual indicator for agent reruns</task>
        </phase>
        
        <phase number="4" name="Persistent Card Implementation">
            <task>Build PersistentResponseCard component with three layers</task>
            <task>Implement FastLayer with agent deduplication</task>
            <task>Implement MediumLayer with streaming from agent_thinking</task>
            <task>Implement SlowLayer with deduplicated agent results</task>
            <task>Add collapse/expand behavior after completion</task>
        </phase>
        
        <phase number="5" name="Overflow Debug Panel">
            <task priority="high">Create OverflowPanel component with drawer animation</task>
            <task priority="high">Implement WebSocket event stream viewer</task>
            <task>Add Run timeline with Gantt visualization</task>
            <task>Display backend state (thread, run, assistant IDs)</task>
            <task>Add performance metrics dashboard</task>
            <task>Implement error detail viewer with stack traces</task>
            <task>Add export functionality for debug data</task>
            <task>Create keyboard shortcut (Ctrl+Shift+D) trigger</task>
        </phase>
        
        <phase number="6" name="WebSocket Integration">
            <task>Update WebSocketProvider for thread-specific connections</task>
            <task>Handle thread_created and thread_loaded events</task>
            <task>Implement run_started and step_created events</task>
            <task>Add reconnection logic when switching threads</task>
            <task>Create event buffer for overflow panel</task>
        </phase>
        
        <phase number="7" name="Backend Integration">
            <task priority="critical">Implement POST /api/threads for new chats</task>
            <task priority="critical">Implement GET /api/threads for sidebar list</task>
            <task priority="critical">Implement GET /api/threads/{id}/messages</task>
            <task>Add thread metadata updates</task>
            <task>Ensure user_id association for all threads</task>
        </phase>
        
        <phase number="8" name="Testing and Validation">
            <task>Test chat isolation - only one active at a time</task>
            <task>Test example prompts create new chats</task>
            <task>Test agent deduplication across multiple runs</task>
            <task>Test overflow panel data accuracy</task>
            <task>Test thread switching preserves message history</task>
            <task>Performance test with 100+ threads in sidebar</task>
            <task>E2E test complete user journey with multiple chats</task>
        </phase>
        <phase number="9" name="Remove Legacy Code">
            <task priority="high">Archive UltraMainChat, ResponsiveMainChat components</task>
            <task priority="high">Consolidate to single MainChat component</task>
            <task priority="medium">Remove duplicate chat component imports</task>
        </phase>
        
        <phase number="10" name="Modern UI Implementation">
            <task priority="critical">Implement glassmorphic design system</task>
            <task priority="critical">Add proper thread sidebar with smooth animations</task>
            <task priority="high">Create collapsible overflow panel with dark theme</task>
            <task priority="high">Add micro-interactions to all interactive elements</task>
            <task priority="medium">Implement smooth streaming text with modern cursor</task>
            <task priority="medium">Add haptic feedback indicators for mobile</task>
        </phase>
        
        <phase number="11" name="Enhanced Developer Experience">
            <task priority="high">Create WebSocket event inspector with filtering</task>
            <task priority="high">Add performance metrics dashboard in overflow panel</task>
            <task priority="high">Implement run timeline with Gantt visualization</task>
            <task priority="medium">Add export functionality for debug logs</task>
            <task priority="medium">Create keyboard shortcuts for developer tools (Ctrl+Shift+D)</task>
            <task priority="low">Add theme toggle for overflow panel (dark/light)</task>
        </phase>
        
        <phase number="12" name="Testing and Quality Assurance">
            <task priority="critical">Verify proper thread isolation and switching</task>
            <task priority="critical">Test agent deduplication with multiple reruns</task>
            <task priority="high">Performance test with 100+ messages and threads</task>
            <task priority="high">Test WebSocket reconnection and error recovery</task>
            <task priority="medium">Accessibility audit for WCAG 2.1 AA compliance</task>
            <task priority="medium">Cross-browser testing (Chrome, Firefox, Safari, Edge)</task>
        </phase>
    </implementation-checklist>
</specification>