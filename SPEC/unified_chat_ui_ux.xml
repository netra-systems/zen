<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Unified Chat UI/UX Specification</name>
        <type>unified_chat_ui_ux</type>
        <version>5.0</version>
        <created>2025-08-11</created>
        <updated>2025-08-11</updated>
        <description>Unified chat interface with isolated chat sessions, deduplication, backend schema alignment, and developer overflow</description>
    </metadata>
    
    <primary-goal>World-class chat interface with isolated chat sessions, REAL backend data, intelligent response streaming, zero duplicate information, and developer-friendly debugging</primary-goal>
    
    <core-principles>
        <principle id="real-data-only">
            <name>Real Data Only</name>
            <description>ALL displayed data must come from backend WebSocket messages. No fake or placeholder data except single presence indicator</description>
            <enforcement>TypeScript types must match backend schemas exactly</enforcement>
        </principle>
        <principle id="single-source-truth">
            <name>Single Source of Truth</name>
            <description>Each piece of information appears exactly once in its relevant context. No duplicates across UI</description>
        </principle>
        <principle id="persistent-response">
            <name>Persistent Response Card</name>
            <description>Single evolving response card that updates with fast/medium/slow data as it arrives</description>
        </principle>
        <principle id="backend-driven">
            <name>Backend-Driven UI State</name>
            <description>UI state transitions based on WebSocket events, not timers or fake data</description>
        </principle>
        <principle id="chat-isolation">
            <name>Chat Session Isolation</name>
            <description>Only one chat thread is active at a time. Switching chats loads complete thread history and context</description>
        </principle>
        <principle id="agent-deduplication">
            <name>Agent Display Deduplication</name>
            <description>Each sub-agent appears exactly once in the UI, even if called multiple times. Show latest status only</description>
        </principle>
    </core-principles>
    
    <chat-session-management>
        <thread-model>
            <description>Each chat corresponds to one Thread in backend with unique thread_id</description>
            <states>
                <state name="active">Currently visible chat with WebSocket connection</state>
                <state name="inactive">Previously created chats shown in sidebar</state>
                <state name="new">Fresh chat with no messages yet</state>
            </states>
        </thread-model>
        
        <navigation-behavior>
            <rule id="new-chat">
                <trigger>Click "New Chat" button or press Ctrl+N</trigger>
                <action>Create new Thread via API, clear message area, reset state</action>
                <websocket>Disconnect from old thread, connect to new thread_id</websocket>
            </rule>
            <rule id="switch-chat">
                <trigger>Click existing chat in sidebar</trigger>
                <action>Load thread messages via API, populate message history</action>
                <websocket>Disconnect current, connect to selected thread_id</websocket>
            </rule>
            <rule id="example-click">
                <trigger>Click any example prompt</trigger>
                <action>Create new Thread, send example as first message</action>
                <note>Examples ALWAYS start new chats, never append to existing</note>
            </rule>
        </navigation-behavior>
    </chat-session-management>
    
    <backend-frontend-contract>
        <websocket-events>
            <!-- Fast Layer Events (0-100ms) -->
            <event type="agent_started">
                <payload>
                    <field name="agent_name" type="string">Current agent name</field>
                    <field name="timestamp" type="number">Unix timestamp</field>
                    <field name="run_id" type="string">Unique run identifier</field>
                </payload>
                <ui-update>Show agent name in response card header</ui-update>
            </event>
            
            <event type="tool_executing">
                <payload>
                    <field name="tool_name" type="string">Tool being executed</field>
                    <field name="agent_name" type="string">Agent using the tool</field>
                    <field name="timestamp" type="number">Start timestamp</field>
                </payload>
                <ui-update>Add tool badge to fast layer</ui-update>
            </event>
            
            <!-- Medium Layer Events (100ms-1s) -->
            <event type="agent_thinking">
                <payload>
                    <field name="thought" type="string">Current thinking/status</field>
                    <field name="agent_name" type="string">Agent name</field>
                    <field name="step_number" type="number">Current step</field>
                    <field name="total_steps" type="number">Estimated total steps</field>
                </payload>
                <ui-update>Update medium layer with thought text</ui-update>
            </event>
            
            <event type="partial_result">
                <payload>
                    <field name="content" type="string">Partial markdown content</field>
                    <field name="agent_name" type="string">Source agent</field>
                    <field name="is_complete" type="boolean">Whether this completes the section</field>
                </payload>
                <ui-update>Stream content to medium layer</ui-update>
            </event>
            
            <!-- Slow Layer Events (1s+) -->
            <event type="agent_completed">
                <payload>
                    <field name="agent_name" type="string">Completed agent</field>
                    <field name="duration_ms" type="number">Execution duration</field>
                    <field name="result" type="object">Agent-specific result data</field>
                    <field name="metrics" type="object">Performance metrics</field>
                    <field name="iteration" type="number">Which iteration if agent called multiple times</field>
                </payload>
                <ui-update>Move agent data to slow layer, deduplicate if same agent</ui-update>
            </event>
            
            <event type="final_report">
                <payload>
                    <field name="report" type="object">Complete analysis report</field>
                    <field name="total_duration_ms" type="number">Total execution time</field>
                    <field name="agent_metrics" type="array">Per-agent metrics</field>
                    <field name="recommendations" type="array">Optimization recommendations</field>
                    <field name="action_plan" type="array">Implementation steps</field>
                </payload>
                <ui-update>Populate slow layer with complete report</ui-update>
            </event>
            
            <event type="error">
                <payload>
                    <field name="error_message" type="string">Error description</field>
                    <field name="error_code" type="string">Error identifier</field>
                    <field name="agent_name" type="string">Agent where error occurred</field>
                    <field name="recoverable" type="boolean">Whether processing can continue</field>
                    <field name="stack_trace" type="string">Full stack trace for debugging</field>
                </payload>
                <ui-update>Show error in appropriate layer, full trace in overflow</ui-update>
            </event>
            
            <!-- Thread Management Events -->
            <event type="thread_created">
                <payload>
                    <field name="thread_id" type="string">New thread identifier</field>
                    <field name="user_id" type="string">User who created thread</field>
                    <field name="created_at" type="number">Creation timestamp</field>
                </payload>
                <ui-update>Add to chat sidebar, mark as active</ui-update>
            </event>
            
            <event type="thread_loaded">
                <payload>
                    <field name="thread_id" type="string">Loaded thread ID</field>
                    <field name="messages" type="array">Historical messages</field>
                    <field name="metadata" type="object">Thread metadata</field>
                </payload>
                <ui-update>Populate message history, update sidebar selection</ui-update>
            </event>
            
            <!-- Run and Step Events -->
            <event type="run_started">
                <payload>
                    <field name="run_id" type="string">Unique run identifier</field>
                    <field name="thread_id" type="string">Associated thread</field>
                    <field name="assistant_id" type="string">Assistant being used</field>
                    <field name="model" type="string">Model name</field>
                </payload>
                <ui-update>Show in overflow debug panel</ui-update>
            </event>
            
            <event type="step_created">
                <payload>
                    <field name="step_id" type="string">Step identifier</field>
                    <field name="run_id" type="string">Parent run</field>
                    <field name="type" type="string">Step type (tool_call, message, etc)</field>
                    <field name="details" type="object">Step-specific details</field>
                </payload>
                <ui-update>Add to overflow timeline view</ui-update>
            </event>
        </websocket-events>
        
        <data-flow>
            <rule>Frontend NEVER generates status messages - only displays what backend sends</rule>
            <rule>Timing data comes from backend timestamps, not frontend timers</rule>
            <rule>Agent names, tool names, and status messages are backend-provided strings</rule>
            <rule>Progress percentages calculated by backend based on actual work done</rule>
            <rule>Presence indicator is the ONLY frontend-generated visual (simple spinner)</rule>
        </data-flow>
    </backend-frontend-contract>
    
    <persistent-response-card>
        <structure>
            <layer id="fast" update-frequency="0-100ms">
                <name>Fast Layer - Immediate Feedback</name>
                <position>Top of card</position>
                <height>48px</height>
                <elements>
                    <element>Current agent name (from agent_started event)</element>
                    <element>Active tool badges (from tool_executing events)</element>
                    <element>Presence indicator (spinning icon, only non-data element)</element>
                </elements>
                <transitions>
                    <transition>Instant updates, no animation</transition>
                    <transition>Tool badges appear/disappear immediately</transition>
                </transitions>
            </layer>
            
            <layer id="medium" update-frequency="100ms-1s">
                <name>Medium Layer - Progressive Updates</name>
                <position>Middle of card</position>
                <height>Dynamic (min 100px, max 400px)</height>
                <elements>
                    <element>Streaming thought text (from agent_thinking events)</element>
                    <element>Partial results markdown (from partial_result events)</element>
                    <element>Step progress (X of Y steps from backend)</element>
                </elements>
                <transitions>
                    <transition>Smooth text streaming with cursor</transition>
                    <transition>Fade in for new content blocks</transition>
                </transitions>
            </layer>
            
            <layer id="slow" update-frequency="1s+">
                <name>Slow Layer - Complete Results</name>
                <position>Bottom of card</position>
                <height>Dynamic (expands as needed)</height>
                <elements>
                    <element>Completed agent results (from agent_completed events)</element>
                    <element>Final report sections (from final_report event)</element>
                    <element>Metrics and timings (from backend calculations)</element>
                    <element>Recommendations and action plans (from backend analysis)</element>
                </elements>
                <transitions>
                    <transition>Slide down animation when section completes</transition>
                    <transition>Smooth height expansion</transition>
                </transitions>
            </layer>
        </structure>
        
        <agent-deduplication>
            <rule>Track unique agent names in Set to prevent duplicates</rule>
            <rule>If agent re-runs, update existing card section rather than add new</rule>
            <rule>Show iteration count if agent runs multiple times (e.g., "Triage (2nd run)")</rule>
            <rule>Latest agent status always overwrites previous in same layer</rule>
            <known-agents>
                <agent>TriageSubAgent</agent>
                <agent>DataSubAgent</agent>
                <agent>OptimizationsCoreSubAgent</agent>
                <agent>ActionsToMeetGoalsSubAgent</agent>
                <agent>ReportingSubAgent</agent>
                <agent>CorpusAdminSubAgent</agent>
                <agent>SyntheticDataSubAgent</agent>
            </known-agents>
        </agent-deduplication>
        
        <behavior>
            <rule>Card persists throughout entire conversation</rule>
            <rule>Layers build up progressively - fast appears first, then medium, then slow</rule>
            <rule>Previous layer content moves down as new layers populate</rule>
            <rule>Completed content in slow layer becomes static and scrollable</rule>
            <rule>Card collapses to summary view after completion (expandable)</rule>
        </behavior>
    </persistent-response-card>
    
    <component-architecture>
        <component id="MainChat">
            <description>Root chat component - single import in app/chat</description>
            <location>components/chat/MainChat.tsx</location>
            <responsibilities>
                <item>WebSocket connection management</item>
                <item>Message history rendering</item>
                <item>Response card container</item>
            </responsibilities>
            <children>
                <child>ChatHeader</child>
                <child>MessageList</child>
                <child>PersistentResponseCard</child>
                <child>ChatInput</child>
                <child>ChatSidebar</child>
                <child>OverflowPanel</child>
            </children>
        </component>
        
        <component id="ChatSidebar">
            <description>Thread navigation sidebar with chat history</description>
            <location>components/chat/ChatSidebar.tsx</location>
            <responsibilities>
                <item>Display all user threads from database</item>
                <item>Show active thread highlight</item>
                <item>New chat button at top</item>
                <item>Thread preview with last message</item>
                <item>Timestamp and message count</item>
            </responsibilities>
            <data-source>GET /api/threads endpoint</data-source>
            <behavior>
                <rule>Load threads on mount and after new chat creation</rule>
                <rule>Show max 50 threads, paginate rest</rule>
                <rule>Sort by last_updated descending</rule>
            </behavior>
        </component>
        
        <component id="OverflowPanel">
            <description>Developer/curious user debug panel (collapsible)</description>
            <location>components/chat/OverflowPanel.tsx</location>
            <trigger>Keyboard shortcut (Ctrl+Shift+D) or settings toggle</trigger>
            <sections>
                <section name="WebSocket Events">
                    <content>Raw WebSocket event stream with timestamps</content>
                    <filter>Filter by event type, agent name</filter>
                </section>
                <section name="Run Timeline">
                    <content>Visual timeline of runs, steps, and agent executions</content>
                    <features>Gantt-style view with durations</features>
                </section>
                <section name="Backend State">
                    <content>Current thread, run, assistant IDs and metadata</content>
                    <content>User secrets status (not values)</content>
                    <content>Active supply options and models</content>
                </section>
                <section name="Performance Metrics">
                    <content>Token usage, latency by agent, cache hits</content>
                    <content>WebSocket reconnection count</content>
                    <content>Memory usage and component render counts</content>
                </section>
                <section name="Error Details">
                    <content>Full stack traces for errors</content>
                    <content>Failed API calls with request/response</content>
                    <content>Agent retry attempts</content>
                </section>
            </sections>
            <styling>
                <position>Bottom drawer or right sidebar</position>
                <height>Resizable, default 300px, max 50% viewport</height>
                <theme>Dark theme for contrast with main UI</theme>
                <font>Monospace for logs and data</font>
            </styling>
        </component>
        
        <component id="PersistentResponseCard">
            <description>Three-layer response card that evolves with real data</description>
            <location>components/chat/PersistentResponseCard.tsx</location>
            <props>
                <prop name="fastLayerData" type="FastLayerData | null">From agent_started, tool_executing</prop>
                <prop name="mediumLayerData" type="MediumLayerData | null">From agent_thinking, partial_result</prop>
                <prop name="slowLayerData" type="SlowLayerData | null">From agent_completed, final_report</prop>
                <prop name="isProcessing" type="boolean">Show presence indicator</prop>
            </props>
            <state-management>
                <rule>Props are derived from WebSocket message store</rule>
                <rule>No local state except UI-only concerns (expand/collapse)</rule>
            </state-management>
        </component>
        
        <component id="FastLayer">
            <location>components/chat/layers/FastLayer.tsx</location>
            <data-source>WebSocket events: agent_started, tool_executing</data-source>
            <update-strategy>Immediate replacement, no buffering</update-strategy>
        </component>
        
        <component id="MediumLayer">
            <location>components/chat/layers/MediumLayer.tsx</location>
            <data-source>WebSocket events: agent_thinking, partial_result</data-source>
            <update-strategy>Stream with 100ms debounce for smooth text flow</update-strategy>
        </component>
        
        <component id="SlowLayer">
            <location>components/chat/layers/SlowLayer.tsx</location>
            <data-source>WebSocket events: agent_completed, final_report</data-source>
            <update-strategy>Append completed sections, never update existing</update-strategy>
        </component>
    </component-architecture>
    
    <information-hierarchy>
        <rule id="no-duplicates">
            <description>Each piece of information appears exactly once</description>
            <examples>
                <example>Agent name: Only in FastLayer header, not repeated elsewhere</example>
                <example>Execution time: Only in SlowLayer metrics, not in header</example>
                <example>Error messages: Only in relevant layer, not duplicated</example>
            </examples>
        </rule>
        
        <rule id="progressive-disclosure">
            <description>Information revealed as it becomes available from backend</description>
            <flow>
                <step>Fast: Agent name and current tool</step>
                <step>Medium: Thinking process and partial results</step>
                <step>Slow: Complete results and metrics</step>
            </flow>
        </rule>
        
        <rule id="context-relevance">
            <description>Information shown only where contextually relevant</description>
            <placement>
                <item>Tools: Fast layer (immediate feedback needed)</item>
                <item>Thoughts: Medium layer (progressive understanding)</item>
                <item>Reports: Slow layer (complete analysis)</item>
            </placement>
        </rule>
    </information-hierarchy>
    
    <type-definitions>
        <typescript-types>
            ```typescript
            // Exact match with backend WebSocket event payloads
            interface FastLayerData {
                agentName: string;        // From agent_started event
                activeTools: string[];    // From tool_executing events
                timestamp: number;        // From backend
                runId: string;           // From backend
            }
            
            interface MediumLayerData {
                thought: string;          // From agent_thinking event
                partialContent: string;   // From partial_result events
                stepNumber: number;       // From backend
                totalSteps: number;       // From backend
                agentName: string;        // From backend
            }
            
            interface SlowLayerData {
                completedAgents: AgentResult[];     // From agent_completed events
                finalReport: FinalReport | null;    // From final_report event
                totalDuration: number;               // From backend
                metrics: ExecutionMetrics;          // From backend
            }
            
            interface AgentResult {
                agentName: string;
                duration: number;
                result: any;  // Agent-specific, from backend
                metrics: any; // Agent-specific, from backend
            }
            
            interface FinalReport {
                report: any;                        // Complete report object
                recommendations: Recommendation[];   // From backend
                actionPlan: ActionStep[];           // From backend
                agentMetrics: AgentMetric[];       // From backend
            }
            
            // Thread and Session Types (aligned with backend models)
            interface Thread {
                id: string;                         // Thread UUID
                object: 'thread';
                created_at: number;                 // Unix timestamp
                metadata: Record<string, any>;
                messages?: Message[];               // Loaded on demand
                last_message?: string;              // For sidebar preview
                message_count?: number;
                updated_at?: number;
            }
            
            interface Run {
                id: string;                         // Run UUID
                object: 'thread.run';
                thread_id: string;
                assistant_id: string;
                status: 'queued' | 'in_progress' | 'completed' | 'failed' | 'cancelled';
                created_at: number;
                started_at?: number;
                completed_at?: number;
                model?: string;
                tools: any[];
                metadata: Record<string, any>;
            }
            
            interface Step {
                id: string;                         // Step UUID
                object: 'thread.run.step';
                run_id: string;
                type: 'message_creation' | 'tool_calls';
                status: string;
                step_details: any;
                created_at: number;
                completed_at?: number;
            }
            
            interface Assistant {
                id: string;
                object: 'assistant';
                name?: string;
                description?: string;
                model: string;
                instructions?: string;
                tools: any[];
            }
            
            // Agent Deduplication Tracking
            interface AgentExecution {
                name: string;                       // Agent name
                iteration: number;                  // 1 for first run, 2+ for reruns
                status: 'running' | 'completed' | 'failed';
                start_time: number;
                end_time?: number;
                result?: any;
            }
            
            interface ChatSession {
                activeThreadId: string | null;
                threads: Thread[];                  // All user threads
                currentRun?: Run;
                executedAgents: Map<string, AgentExecution>;  // Dedup tracking
                isProcessing: boolean;
            }
            ```
        </typescript-types>
    </type-definitions>
    
    <visual-design>
        <persistent-card-styling>
            <fast-layer>
                <background>Linear gradient: #3B82F6 to #2563EB</background>
                <text-color>White</text-color>
                <height>48px fixed</height>
                <padding>12px horizontal</padding>
                <elements>
                    <agent-name>Font-weight: 600, font-size: 14px</agent-name>
                    <tool-badges>Rounded pills, 8px padding, semi-transparent background</tool-badges>
                    <presence>Animated spin, 16px size, opacity 0.8</presence>
                </elements>
            </fast-layer>
            
            <medium-layer>
                <background>White with subtle top shadow</background>
                <text-color>#27272A</text-color>
                <padding>16px</padding>
                <min-height>100px</min-height>
                <max-height>400px with internal scroll</max-height>
                <streaming-cursor>Blinking vertical bar at text end</streaming-cursor>
            </medium-layer>
            
            <slow-layer>
                <background>#FAFAFA</background>
                <border-top>1px solid #E4E4E7</border-top>
                <padding>20px</padding>
                <sections>
                    <section-header>Font-weight: 600, font-size: 16px, margin-bottom: 12px</section-header>
                    <content>Font-size: 14px, line-height: 1.6</content>
                    <metrics>Monospace font, background: white, border: 1px solid #E4E4E7</metrics>
                </sections>
            </slow-layer>
        </persistent-card-styling>
        
        <animations>
            <animation id="layer-transition">
                <description>Smooth transition as layers populate</description>
                <duration>300ms</duration>
                <easing>ease-out</easing>
                <effect>Height expansion with opacity fade-in</effect>
            </animation>
            
            <animation id="content-streaming">
                <description>Text appears character by character in medium layer</description>
                <speed>30 characters per second</speed>
                <smooth>RequestAnimationFrame for 60fps</smooth>
            </animation>
            
            <animation id="completion-collapse">
                <description>Card collapses to summary after completion</description>
                <delay>2000ms after final_report</delay>
                <duration>400ms</duration>
                <maintains>Expandable state for full view</maintains>
            </animation>
        </animations>
    </visual-design>
    
    <performance-requirements>
        <requirement id="websocket-efficiency">
            <description>Efficient WebSocket message handling</description>
            <strategies>
                <strategy>Message batching with 50ms window</strategy>
                <strategy>Selective component updates using React.memo</strategy>
                <strategy>Virtual scrolling for message history</strategy>
            </strategies>
        </requirement>
        
        <requirement id="render-performance">
            <description>60fps during all interactions</description>
            <strategies>
                <strategy>CSS transforms for animations (GPU accelerated)</strategy>
                <strategy>RequestAnimationFrame for content streaming</strategy>
                <strategy>Debounced updates for rapid events</strategy>
            </strategies>
        </requirement>
        
        <requirement id="memory-management">
            <description>Efficient memory usage for long conversations</description>
            <strategies>
                <strategy>Message pagination (load 50 at a time)</strategy>
                <strategy>Clear old WebSocket event data after processing</strategy>
                <strategy>Lazy load historical messages</strategy>
            </strategies>
        </requirement>
    </performance-requirements>
    
    <example-behaviors>
        <example id="new-chat-flow">
            <scenario>User clicks "New Chat" button</scenario>
            <steps>
                <step>Frontend calls POST /api/threads to create new thread</step>
                <step>Backend returns thread_id</step>
                <step>Frontend clears message area</step>
                <step>WebSocket disconnects from old thread_id</step>
                <step>WebSocket connects with new thread_id</step>
                <step>Sidebar updates to show new thread at top</step>
                <step>Input field gets focus</step>
            </steps>
        </example>
        
        <example id="example-prompt-flow">
            <scenario>User clicks "Optimize my LLM costs" example</scenario>
            <steps>
                <step>Frontend creates new thread (same as new-chat-flow)</step>
                <step>Example text auto-populates in input</step>
                <step>Message sends automatically</step>
                <step>New thread appears in sidebar with example as first message</step>
                <step>Previous chat remains in sidebar but inactive</step>
            </steps>
        </example>
        
        <example id="switch-chat-flow">
            <scenario>User clicks different chat in sidebar</scenario>
            <steps>
                <step>Frontend calls GET /api/threads/{thread_id}/messages</step>
                <step>Message history loads and displays</step>
                <step>WebSocket switches to new thread_id</step>
                <step>Sidebar highlights selected thread</step>
                <step>Scroll to bottom of message history</step>
                <step>Any in-progress responses in old thread continue in background</step>
            </steps>
        </example>
        
        <example id="agent-deduplication-flow">
            <scenario>TriageSubAgent runs twice in same request</scenario>
            <steps>
                <step>First agent_started event for TriageSubAgent</step>
                <step>Fast layer shows "TriageSubAgent" badge</step>
                <step>Agent completes, moves to slow layer</step>
                <step>Second agent_started event for TriageSubAgent</step>
                <step>Fast layer shows "TriageSubAgent (2)" badge</step>
                <step>On completion, slow layer updates existing section</step>
                <step>Only one TriageSubAgent section visible in final view</step>
            </steps>
        </example>
        
        <example id="overflow-debug-flow">
            <scenario>Developer presses Ctrl+Shift+D</scenario>
            <steps>
                <step>Overflow panel slides up from bottom</step>
                <step>Shows last 100 WebSocket events in scrollable list</step>
                <step>Timeline view shows current run with agent durations</step>
                <step>Click event to see full JSON payload</step>
                <step>Filter events by type or search by content</step>
                <step>Export debug data as JSON for issue reporting</step>
            </steps>
        </example>
    </example-behaviors>
    
    <testing-requirements>
        <unit-tests>
            <test>PersistentResponseCard renders correct layers based on props</test>
            <test>Layers update only with matching WebSocket events</test>
            <test>No duplicate information across layers</test>
            <test>Type safety between backend events and frontend types</test>
        </unit-tests>
        
        <integration-tests>
            <test>WebSocket events trigger correct UI updates</test>
            <test>Fast/medium/slow layers populate in correct order</test>
            <test>Error events handled appropriately per layer</test>
            <test>Complete flow from agent_started to final_report</test>
        </integration-tests>
        
        <e2e-tests>
            <test>Full conversation with real backend data</test>
            <test>Response card persists across component re-renders</test>
            <test>Performance remains smooth with 100+ messages</test>
            <test>Graceful handling of WebSocket disconnection/reconnection</test>
        </e2e-tests>
    </testing-requirements>
    
    <implementation-checklist>
        <phase number="1" name="Type Alignment">
            <task priority="critical">Create TypeScript interfaces for Thread, Run, Step, Assistant models</task>
            <task priority="critical">Add WebSocket event types for thread management</task>
            <task>Generate types from backend Pydantic schemas</task>
            <task>Validate no type mismatches between frontend and backend</task>
            <task>Add ChatSession state interface with deduplication tracking</task>
        </phase>
        
        <phase number="2" name="Chat Session Management">
            <task priority="critical">Implement ChatSidebar component with thread list</task>
            <task priority="critical">Add thread switching logic with WebSocket reconnection</task>
            <task priority="critical">Implement "New Chat" button creating fresh threads</task>
            <task>Add example prompts that auto-create new chats</task>
            <task>Store active thread_id in localStorage for persistence</task>
            <task>Implement thread pagination for users with many chats</task>
        </phase>
        
        <phase number="3" name="Agent Deduplication">
            <task priority="critical">Create Map to track executed agents per thread</task>
            <task priority="critical">Implement deduplication logic in PersistentResponseCard</task>
            <task>Show iteration count for re-executed agents</task>
            <task>Update only latest agent status in UI layers</task>
            <task>Add visual indicator for agent reruns</task>
        </phase>
        
        <phase number="4" name="Persistent Card Implementation">
            <task>Build PersistentResponseCard component with three layers</task>
            <task>Implement FastLayer with agent deduplication</task>
            <task>Implement MediumLayer with streaming from agent_thinking</task>
            <task>Implement SlowLayer with deduplicated agent results</task>
            <task>Add collapse/expand behavior after completion</task>
        </phase>
        
        <phase number="5" name="Overflow Debug Panel">
            <task priority="high">Create OverflowPanel component with drawer animation</task>
            <task priority="high">Implement WebSocket event stream viewer</task>
            <task>Add Run timeline with Gantt visualization</task>
            <task>Display backend state (thread, run, assistant IDs)</task>
            <task>Add performance metrics dashboard</task>
            <task>Implement error detail viewer with stack traces</task>
            <task>Add export functionality for debug data</task>
            <task>Create keyboard shortcut (Ctrl+Shift+D) trigger</task>
        </phase>
        
        <phase number="6" name="WebSocket Integration">
            <task>Update WebSocketProvider for thread-specific connections</task>
            <task>Handle thread_created and thread_loaded events</task>
            <task>Implement run_started and step_created events</task>
            <task>Add reconnection logic when switching threads</task>
            <task>Create event buffer for overflow panel</task>
        </phase>
        
        <phase number="7" name="Backend Integration">
            <task priority="critical">Implement POST /api/threads for new chats</task>
            <task priority="critical">Implement GET /api/threads for sidebar list</task>
            <task priority="critical">Implement GET /api/threads/{id}/messages</task>
            <task>Add thread metadata updates</task>
            <task>Ensure user_id association for all threads</task>
        </phase>
        
        <phase number="8" name="Testing and Validation">
            <task>Test chat isolation - only one active at a time</task>
            <task>Test example prompts create new chats</task>
            <task>Test agent deduplication across multiple runs</task>
            <task>Test overflow panel data accuracy</task>
            <task>Test thread switching preserves message history</task>
            <task>Performance test with 100+ threads in sidebar</task>
            <task>E2E test complete user journey with multiple chats</task>
        </phase>
    </implementation-checklist>
</specification>