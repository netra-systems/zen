<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>Core System Architecture</name>
        <type>Core.SystemArchitecture</type>
        <version>3.0</version>
        <description>Core architectural principles, unified system patterns, and inter-service communication architecture</description>
        <created>2025-08-24</created>
        <updated>2025-08-24</updated>
    </metadata>

    <core_principles>
        <principle priority="CRITICAL">
            <name>System Coherence</name>
            <description>
                The entire platform operates as a unified, coherent system where all
                components work in harmony. Each service maintains independence while
                contributing to the overall system functionality.
            </description>
        </principle>

        <principle priority="CRITICAL">
            <name>Single Source of Truth</name>
            <description>
                Every concept, configuration, and implementation MUST exist exactly ONCE
                within each service. Duplication within a service is forbidden. Similar
                patterns across services are acceptable for maintaining independence.
            </description>
        </principle>

        <principle priority="HIGH">
            <name>Atomic Operations</name>
            <description>
                All changes MUST be atomic and complete. Partial implementations,
                half-finished refactors, or broken intermediate states are forbidden.
                Every edit represents a complete update to the system.
            </description>
        </principle>

        <principle priority="HIGH">
            <name>Environment Isolation</name>
            <description>
                Development, staging, and production environments MUST be properly
                isolated with environment-specific configurations and no cross-contamination.
            </description>
        </principle>
    </core_principles>

    <system_architecture>
        <microservices>
            <service name="Backend">
                <path>netra_backend/app</path>
                <purpose>Main application logic and API</purpose>
                <port>8000</port>
                <database>PostgreSQL, ClickHouse, Redis</database>
            </service>

            <service name="Auth Service">
                <path>auth_service</path>
                <purpose>Centralized authentication and authorization</purpose>
                <port>8080</port>
                <database>PostgreSQL (separate auth_users table)</database>
            </service>

            <service name="Frontend">
                <path>frontend</path>
                <purpose>Next.js web application</purpose>
                <port>3000</port>
                <framework>React with TypeScript</framework>
            </service>
        </microservices>

        <shared_components>
            <component name="Database Management">
                <path>shared/database/</path>
                <purpose>Unified database connectivity and SSL resolution</purpose>
            </component>

            <component name="Configuration">
                <path>shared/configuration/</path>
                <purpose>Environment validation and configuration management</purpose>
            </component>

            <component name="Test Framework">
                <path>test_framework/</path>
                <purpose>Centralized test utilities and fixtures</purpose>
            </component>
        </shared_components>
    </system_architecture>

    <inter_service_communication>
        <principle>
            Services MUST remain 100% independent. No direct code imports between services.
            All communication through well-defined APIs and shared interfaces.
        </principle>
        
        <communication_patterns>
            <pattern name="REST API">
                <description>Synchronous service-to-service HTTP calls</description>
                <examples>
                    <example>Backend → Auth Service: User validation</example>
                    <example>Frontend → Backend: Data fetching</example>
                </examples>
                <implementation>
                    <backend>FastAPI with httpx client</backend>
                    <auth>FastAPI endpoints</auth>
                    <frontend>Next.js API routes with fetch</frontend>
                </implementation>
            </pattern>
            
            <pattern name="WebSocket">
                <description>Real-time bidirectional communication</description>
                <examples>
                    <example>Frontend ↔ Backend: Live AI responses</example>
                    <example>Agent system updates</example>
                </examples>
                <implementation>
                    <backend>FastAPI WebSocket with connection manager</backend>
                    <frontend>React hooks with reconnection logic</frontend>
                </implementation>
            </pattern>
            
            <pattern name="Shared Interfaces">
                <description>Common types and utilities in /shared directory</description>
                <examples>
                    <example>CoreDatabaseManager for SSL resolution</example>
                    <example>IsolatedEnvironment for env management</example>
                </examples>
                <rules>
                    <rule>Interfaces only, no business logic</rule>
                    <rule>Version compatibility required</rule>
                </rules>
            </pattern>
        </communication_patterns>
        
        <service_contracts>
            <contract service="Auth Service">
                <endpoint>/auth/validate</endpoint>
                <method>POST</method>
                <request>{"token": "jwt_token"}</request>
                <response>{"valid": true, "user_id": "uuid", "permissions": []}</response>
            </contract>
            
            <contract service="Backend">
                <endpoint>/api/threads</endpoint>
                <method>GET</method>
                <auth>Bearer token required</auth>
                <response>{"threads": [], "total": 0}</response>
            </contract>
            
            <contract service="WebSocket">
                <endpoint>/ws</endpoint>
                <protocol>WebSocket</protocol>
                <auth>Token in query params or headers</auth>
                <messages>
                    <message>{"type": "chat", "content": "..."}</message>
                    <message>{"type": "status", "state": "processing"}</message>
                </messages>
            </contract>
        </service_contracts>
        
        <forbidden_patterns>
            <pattern>Direct database sharing between services</pattern>
            <pattern>Cross-service code imports</pattern>
            <pattern>Shared state without proper synchronization</pattern>
            <pattern>Bypassing service APIs for internal access</pattern>
        </forbidden_patterns>
    </inter_service_communication>

    <configuration_management>
        <unified_config>
            <description>
                Single unified configuration system using IsolatedEnvironment
                for all environment variable access.
            </description>
            <location>dev_launcher/isolated_environment.py</location>
            <features>
                <feature>Environment isolation in development</feature>
                <feature>Source tracking for debugging</feature>
                <feature>Thread-safe operations</feature>
                <feature>Subprocess environment management</feature>
            </features>
        </unified_config>

        <secret_management>
            <development>Local .env files with isolation</development>
            <staging>GCP Secret Manager with validation</staging>
            <production>GCP Secret Manager with encryption</production>
        </secret_management>
    </configuration_management>

    <database_architecture>
        <connectivity>
            <description>
                Unified database connectivity with automatic SSL parameter
                resolution between asyncpg and psycopg2 drivers.
            </description>
            <manager>CoreDatabaseManager</manager>
            <features>
                <feature>SSL parameter conflict resolution</feature>
                <feature>Cloud SQL Unix socket support</feature>
                <feature>Environment-aware connection strategies</feature>
                <feature>Automatic driver selection</feature>
            </features>
        </connectivity>

        <databases>
            <database name="PostgreSQL">
                <purpose>Primary data store</purpose>
                <async_driver>asyncpg</async_driver>
                <sync_driver>psycopg2</sync_driver>
            </database>
            <database name="ClickHouse">
                <purpose>Analytics and metrics</purpose>
                <driver>clickhouse-driver</driver>
            </database>
            <database name="Redis">
                <purpose>Caching and sessions</purpose>
                <driver>redis.asyncio</driver>
            </database>
        </databases>
    </database_architecture>

    <testing_infrastructure>
        <unified_test_runner>
            <description>Single entry point for all test operations</description>
            <location>unified_test_runner.py</location>
            <levels>unit, integration, e2e, agents</levels>
        </unified_test_runner>

        <test_requirements>
            <requirement>Absolute imports only (no relative imports)</requirement>
            <requirement>Centralized path setup with setup_test_path()</requirement>
            <requirement>@pytest.mark.asyncio for all async tests</requirement>
            <requirement>Environment isolation for all tests</requirement>
            <requirement>Service boundary respect</requirement>
        </test_requirements>

        <coverage_targets>
            <overall>80%</overall>
            <authentication>90%</authentication>
            <api_endpoints>90%</api_endpoints>
            <database_operations>85%</database_operations>
        </coverage_targets>
    </testing_infrastructure>

    <deployment_pipeline>
        <environments>
            <env name="development">Local with dev_launcher.py</env>
            <env name="staging">GCP Cloud Run with validation</env>
            <env name="production">GCP Cloud Run with full monitoring</env>
        </environments>

        <deployment_process>
            <step>Pre-deployment validation</step>
            <step>Build and push images</step>
            <step>Deploy to Cloud Run</step>
            <step>Health check validation</step>
            <step>Traffic management</step>
            <step>Post-deployment verification</step>
        </deployment_process>

        <rollback_strategy>
            <automatic>On error rate > 10%</automatic>
            <manual>Route traffic to previous revision</manual>
        </rollback_strategy>
    </deployment_pipeline>

    <monitoring_observability>
        <health_checks>
            <endpoint>/health/live</endpoint>
            <endpoint>/health/ready</endpoint>
            <timeout>30 seconds</timeout>
        </health_checks>

        <metrics>
            <metric>Request latency (p50, p95, p99)</metric>
            <metric>Error rates by endpoint</metric>
            <metric>Database pool utilization</metric>
            <metric>WebSocket connections</metric>
        </metrics>

        <logging>
            <framework>Loguru with structured logging</framework>
            <correlation>Request ID tracking</correlation>
            <aggregation>GCP Cloud Logging</aggregation>
        </logging>
    </monitoring_observability>

    <development_workflow>
        <local_development>
            <command>python scripts/dev_launcher.py</command>
            <features>
                <feature>Dynamic port allocation</feature>
                <feature>Service discovery</feature>
                <feature>Hot reload</feature>
                <feature>Mock LLM mode</feature>
            </features>
        </local_development>

        <testing>
            <quick>python unified_test_runner.py --level integration --no-coverage --fast-fail</quick>
            <comprehensive>python unified_test_runner.py --level e2e --real-llm</comprehensive>
            <staging>python unified_test_runner.py --level e2e --env staging</staging>
        </testing>

        <deployment>
            <staging>python scripts/deploy_to_gcp.py --project netra-staging --build-local</staging>
            <production>python scripts/deploy_to_gcp.py --project netra-production --run-checks</production>
        </deployment>
    </development_workflow>

    <quality_standards>
        <code_quality>
            <standard>450 lines per file maximum</standard>
            <standard>25 lines per function maximum</standard>
            <standard>Cyclomatic complexity < 10</standard>
            <standard>Type hints required</standard>
        </code_quality>

        <documentation>
            <requirement>All public APIs documented</requirement>
            <requirement>Complex logic explained</requirement>
            <requirement>Configuration examples provided</requirement>
        </documentation>

        <security>
            <requirement>No secrets in code</requirement>
            <requirement>Input validation required</requirement>
            <requirement>SQL injection prevention</requirement>
            <requirement>XSS protection</requirement>
        </security>
    </quality_standards>

    <business_alignment>
        <goal>Enterprise AI workload optimization</goal>
        <value_proposition>
            Reduce AI/LLM costs while improving performance through
            intelligent orchestration and optimization.
        </value_proposition>
        <customer_segments>
            <segment>Free - Conversion focus</segment>
            <segment>Early - Feature adoption</segment>
            <segment>Mid - Expansion</segment>
            <segment>Enterprise - Full platform</segment>
        </customer_segments>
    </business_alignment>

    <compliance_checklist>
        <system_coherence>
            <check>All services working in harmony</check>
            <check>No duplicate implementations within services</check>
            <check>Atomic operations completed</check>
            <check>Clean codebase without legacy artifacts</check>
        </system_coherence>

        <configuration>
            <check>Unified environment management in use</check>
            <check>Secrets properly managed per environment</check>
            <check>No localhost in staging/production</check>
            <check>SSL parameters resolved correctly</check>
        </configuration>

        <quality>
            <check>Test coverage targets met</check>
            <check>Code quality standards enforced</check>
            <check>Documentation up to date</check>
            <check>Security requirements satisfied</check>
        </quality>

        <operations>
            <check>Health monitoring active</check>
            <check>Deployment pipeline functional</check>
            <check>Rollback strategy tested</check>
            <check>Metrics and logging operational</check>
        </operations>
    </compliance_checklist>

    <critical_architecture_patterns>
        <pattern name="Import Management">
            <description>Zero tolerance for relative imports across entire codebase</description>
            <enforcement>
                <tool>Pre-commit hooks</tool>
                <tool>CI/CD validation</tool>
                <script>python scripts/fix_all_import_issues.py --absolute-only</script>
            </enforcement>
            <rationale>
                Relative imports are the #1 cause of test infrastructure failures.
                Absolute imports ensure consistent module resolution across all environments.
            </rationale>
        </pattern>
        
        <pattern name="Environment Isolation">
            <description>Complete isolation of environment variables in development and testing</description>
            <implementation>
                <component>IsolatedEnvironment class</component>
                <benefits>
                    <benefit>Prevents os.environ pollution</benefit>
                    <benefit>Enables predictable testing</benefit>
                    <benefit>Source tracking for debugging</benefit>
                </benefits>
            </implementation>
        </pattern>
        
        <pattern name="Database URL Normalization">
            <description>Automatic resolution of driver-specific SSL parameters</description>
            <problem>asyncpg uses 'ssl=' while psycopg2 uses 'sslmode='</problem>
            <solution>CoreDatabaseManager.resolve_ssl_parameter_conflicts()</solution>
            <rules>
                <rule>Convert parameters based on target driver</rule>
                <rule>Remove ALL SSL params for Unix sockets</rule>
                <rule>Maintain other URL components unchanged</rule>
            </rules>
        </pattern>
        
        <pattern name="Service Boundaries">
            <description>Strict enforcement of microservice independence</description>
            <boundaries>
                <boundary>No cross-service imports</boundary>
                <boundary>Separate test directories per service</boundary>
                <boundary>Independent deployment units</boundary>
                <boundary>Service-specific configuration</boundary>
            </boundaries>
        </pattern>
    </critical_architecture_patterns>

    <architecture_evolution>
        <phase name="Current State">
            <description>Three-service architecture with unified infrastructure</description>
            <services>Backend, Auth, Frontend</services>
            <infrastructure>Unified config, test framework, deployment</infrastructure>
        </phase>
        
        <phase name="Near Term">
            <description>Enhanced observability and monitoring</description>
            <additions>
                <addition>Distributed tracing with OpenTelemetry</addition>
                <addition>Service mesh for inter-service communication</addition>
                <addition>Advanced circuit breakers</addition>
            </additions>
        </phase>
        
        <phase name="Future">
            <description>Event-driven architecture with message queues</description>
            <additions>
                <addition>Event sourcing for audit trails</addition>
                <addition>CQRS for read/write separation</addition>
                <addition>Multi-region deployment</addition>
            </additions>
        </phase>
    </architecture_evolution>

    <reference_specifications>
        <spec>unified_environment_management.xml - Environment isolation patterns</spec>
        <spec>database_connectivity_architecture.xml - Database connection management</spec>
        <spec>test_infrastructure_architecture.xml - Testing patterns and organization</spec>
        <spec>import_management_architecture.xml - Import rules and enforcement</spec>
        <spec>deployment_architecture.xml - Multi-environment deployment</spec>
        <spec>independent_services.xml - Service independence requirements</spec>
        <spec>type_safety.xml - Type safety and SSOT enforcement</spec>
        <spec>conventions.xml - Code quality standards</spec>
    </reference_specifications>
</specification>