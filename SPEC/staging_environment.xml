<?xml version="1.0" encoding="UTF-8"?>
<specification>
  <title>Automatic Staging Environment System</title>
  <version>1.0.0</version>
  <created>2025-08-11</created>
  <purpose>
    Define comprehensive automatic staging environment creation for pull requests,
    providing isolated testing environments with cost optimization and resource management.
  </purpose>

  <overview>
    <description>
      Staging deployment system supporting multiple deployment methods:
      1. GitHub Actions automatic staging - Triggered by PRs, fully automated
      2. Local to remote staging - Deploy from local machine to GCP staging
      3. Local staging - Run staging environment locally for development
      Each method serves different purposes in the development lifecycle.
    </description>
    <deployment_methods>
      <method name="GitHub Actions Staging">
        <trigger>Pull request events (open/update/close)</trigger>
        <location>GCP Cloud Run</location>
        <purpose>Automated PR testing in cloud environment</purpose>
        <automation>Fully automated via GitHub Actions</automation>
      </method>
      <method name="Local to Remote Staging">
        <trigger>Manual via CLI or script</trigger>
        <location>GCP Cloud Run (staging project)</location>
        <purpose>Test local changes in cloud before PR</purpose>
        <automation>Semi-automated via local scripts</automation>
      </method>
      <method name="Local Staging">
        <trigger>Manual via dev_launcher.py</trigger>
        <location>Local machine (Docker/native)</location>
        <purpose>Development and debugging</purpose>
        <automation>Local tooling with hot reload</automation>
      </method>
    </deployment_methods>
    <key_features>
      - Three distinct deployment paths for different use cases
      - GitHub Actions for automatic PR staging
      - Local deployment to GCP staging for pre-PR testing
      - Local staging for development with full stack
      - Resource limiting and cost optimization
      - Integration with existing test runner
      - SSL/TLS with automatic certificates
      - Database isolation with seeded test data
      - WebSocket support for real-time features
      - Preview URL generation with GitHub integration
    </key_features>
  </overview>

  <architecture>
    <components>
      <component name="GitHub Actions">
        <responsibility>Orchestrate staging lifecycle</responsibility>
        <triggers>
          - pull_request.opened
          - pull_request.synchronize
          - pull_request.closed
          - pull_request.merged
        </triggers>
        <concurrency>
          <description>
            Automatic cancellation of superseded workflow runs when new commits are pushed.
            Only the latest commit's workflow runs to completion, preventing resource waste
            and ensuring developers always see results from their latest changes.
          </description>
          <group>staging-pr-${PR_NUMBER}</group>
          <cancel_in_progress>true</cancel_in_progress>
          <exceptions>
            - Destroy operations use separate concurrency group with cancel_in_progress=false
            - Ensures cleanup always completes to prevent resource leaks
          </exceptions>
        </concurrency>
      </component>
      
      <component name="Terraform">
        <responsibility>Infrastructure as Code management</responsibility>
        <modules>
          - gcp-staging-core: Core GCP resources
          - gcp-networking: VPC, subnets, load balancers
          - gcp-compute: Cloud Run, GKE autopilot
          - gcp-data: Cloud SQL, Redis, ClickHouse
          - gcp-security: IAM, secrets, certificates
        </modules>
      </component>
      
      <component name="Google Cloud Platform">
        <services>
          - Cloud Run: Application hosting (auto-scaling)
          - Cloud SQL: PostgreSQL database
          - Memorystore: Redis caching
          - Cloud Storage: Static assets
          - Cloud Load Balancing: HTTPS termination
          - Cloud DNS: Dynamic subdomain management
          - Secret Manager: Environment variables
          - Cloud Build: Container builds
          - Artifact Registry: Container storage
        </services>
      </component>
    </components>

    <workflow>
      <step order="1">PR opened/updated trigger (supersedes any running workflows)</step>
      <step order="2">GitHub Action validates PR metadata</step>
      <step order="3" parallel="true">Build containers (backend + frontend in parallel)</step>
      <step order="4">Terraform plan staging infrastructure</step>
      <step order="5">Apply Terraform with PR-specific namespace</step>
      <step order="6">Deploy containers to Cloud Run</step>
      <step order="7">Run database migrations</step>
      <step order="8">Seed test data</step>
      <step order="9">Execute test runner suite</step>
      <step order="10">Update PR with staging URL and test results</step>
      <step order="11">Monitor for PR close/merge</step>
      <step order="12">Destroy infrastructure on PR close (never cancelled)</step>
    </workflow>
    
    <performance_optimizations>
      <optimization name="parallel_builds">
        <description>Backend and frontend containers build in parallel to reduce deployment time</description>
        <implementation>Separate GitHub Actions jobs with needs dependency on check-eligibility only</implementation>
        <time_saved>~5-10 minutes per deployment</time_saved>
      </optimization>
      <optimization name="build_caching">
        <description>Docker layer caching and build result caching via GCS</description>
        <implementation>Store successful build SHA and image URL in GCS, skip rebuild if no changes</implementation>
        <time_saved>~10-15 minutes when no code changes</time_saved>
      </optimization>
      <optimization name="workflow_cancellation">
        <description>Automatic cancellation of superseded workflow runs</description>
        <implementation>GitHub Actions concurrency groups with cancel-in-progress</implementation>
        <benefits>
          - Prevents resource waste on outdated commits
          - Faster feedback on latest changes
          - Reduced cloud costs from cancelled builds
          - Cleaner workflow history
        </benefits>
      </optimization>
    </performance_optimizations>
  </architecture>

  <configuration>
    <file path=".github/staging.yml">
      <setting name="auto_deploy" default="true">
        Enable automatic staging for all PRs
      </setting>
      <setting name="required_labels" default="[]">
        List of labels required for staging deployment
      </setting>
      <setting name="excluded_labels" default="['no-staging', 'WIP']">
        PRs with these labels skip staging
      </setting>
      <setting name="max_staging_envs" default="10">
        Maximum concurrent staging environments
      </setting>
      <setting name="default_test_level" default="integration">
        Test level to run: smoke|unit|integration|comprehensive
      </setting>
      <setting name="staging_ttl_hours" default="168">
        Auto-destroy staging after 7 days of inactivity
      </setting>
    </file>

    <resource_limits>
      <compute>
        <cpu_limit>2</cpu_limit>
        <memory_limit>4Gi</memory_limit>
        <min_instances>0</min_instances>
        <max_instances>3</max_instances>
        <scale_to_zero_delay>15m</scale_to_zero_delay>
      </compute>
      
      <database>
        <tier>db-f1-micro</tier>
        <storage_gb>10</storage_gb>
        <backup_enabled>false</backup_enabled>
        <high_availability>false</high_availability>
      </database>
      
      <redis>
        <tier>basic</tier>
        <memory_gb>1</memory_gb>
      </redis>
    </resource_limits>

    <cost_optimization>
      <strategy name="scale-to-zero">
        Cloud Run scales to 0 after 15 minutes of inactivity
      </strategy>
      <strategy name="spot-instances">
        Use spot/preemptible instances where possible
      </strategy>
      <strategy name="resource-quotas">
        Enforce project-wide quotas to prevent runaway costs
      </strategy>
      <strategy name="auto-cleanup">
        Destroy environments after PR close or TTL expiry
      </strategy>
      <strategy name="shared-resources">
        Share non-sensitive resources across staging envs (e.g., build cache)
      </strategy>
    </cost_optimization>
  </configuration>

  <environment_variables>
    <variable name="STAGING_ENV" value="true" />
    <variable name="PR_NUMBER" value="${github.event.pull_request.number}" />
    <variable name="PR_BRANCH" value="${github.head_ref}" />
    <variable name="STAGING_URL" value="https://pr-${PR_NUMBER}.staging.netrasystems.ai" />
    <variable name="DATABASE_URL" value="postgresql://staging:${SECRET}@${DB_HOST}/netra_pr_${PR_NUMBER}" />
    <variable name="REDIS_URL" value="redis://${REDIS_HOST}:6379/${PR_NUMBER}" />
    <variable name="CLICKHOUSE_URL" value="clickhouse://${CLICKHOUSE_HOST}/staging_pr_${PR_NUMBER}" />
    <variable name="DISABLE_AUTH" value="false" />
    <variable name="TEST_MODE" value="true" />
  </environment_variables>

  <testing_integration>
    <test_runner>
      <command>python test_runner.py --level ${TEST_LEVEL} --staging</command>
      <environment>STAGING_URL=${STAGING_URL}</environment>
      <timeout>1800</timeout>
      <retry_count>2</retry_count>
    </test_runner>

    <test_levels>
      <level name="smoke" condition="commits < 3">
        Quick validation for small changes
      </level>
      <level name="integration" condition="default">
        Standard testing for most PRs
      </level>
      <level name="comprehensive" condition="label:requires-full-test">
        Full test suite for critical changes
      </level>
    </test_levels>

    <test_data>
      <seed_script>scripts/seed_staging_data.py</seed_script>
      <fixtures>
        - 10 test users with various roles
        - 50 optimization requests
        - 100 metric data points
        - Sample LLM responses
      </fixtures>
    </test_data>
  </testing_integration>

  <security>
    <access_control>
      <authentication>OAuth with GitHub</authentication>
      <authorized_users>PR author + reviewers + maintainers</authorized_users>
      <ip_whitelist>Optional IP restrictions</ip_whitelist>
    </access_control>

    <secrets_management>
      <source>Google Secret Manager</source>
      <rotation>Automatic for staging environments</rotation>
      <isolation>Per-PR secret namespaces</isolation>
    </secrets_management>

    <network_security>
      <ssl>Automatic Let's Encrypt certificates</ssl>
      <firewall>Restrictive ingress rules</firewall>
      <vpc>Isolated VPC per staging environment</vpc>
    </network_security>
  </security>

  <monitoring>
    <metrics>
      <metric name="deployment_time">Time to create staging env</metric>
      <metric name="test_duration">Time to run test suite</metric>
      <metric name="resource_usage">CPU, memory, storage usage</metric>
      <metric name="cost_per_pr">Estimated cost per staging env</metric>
      <metric name="error_rate">Deployment failure rate</metric>
    </metrics>

    <alerts>
      <alert condition="deployment_time > 10m">Slow deployment warning</alert>
      <alert condition="cost_per_pr > $5">High cost warning</alert>
      <alert condition="error_rate > 0.1">High failure rate alert</alert>
    </alerts>

    <logging>
      <destination>Cloud Logging</destination>
      <retention>7 days for staging logs</retention>
      <structured>JSON formatted with PR metadata</structured>
    </logging>
  </monitoring>

  <github_integration>
    <status_checks>
      <check name="staging/deploy">Deployment status</check>
      <check name="staging/tests">Test execution status</check>
      <check name="staging/health">Application health check</check>
    </status_checks>

    <pr_comments>
      <deployment_comment>
        ðŸš€ **Staging Environment Ready**
        
        URL: ${STAGING_URL}
        Status: âœ… Deployed
        Test Results: ${TEST_RESULTS_URL}
        
        **Quick Links:**
        - [Frontend](${STAGING_URL})
        - [API Docs](${STAGING_URL}/docs)
        - [Logs](${LOGS_URL})
        
        _Environment will be destroyed when PR is closed._
      </deployment_comment>
    </pr_comments>

    <labels>
      <label name="staging-deployed">Added when staging is ready</label>
      <label name="staging-failed">Added on deployment failure</label>
      <label name="no-staging">Skip staging deployment</label>
    </labels>
  </github_integration>

  <cleanup>
    <triggers>
      - PR closed
      - PR merged
      - TTL expired
      - Manual trigger
    </triggers>

    <process>
      <step>Backup logs and test results</step>
      <step>Terraform destroy infrastructure</step>
      <step>Delete container images</step>
      <step>Clean up DNS records</step>
      <step>Remove secrets</step>
      <step>Update PR with cleanup status</step>
    </process>

    <retention>
      <logs>7 days after cleanup</logs>
      <test_results>30 days after cleanup</test_results>
      <metrics>90 days after cleanup</metrics>
    </retention>
  </cleanup>

  <deployment_scenarios>
    <scenario name="GitHub_Actions_Staging">
      <description>
        Fully automated staging deployment triggered by pull request events.
        Creates isolated environment in GCP for each PR.
      </description>
      <trigger>PR opened, synchronized, or labeled</trigger>
      <infrastructure>
        - GCP Cloud Run for application
        - Cloud SQL for PostgreSQL
        - Memorystore for Redis
        - Automated SSL certificates
      </infrastructure>
      <workflow>
        1. GitHub webhook triggers workflow
        2. Builds containers in parallel
        3. Terraform creates PR-specific infrastructure
        4. Deploys to Cloud Run with PR-specific URL
        5. Runs automated tests
        6. Posts results to PR
        7. Auto-destroys on PR close
      </workflow>
      <access>https://pr-{number}.staging.netrasystems.ai</access>
      <authentication>GitHub OAuth for PR participants</authentication>
      <use_cases>
        - Automated PR validation
        - Reviewer testing
        - Stakeholder preview
      </use_cases>
    </scenario>

    <scenario name="Local_to_Remote_Staging">
      <description>
        Deploy local changes to GCP staging environment for cloud testing
        before creating a pull request. Uses shared staging infrastructure.
      </description>
      <trigger>Manual command from local machine</trigger>
      <infrastructure>
        - Shared GCP staging project
        - Persistent staging Cloud Run service
        - Shared staging databases with namespace isolation
      </infrastructure>
      <workflow>
        1. Run 'gcloud builds submit' from local
        2. Build container with Cloud Build
        3. Deploy to staging Cloud Run service
        4. Use personal namespace in shared databases
        5. Manual testing via staging URL
      </workflow>
      <commands>
        # Build and deploy backend
        gcloud builds submit --config=cloudbuild-staging.yaml \
          --substitutions=_IMAGE_TAG=local-$(git rev-parse --short HEAD)
        
        # Deploy specific version
        gcloud run deploy netra-staging \
          --image=gcr.io/netra-staging/netra:local-{tag} \
          --region=us-central1
      </commands>
      <access>https://staging.netrasystems.ai</access>
      <authentication>Development team credentials</authentication>
      <use_cases>
        - Pre-PR validation
        - Integration testing
        - Performance testing in cloud
      </use_cases>
    </scenario>

    <scenario name="Local_Staging">
      <description>
        Complete staging environment running on local machine for
        development and debugging with hot reload capabilities.
      </description>
      <trigger>dev_launcher.py or manual setup</trigger>
      <infrastructure>
        - Local Python virtual environment
        - Local PostgreSQL (Docker or native)
        - Local Redis (Docker or native)
        - Local ClickHouse (Docker)
        - Next.js dev server
      </infrastructure>
      <workflow>
        1. Run 'python dev_launcher.py'
        2. Starts all required services
        3. Applies database migrations
        4. Seeds development data
        5. Starts backend with uvicorn --reload
        6. Starts frontend with next dev
        7. Opens browser to localhost
      </workflow>
      <commands>
        # Automated setup
        python dev_launcher.py
        
        # Manual setup
        docker-compose up -d postgres redis clickhouse
        python -m venv venv
        source venv/bin/activate
        pip install -r requirements.txt
        alembic upgrade head
        python scripts/seed_dev_data.py
        uvicorn app.main:app --reload --port 8000
        cd frontend && npm run dev
      </commands>
      <access>
        - Backend: http://localhost:8000
        - Frontend: http://localhost:3000
        - API Docs: http://localhost:8000/docs
      </access>
      <authentication>Disabled or test credentials</authentication>
      <use_cases>
        - Active development
        - Debugging
        - Unit test development
        - UI/UX iteration
      </use_cases>
    </scenario>
  </deployment_scenarios>

  <configuration_differences>
    <difference aspect="Environment Variables">
      <github_actions>
        - Sourced from GitHub Secrets
        - PR-specific namespaces
        - Production-like values
      </github_actions>
      <local_to_remote>
        - Mix of local .env and GCP Secret Manager
        - Shared staging credentials
        - Developer-specific namespaces
      </local_to_remote>
      <local_staging>
        - Local .env file
        - Development defaults
        - Simplified authentication
      </local_staging>
    </difference>

    <difference aspect="Database Management">
      <github_actions>
        - Isolated database per PR
        - Automatic creation and teardown
        - Fresh migrations each deployment
      </github_actions>
      <local_to_remote>
        - Shared staging database
        - Schema namespaces for isolation
        - Persistent data between deployments
      </local_to_remote>
      <local_staging>
        - Local database instance
        - Developer controls lifecycle
        - Persistent development data
      </local_staging>
    </difference>

    <difference aspect="Resource Limits">
      <github_actions>
        - Strict CPU/memory limits
        - Auto-scaling with max instances
        - Cost optimization enabled
      </github_actions>
      <local_to_remote>
        - Moderate resource allocation
        - Shared between developers
        - Manual scaling if needed
      </local_to_remote>
      <local_staging>
        - No limits (local resources)
        - Developer machine dependent
        - No cost considerations
      </local_staging>
    </difference>
  </configuration_differences>

  <implementation_checklist>
    <task status="completed">Create GitHub Actions workflows</task>
    <task status="completed">Implement parallel build jobs for backend/frontend</task>
    <task status="completed">Add workflow concurrency control for superseding commits</task>
    <task status="completed">Set up build caching via GCS</task>
    <task status="completed">Implement automatic cleanup on PR close</task>
    <task status="completed">Add destroy job protection (no cancellation)</task>
    <task status="pending">Set up Terraform modules for PR staging</task>
    <task status="pending">Configure GCP staging project for local deployments</task>
    <task status="pending">Create cloudbuild-staging.yaml for local to remote</task>
    <task status="pending">Update dev_launcher.py for local staging mode</task>
    <task status="pending">Create staging configuration templates</task>
    <task status="pending">Implement test runner integration for all modes</task>
    <task status="pending">Set up DNS for staging environments</task>
    <task status="pending">Create seed data scripts</task>
    <task status="pending">Implement cost monitoring</task>
    <task status="pending">Write deployment mode documentation</task>
  </implementation_checklist>
</specification>