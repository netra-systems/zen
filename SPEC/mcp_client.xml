<?xml version='1.0' encoding='utf-8'?>
<specification>
  <metadata>
    <title>Model Context Protocol (MCP) Client Specification</title>
    <version>1.0.0</version>
    <description>Specification for MCP Client implementation to connect to external MCP servers</description>
    <created>2025-08-16</created>
    <author>Netra AI Platform Team</author>
    <priority>CRITICAL</priority>
    <last_edited>2025-08-21T08:47:28.543373</last_edited>
  </metadata>
  <overview>
    <description>
      The MCP Client enables Netra to connect to external MCP servers and use their tools, resources,
      and prompts. This extends Netra's capabilities by integrating with third-party MCP providers like
      documentation servers, GitHub repositories, filesystem access, and specialized AI tools.
    </description>
    <goals>
      <goal priority="critical">Connect to multiple external MCP servers simultaneously</goal>
      <goal priority="critical">Discover and execute tools from external servers</goal>
      <goal priority="critical">Access resources from external providers</goal>
      <goal priority="high">Maintain security boundaries and authentication</goal>
      <goal priority="high">Cache and optimize external tool calls</goal>
      <goal priority="medium">Support all MCP transport protocols</goal>
      <goal priority="medium">Registry management for external servers</goal>
    </goals>
  </overview>
  <architecture>
    <principles>
      <principle>Modular design with 450-line maximum per file</principle>
      <principle>Functions limited to 8 lines maximum</principle>
      <principle>Strong typing with Pydantic models</principle>
      <principle>Async-first implementation</principle>
      <principle>Security by default</principle>
      <principle>Performance through caching and pooling</principle>
    </principles>
    <module_structure>
      <module name="client_core">
        <file>app/mcp_client/client_core.py</file>
        <max_lines>300</max_lines>
        <responsibilities>
          <item>MCP Client base class</item>
          <item>Protocol negotiation</item>
          <item>Session management</item>
        </responsibilities>
      </module>
      <module name="connection_manager">
        <file>app/mcp_client/connection_manager.py</file>
        <max_lines>300</max_lines>
        <responsibilities>
          <item>Connection pooling</item>
          <item>Transport selection</item>
          <item>Reconnection logic</item>
        </responsibilities>
      </module>
      <module name="tool_proxy">
        <file>app/mcp_client/tool_proxy.py</file>
        <max_lines>300</max_lines>
        <responsibilities>
          <item>Tool discovery</item>
          <item>Tool execution proxy</item>
          <item>Result transformation</item>
        </responsibilities>
      </module>
      <module name="resource_proxy">
        <file>app/mcp_client/resource_proxy.py</file>
        <max_lines>300</max_lines>
        <responsibilities>
          <item>Resource discovery</item>
          <item>Resource fetching</item>
          <item>Content caching</item>
        </responsibilities>
      </module>
      <module name="transport_clients">
        <submodules>
          <module name="stdio_client">
            <file>app/mcp_client/transports/stdio_client.py</file>
            <max_lines>300</max_lines>
          </module>
          <module name="http_client">
            <file>app/mcp_client/transports/http_client.py</file>
            <max_lines>300</max_lines>
          </module>
          <module name="websocket_client">
            <file>app/mcp_client/transports/websocket_client.py</file>
            <max_lines>300</max_lines>
          </module>
        </submodules>
      </module>
      <module name="registry">
        <file>app/mcp_client/registry.py</file>
        <max_lines>300</max_lines>
        <responsibilities>
          <item>Server registration</item>
          <item>Configuration management</item>
          <item>Discovery service</item>
        </responsibilities>
      </module>
      <module name="cache">
        <file>app/mcp_client/cache.py</file>
        <max_lines>300</max_lines>
        <responsibilities>
          <item>Tool result caching</item>
          <item>Resource content caching</item>
          <item>TTL management</item>
        </responsibilities>
      </module>
      <module name="security">
        <file>app/mcp_client/security.py</file>
        <max_lines>300</max_lines>
        <responsibilities>
          <item>Credential management</item>
          <item>Server authentication</item>
          <item>Input sanitization</item>
        </responsibilities>
      </module>
    </module_structure>
  </architecture>
  <core_components>
    <component name="MCPClient">
      <description>Main client class for connecting to external MCP servers</description>
      <interface>
        <method name="connect">
          <params>
            <param name="server_config" type="MCPServerConfig">Server configuration</param>
          </params>
          <returns>MCPConnection</returns>
        </method>
        <method name="discover_tools">
          <params>
            <param name="connection" type="MCPConnection">Active connection</param>
          </params>
          <returns>List[MCPTool]</returns>
        </method>
        <method name="execute_tool">
          <params>
            <param name="connection" type="MCPConnection">Active connection</param>
            <param name="tool_name" type="str">Tool identifier</param>
            <param name="arguments" type="Dict[str, Any]">Tool arguments</param>
          </params>
          <returns>MCPToolResult</returns>
        </method>
        <method name="get_resource">
          <params>
            <param name="connection" type="MCPConnection">Active connection</param>
            <param name="uri" type="str">Resource URI</param>
          </params>
          <returns>MCPResource</returns>
        </method>
      </interface>
    </component>
    <component name="MCPConnectionManager">
      <description>Manages connections to multiple MCP servers</description>
      <features>
        <feature>Connection pooling (max 10 per server)</feature>
        <feature>Automatic reconnection with exponential backoff</feature>
        <feature>Health checks every 30 seconds</feature>
        <feature>Load balancing across connections</feature>
      </features>
    </component>
    <component name="MCPToolProxy">
      <description>Proxies tool execution to external servers</description>
      <features>
        <feature>Tool schema validation</feature>
        <feature>Argument transformation</feature>
        <feature>Result normalization</feature>
        <feature>Error handling and retry</feature>
      </features>
    </component>
    <component name="MCPRegistry">
      <description>Registry of external MCP servers</description>
      <storage>
        <table name="mcp_external_servers">
          <column name="id" type="UUID" primary="true" />
          <column name="name" type="VARCHAR(255)" unique="true" />
          <column name="url" type="TEXT" />
          <column name="transport" type="VARCHAR(20)" />
          <column name="auth_type" type="VARCHAR(50)" />
          <column name="credentials" type="JSONB" encrypted="true" />
          <column name="capabilities" type="JSONB" />
          <column name="metadata" type="JSONB" />
          <column name="status" type="VARCHAR(20)" />
          <column name="last_health_check" type="TIMESTAMP" />
          <column name="created_at" type="TIMESTAMP" />
          <column name="updated_at" type="TIMESTAMP" />
        </table>
      </storage>
    </component>
  </core_components>
  <data_models>
    <model name="MCPServerConfig">
      <fields>
        <field name="name" type="str" required="true">Server identifier</field>
        <field name="url" type="str" required="true">Server URL or command</field>
        <field name="transport" type="MCPTransport" required="true">Transport type</field>
        <field name="auth" type="MCPAuthConfig" required="false">Authentication config</field>
        <field name="timeout" type="int" default="30000">Timeout in ms</field>
        <field name="retry_config" type="RetryConfig" required="false">Retry configuration</field>
      </fields>
    </model>
    <model name="MCPConnection">
      <fields>
        <field name="id" type="str">Connection ID</field>
        <field name="server_name" type="str">Server name</field>
        <field name="transport" type="MCPTransport">Transport instance</field>
        <field name="session_id" type="str">Session identifier</field>
        <field name="capabilities" type="Dict[str, Any]">Server capabilities</field>
        <field name="status" type="ConnectionStatus">Connection status</field>
        <field name="created_at" type="datetime">Creation timestamp</field>
      </fields>
    </model>
    <model name="MCPTool">
      <fields>
        <field name="name" type="str">Tool identifier</field>
        <field name="description" type="str">Tool description</field>
        <field name="server_name" type="str">Source server</field>
        <field name="input_schema" type="Dict[str, Any]">JSON Schema for inputs</field>
        <field name="output_schema" type="Dict[str, Any]">JSON Schema for outputs</field>
        <field name="metadata" type="Dict[str, Any]">Additional metadata</field>
      </fields>
    </model>
    <model name="MCPToolResult">
      <fields>
        <field name="tool_name" type="str">Tool that was executed</field>
        <field name="server_name" type="str">Server that executed it</field>
        <field name="content" type="List[Dict[str, Any]]">Result content</field>
        <field name="is_error" type="bool">Error indicator</field>
        <field name="error_message" type="str" optional="true">Error details</field>
        <field name="execution_time_ms" type="int">Execution duration</field>
      </fields>
    </model>
  </data_models>
  <external_server_examples>
    <server name="filesystem">
      <description>Local filesystem access via MCP</description>
      <config>
        {
          "name": "filesystem",
          "command": "npx",
          "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/allowed/directory"],
          "transport": "stdio"
        }
      </config>
      <tools>
        <tool>read_file</tool>
        <tool>write_file</tool>
        <tool>list_directory</tool>
        <tool>search_files</tool>
      </tools>
    </server>
    <server name="github">
      <description>GitHub repository access</description>
      <config>
        {
          "name": "github",
          "command": "npx",
          "args": ["-y", "@modelcontextprotocol/server-github"],
          "transport": "stdio",
          "env": {
            "GITHUB_TOKEN": "${GITHUB_TOKEN}"
          }
        }
      </config>
      <tools>
        <tool>search_repositories</tool>
        <tool>read_file_from_repo</tool>
        <tool>list_issues</tool>
        <tool>create_issue</tool>
      </tools>
    </server>
    <server name="postgres">
      <description>PostgreSQL database access</description>
      <config>
        {
          "name": "postgres",
          "command": "npx",
          "args": ["-y", "@modelcontextprotocol/server-postgres", "postgresql://localhost/mydb"],
          "transport": "stdio"
        }
      </config>
      <tools>
        <tool>query</tool>
        <tool>list_tables</tool>
        <tool>describe_table</tool>
      </tools>
    </server>
    <server name="readme">
      <description>Documentation server for README files</description>
      <config>
        {
          "name": "readme",
          "url": "http://localhost:3000/mcp",
          "transport": "http",
          "auth": {
            "type": "api_key",
            "key": "${README_API_KEY}"
          }
        }
      </config>
      <resources>
        <resource>readme://project/overview</resource>
        <resource>readme://api/reference</resource>
        <resource>readme://guides/quickstart</resource>
      </resources>
    </server>
  </external_server_examples>
  <caching_strategy>
    <cache_levels>
      <level name="tool_results">
        <ttl>300</ttl>
        <description>Cache tool execution results for 5 minutes</description>
        <key_pattern>{server_name}:{tool_name}:{args_hash}</key_pattern>
      </level>
      <level name="resource_content">
        <ttl>600</ttl>
        <description>Cache resource content for 10 minutes</description>
        <key_pattern>{server_name}:{resource_uri}</key_pattern>
      </level>
      <level name="tool_definitions">
        <ttl>3600</ttl>
        <description>Cache tool definitions for 1 hour</description>
        <key_pattern>{server_name}:tools</key_pattern>
      </level>
    </cache_levels>
    <invalidation>
      <trigger>Manual cache clear via API</trigger>
      <trigger>Server reconnection</trigger>
      <trigger>TTL expiration</trigger>
    </invalidation>
  </caching_strategy>
  <security_model>
    <authentication>
      <method name="api_key">
        <storage>Encrypted in database</storage>
        <rotation>Support for key rotation</rotation>
      </method>
      <method name="oauth2">
        <providers>GitHub, Google, Custom</providers>
        <token_refresh>Automatic refresh before expiry</token_refresh>
      </method>
      <method name="environment">
        <description>Environment variables for sensitive data</description>
        <interpolation>Support for ${VAR_NAME} in configs</interpolation>
      </method>
    </authentication>
    <authorization>
      <policy name="server_whitelist">
        <description>Only connect to whitelisted servers</description>
        <enforcement>Check before connection</enforcement>
      </policy>
      <policy name="tool_permissions">
        <description>Restrict tool execution based on user role</description>
        <enforcement>Check before tool execution</enforcement>
      </policy>
      <policy name="resource_access">
        <description>Control resource access patterns</description>
        <enforcement>URI pattern matching</enforcement>
      </policy>
    </authorization>
    <sandboxing>
      <feature>Input sanitization before forwarding</feature>
      <feature>Output validation after execution</feature>
      <feature>Rate limiting per server</feature>
      <feature>Execution timeout enforcement</feature>
    </sandboxing>
  </security_model>
  <api_endpoints>
    <endpoint method="POST" path="/api/mcp-client/servers">
      <description>Register a new external MCP server</description>
      <auth>Admin role required</auth>
      <body>
        <field name="name" type="str">Server name</field>
        <field name="config" type="MCPServerConfig">Server configuration</field>
      </body>
    </endpoint>
    <endpoint method="GET" path="/api/mcp-client/servers">
      <description>List registered MCP servers</description>
      <response>
        <field name="servers" type="List[MCPServerInfo]">Server list</field>
      </response>
    </endpoint>
    <endpoint method="POST" path="/api/mcp-client/servers/{server_name}/connect">
      <description>Connect to an MCP server</description>
      <params>
        <param name="server_name" location="path">Server to connect</param>
      </params>
    </endpoint>
    <endpoint method="GET" path="/api/mcp-client/servers/{server_name}/tools">
      <description>List tools from external server</description>
      <params>
        <param name="server_name" location="path">Server name</param>
      </params>
    </endpoint>
    <endpoint method="POST" path="/api/mcp-client/tools/execute">
      <description>Execute tool from external server</description>
      <body>
        <field name="server_name" type="str">Target server</field>
        <field name="tool_name" type="str">Tool to execute</field>
        <field name="arguments" type="Dict">Tool arguments</field>
      </body>
    </endpoint>
    <endpoint method="GET" path="/api/mcp-client/servers/{server_name}/resources">
      <description>List resources from external server</description>
      <params>
        <param name="server_name" location="path">Server name</param>
      </params>
    </endpoint>
    <endpoint method="POST" path="/api/mcp-client/resources/read">
      <description>Read resource from external server</description>
      <body>
        <field name="server_name" type="str">Target server</field>
        <field name="uri" type="str">Resource URI</field>
      </body>
    </endpoint>
    <endpoint method="DELETE" path="/api/mcp-client/cache">
      <description>Clear MCP client cache</description>
      <params>
        <param name="server_name" location="query" optional="true">Specific server</param>
        <param name="cache_type" location="query" optional="true">Cache type to clear</param>
      </params>
    </endpoint>
  </api_endpoints>
  <integration_flow>
    <step number="1">
      <action>Register external MCP server configuration</action>
      <details>Admin adds server config with authentication details</details>
    </step>
    <step number="2">
      <action>Establish connection to server</action>
      <details>Client connects using appropriate transport</details>
    </step>
    <step number="3">
      <action>Discover available tools and resources</action>
      <details>Query server for capabilities and cache results</details>
    </step>
    <step number="4">
      <action>Execute tools or read resources</action>
      <details>Proxy requests through security layer</details>
    </step>
    <step number="5">
      <action>Return results to Netra agents</action>
      <details>Transform and validate results before returning</details>
    </step>
  </integration_flow>
  <chat_interface_integration>
    <overview>
      <description>
        Users can interact with MCP tools and resources through the chat interface.
        The supervisor agent, triage agent, and data agent can discover and execute 
        MCP tools from external servers as part of their normal workflow, extending
        Netra's capabilities with external integrations.
      </description>
      <goals>
        <goal priority="critical">Enable MCP tool discovery through chat messages</goal>
        <goal priority="critical">Execute MCP tools via agent orchestration</goal>
        <goal priority="critical">Display MCP results in chat response layers</goal>
        <goal priority="high">Seamless integration with existing agent workflow</goal>
        <goal priority="high">Natural language invocation of MCP capabilities</goal>
      </goals>
    </overview>
    <agent_integration>
      <supervisor_agent>
        <capabilities>
          <capability>Discover available MCP servers and tools</capability>
          <capability>Route MCP requests to appropriate sub-agents</capability>
          <capability>Coordinate multi-server MCP operations</capability>
          <capability>Manage MCP tool execution permissions</capability>
        </capabilities>
        <flow>
          <step>Analyze user message for MCP-related intent</step>
          <step>Query MCP registry for available tools</step>
          <step>Delegate to appropriate sub-agent with MCP context</step>
          <step>Aggregate results from MCP operations</step>
        </flow>
      </supervisor_agent>
      <triage_agent>
        <capabilities>
          <capability>Execute diagnostic MCP tools</capability>
          <capability>Access external documentation via MCP</capability>
          <capability>Query external monitoring systems</capability>
        </capabilities>
        <tools>
          <tool>GitHub issue search and creation</tool>
          <tool>Documentation server queries</tool>
          <tool>Log file analysis via filesystem MCP</tool>
        </tools>
      </triage_agent>
      <data_agent>
        <capabilities>
          <capability>Query external databases via MCP</capability>
          <capability>Access external data sources</capability>
          <capability>Transform and analyze MCP-provided data</capability>
        </capabilities>
        <tools>
          <tool>PostgreSQL queries via MCP</tool>
          <tool>CSV/JSON file processing</tool>
          <tool>External API data fetching</tool>
        </tools>
      </data_agent>
    </agent_integration>
    <message_processing>
      <detection>
        <pattern>Explicit MCP tool invocation: "use MCP tool {tool_name}"</pattern>
        <pattern>Server reference: "from {server_name} server"</pattern>
        <pattern>Resource access: "get resource {uri}"</pattern>
        <pattern>Natural language: AI detects MCP-solvable queries</pattern>
      </detection>
      <routing>
        <rule>
          <condition>User requests external data or file access</condition>
          <action>Route to data_agent with MCP context</action>
        </rule>
        <rule>
          <condition>User needs GitHub or documentation access</condition>
          <action>Route to triage_agent with MCP context</action>
        </rule>
        <rule>
          <condition>User wants to manage MCP servers</condition>
          <action>Handle in supervisor with admin check</action>
        </rule>
      </routing>
    </message_processing>
    <websocket_protocol>
      <message_types>
        <message type="mcp_tool_discovery">
          <fields>
            <field name="server_name" type="str">Target server</field>
            <field name="tools" type="List[MCPTool]">Available tools</field>
          </fields>
        </message>
        <message type="mcp_tool_execution">
          <fields>
            <field name="tool_name" type="str">Tool being executed</field>
            <field name="server_name" type="str">Server executing</field>
            <field name="status" type="str">pending|executing|completed|error</field>
          </fields>
        </message>
        <message type="mcp_tool_result">
          <fields>
            <field name="tool_name" type="str">Tool that executed</field>
            <field name="result" type="MCPToolResult">Execution result</field>
            <field name="layer" type="str">fast|medium|slow</field>
          </fields>
        </message>
      </message_types>
      <event_flow>
        <event>User sends message requiring MCP tool</event>
        <event>Supervisor identifies MCP requirement</event>
        <event>Send mcp_tool_discovery message</event>
        <event>Send mcp_tool_execution with status=pending</event>
        <event>Execute tool via appropriate agent</event>
        <event>Send mcp_tool_execution with status=executing</event>
        <event>Send mcp_tool_result with response</event>
        <event>Update chat layers with formatted result</event>
      </event_flow>
    </websocket_protocol>
    <ui_components>
      <component name="MCPToolIndicator">
        <location>MessageItem component</location>
        <display>
          <item>Show MCP tool icon when MCP tools used</item>
          <item>Display server name and tool name</item>
          <item>Show execution status and timing</item>
        </display>
      </component>
      <component name="MCPServerStatus">
        <location>ChatHeader component</location>
        <display>
          <item>Connected MCP servers count</item>
          <item>Active MCP operations indicator</item>
          <item>Click to view server details</item>
        </display>
      </component>
      <component name="MCPResultCard">
        <location>Within message layers</location>
        <display>
          <item>Formatted MCP tool results</item>
          <item>Source server attribution</item>
          <item>Execution metadata</item>
        </display>
      </component>
    </ui_components>
    <user_scenarios>
      <scenario name="Query External Database">
        <user_message>Can you check the user_stats table in our analytics database?</user_message>
        <flow>
          <step>Supervisor detects database query intent</step>
          <step>Routes to data_agent with MCP context</step>
          <step>Data agent discovers postgres MCP server</step>
          <step>Executes query tool with table name</step>
          <step>Returns formatted results in medium layer</step>
        </flow>
      </scenario>
      <scenario name="Access GitHub Issues">
        <user_message>Show me open issues labeled as 'bug' in our repo</user_message>
        <flow>
          <step>Supervisor identifies GitHub operation</step>
          <step>Routes to triage_agent</step>
          <step>Triage agent uses GitHub MCP server</step>
          <step>Executes list_issues tool with filters</step>
          <step>Displays issues in fast layer</step>
        </flow>
      </scenario>
      <scenario name="Read External Files">
        <user_message>Can you analyze the log files in /var/logs/app?</user_message>
        <flow>
          <step>Supervisor detects file operation</step>
          <step>Routes to data_agent</step>
          <step>Data agent uses filesystem MCP server</step>
          <step>Lists and reads log files</step>
          <step>Analyzes content and returns insights</step>
        </flow>
      </scenario>
      <scenario name="Multi-Server Operation">
        <user_message>Compare our GitHub issues with entries in the bug database</user_message>
        <flow>
          <step>Supervisor identifies multi-source operation</step>
          <step>Coordinates between multiple agents</step>
          <step>Triage agent queries GitHub MCP</step>
          <step>Data agent queries postgres MCP</step>
          <step>Supervisor aggregates and correlates results</step>
          <step>Returns comprehensive analysis in slow layer</step>
        </flow>
      </scenario>
    </user_scenarios>
    <permissions_model>
      <user_roles>
        <role name="admin">
          <permissions>
            <permission>Register new MCP servers</permission>
            <permission>Execute all MCP tools</permission>
            <permission>Access all MCP resources</permission>
          </permissions>
        </role>
        <role name="developer">
          <permissions>
            <permission>Execute approved MCP tools</permission>
            <permission>Access development MCP resources</permission>
            <permission>Cannot register new servers</permission>
          </permissions>
        </role>
        <role name="viewer">
          <permissions>
            <permission>View MCP tool results</permission>
            <permission>Cannot execute MCP tools directly</permission>
          </permissions>
        </role>
      </user_roles>
      <tool_restrictions>
        <restriction>
          <tool_pattern>*_write|*_delete|*_update</tool_pattern>
          <required_role>admin</required_role>
        </restriction>
        <restriction>
          <tool_pattern>*_read|*_list|*_search</tool_pattern>
          <required_role>viewer</required_role>
        </restriction>
      </tool_restrictions>
    </permissions_model>
    <error_handling>
      <error_type name="server_unavailable">
        <handling>Fallback to cached results if available</handling>
        <user_message>External server temporarily unavailable</user_message>
      </error_type>
      <error_type name="permission_denied">
        <handling>Log attempt and notify admin</handling>
        <user_message>You don't have permission for this operation</user_message>
      </error_type>
      <error_type name="tool_not_found">
        <handling>Suggest alternative tools</handling>
        <user_message>Requested tool not available</user_message>
      </error_type>
    </error_handling>
  </chat_interface_integration>
  <testing_requirements>
    <unit_tests>
      <test_file>app/tests/mcp_client/test_client_core.py</test_file>
      <test_file>app/tests/mcp_client/test_connection_manager.py</test_file>
      <test_file>app/tests/mcp_client/test_tool_proxy.py</test_file>
      <test_file>app/tests/mcp_client/test_cache.py</test_file>
      <test_file>app/tests/mcp_client/test_security.py</test_file>
    </unit_tests>
    <integration_tests>
      <test_file>app/tests/mcp_client/test_stdio_integration.py</test_file>
      <test_file>app/tests/mcp_client/test_http_integration.py</test_file>
      <test_file>app/tests/mcp_client/test_websocket_integration.py</test_file>
    </integration_tests>
    <e2e_tests>
      <test_file>app/tests/mcp_client/test_e2e_filesystem.py</test_file>
      <test_file>app/tests/mcp_client/test_e2e_github.py</test_file>
      <test_file>app/tests/mcp_client/test_e2e_multi_server.py</test_file>
    </e2e_tests>
  </testing_requirements>
  <performance_targets>
    <metric name="connection_time">
      <target>&lt; 500ms</target>
      <description>Time to establish connection</description>
    </metric>
    <metric name="tool_discovery">
      <target>&lt; 100ms (cached)</target>
      <description>Time to list available tools</description>
    </metric>
    <metric name="tool_execution">
      <target>&lt; 50ms overhead</target>
      <description>Additional latency for proxying</description>
    </metric>
    <metric name="concurrent_servers">
      <target>50+</target>
      <description>Number of simultaneous server connections</description>
    </metric>
  </performance_targets>
  <monitoring>
    <metrics>
      <metric name="mcp_client_connections_total">Active connections by server</metric>
      <metric name="mcp_client_tool_executions">Tool executions by server and tool</metric>
      <metric name="mcp_client_errors">Errors by type and server</metric>
      <metric name="mcp_client_cache_hits">Cache hit rate by type</metric>
      <metric name="mcp_client_latency">Request latency by operation</metric>
    </metrics>
    <logging>
      <level>INFO</level>
      <structured>JSON format with trace_id</structured>
      <sensitive_data>Redact authentication tokens</sensitive_data>
    </logging>
  </monitoring>
  <deployment>
    <environment_variables>
      <var name="MCP_CLIENT_ENABLED" default="true">Enable MCP client</var>
      <var name="MCP_CLIENT_CACHE_SIZE" default="1000">Max cache entries</var>
      <var name="MCP_CLIENT_TIMEOUT" default="30000">Default timeout in ms</var>
      <var name="MCP_CLIENT_MAX_RETRIES" default="3">Max retry attempts</var>
    </environment_variables>
    <dependencies>
      <dependency name="httpx">Async HTTP client</dependency>
      <dependency name="websockets">WebSocket client</dependency>
      <dependency name="asyncio">Async subprocess for stdio</dependency>
    </dependencies>
  </deployment>
  <future_enhancements>
    <enhancement priority="high">
      <title>Tool Composition</title>
      <description>Combine tools from multiple servers into workflows</description>
    </enhancement>
    <enhancement priority="medium">
      <title>Server Discovery</title>
      <description>Automatic discovery of MCP servers via mDNS/DNS-SD</description>
    </enhancement>
    <enhancement priority="low">
      <title>Tool Translation</title>
      <description>Translate between different tool formats and schemas</description>
    </enhancement>
    <enhancement priority="medium">
      <title>Federated Execution</title>
      <description>Execute tools across multiple servers in parallel</description>
    </enhancement>
  </future_enhancements>
</specification>