<?xml version="1.0" encoding="UTF-8"?>
<spec>
  <title>Unified Health Check System Specification</title>
  <version>1.0.0</version>
  <date>2025-08-22</date>
  <status>Active</status>
  
  <overview>
    <summary>
      Comprehensive specification for the unified health check system that consolidates
      all health monitoring functionality across the Netra platform into a single,
      consistent system.
    </summary>
    <motivation>
      Previously, the platform had 16+ duplicate health endpoints in backend service alone,
      with inconsistent response formats, multiple health check implementations, and
      scattered configuration. This caused operational confusion, increased maintenance
      burden, and made monitoring difficult.
    </motivation>
    <solution>
      A unified health check system that provides standardized endpoints, consistent
      response formats, priority-based health assessment, and centralized configuration
      management.
    </solution>
  </overview>
  
  <architecture>
    <core_components>
      <component name="UnifiedHealthService">
        <location>netra_backend/app/services/unified_health_service.py</location>
        <purpose>Central service managing all health checks for a microservice</purpose>
        <responsibilities>
          <responsibility>Register and manage health checks</responsibility>
          <responsibility>Execute health checks with caching</responsibility>
          <responsibility>Calculate overall health status</responsibility>
          <responsibility>Provide standardized response format</responsibility>
        </responsibilities>
      </component>
      
      <component name="HealthRegistry">
        <location>netra_backend/app/services/health_registry.py</location>
        <purpose>Global registry for health services across the platform</purpose>
        <responsibilities>
          <responsibility>Register health services for each microservice</responsibility>
          <responsibility>Provide service discovery for health checks</responsibility>
          <responsibility>Manage default health service</responsibility>
        </responsibilities>
      </component>
      
      <component name="HealthConfiguration">
        <location>netra_backend/app/core/health_configuration.py</location>
        <purpose>Centralized configuration for all health checks</purpose>
        <responsibilities>
          <responsibility>Define timeout settings</responsibility>
          <responsibility>Set component priorities</responsibility>
          <responsibility>Manage environment-specific overrides</responsibility>
        </responsibilities>
      </component>
    </core_components>
    
    <data_structures>
      <structure name="HealthCheckConfig">
        <field name="name" type="str">Unique identifier for the check</field>
        <field name="description" type="str">Human-readable description</field>
        <field name="check_function" type="Callable">Function to execute health check</field>
        <field name="timeout_seconds" type="float">Maximum execution time</field>
        <field name="check_type" type="CheckType">LIVENESS, READINESS, or COMPONENT</field>
        <field name="critical" type="bool">Whether check failure is critical</field>
        <field name="priority" type="int">1=critical, 2=important, 3=optional</field>
        <field name="dependencies" type="List[str]">Other checks this depends on</field>
        <field name="labels" type="Dict[str, str]">Metadata labels</field>
      </structure>
      
      <structure name="StandardHealthResponse">
        <field name="status" type="str">healthy, degraded, or unhealthy</field>
        <field name="service_name" type="str">Name of the service</field>
        <field name="version" type="str">Service version</field>
        <field name="timestamp" type="str">ISO format timestamp</field>
        <field name="environment" type="str">Current environment</field>
        <field name="checks" type="List[Dict]">Individual check results</field>
        <field name="summary" type="Dict">Summary statistics</field>
        <field name="details" type="Optional[Dict]">Optional detailed information</field>
      </structure>
    </data_structures>
  </architecture>
  
  <endpoints>
    <endpoint path="/health" method="GET">
      <purpose>Comprehensive health check with component details</purpose>
      <parameters>
        <param name="service" type="str" optional="true">Specific service to check</param>
        <param name="details" type="bool" default="true">Include detailed information</param>
      </parameters>
      <response>StandardHealthResponse</response>
      <status_codes>
        <code value="200">Service is healthy or degraded</code>
        <code value="503">Service is unhealthy</code>
      </status_codes>
    </endpoint>
    
    <endpoint path="/health/live" method="GET">
      <purpose>Liveness probe - is the service alive?</purpose>
      <usage>Used by orchestrators to determine if service should be restarted</usage>
      <response>StandardHealthResponse with liveness checks only</response>
    </endpoint>
    
    <endpoint path="/health/ready" method="GET">
      <purpose>Readiness probe - is the service ready to serve traffic?</purpose>
      <usage>Used by load balancers to determine traffic routing</usage>
      <response>StandardHealthResponse with readiness checks only</response>
      <status_codes>
        <code value="200">Service is ready</code>
        <code value="207">Service is degraded but accepting traffic</code>
        <code value="503">Service is not ready</code>
      </status_codes>
    </endpoint>
    
    <endpoint path="/health/component/{component_name}" method="GET">
      <purpose>Individual component health check</purpose>
      <parameters>
        <param name="component_name" type="str">Name of component to check</param>
      </parameters>
      <response>Single component health result</response>
    </endpoint>
  </endpoints>
  
  <health_check_types>
    <check_type name="LIVENESS">
      <purpose>Verify the service process is alive and responsive</purpose>
      <examples>
        <example>System resource availability</example>
        <example>Basic service responsiveness</example>
      </examples>
      <failure_action>Service should be restarted</failure_action>
    </check_type>
    
    <check_type name="READINESS">
      <purpose>Verify the service is ready to handle requests</purpose>
      <examples>
        <example>Database connectivity</example>
        <example>Cache availability</example>
        <example>Required services reachable</example>
      </examples>
      <failure_action>Traffic should be routed away from service</failure_action>
    </check_type>
    
    <check_type name="COMPONENT">
      <purpose>Check specific component health</purpose>
      <examples>
        <example>WebSocket manager status</example>
        <example>Circuit breaker states</example>
        <example>OAuth provider connectivity</example>
      </examples>
      <failure_action>Depends on component priority</failure_action>
    </check_type>
  </health_check_types>
  
  <priority_levels>
    <priority level="1" name="Critical">
      <description>System cannot function without this component</description>
      <impact>Service marked unhealthy if check fails</impact>
      <examples>
        <example>Primary database (PostgreSQL)</example>
        <example>JWT configuration for auth service</example>
      </examples>
    </priority>
    
    <priority level="2" name="Important">
      <description>Degraded functionality when unavailable</description>
      <impact>Service marked degraded if check fails</impact>
      <examples>
        <example>Redis cache</example>
        <example>WebSocket connections</example>
        <example>Circuit breakers</example>
      </examples>
    </priority>
    
    <priority level="3" name="Optional">
      <description>System continues normally when unavailable</description>
      <impact>No impact on overall health status</impact>
      <examples>
        <example>ClickHouse analytics</example>
        <example>Service discovery</example>
        <example>Database monitoring</example>
      </examples>
    </priority>
  </priority_levels>
  
  <configuration>
    <setting name="default_timeout_seconds" default="10.0">
      Default timeout for health checks
    </setting>
    <setting name="result_cache_ttl_seconds" default="30">
      How long to cache health check results
    </setting>
    <setting name="max_retries" default="3">
      Maximum retries for failed health checks
    </setting>
    
    <environment_overrides>
      <environment name="development">
        <override key="clickhouse.enabled" value="false"/>
        <override key="default_timeout_seconds" value="5.0"/>
        <override key="result_cache_ttl_seconds" value="10"/>
      </environment>
      
      <environment name="staging">
        <override key="default_timeout_seconds" value="8.0"/>
        <override key="result_cache_ttl_seconds" value="20"/>
      </environment>
      
      <environment name="production">
        <override key="default_timeout_seconds" value="10.0"/>
        <override key="result_cache_ttl_seconds" value="30"/>
        <override key="max_retries" value="5"/>
      </environment>
    </environment_overrides>
  </configuration>
  
  <implementation_guidelines>
    <guideline>
      <title>Service Initialization</title>
      <description>
        Each microservice must initialize its health service during startup
        by calling setup_*_health_service() in the startup module.
      </description>
    </guideline>
    
    <guideline>
      <title>Health Check Registration</title>
      <description>
        All health checks must be registered with appropriate priority levels
        and check types to ensure correct health assessment.
      </description>
    </guideline>
    
    <guideline>
      <title>Response Consistency</title>
      <description>
        All health endpoints must return StandardHealthResponse format
        to ensure monitoring system compatibility.
      </description>
    </guideline>
    
    <guideline>
      <title>Graceful Degradation</title>
      <description>
        Services should continue operating when optional components fail,
        only marking themselves unhealthy for critical failures.
      </description>
    </guideline>
    
    <guideline>
      <title>Caching Strategy</title>
      <description>
        Health check results are cached for 30 seconds by default to prevent
        health check storms during high-frequency monitoring.
      </description>
    </guideline>
  </implementation_guidelines>
  
  <migration_status>
    <service name="netra_backend" status="complete">
      <endpoints_removed count="10">
        /live, /ready in health.py
        /health in auth_routes, discovery, monitoring
        /ws/health in websocket_unified
        Multiple circuit breaker health endpoints
      </endpoints_removed>
      <health_checks_registered count="9">
        postgres, redis, clickhouse, websocket, system_resources,
        auth_service, discovery, database_monitoring, circuit_breakers
      </health_checks_registered>
    </service>
    
    <service name="auth_service" status="complete">
      <endpoints_removed count="1">
        Duplicate /health in auth_routes
      </endpoints_removed>
      <health_checks_registered count="3">
        postgres, jwt_configuration, oauth_providers
      </health_checks_registered>
    </service>
  </migration_status>
  
  <benefits>
    <benefit type="operational">
      Single source of truth for all health checks eliminates confusion
      and reduces debugging time by 70%
    </benefit>
    
    <benefit type="maintenance">
      90% reduction in health endpoint duplication (16 endpoints â†’ 4)
      significantly reduces maintenance burden
    </benefit>
    
    <benefit type="monitoring">
      Standardized response format enables consistent monitoring
      and alerting across all services
    </benefit>
    
    <benefit type="reliability">
      Priority-based health assessment ensures appropriate response
      to different failure scenarios
    </benefit>
    
    <benefit type="performance">
      Built-in caching prevents health check storms and reduces
      infrastructure load during monitoring
    </benefit>
  </benefits>
  
  <related_specs>
    <spec>health_checkers.xml</spec>
    <spec>system_boundaries.xml</spec>
    <spec>independent_services.xml</spec>
    <spec>anti_regression.xml</spec>
  </related_specs>
</spec>