<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>SecretManagementPatterns</name>
        <type>ArchitecturalPattern</type>
        <version>1.0</version>
        <description>Defines architectural patterns and interfaces for secure secret management across the platform</description>
        <created>2025-08-21</created>
    </metadata>

    <principles>
        <principle id="unified-interface">
            <title>Unified Secret Management Interface</title>
            <description>
                All secret management must go through a unified interface that provides
                consistent access patterns regardless of the underlying secret store.
            </description>
        </principle>
        
        <principle id="public-api">
            <title>Public API for External Consumers</title>
            <description>
                Secret managers must expose public methods for external components.
                Private methods (_method) should only be used internally.
            </description>
        </principle>
        
        <principle id="graceful-degradation">
            <title>Graceful Degradation on Failure</title>
            <description>
                Secret loading failures should be logged but not crash the application.
                The system should operate with available secrets.
            </description>
        </principle>
        
        <principle id="multi-source">
            <title>Multi-Source Secret Loading</title>
            <description>
                Support loading secrets from multiple sources with proper precedence:
                1. Environment variables (highest priority)
                2. Cloud provider secret stores (GCP, AWS)
                3. Local files (development only)
            </description>
        </principle>
    </principles>

    <interfaces>
        <interface name="SecretManager">
            <description>Core secret management interface for loading and managing secrets</description>
            <methods>
                <method name="load_all_secrets" visibility="public">
                    <signature>load_all_secrets() -> Dict[str, Any]</signature>
                    <description>Load all secrets from configured sources and return as dictionary</description>
                    <behavior>
                        - Calls internal _load_secrets_from_sources()
                        - Returns copy of internal cache to prevent external modification
                        - Handles cache expiration and refresh
                    </behavior>
                </method>
                
                <method name="populate_secrets" visibility="public">
                    <signature>populate_secrets(config: AppConfig) -> None</signature>
                    <description>Populate configuration object with loaded secrets</description>
                </method>
                
                <method name="rotate_secret" visibility="public">
                    <signature>rotate_secret(secret_name: str) -> bool</signature>
                    <description>Rotate a specific secret if rotation is enabled</description>
                </method>
                
                <method name="get_secret_summary" visibility="public">
                    <signature>get_secret_summary() -> Dict[str, Any]</signature>
                    <description>Get monitoring summary of secret management status</description>
                </method>
                
                <method name="validate_secrets_consistency" visibility="public">
                    <signature>validate_secrets_consistency(config: AppConfig) -> List[str]</signature>
                    <description>Validate secret configuration consistency and return issues</description>
                </method>
            </methods>
        </interface>
        
        <interface name="UnifiedSecretManager">
            <description>High-level unified interface aggregating multiple secret sources</description>
            <methods>
                <method name="load_all_secrets" visibility="public">
                    <signature>load_all_secrets() -> Dict[str, Any]</signature>
                    <description>Load and merge secrets from all configured sources</description>
                    <behavior>
                        - Load environment variable secrets
                        - Load GCP secrets via SecretManager.load_all_secrets()
                        - Load AWS secrets (when implemented)
                        - Merge with proper precedence
                        - Return consolidated dictionary
                    </behavior>
                </method>
                
                <method name="get_secret" visibility="public">
                    <signature>get_secret(key: str, default: Optional[Any] = None) -> Any</signature>
                    <description>Get a specific secret value with optional default</description>
                </method>
                
                <method name="refresh_secrets" visibility="public">
                    <signature>refresh_secrets() -> None</signature>
                    <description>Force refresh of all secret caches</description>
                </method>
            </methods>
        </interface>
    </interfaces>

    <patterns>
        <pattern id="error-handling">
            <title>Resilient Error Handling</title>
            <code><![CDATA[
def _load_gcp_secrets(self) -> Dict[str, Any]:
    """Load secrets from Google Secret Manager."""
    try:
        return self._secret_manager.load_all_secrets()
    except Exception as e:
        self._logger.warning(f"Failed to load GCP secrets: {e}")
        return {}  # Return empty dict, don't crash
            ]]></code>
        </pattern>
        
        <pattern id="interface-testing">
            <title>Interface Contract Testing</title>
            <code><![CDATA[
def test_secret_manager_interface():
    """Test that SecretManager provides required public interface."""
    manager = SecretManager()
    
    # Verify public methods exist
    assert hasattr(manager, 'load_all_secrets')
    assert hasattr(manager, 'populate_secrets')
    assert hasattr(manager, 'rotate_secret')
    assert hasattr(manager, 'get_secret_summary')
    
    # Verify methods are callable
    assert callable(manager.load_all_secrets)
    
    # Verify return types
    result = manager.load_all_secrets()
    assert isinstance(result, dict)
            ]]></code>
        </pattern>
        
        <pattern id="cache-management">
            <title>Secure Cache Management</title>
            <code><![CDATA[
def load_all_secrets(self) -> Dict[str, Any]:
    """Load all secrets with cache management."""
    self._load_secrets_from_sources()
    # Return copy to prevent external modification
    return dict(self._secret_cache)
            ]]></code>
        </pattern>
    </patterns>

    <anti-patterns>
        <anti-pattern id="private-method-access">
            <title>Accessing Private Methods Externally</title>
            <bad><![CDATA[
# BAD: External component accessing private method
secrets = secret_manager._load_from_gcp_secret_manager()
cache = secret_manager._secret_cache  # Direct cache access
            ]]></bad>
            <good><![CDATA[
# GOOD: Use public interface
secrets = secret_manager.load_all_secrets()
            ]]></good>
        </anti-pattern>
        
        <anti-pattern id="crash-on-failure">
            <title>Crashing on Secret Loading Failure</title>
            <bad><![CDATA[
# BAD: Crash the application
secrets = self._secret_manager.load_all_secrets()
if not secrets:
    raise ConfigurationError("Failed to load secrets")
            ]]></bad>
            <good><![CDATA[
# GOOD: Log and continue with available secrets
try:
    secrets = self._secret_manager.load_all_secrets()
except Exception as e:
    self._logger.warning(f"Failed to load some secrets: {e}")
    secrets = {}
            ]]></good>
        </anti-pattern>
    </anti-patterns>

    <testing>
        <test-requirement>
            All secret management components must have interface contract tests
        </test-requirement>
        <test-requirement>
            Error handling paths must be tested with mock failures
        </test-requirement>
        <test-requirement>
            Multi-source precedence must be verified with integration tests
        </test-requirement>
    </testing>
</specification>