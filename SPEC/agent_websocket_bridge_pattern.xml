<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <title>AgentWebSocketBridge Pattern - SSOT for Service Integration</title>
    <version>1.0</version>
    <date>2025-09-01</date>
    <status>implemented</status>
    
    <business_justification>
        <segment>Platform/Internal</segment>
        <business_goal>Stability &amp; Development Velocity</business_goal>
        <value_impact>60% reduction in glue code, reliable agent-websocket coordination</value_impact>
        <strategic_impact>Enables zero-downtime recovery and substantive chat interactions</strategic_impact>
    </business_justification>
    
    <pattern_overview>
        <description>
            The AgentWebSocketBridge serves as the Single Source of Truth (SSOT) for 
            managing the integration lifecycle between AgentService and WebSocketAgentOrchestrator.
            It provides idempotent initialization, health monitoring, and recovery mechanisms
            while maintaining clear boundaries between WebSocket, Agent, and Bridge concerns.
        </description>
        
        <problem_solved>
            <issue>Repetitive glue code for WebSocket-Agent integration setup</issue>
            <issue>Non-idempotent initialization causing race conditions</issue>
            <issue>Mixed responsibilities between service and integration concerns</issue>
            <issue>No recovery mechanisms for failed integrations</issue>
            <issue>Global state dependencies making testing difficult</issue>
        </problem_solved>
        
        <solution_approach>
            <approach>Single Source of Truth pattern for integration lifecycle</approach>
            <approach>Bridge pattern for clean coordination without mixing concerns</approach>
            <approach>Singleton pattern with thread-safe async initialization</approach>
            <approach>Health monitoring with automatic recovery mechanisms</approach>
            <approach>Graceful degradation ensuring service availability</approach>
        </solution_approach>
    </pattern_overview>
    
    <architectural_principles>
        <principle id="ssot">
            <name>Single Source of Truth</name>
            <description>Bridge is THE place for WebSocket-Agent integration logic</description>
            <implementation>All integration setup, health monitoring, and recovery in one class</implementation>
            <violation>Multiple classes handling integration setup or state</violation>
        </principle>
        
        <principle id="clear_boundaries">
            <name>Clear Boundary Separation</name>
            <description>WebSocket, Agent, and Bridge concerns remain separate</description>
            <implementation>Bridge coordinates but doesn't mix domain-specific logic</implementation>
            <example>Agent determines error messages, WebSocket handles delivery, Bridge coordinates</example>
        </principle>
        
        <principle id="idempotent_operations">
            <name>Idempotent Operations</name>
            <description>All bridge methods can be called multiple times safely</description>
            <implementation>ensure_integration() checks state before acting</implementation>
            <benefit>Safe retry mechanisms, no side effects from repeated calls</benefit>
        </principle>
        
        <principle id="health_monitoring">
            <name>Continuous Health Monitoring</name>
            <description>Bridge continuously monitors integration health</description>
            <implementation>Background health checks with automatic recovery triggers</implementation>
            <sla>Health check interval ≤ 60s, recovery time ≤ 5s</sla>
        </principle>
        
        <principle id="graceful_degradation">
            <name>Graceful Degradation</name>
            <description>Service works even if bridge/coordination fails</description>
            <implementation>Fallback execution paths in AgentService</implementation>
            <business_continuity>Core agent functionality always available</business_continuity>
        </principle>
    </architectural_principles>
    
    <implementation_structure>
        <core_class>
            <name>AgentWebSocketBridge</name>
            <location>netra_backend/app/services/agent_websocket_bridge.py</location>
            <pattern>Singleton with async initialization</pattern>
            <responsibilities>
                <responsibility>Integration lifecycle management</responsibility>
                <responsibility>Health monitoring and metrics</responsibility>
                <responsibility>Recovery and retry mechanisms</responsibility>
                <responsibility>Configuration management</responsibility>
            </responsibilities>
        </core_class>
        
        <integration_points>
            <point>
                <name>AgentService Integration</name>
                <description>AgentService uses bridge for WebSocket coordination</description>
                <method>ensure_service_ready() for comprehensive readiness</method>
                <boundary>Service handles agent logic, bridge handles coordination</boundary>
            </point>
            
            <point>
                <name>WebSocketAgentOrchestrator Management</name>
                <description>Bridge manages orchestrator lifecycle</description>
                <method>Bridge owns orchestrator reference and configuration</method>
                <benefit>Clean separation from service-level concerns</benefit>
            </point>
            
            <point>
                <name>WebSocket Manager Coordination</name>
                <description>Bridge coordinates WebSocket manager setup</description>
                <method>Bridge provides manager to service components</method>
                <idempotency>Safe to reconfigure multiple times</idempotency>
            </point>
        </integration_points>
        
        <state_management>
            <states>
                <state name="UNINITIALIZED">No integration setup performed</state>
                <state name="INITIALIZING">Integration setup in progress</state>
                <state name="ACTIVE">Full integration working correctly</state>
                <state name="DEGRADED">Partial failure, attempting recovery</state>
                <state name="FAILED">Integration broken, manual intervention needed</state>
            </states>
            
            <transitions>
                <transition from="UNINITIALIZED" to="INITIALIZING" trigger="ensure_integration() called"/>
                <transition from="INITIALIZING" to="ACTIVE" trigger="Integration successful"/>
                <transition from="INITIALIZING" to="FAILED" trigger="Integration failed"/>
                <transition from="ACTIVE" to="DEGRADED" trigger="Health check failure"/>
                <transition from="DEGRADED" to="ACTIVE" trigger="Recovery successful"/>
                <transition from="DEGRADED" to="FAILED" trigger="Recovery failed"/>
            </transitions>
        </state_management>
    </implementation_structure>
    
    <key_methods>
        <method name="ensure_integration">
            <signature>async def ensure_integration(supervisor=None, registry=None, force_reinit=False) -> IntegrationResult</signature>
            <purpose>Idempotent integration setup - can be called multiple times safely</purpose>
            <behavior>Checks current state, only initializes if needed or forced</behavior>
            <return>IntegrationResult with success status, state, and metrics</return>
            <idempotency>true</idempotency>
        </method>
        
        <method name="health_check">
            <signature>async def health_check() -> HealthStatus</signature>
            <purpose>Comprehensive health check of integration components</purpose>
            <checks>WebSocket manager, orchestrator, connection health</checks>
            <frequency>Every 60 seconds by default</frequency>
            <performance>≤10ms execution time</performance>
        </method>
        
        <method name="recover_integration">
            <signature>async def recover_integration() -> IntegrationResult</signature>
            <purpose>Attempt recovery from failed integration state</purpose>
            <mechanism>Exponential backoff with configurable max attempts</mechanism>
            <default_config>3 attempts, 1s base delay, 30s max delay</default_config>
            <trigger>Automatic after 3 consecutive health failures</trigger>
        </method>
        
        <method name="get_status">
            <signature>async def get_status() -> Dict[str, Any]</signature>
            <purpose>Comprehensive status including health, metrics, and config</purpose>
            <sections>state, health, metrics, config, dependencies</sections>
            <observability>Full system observability for monitoring</observability>
        </method>
        
        <method name="ensure_event_delivery">
            <signature>async def ensure_event_delivery(context, event_type, payload) -> bool</signature>
            <purpose>Guaranteed event delivery with retry logic</purpose>
            <business_critical>Enables substantive chat interactions</business_critical>
            <retry_mechanism>Exponential backoff, 3 attempts max</retry_mechanism>
            <timeout>500ms max for good chat UX</timeout>
        </method>
    </key_methods>
    
    <integration_with_agent_service>
        <constructor_changes>
            <old_pattern>Direct WebSocket manager setup with try/catch fallbacks</old_pattern>
            <new_pattern>Bridge initialization through asyncio.create_task()</new_pattern>
            <benefit>Clean separation, non-blocking initialization</benefit>
        </constructor_changes>
        
        <readiness_pattern>
            <method>ensure_service_ready()</method>
            <description>Comprehensive readiness check including bridge status</description>
            <usage>Call before critical operations like agent execution</usage>
            <recovery>Automatically attempts recovery if bridge unhealthy</recovery>
        </readiness_pattern>
        
        <execution_flow>
            <step>AgentService.execute_agent() called</step>
            <step>ensure_service_ready() verifies bridge status</step>
            <step>Bridge provides orchestrator for execution context</step>
            <step>WebSocket events sent through bridge-managed components</step>
            <step>Fallback to direct execution if bridge unavailable</step>
        </execution_flow>
        
        <status_integration>
            <comprehensive_status>AgentService.get_comprehensive_status() includes bridge metrics</comprehensive_status>
            <user_status>get_agent_status() includes bridge health for user-facing status</user_status>
            <observability>Full stack observability through service interface</observability>
        </status_integration>
    </integration_with_agent_service>
    
    <testing_strategy>
        <unit_tests>
            <file>netra_backend/tests/services/test_agent_websocket_bridge.py</file>
            <coverage>Singleton pattern, state management, health monitoring, recovery</coverage>
            <test_count>20+ unit tests</test_count>
        </unit_tests>
        
        <integration_tests>
            <file>netra_backend/tests/services/test_agent_service_bridge_integration.py</file>
            <coverage>Service-bridge integration, boundary separation, lifecycle</coverage>
            <test_count>15+ integration tests</test_count>
        </integration_tests>
        
        <mission_critical_tests>
            <file>netra_backend/tests/mission_critical/test_websocket_agent_events_bridge.py</file>
            <coverage>WebSocket event delivery, business value preservation, chat UX</coverage>
            <business_focus>Substantive chat interactions, user trust, system reliability</business_focus>
            <test_count>10+ mission-critical tests</test_count>
        </mission_critical_tests>
        
        <test_principles>
            <principle>Real services over mocks wherever possible</principle>
            <principle>Business value validation in mission-critical tests</principle>
            <principle>Boundary separation verification</principle>
            <principle>Idempotency and recovery testing</principle>
            <principle>Performance and timing validation</principle>
        </test_principles>
    </testing_strategy>
    
    <usage_guidelines>
        <for_agent_services>
            <initialization>Use bridge through ensure_service_ready() before operations</initialization>
            <status_checking>Include bridge status in service status reporting</status_checking>
            <error_handling>Implement fallback paths for bridge unavailability</error_handling>
            <websocket_access>Access WebSocket manager through bridge, not directly</websocket_access>
        </for_agent_services>
        
        <for_websocket_integration>
            <setup>Let bridge handle all orchestrator configuration</setup>
            <event_delivery>Use bridge.ensure_event_delivery() for critical events</event_delivery>
            <health_monitoring>Rely on bridge health checks rather than custom monitoring</health_monitoring>
            <recovery>Trust bridge recovery mechanisms, avoid custom retry logic</recovery>
        </for_websocket_integration>
        
        <for_testing>
            <mocking>Mock bridge factory function for clean test isolation</mocking>
            <state_testing>Test all integration states and transitions</state_testing>
            <boundary_testing>Verify concerns don't leak across boundaries</boundary_testing>
            <business_value>Include mission-critical tests for WebSocket event delivery</business_value>
        </for_testing>
    </usage_guidelines>
    
    <performance_characteristics>
        <initialization>≤100ms for normal integration setup</initialization>
        <health_checks>≤10ms per health check operation</health_checks>
        <recovery_time>≤5s for typical failure recovery</recovery_time>
        <memory_overhead>≤1MB additional memory for bridge singleton</memory_overhead>
        <event_delivery>≥99.5% success rate with retry mechanisms</event_delivery>
        <scalability>Single bridge instance supports unlimited service instances</scalability>
    </performance_characteristics>
    
    <maintenance_considerations>
        <singleton_management>
            <consideration>Bridge singleton lives for application lifetime</consideration>
            <shutdown>Proper shutdown required to clean up background tasks</shutdown>
            <testing>Reset singleton between tests for isolation</testing>
        </singleton_management>
        
        <configuration_updates>
            <consideration>Bridge configuration changes require restart</consideration>
            <hot_reloading>No hot reloading support for configuration</hot_reloading>
            <environment_changes>Environment variable changes need application restart</environment_changes>
        </configuration_updates>
        
        <monitoring_integration>
            <metrics>Bridge exposes comprehensive metrics for monitoring</metrics>
            <alerts>Set up alerts on consecutive health failures ≥3</alerts>
            <dashboards>Include bridge status in operational dashboards</dashboards>
        </monitoring_integration>
        
        <troubleshooting>
            <logs>Bridge provides detailed logging for troubleshooting</logs>
            <status_endpoint>Use get_status() for diagnostic information</status_endpoint>
            <recovery>Manual recovery through ensure_integration(force_reinit=True)</recovery>
        </troubleshooting>
    </maintenance_considerations>
    
    <compliance_requirements>
        <ssot_compliance>Bridge must be only place for integration logic</ssot_compliance>
        <boundary_compliance>Clear separation between WebSocket/Agent/Bridge concerns</boundary_compliance>
        <idempotency_compliance>All operations must be safe to retry</idempotency_compliance>
        <health_compliance>Continuous health monitoring with recovery</health_compliance>
        <testing_compliance>95%+ test coverage including mission-critical scenarios</testing_compliance>
        <performance_compliance>Meet all specified performance characteristics</performance_compliance>
        <documentation_compliance>Keep specification updated with implementation changes</documentation_compliance>
    </compliance_requirements>
</specification>