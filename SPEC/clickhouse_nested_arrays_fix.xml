<?xml version="1.0" encoding="UTF-8"?>
<specification>
  <title>ClickHouse Nested Arrays Type Handling Fix</title>
  <version>1.0</version>
  <date>2025-08-10</date>
  <author>Netra AI Development Team</author>
  
  <problem_description>
    <issue>
      ClickHouse queries were failing with error code 386 (NO_COMMON_TYPE) when trying to 
      access nested array fields in the workload_events table.
    </issue>
    <error_message>
      Code: 386. DB::Exception: There is no supertype for types Array(String), String 
      because some of them are Array and some of them are not
    </error_message>
    <affected_queries>
      - Performance metrics queries
      - Usage pattern analysis queries  
      - Anomaly detection queries
    </affected_queries>
  </problem_description>

  <root_cause>
    <description>
      The workload_events table uses ClickHouse's Nested data type for metrics, which creates:
      - metrics.name as Array(String)
      - metrics.value as Array(Float64)
      - metrics.unit as Array(String)
      
      However, the queries were using incorrect syntax that could return mixed types when 
      indexOf returns 0 (element not found), leading to type mismatches.
    </description>
    <incorrect_syntax>
      <!-- Old incorrect syntax that could cause type issues -->
      metrics.value[indexOf(metrics.name, 'latency_ms')]
      
      <!-- This syntax fails when indexOf returns 0 or when dealing with null values -->
    </incorrect_syntax>
  </root_cause>

  <solution>
    <approach>
      Refactor all ClickHouse queries to properly handle nested arrays with null-safe operations
      and conditional expressions to ensure type consistency.
    </approach>
    
    <key_changes>
      <change id="1">
        <description>Use conditional aggregate functions with index checks</description>
        <before>
          quantile(0.5)(metrics.value[indexOf(metrics.name, 'latency_ms')])
        </before>
        <after>
          quantileIf(0.5)(arrayElement(metrics.value, idx), idx > 0)
        </after>
      </change>
      
      <change id="2">
        <description>Pre-calculate indices in subqueries</description>
        <before>
          SELECT 
            avg(arrayElement(metrics.value, indexOf(metrics.name, 'latency_ms')))
          FROM workload_events
        </before>
        <after>
          SELECT 
            avgIf(arrayElement(metrics.value, idx), idx > 0)
          FROM (
            SELECT 
              metrics.value,
              indexOf(metrics.name, 'latency_ms') as idx
            FROM workload_events
          )
        </after>
      </change>
      
      <change id="3">
        <description>Use conditional expressions for null-safe access</description>
        <before>
          arrayElement(metrics.value, indexOf(metrics.name, 'cost_cents'))
        </before>
        <after>
          if(indexOf(metrics.name, 'cost_cents') > 0, 
             arrayElement(metrics.value, indexOf(metrics.name, 'cost_cents')), 
             0)
        </after>
      </change>
    </key_changes>
  </solution>

  <best_practices>
    <practice id="1">
      <title>Always check index validity</title>
      <description>
        When using indexOf with nested arrays, always check if the result is greater than 0
        before using it with arrayElement to avoid accessing invalid indices.
      </description>
    </practice>
    
    <practice id="2">
      <title>Use conditional aggregate functions</title>
      <description>
        Use functions like avgIf, sumIf, quantileIf when aggregating values from nested arrays
        to handle cases where the metric might not exist in some rows.
      </description>
    </practice>
    
    <practice id="3">
      <title>Pre-calculate indices in subqueries</title>
      <description>
        For complex queries, calculate indices once in a subquery and reuse them in the outer
        query to improve performance and readability.
      </description>
    </practice>
    
    <practice id="4">
      <title>Provide default values</title>
      <description>
        Always provide sensible default values (e.g., 0 for numeric fields) when a metric
        is not found in the nested array.
      </description>
    </practice>
  </best_practices>

  <implementation_notes>
    <note id="1">
      <title>Performance Consideration</title>
      <description>
        While the conditional checks add some overhead, they ensure query reliability and
        prevent runtime errors. The performance impact is minimal compared to the cost of
        query failures.
      </description>
    </note>
    
    <note id="2">
      <title>Backward Compatibility</title>
      <description>
        These changes maintain backward compatibility with existing data and don't require
        any schema migrations. They only affect how queries are constructed.
      </description>
    </note>
    
    <note id="3">
      <title>Testing Recommendation</title>
      <description>
        Test queries with both populated and empty nested arrays to ensure they handle all
        edge cases correctly.
      </description>
    </note>
  </implementation_notes>

  <affected_files>
    <file>app/agents/data_sub_agent.py</file>
  </affected_files>

  <query_patterns>
    <pattern id="performance_metrics">
      <description>Pattern for aggregating performance metrics</description>
      <template><![CDATA[
SELECT
    {time_function}(timestamp) as time_bucket,
    count() as event_count,
    quantileIf(0.5)(arrayElement(metrics.value, idx), idx > 0) as latency_p50,
    avgIf(arrayElement(metrics.value, idx2), idx2 > 0) as avg_throughput
FROM (
    SELECT
        *,
        indexOf(metrics.name, 'latency_ms') as idx,
        indexOf(metrics.name, 'throughput') as idx2
    FROM workload_events
    WHERE {conditions}
)
GROUP BY time_bucket
      ]]></template>
    </pattern>
    
    <pattern id="anomaly_detection">
      <description>Pattern for anomaly detection with baseline stats</description>
      <template><![CDATA[
WITH baseline_stats AS (
    SELECT
        avgIf(arrayElement(metrics.value, idx), idx > 0) as mean_value,
        stddevPopIf(arrayElement(metrics.value, idx), idx > 0) as std_value
    FROM (
        SELECT
            metrics.value,
            indexOf(metrics.name, '{metric_name}') as idx
        FROM workload_events
        WHERE {baseline_conditions}
    )
)
SELECT
    timestamp,
    if(idx > 0, arrayElement(metrics.value, idx), 0) as metric_value,
    (metric_value - baseline_stats.mean_value) / nullIf(baseline_stats.std_value, 0) as z_score
FROM (
    SELECT
        *,
        indexOf(metrics.name, '{metric_name}') as idx
    FROM workload_events
    WHERE {conditions}
), baseline_stats
      ]]></template>
    </pattern>
  </query_patterns>

  <verification>
    <test id="1">
      <description>Verify queries handle empty nested arrays</description>
      <scenario>Run queries on rows where metrics.name is an empty array</scenario>
      <expected>Queries should return 0 or null values without errors</expected>
    </test>
    
    <test id="2">
      <description>Verify queries handle missing metrics</description>
      <scenario>Query for a metric name that doesn't exist in any row</scenario>
      <expected>Queries should return 0 values without type errors</expected>
    </test>
    
    <test id="3">
      <description>Verify performance with large datasets</description>
      <scenario>Run queries on tables with millions of rows</scenario>
      <expected>Query performance should be acceptable (< 5 seconds for most queries)</expected>
    </test>
  </verification>
</specification>