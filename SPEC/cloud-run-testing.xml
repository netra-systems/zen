<CloudRunLocalTestingGuide>
  <Title>Netra Apex Cloud Run Local Testing and Validation</Title>
  <Introduction>
    This guide outlines the procedures for locally testing the Netra Apex AI Optimization Platform services before Cloud Run deployment. The focus is on simulating the complete microservice architecture (backend, frontend, auth-service), validating agent workloads, and ensuring WebSocket connectivity.
  </Introduction>
  
  <NetraContext>
    <ProjectID>netra-staging</ProjectID>
    <Region>us-central1</Region>
    <Services>
      <Service name="netra-backend-staging" port="8000" type="FastAPI"/>
      <Service name="netra-frontend-staging" port="3000" type="React"/>
      <Service name="netra-auth-service" port="8001" type="FastAPI"/>
    </Services>
    <Databases>
      <Database type="PostgreSQL" port="5432"/>
      <Database type="ClickHouse" port="8123"/>
      <Database type="Redis" port="6379"/>
    </Databases>
  </NetraContext>

  <Prerequisites>
    <Item>Docker Desktop or Engine installed and running.</Item>
    <Item>Google Cloud SDK (gcloud CLI) installed and authenticated.</Item>
    <Item>Dockerfiles: Dockerfile.backend, Dockerfile.frontend.staging, Dockerfile.auth</Item>
    <Item>Service account key: gcp-staging-sa-key.json</Item>
    <Item>Python test_runner.py configured for staging tests</Item>
  </Prerequisites>

  <Section title="1. Simulating the Cloud Run Environment">
    <Subsection title="1.1. Building Netra Service Images">
      <Description>Build all Netra microservice images locally using staging configurations.</Description>
      <Commands>
        <Backend>docker build -t netra-backend-staging:local -f Dockerfile.backend .</Backend>
        <Frontend>docker build -t netra-frontend-staging:local -f Dockerfile.frontend.staging --build-arg REACT_APP_API_URL=http://localhost:8000 --build-arg REACT_APP_WS_URL=ws://localhost:8000/ws .</Frontend>
        <Auth>docker build -t netra-auth-service:local -f Dockerfile.auth .</Auth>
      </Commands>
    </Subsection>

    <Subsection title="1.2. Adhering to the Container Contract">
      <Description>Cloud Run requires the application to be stateless and listen on `0.0.0.0` at the port specified by the `PORT` environment variable (usually 8080).</Description>
      <Command>
export PORT=8080
# Run the container, mapping a local port (e.g., 9090) to the container's PORT
docker run -p 9090:${PORT} -e PORT=${PORT} my-app:local
      </Command>
      <Verification>Access the application via `http://localhost:9090`.</Verification>
    </Subsection>

    <Subsection title="1.3. Injecting Configuration">
      <Description>Use environment variables for configuration. Locally, use a `.env` file (ensure it is in `.gitignore`) or the `-e` flag.</Description>
      <Command>docker run -p 9090:8080 --env-file ./.env.local my-app:local</Command>
    </Subsection>

    <Subsection title="1.4. Simulating Cloud Run Variables">
      <Description>Cloud Run automatically injects `K_SERVICE`, `K_REVISION`, and `K_CONFIGURATION`. Simulate these if needed.</Description>
      <Command>
docker run -p 9090:8080 -e PORT=8080 \
  -e K_SERVICE=local-dev \
  -e K_REVISION=local-dev-001 \
  my-app:local
      </Command>
    </Subsection>
  </Section>

  <Section title="2. Authentication to Google Cloud Services">
    <Description>When your local container interacts with other GCP services (e.g., Storage, Firestore), it needs credentials. Do not embed credentials in the image.</Description>

    <Method name="Application Default Credentials (ADC) - Recommended">
      <Description>Mount the credentials generated by the gcloud CLI on your host machine into the container. Google client libraries will automatically detect them.</Description>
      <Step1>Generate local ADC (if not already done):</Step1>
      <Command>gcloud auth application-default login</Command>
      <Step2>Run the container by mounting the gcloud configuration directory:</Step2>
      <Command>
# Example for Linux/macOS. Adjust the source path for Windows (%APPDATA%\gcloud).
docker run -p 9090:8080 -e PORT=8080 \
  -v ~/.config/gcloud:/root/.config/gcloud \
  my-app:local
      </Command>
    </Method>

    <Method name="Service Account Impersonation (Netra Staging)">
      <Description>Test with the exact permissions of the Netra staging service account.</Description>
      <Command>gcloud auth application-default login --impersonate-service-account=staging-deployer@netra-staging.iam.gserviceaccount.com</Command>
    </Method>

    <Method name="Service Account Key File (Use with Caution)">
      <Description>If ADC is not feasible, mount a service account key file. Treat this file as a secret.</Description>
      <Command>
SA_KEY_PATH="/path/to/key.json"
docker run -p 9090:8080 -e PORT=8080 \
  -v ${SA_KEY_PATH}:/tmp/keys/sa_key.json:ro \
  -e GOOGLE_APPLICATION_CREDENTIALS=/tmp/keys/sa_key.json \
  my-app:local
      </Command>
    </Method>
  </Section>

  <Section title="3. Managing Dependencies and Emulation">
    <Step name="Use Google Cloud Emulators">
      <Description>Use local emulators for services like Pub/Sub, Firestore, and Bigtable instead of connecting to live services.</Description>
      <Example>gcloud beta emulators pubsub start --host-port=localhost:8085</Example>
      <Note>Configure your application to use the emulator by setting environment variables (e.g., `PUBSUB_EMULATOR_HOST`). When running in Docker, you may need to use `host.docker.internal` instead of `localhost` to access the host machine.</Note>
    </Step>
    <Step name="Orchestrate Netra Services with Docker Compose">
      <Description>Use Docker Compose to manage all Netra microservices and dependencies.</Description>
      <Example language="yaml">
version: '3.8'
services:
  # Backend Service
  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    ports:
      - "8000:8000"
    environment:
      PORT: 8000
      DATABASE_URL: postgresql://netra:password@postgres:5432/netra
      CLICKHOUSE_HOST: clickhouse
      REDIS_URL: redis://redis:6379
      JWT_SECRET: test-secret-key
      AUTH_SERVICE_URL: http://auth:8001
    depends_on:
      - postgres
      - clickhouse
      - redis
      - auth

  # Frontend Service  
  frontend:
    build:
      context: .
      dockerfile: Dockerfile.frontend.staging
      args:
        REACT_APP_API_URL: http://localhost:8000
        REACT_APP_WS_URL: ws://localhost:8000/ws
    ports:
      - "3000:3000"
    environment:
      PORT: 3000
    depends_on:
      - backend

  # Auth Service
  auth:
    build:
      context: .
      dockerfile: Dockerfile.auth
    ports:
      - "8001:8001"
    environment:
      PORT: 8001
      DATABASE_URL: postgresql://netra:password@postgres:5432/netra_auth
      JWT_SECRET: test-secret-key
    depends_on:
      - postgres

  # Databases
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: netra
      POSTGRES_PASSWORD: password
      POSTGRES_DB: netra
    ports:
      - "5432:5432"
      
  clickhouse:
    image: clickhouse/clickhouse-server:latest
    ports:
      - "8123:8123"
      - "9000:9000"
      
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
      </Example>
    </Step>
    <Step name="Cloud SQL Connectivity">
      <Description>If connecting to a managed Cloud SQL instance, use the Cloud SQL Auth Proxy locally, either running on the host machine or as a sidecar container in Docker Compose.</Description>
    </Step>
  </Section>

  <Section title="4. Infrastructure (IaC) and CI/CD Validation">
    <Subsection title="4.1. Infrastructure as Code (e.g., Terraform)">
      <Description>Validate the configuration for "cloud infra deploy" locally.</Description>
      <Step>Static Analysis: Check syntax and structure.</Step>
      <Command>terraform validate</Command>
      <Step>Dry Run: Preview changes against a development GCP project.</Step>
      <Command>terraform plan -var-file="dev.tfvars"</Command>
    </Subsection>
    <Subsection title="4.2. CI/CD Pipeline Simulation (Cloud Build)">
      <Description>If using `cloudbuild.yaml`, simulate the build process locally using the `cloud-build-local` tool.</Description>
      <Setup>gcloud components install cloud-build-local</Setup>
      <Command>cloud-build-local --dryrun=false .</Command>
    </Subsection>
  </Section>

  <Section title="5. Advanced Tooling">
    <Tool name="Cloud Code">
      <Description>Use Cloud Code plugins (VS Code, JetBrains) for an integrated Cloud Run emulation experience, offering debugging and hot-reloading directly within the IDE.</Description>
    </Tool>
  </Section>

  <Section title="6. Key Considerations">
    <Item>
      <Topic>Filesystem</Topic>
      <Detail>Cloud Run uses an in-memory filesystem. Ensure the application is stateless and does not rely on persistent local storage.</Detail>
    </Item>
    <Item>
      <Topic>Metadata Server</Topic>
      <Detail>The Google Cloud Metadata server (for instance identity, project info) is unavailable locally. Mock responses if your application depends on it.</Detail>
    </Item>
  </Section>

  <Section title="7. Netra-Specific Testing Procedures">
    <Subsection title="7.1. Agent Testing">
      <Description>Test LLM agent functionality with local and staging configurations.</Description>
      <LocalTesting>
        <Command>python test_runner.py --level agents --mock-llm</Command>
        <Description>Test with mocked LLM responses for fast feedback</Description>
      </LocalTesting>
      <StagingTesting>
        <Command>python test_runner.py --level agents --real-llm --staging</Command>
        <Description>Test with real LLM calls against staging endpoints</Description>
      </StagingTesting>
    </Subsection>

    <Subsection title="7.2. WebSocket Testing">
      <Description>Validate WebSocket connections and message handling.</Description>
      <LocalTest>
        <Command>python -m pytest tests/e2e/websocket_resilience/ -v</Command>
      </LocalTest>
      <StagingTest>
        <Command>STAGING_MODE=true python -m pytest tests/e2e/websocket_resilience/ -v</Command>
      </StagingTest>
    </Subsection>

    <Subsection title="7.3. Integration Testing">
      <Description>Run integration tests against local Docker containers.</Description>
      <Command>docker-compose up -d && python test_runner.py --level integration --docker-endpoints</Command>
    </Subsection>

    <Subsection title="7.4. Health Check Validation">
      <Description>Verify all services respond correctly to health checks.</Description>
      <Commands>
        <Backend>curl http://localhost:8000/health</Backend>
        <Frontend>curl http://localhost:3000/health</Frontend>
        <Auth>curl http://localhost:8001/health</Auth>
      </Commands>
    </Subsection>
  </Section>

  <Section title="8. Pre-Deployment Checklist">
    <Item>✓ All Docker images build successfully</Item>
    <Item>✓ Docker Compose brings up all services without errors</Item>
    <Item>✓ Health checks pass for all services</Item>
    <Item>✓ Integration tests pass locally</Item>
    <Item>✓ WebSocket connections work correctly</Item>
    <Item>✓ Authentication flow works end-to-end</Item>
    <Item>✓ Database migrations apply cleanly</Item>
    <Item>✓ Environment variables are correctly configured</Item>
    <Item>✓ Service account permissions are validated</Item>
    <Item>✓ No hardcoded secrets in images</Item>
  </Section>
</CloudRunLocalTestingGuide>