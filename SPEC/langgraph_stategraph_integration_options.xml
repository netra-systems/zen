<?xml version="1.0" encoding="UTF-8"?>
<specification>
    <metadata>
        <name>LangGraph StateGraph Integration Options for Netra Apex</name>
        <type>Architecture Proposal</type>
        <version>1.0</version>
        <created>2025-08-26</created>
        <description>Detailed integration options for implementing LangGraph StateGraph in the agent system</description>
        <business_impact>Improved workflow orchestration, state management, and system reliability</business_impact>
    </metadata>

    <executive_summary>
        <current_state>Custom workflow execution with separate TODO tracking</current_state>
        <proposed_change>Integrate LangGraph StateGraph for unified state and workflow management</proposed_change>
        <expected_benefits>Better state persistence, workflow visualization, error recovery, and task tracking</expected_benefits>
    </executive_summary>

    <integration_options>
        
        <option id="OPT-001" priority="HIGH" complexity="MEDIUM">
            <title>Replace SupervisorWorkflowExecutor with StateGraph</title>
            <scope>netra_backend/app/agents/supervisor/workflow_execution.py</scope>
            
            <implementation_approach>
                <step>Define AgentGraphState extending TypedDict with all DeepAgentState fields</step>
                <step>Create StateGraph nodes for each pipeline step (triage, data, optimization, etc.)</step>
                <step>Define conditional edges based on triage results</step>
                <step>Add checkpointing for state persistence</step>
            </implementation_approach>

            <code_example><![CDATA[
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Optional, Any

class AgentGraphState(TypedDict):
    # Core request fields
    user_request: str
    chat_thread_id: str
    user_id: str
    
    # Agent results (from DeepAgentState)
    triage_result: Optional[dict]
    data_result: Optional[dict]
    optimizations_result: Optional[dict]
    action_plan_result: Optional[dict]
    
    # TODO tracking integration
    todo_items: List[dict]
    current_task: Optional[str]
    completed_tasks: List[str]
    
    # Workflow metadata
    messages: List[dict]
    next_action: str
    error: Optional[str]

# Build the graph
workflow = StateGraph(AgentGraphState)

# Add nodes for each agent
workflow.add_node("triage", triage_agent_node)
workflow.add_node("data_analysis", data_agent_node)
workflow.add_node("optimization", optimization_agent_node)
workflow.add_node("action_planning", action_agent_node)
workflow.add_node("todo_update", todo_update_node)

# Add conditional routing
workflow.add_conditional_edges(
    "triage",
    route_based_on_triage,
    {
        "data": "data_analysis",
        "optimize": "optimization",
        "action": "action_planning",
        "error": END
    }
)

# Compile with checkpointing
from langgraph.checkpoint import MemorySaver
checkpointer = MemorySaver()
app = workflow.compile(checkpointer=checkpointer)
            ]]></code_example>

            <benefits>
                <benefit>Unified state management across all agents</benefit>
                <benefit>Built-in checkpointing for crash recovery</benefit>
                <benefit>Visual workflow representation via graph.get_graph()</benefit>
                <benefit>Streaming state updates for real-time monitoring</benefit>
            </benefits>

            <risks>
                <risk>Breaking change to existing workflow execution</risk>
                <risk>Need to migrate existing state persistence logic</risk>
            </risks>
        </option>

        <option id="OPT-002" priority="HIGH" complexity="LOW">
            <title>Integrate TODO Tracking into Agent State</title>
            <scope>netra_backend/app/agents/state.py and observability_todo_tracker.py</scope>
            
            <implementation_approach>
                <step>Add todo_state field to DeepAgentState</step>
                <step>Create TodoState TypedDict for LangGraph compatibility</step>
                <step>Update TodoTracker to work with graph state</step>
                <step>Add todo state transitions as graph nodes</step>
            </implementation_approach>

            <code_example><![CDATA[
from typing import TypedDict, List, Literal

class TodoItem(TypedDict):
    task_id: str
    description: str
    priority: Literal["high", "medium", "low"]
    status: Literal["pending", "in_progress", "completed", "failed"]
    created_time: float
    completed_time: Optional[float]
    error: Optional[str]

class TodoState(TypedDict):
    todos: List[TodoItem]
    active_task_id: Optional[str]
    completed_count: int
    failed_count: int

# Add to DeepAgentState
class DeepAgentState(BaseModel):
    # ... existing fields ...
    todo_state: Optional[TodoState] = None
    
# Graph node for TODO updates
async def update_todo_state(state: AgentGraphState) -> AgentGraphState:
    """Update TODO items based on agent execution results."""
    if state.get("triage_result"):
        # Mark triage task as completed
        for todo in state["todos"]:
            if todo["task_id"] == "triage":
                todo["status"] = "completed"
                todo["completed_time"] = time.time()
    
    # Determine next task
    next_task = get_next_pending_task(state["todos"])
    if next_task:
        state["current_task"] = next_task["task_id"]
        next_task["status"] = "in_progress"
    
    return state
            ]]></code_example>

            <benefits>
                <benefit>Unified task tracking within agent state</benefit>
                <benefit>Task state transitions as part of workflow</benefit>
                <benefit>Better debugging with task progression visibility</benefit>
            </benefits>

            <risks>
                <risk>Minimal - additive change to existing state</risk>
            </risks>
        </option>

        <option id="OPT-003" priority="MEDIUM" complexity="HIGH">
            <title>Full LangGraph Migration with Persistence</title>
            <scope>Entire supervisor and agent execution system</scope>
            
            <implementation_approach>
                <step>Replace all agent execute() methods with graph nodes</step>
                <step>Implement PostgreSQL checkpointer for production persistence</step>
                <step>Add graph visualization endpoint for monitoring</step>
                <step>Implement streaming updates via WebSocket</step>
            </implementation_approach>

            <code_example><![CDATA[
from langgraph.checkpoint.postgres import PostgresSaver
from langgraph.graph import StateGraph, END
import asyncpg

# Production-grade checkpointing
async def create_checkpointer():
    conn = await asyncpg.connect(DATABASE_URL)
    return PostgresSaver(conn)

class SupervisorGraph:
    def __init__(self, checkpointer):
        self.graph = self._build_graph()
        self.app = self.graph.compile(checkpointer=checkpointer)
    
    def _build_graph(self) -> StateGraph:
        workflow = StateGraph(AgentGraphState)
        
        # Add all agent nodes
        workflow.add_node("start", self.initialize_state)
        workflow.add_node("triage", self.triage_node)
        workflow.add_node("parallel_execution", self.parallel_agents_node)
        workflow.add_node("aggregation", self.aggregate_results)
        workflow.add_node("response", self.format_response)
        
        # Complex routing logic
        workflow.add_edge("start", "triage")
        workflow.add_conditional_edges(
            "triage",
            self.route_after_triage,
            {
                "parallel": "parallel_execution",
                "sequential": "data_analysis",
                "error": "error_handler"
            }
        )
        
        return workflow
    
    async def execute(self, user_request: str, thread_id: str) -> AsyncIterator[dict]:
        """Stream execution updates."""
        initial_state = {
            "user_request": user_request,
            "chat_thread_id": thread_id,
            "todos": self._initialize_todos(user_request)
        }
        
        async for state in self.app.astream(
            initial_state,
            {"configurable": {"thread_id": thread_id}}
        ):
            yield state  # Stream to WebSocket
            ]]></code_example>

            <benefits>
                <benefit>Complete workflow managed by LangGraph</benefit>
                <benefit>Production-grade persistence and recovery</benefit>
                <benefit>Built-in parallelization support</benefit>
                <benefit>Time-travel debugging via checkpoints</benefit>
            </benefits>

            <risks>
                <risk>Major architectural change</risk>
                <risk>Requires extensive testing and migration</risk>
                <risk>Team learning curve for LangGraph patterns</risk>
            </risks>
        </option>

        <option id="OPT-004" priority="LOW" complexity="LOW">
            <title>Hybrid Approach - LangGraph for Complex Workflows Only</title>
            <scope>Create new graph-based workflows alongside existing system</scope>
            
            <implementation_approach>
                <step>Keep existing system for simple workflows</step>
                <step>Use LangGraph for complex multi-agent orchestration</step>
                <step>Gradually migrate workflows based on complexity</step>
            </implementation_approach>

            <benefits>
                <benefit>Low risk - existing system continues working</benefit>
                <benefit>Learn LangGraph patterns gradually</benefit>
                <benefit>Can A/B test performance</benefit>
            </benefits>

            <risks>
                <risk>Dual maintenance burden</risk>
                <risk>Potential confusion with two systems</risk>
            </risks>
        </option>
    </integration_options>

    <recommended_approach>
        <phase number="1" timeline="1 week">
            <action>Implement OPT-002: Integrate TODO tracking into DeepAgentState</action>
            <rationale>Low risk, immediate benefit, prepares state for LangGraph</rationale>
        </phase>
        <phase number="2" timeline="2-3 weeks">
            <action>Implement OPT-001: Replace SupervisorWorkflowExecutor with basic StateGraph</action>
            <rationale>Core integration with manageable scope</rationale>
        </phase>
        <phase number="3" timeline="1 month">
            <action>Add persistence and streaming from OPT-003</action>
            <rationale>Production-ready features once core is stable</rationale>
        </phase>
    </recommended_approach>

    <success_metrics>
        <metric>Workflow execution time reduction (target: 20%)</metric>
        <metric>State recovery success rate (target: 99.9%)</metric>
        <metric>TODO tracking accuracy (target: 100%)</metric>
        <metric>Developer productivity improvement via visualization</metric>
    </success_metrics>

    <implementation_checklist>
        <item>Verify LangGraph compatibility with existing LangChain versions</item>
        <item>Create state migration utilities for existing workflows</item>
        <item>Implement comprehensive test suite for graph workflows</item>
        <item>Add monitoring and alerting for graph execution</item>
        <item>Create developer documentation and examples</item>
        <item>Plan rollback strategy if issues arise</item>
    </implementation_checklist>
</specification>