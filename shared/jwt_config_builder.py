"""
JWT Configuration Builder - Unified JWT Settings
Following SecretManagerBuilder pattern for consistent JWT configuration.

Business Value Justification (BVJ):
- Segment: Enterprise (prevents $12K MRR churn)
- Business Goal: Retention (eliminate cross-service auth failures)
- Value Impact: Standardizes JWT configuration across all services preventing token validation failures
- Strategic Impact: $12K MRR retention + $8K expansion opportunity by fixing auth inconsistencies

CRITICAL BUSINESS PROBLEM SOLVED:
JWT configuration drift between auth_service and netra_backend causes authentication failures
affecting 3 enterprise customers. Different services use different JWT environment variable names,
expiry settings, and secret resolution patterns, leading to tokens generated by one service
failing validation in another service.
"""

import logging
from typing import Dict, Any, Optional, List, Tuple
from dataclasses import dataclass
from shared.secret_manager_builder import SecretManagerBuilder
from shared.config_builder_base import ConfigBuilderBase

logger = logging.getLogger(__name__)


@dataclass
class JWTConfiguration:
    """JWT configuration data structure."""
    secret_key: str
    algorithm: str
    access_token_expire_minutes: int
    refresh_token_expire_days: int
    service_token_expire_minutes: int
    issuer: str
    audience: str
    environment: str


class JWTConfigBuilder(ConfigBuilderBase):
    """
    JWT Configuration Builder - Unified JWT settings across services.
    
    Provides organized access to JWT configuration:
    - secrets.get_jwt_secret_key()
    - timing.get_access_token_expire_minutes()
    - validation.get_algorithm()
    - environment.get_issuer()
    - standardization.get_unified_config()
    """
    
    def __init__(self, service: str = "shared", env_vars: Optional[Dict[str, Any]] = None):
        """Initialize JWT configuration builder."""
        # Call parent constructor which handles environment detection
        super().__init__(env_vars)
        
        self.service = service
        self.secret_builder = SecretManagerBuilder(env_vars=env_vars, service=service)
        
        # Initialize sub-builders
        self.secrets = self.SecretsBuilder(self)
        self.timing = self.TimingBuilder(self)
        self.validation = self.ValidationBuilder(self)
        self.env_settings = self.EnvironmentBuilder(self)  # Renamed to avoid conflict with base class
        self.standardization = self.StandardizationBuilder(self)
    
    class SecretsBuilder:
        """Manages JWT secret key resolution with fallback chains."""
        
        def __init__(self, parent):
            self.parent = parent
        
        def get_jwt_secret_key(self) -> str:
            """Get JWT secret key with comprehensive fallback chain."""
            return self.parent.secret_builder.auth.get_jwt_secret()
        
        def validate_jwt_secret_strength(self, secret: str) -> tuple[bool, str]:
            """Validate JWT secret strength for current environment."""
            env = self.parent.secret_builder.environment
            
            if not secret:
                return False, "JWT secret cannot be empty"
            
            # Environment-specific requirements
            if env == "production":
                if len(secret) < 64:
                    return False, "JWT secret must be at least 64 characters in production"
            elif env == "staging":
                if len(secret) < 32:
                    return False, "JWT secret must be at least 32 characters in staging"
            elif env == "development":
                if len(secret) < 8:
                    return False, "JWT secret must be at least 8 characters even in development"
            
            # Check for weak patterns
            weak_patterns = [
                "dev-jwt-secret",
                "test-secret",
                "jwt-secret-key",
                "change-me",
                "placeholder",
                "example"
            ]
            
            secret_lower = secret.lower()
            for pattern in weak_patterns:
                if pattern in secret_lower and env in ["staging", "production"]:
                    return False, f"JWT secret contains weak pattern '{pattern}' not allowed in {env}"
            
            return True, ""
    
    class TimingBuilder:
        """Manages JWT token timing and expiry settings."""
        
        def __init__(self, parent):
            self.parent = parent
        
        def get_access_token_expire_minutes(self) -> int:
            """Get access token expiry in minutes - standardized across services."""
            # Check for environment-specific override
            env_value = self.parent.secret_builder.env.get("JWT_ACCESS_TOKEN_EXPIRE_MINUTES")
            if env_value:
                try:
                    return int(env_value)
                except ValueError:
                    logger.warning(f"Invalid JWT_ACCESS_TOKEN_EXPIRE_MINUTES: {env_value}, using default")
            
            # Check legacy environment variable names
            legacy_value = self.parent.secret_builder.env.get("JWT_ACCESS_EXPIRY_MINUTES")
            if legacy_value:
                try:
                    # Only warn once about deprecated variable usage
                    if not hasattr(self.parent, '_jwt_access_deprecation_warned'):
                        logger.warning("Using JWT_ACCESS_EXPIRY_MINUTES (DEPRECATED - use JWT_ACCESS_TOKEN_EXPIRE_MINUTES)")
                        self.parent._jwt_access_deprecation_warned = True
                    return int(legacy_value)
                except ValueError:
                    logger.warning(f"Invalid JWT_ACCESS_EXPIRY_MINUTES: {legacy_value}, using default")
            
            # Environment-specific defaults using base class helpers
            if self.parent.is_development():
                return 60  # 1 hour for development convenience
            elif self.parent.is_staging():
                return 30  # 30 minutes for staging
            else:
                return 15  # 15 minutes for production security
        
        def get_refresh_token_expire_days(self) -> int:
            """Get refresh token expiry in days - standardized across services."""
            # Check for environment-specific override
            env_value = self.parent.secret_builder.env.get("JWT_REFRESH_TOKEN_EXPIRE_DAYS")
            if env_value:
                try:
                    return int(env_value)
                except ValueError:
                    logger.warning(f"Invalid JWT_REFRESH_TOKEN_EXPIRE_DAYS: {env_value}, using default")
            
            # Check legacy environment variable names
            legacy_value = self.parent.secret_builder.env.get("JWT_REFRESH_EXPIRY_DAYS")
            if legacy_value:
                try:
                    # Only warn once about deprecated variable usage
                    if not hasattr(self.parent, '_jwt_refresh_deprecation_warned'):
                        logger.warning("Using JWT_REFRESH_EXPIRY_DAYS (DEPRECATED - use JWT_REFRESH_TOKEN_EXPIRE_DAYS)")
                        self.parent._jwt_refresh_deprecation_warned = True
                    return int(legacy_value)
                except ValueError:
                    logger.warning(f"Invalid JWT_REFRESH_EXPIRY_DAYS: {legacy_value}, using default")
            
            # Environment-specific defaults using base class helpers
            if self.parent.is_development():
                return 30  # 30 days for development convenience
            else:
                return 7   # 7 days for staging and production
        
        def get_service_token_expire_minutes(self) -> int:
            """Get service token expiry in minutes - for service-to-service auth."""
            env_value = self.parent.secret_builder.env.get("JWT_SERVICE_TOKEN_EXPIRE_MINUTES")
            if env_value:
                try:
                    return int(env_value)
                except ValueError:
                    logger.warning(f"Invalid JWT_SERVICE_TOKEN_EXPIRE_MINUTES: {env_value}, using default")
            
            # Service tokens have longer expiry for reliability
            return 120  # 2 hours
    
    class ValidationBuilder:
        """Manages JWT validation settings and algorithms."""
        
        def __init__(self, parent):
            self.parent = parent
        
        def get_algorithm(self) -> str:
            """Get JWT algorithm - standardized across services."""
            # Allow environment override for future flexibility
            env_algorithm = self.parent.secret_builder.env.get("JWT_ALGORITHM")
            if env_algorithm:
                # Validate allowed algorithms
                allowed_algorithms = ["HS256", "HS384", "HS512", "RS256", "RS384", "RS512"]
                if env_algorithm in allowed_algorithms:
                    return env_algorithm
                else:
                    logger.warning(f"Invalid JWT_ALGORITHM: {env_algorithm}, using default HS256")
            
            return "HS256"  # Standard HMAC SHA-256
        
        def get_verify_signature(self) -> bool:
            """Get signature verification setting."""
            env_value = self.parent.secret_builder.env.get("JWT_VERIFY_SIGNATURE")
            if env_value:
                return env_value.lower() in ["true", "1", "yes"]
            
            # Always verify signatures except in development with explicit override
            if (self.parent.is_development() and
                self.parent.get_env_bool("JWT_SKIP_SIGNATURE_VERIFICATION", False)):
                logger.warning("JWT signature verification DISABLED for development")
                return False
            
            return True
        
        def get_verify_expiry(self) -> bool:
            """Get expiry verification setting."""
            env_value = self.parent.secret_builder.env.get("JWT_VERIFY_EXPIRY")
            if env_value:
                return env_value.lower() in ["true", "1", "yes"]
            
            # Always verify expiry except in development with explicit override
            if (self.parent.is_development() and
                self.parent.get_env_bool("JWT_SKIP_EXPIRY_VERIFICATION", False)):
                logger.warning("JWT expiry verification DISABLED for development")
                return False
            
            return True
    
    class EnvironmentBuilder:
        """Manages environment-specific JWT settings."""
        
        def __init__(self, parent):
            self.parent = parent
        
        def get_issuer(self) -> str:
            """Get JWT issuer - environment and service specific."""
            # Check for explicit override
            env_issuer = self.parent.secret_builder.env.get("JWT_ISSUER")
            if env_issuer:
                return env_issuer
            
            # Generate environment and service-specific issuer
            return f"netra-{self.parent.service}-{self.parent.environment}"
        
        def get_audience(self) -> str:
            """Get JWT audience - standardized across services."""
            # Check for explicit override
            env_audience = self.parent.secret_builder.env.get("JWT_AUDIENCE")
            if env_audience:
                return env_audience
            
            # Standard audience for all Netra services
            return f"netra-platform-{self.parent.environment}"
        
        def get_subject_prefix(self) -> str:
            """Get subject prefix for JWT tokens."""
            service = self.parent.service
            return f"{service}:"
    
    class StandardizationBuilder:
        """Manages cross-service standardization and compatibility."""
        
        def __init__(self, parent):
            self.parent = parent
        
        def get_unified_config(self) -> JWTConfiguration:
            """Get complete unified JWT configuration."""
            secret_key = self.parent.secrets.get_jwt_secret_key()
            
            # Validate secret strength
            is_valid, error = self.parent.secrets.validate_jwt_secret_strength(secret_key)
            if not is_valid:
                if self.parent.is_staging() or self.parent.is_production():
                    raise ValueError(f"JWT secret validation failed: {error}")
                else:
                    logger.warning(f"JWT secret validation warning: {error}")
            
            return JWTConfiguration(
                secret_key=secret_key,
                algorithm=self.parent.validation.get_algorithm(),
                access_token_expire_minutes=self.parent.timing.get_access_token_expire_minutes(),
                refresh_token_expire_days=self.parent.timing.get_refresh_token_expire_days(),
                service_token_expire_minutes=self.parent.timing.get_service_token_expire_minutes(),
                issuer=self.parent.env_settings.get_issuer(),
                audience=self.parent.env_settings.get_audience(),
                environment=self.parent.environment
            )
        
        def get_config_dict(self) -> Dict[str, Any]:
            """Get configuration as dictionary for backward compatibility."""
            config = self.get_unified_config()
            
            return {
                "secret_key": config.secret_key,
                "algorithm": config.algorithm,
                "access_token_expire_minutes": config.access_token_expire_minutes,
                "refresh_token_expire_days": config.refresh_token_expire_days,
                "service_token_expire_minutes": config.service_token_expire_minutes,
                "issuer": config.issuer,
                "audience": config.audience,
                "verify_signature": self.parent.validation.get_verify_signature(),
                "verify_expiry": self.parent.validation.get_verify_expiry()
            }
        
        def validate_cross_service_compatibility(self) -> List[str]:
            """Validate that JWT configuration is compatible across services."""
            issues = []
            
            # Check for environment variable conflicts
            env = self.parent.secret_builder.env
            
            # Check for old vs new variable naming
            jwt_secret_key = env.get("JWT_SECRET_KEY")
            jwt_secret = env.get("JWT_SECRET")
            
            if jwt_secret_key and jwt_secret and jwt_secret_key != jwt_secret:
                issues.append("JWT_SECRET_KEY and JWT_SECRET have different values - use JWT_SECRET_KEY only")
            
            # Check expiry variable naming
            access_expire_new = env.get("JWT_ACCESS_TOKEN_EXPIRE_MINUTES")
            access_expire_old = env.get("JWT_ACCESS_EXPIRY_MINUTES")
            
            if access_expire_new and access_expire_old and access_expire_new != access_expire_old:
                issues.append("JWT_ACCESS_TOKEN_EXPIRE_MINUTES and JWT_ACCESS_EXPIRY_MINUTES have different values")
            
            refresh_expire_new = env.get("JWT_REFRESH_TOKEN_EXPIRE_DAYS")
            refresh_expire_old = env.get("JWT_REFRESH_EXPIRY_DAYS")
            
            if refresh_expire_new and refresh_expire_old and refresh_expire_new != refresh_expire_old:
                issues.append("JWT_REFRESH_TOKEN_EXPIRE_DAYS and JWT_REFRESH_EXPIRY_DAYS have different values")
            
            return issues
        
        def get_standardized_environment_variables(self) -> Dict[str, str]:
            """Get standardized environment variables for JWT configuration."""
            config = self.get_unified_config()
            
            return {
                "JWT_SECRET_KEY": config.secret_key,
                "JWT_ALGORITHM": config.algorithm,
                "JWT_ACCESS_TOKEN_EXPIRE_MINUTES": str(config.access_token_expire_minutes),
                "JWT_REFRESH_TOKEN_EXPIRE_DAYS": str(config.refresh_token_expire_days),
                "JWT_SERVICE_TOKEN_EXPIRE_MINUTES": str(config.service_token_expire_minutes),
                "JWT_ISSUER": config.issuer,
                "JWT_AUDIENCE": config.audience
            }
    
    # Abstract method implementations required by ConfigBuilderBase
    
    def validate(self) -> Tuple[bool, str]:
        """
        Validate JWT configuration (required by ConfigBuilderBase).
        
        Returns:
            Tuple of (is_valid, error_message)
        """
        is_valid, issues = self.validate_configuration()
        if not is_valid and issues:
            return False, "; ".join(issues)
        return is_valid, ""
    
    # Main interface methods
    
    def get_unified_jwt_config(self) -> Dict[str, Any]:
        """Get unified JWT configuration - main interface method."""
        return self.standardization.get_config_dict()
    
    def validate_configuration(self) -> tuple[bool, List[str]]:
        """Validate complete JWT configuration."""
        issues = []
        
        try:
            # Test configuration generation
            config = self.standardization.get_unified_config()
            
            # Validate secret
            is_valid, error = self.secrets.validate_jwt_secret_strength(config.secret_key)
            if not is_valid:
                issues.append(f"JWT secret validation: {error}")
            
            # Check cross-service compatibility
            compatibility_issues = self.standardization.validate_cross_service_compatibility()
            issues.extend(compatibility_issues)
            
        except Exception as e:
            issues.append(f"Configuration generation failed: {str(e)}")
        
        return len(issues) == 0, issues
    
    def get_debug_info(self) -> Dict[str, Any]:
        """Get debug information about JWT configuration."""
        try:
            config = self.standardization.get_unified_config()
            is_valid, issues = self.validate_configuration()
            
            # Get common debug info from base class
            debug_info = self.get_common_debug_info()
            
            # Add JWT-specific debug information
            debug_info.update({
                "service": self.service,
                "configuration": {
                    "algorithm": config.algorithm,
                    "access_token_expire_minutes": config.access_token_expire_minutes,
                    "refresh_token_expire_days": config.refresh_token_expire_days,
                    "service_token_expire_minutes": config.service_token_expire_minutes,
                    "issuer": config.issuer,
                    "audience": config.audience,
                    "secret_key_length": len(config.secret_key),
                    "verify_signature": self.validation.get_verify_signature(),
                    "verify_expiry": self.validation.get_verify_expiry()
                },
                "validation": {
                    "is_valid": is_valid,
                    "issues": issues
                },
                "environment_variables": {
                    "standardized": self.standardization.get_standardized_environment_variables()
                }
            })
            
            return debug_info
        except Exception as e:
            # Get common debug info even on error
            debug_info = self.get_common_debug_info()
            debug_info.update({
                "service": self.service,
                "error": str(e),
                "validation": {
                    "is_valid": False,
                    "issues": [str(e)]
                }
            })
            return debug_info


# ===== BACKWARD COMPATIBILITY AND CONVENIENCE FUNCTIONS =====

def get_jwt_config_builder(service: str = "shared") -> JWTConfigBuilder:
    """Get JWT Configuration Builder instance for service."""
    return JWTConfigBuilder(service=service)


def get_unified_jwt_config(service: str = "shared") -> Dict[str, Any]:
    """Get unified JWT configuration for service."""
    builder = JWTConfigBuilder(service=service)
    return builder.get_unified_jwt_config()


def validate_jwt_configuration(service: str = "shared") -> tuple[bool, List[str]]:
    """Validate JWT configuration for service."""
    builder = JWTConfigBuilder(service=service)
    return builder.validate_configuration()


def get_jwt_secret_key_standardized(service: str = "shared") -> str:
    """Get JWT secret key using standardized resolution."""
    builder = JWTConfigBuilder(service=service)
    return builder.secrets.get_jwt_secret_key()


def get_jwt_timing_config(service: str = "shared") -> Dict[str, int]:
    """Get JWT timing configuration."""
    builder = JWTConfigBuilder(service=service)
    
    return {
        "access_token_expire_minutes": builder.timing.get_access_token_expire_minutes(),
        "refresh_token_expire_days": builder.timing.get_refresh_token_expire_days(),
        "service_token_expire_minutes": builder.timing.get_service_token_expire_minutes()
    }