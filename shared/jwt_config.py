"""
Shared JWT Configuration

Business Value Justification (BVJ):
- Segment: Platform/Internal
- Business Goal: Ensure consistent JWT configuration across all services
- Value Impact: Prevents authentication token validation failures between services
- Strategic Impact: Maintains authentication reliability for all user segments

This module provides a unified JWT configuration that all services can use
to ensure consistent token generation and validation.

**CRITICAL**: All services MUST use this shared configuration to ensure
JWT tokens generated by one service can be validated by another.
"""

import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)


class SharedJWTConfig:
    """Shared JWT configuration for all services.
    
    This ensures that both netra_backend and auth_service use identical
    JWT settings for token generation and validation.
    """
    
    @staticmethod
    def get_jwt_algorithm() -> str:
        """Get JWT algorithm - consistent across all services."""
        return "HS256"
    
    @staticmethod
    def get_access_token_expire_minutes() -> int:
        """Get access token expiry in minutes - consistent across all services."""
        return 15
    
    @staticmethod
    def get_refresh_token_expire_days() -> int:
        """Get refresh token expiry in days - consistent across all services."""
        return 7
    
    @staticmethod
    def get_service_token_expire_minutes() -> int:
        """Get service token expiry in minutes - consistent across all services."""
        return 60
    
    @staticmethod
    def get_jwt_secret_from_env(env_manager) -> str:
        """Get JWT secret key using environment manager.
        
        Args:
            env_manager: IsolatedEnvironment instance
            
        Returns:
            JWT secret key
            
        Raises:
            ValueError: If JWT secret not found or invalid
        """
        # Primary: JWT_SECRET_KEY (shared across services)
        secret = env_manager.get("JWT_SECRET_KEY")
        if secret:
            logger.debug("Using JWT_SECRET_KEY from environment")
            return secret
            
        # Fallback: JWT_SECRET (legacy)
        secret = env_manager.get("JWT_SECRET")
        if secret:
            logger.warning("Using JWT_SECRET from environment (DEPRECATED - use JWT_SECRET_KEY)")
            return secret
            
        raise ValueError("JWT secret not configured. Set JWT_SECRET_KEY environment variable.")
    
    @staticmethod
    def validate_jwt_secret(secret: str, environment: str = "development") -> None:
        """Validate JWT secret meets security requirements.
        
        Args:
            secret: JWT secret to validate
            environment: Current environment
            
        Raises:
            ValueError: If secret doesn't meet requirements
        """
        if not secret:
            raise ValueError("JWT secret cannot be empty")
            
        if environment in ["staging", "production"] and len(secret) < 32:
            raise ValueError(f"JWT secret must be at least 32 characters in {environment}")
            
        if environment == "production" and len(secret) < 64:
            logger.warning("JWT secret should be at least 64 characters in production")
    
    @staticmethod
    def get_jwt_config_dict(env_manager) -> Dict[str, Any]:
        """Get complete JWT configuration dictionary.
        
        Args:
            env_manager: IsolatedEnvironment instance
            
        Returns:
            Dictionary with all JWT configuration values
        """
        secret = SharedJWTConfig.get_jwt_secret_from_env(env_manager)
        environment = env_manager.get("ENVIRONMENT", "development").lower()
        
        # Validate secret
        SharedJWTConfig.validate_jwt_secret(secret, environment)
        
        return {
            "secret_key": secret,
            "algorithm": SharedJWTConfig.get_jwt_algorithm(),
            "access_token_expire_minutes": SharedJWTConfig.get_access_token_expire_minutes(),
            "refresh_token_expire_days": SharedJWTConfig.get_refresh_token_expire_days(),
            "service_token_expire_minutes": SharedJWTConfig.get_service_token_expire_minutes()
        }
    
    @staticmethod
    def log_jwt_config_summary(env_manager) -> None:
        """Log JWT configuration summary (without exposing secrets).
        
        Args:
            env_manager: IsolatedEnvironment instance
        """
        try:
            secret = SharedJWTConfig.get_jwt_secret_from_env(env_manager)
            environment = env_manager.get("ENVIRONMENT", "development").lower()
            
            logger.info("JWT Configuration Summary:")
            logger.info(f"  Environment: {environment}")
            logger.info(f"  Algorithm: {SharedJWTConfig.get_jwt_algorithm()}")
            logger.info(f"  Access Token Expiry: {SharedJWTConfig.get_access_token_expire_minutes()} minutes")
            logger.info(f"  Refresh Token Expiry: {SharedJWTConfig.get_refresh_token_expire_days()} days")
            logger.info(f"  Service Token Expiry: {SharedJWTConfig.get_service_token_expire_minutes()} minutes")
            logger.info(f"  Secret Key Length: {len(secret)} characters")
            logger.info(f"  Secret Key Status: {'✓ Configured' if secret else '✗ Missing'}")
            
        except Exception as e:
            logger.error(f"Failed to log JWT configuration summary: {e}")


# Convenience functions for backward compatibility
def get_jwt_secret_key(env_manager) -> str:
    """Get JWT secret key - convenience function."""
    return SharedJWTConfig.get_jwt_secret_from_env(env_manager)


def get_jwt_algorithm() -> str:
    """Get JWT algorithm - convenience function."""
    return SharedJWTConfig.get_jwt_algorithm()


def get_access_token_expire_minutes() -> int:
    """Get access token expiry - convenience function."""
    return SharedJWTConfig.get_access_token_expire_minutes()


def get_refresh_token_expire_days() -> int:
    """Get refresh token expiry - convenience function."""
    return SharedJWTConfig.get_refresh_token_expire_days()