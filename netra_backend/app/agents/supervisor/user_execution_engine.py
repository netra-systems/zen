"""UserExecutionEngine for per-user isolated agent execution.

This module provides the UserExecutionEngine class that handles agent execution
with complete per-user isolation, eliminating global state issues that prevent
concurrent user operations.

Business Value Justification:
- Segment: Platform/Internal  
- Business Goal: Stability & Scalability
- Value Impact: Enables 10+ concurrent users with zero context leakage and proper resource limits
- Strategic Impact: Critical foundation for multi-tenant production deployment at scale

Key Design Principles:
- Complete per-user state isolation (no shared state between users)
- User-specific resource limits and concurrency control
- Automatic cleanup and memory management
- UserExecutionContext-driven design for complete isolation
- Per-user WebSocket event routing with no cross-user contamination
"""

import asyncio
import time
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from netra_backend.app.agents.supervisor.agent_registry import AgentRegistry
    from netra_backend.app.services.agent_websocket_bridge import AgentWebSocketBridge
    from netra_backend.app.websocket_core.unified_emitter import UnifiedWebSocketEmitter as UserWebSocketEmitter

from netra_backend.app.agents.state import DeepAgentState
from netra_backend.app.agents.supervisor.agent_execution_core import AgentExecutionCore
from netra_backend.app.agents.supervisor.execution_context import (
    AgentExecutionContext,
    AgentExecutionResult,
    PipelineStep,
)
from netra_backend.app.agents.supervisor.user_execution_context import (
    UserExecutionContext,
    validate_user_context
)
# DISABLED: fallback_manager module removed
# from netra_backend.app.agents.supervisor.fallback_manager import FallbackManager
# DISABLED: periodic_update_manager module removed
# from netra_backend.app.agents.supervisor.periodic_update_manager import PeriodicUpdateManager
from netra_backend.app.agents.supervisor.observability_flow import (
    get_supervisor_flow_logger,
)
from netra_backend.app.core.agent_execution_tracker import (
    get_execution_tracker,
    ExecutionState
)
from netra_backend.app.agents.supervisor.data_access_integration import (
    UserExecutionEngineExtensions
)
from netra_backend.app.logging_config import central_logger

logger = central_logger.get_logger(__name__)


class UserExecutionEngine:
    """Per-user execution engine with isolated state.
    
    This engine is created per-request with UserExecutionContext and maintains
    execution state ONLY for that specific user. No state is shared between
    different users or requests.
    
    Key Features:
    - Complete per-user isolation (no global state)
    - User-specific concurrency limits
    - Per-user WebSocket event emission via UserWebSocketEmitter
    - Automatic resource cleanup and memory management
    - User-specific execution statistics and history
    - Resource limits enforcement per UserExecutionContext
    
    Design Pattern:
    This follows the "Request-Scoped Service" pattern where each user request
    gets its own service instance with completely isolated state. This prevents
    the classic global state problems that cause user context leakage.
    """
    
    # Constants (immutable, safe to share)
    AGENT_EXECUTION_TIMEOUT = 30.0
    MAX_HISTORY_SIZE = 100
    
    def __init__(self, 
                 context: UserExecutionContext,
                 agent_factory: 'AgentInstanceFactory',
                 websocket_emitter: 'UserWebSocketEmitter'):
        """Initialize per-user execution engine.
        
        Args:
            context: User execution context for complete isolation
            agent_factory: Factory for creating user-scoped agent instances
            websocket_emitter: User-specific WebSocket emitter for events
            
        Raises:
            TypeError: If context is not a valid UserExecutionContext
            ValueError: If required parameters are missing
        """
        # Validate user context immediately (fail-fast)
        self.context = validate_user_context(context)
        
        if not agent_factory:
            raise ValueError("AgentInstanceFactory cannot be None")
        if not websocket_emitter:
            raise ValueError("UserWebSocketEmitter cannot be None")
        
        self.agent_factory = agent_factory
        self.websocket_emitter = websocket_emitter
        
        # PER-USER STATE ONLY (no shared state between users)
        self.active_runs: Dict[str, AgentExecutionContext] = {}  # Only this user's runs
        self.run_history: List[AgentExecutionResult] = []  # Only this user's history  
        self.execution_stats: Dict[str, Any] = {  # Only this user's stats
            'total_executions': 0,
            'concurrent_executions': 0,
            'queue_wait_times': [],
            'execution_times': [],
            'failed_executions': 0,
            'timeout_executions': 0,
            'dead_executions': 0
        }
        
        # Per-user resource limits from context
        resource_limits = getattr(context, 'resource_limits', None)
        if resource_limits:
            self.max_concurrent = resource_limits.max_concurrent_agents
        else:
            # Default per-user limits
            self.max_concurrent = 3
        
        # Per-user semaphore for concurrency control
        self.semaphore = asyncio.Semaphore(self.max_concurrent)
        
        # Engine metadata (must be set before _init_components)
        self.engine_id = f"user_engine_{context.user_id}_{context.run_id}_{int(time.time()*1000)}"
        self.created_at = datetime.now(timezone.utc)
        self._is_active = True
        
        # Initialize components with user context
        self._init_components()
        
        # Integrate data access capabilities for user-scoped ClickHouse and Redis access
        UserExecutionEngineExtensions.integrate_data_access(self)
        
        logger.info(f"âœ… Created UserExecutionEngine {self.engine_id} for user {context.user_id} "
                   f"(max_concurrent: {self.max_concurrent}, run_id: {context.run_id}) with data access capabilities")
    
    def _init_components(self) -> None:
        """Initialize execution components with user context."""
        # Get infrastructure components from factory
        # Note: These components should be stateless or request-scoped
        try:
            # Access infrastructure components through factory
            if hasattr(self.agent_factory, '_agent_registry'):
                registry = self.agent_factory._agent_registry
            else:
                raise ValueError("Agent registry not available in factory")
            
            if hasattr(self.agent_factory, '_websocket_bridge'):
                websocket_bridge = self.agent_factory._websocket_bridge
            else:
                raise ValueError("WebSocket bridge not available in factory")
            
            # Initialize components with user-scoped bridge
            # periodic_update_manager removed - no longer needed
            self.periodic_update_manager = None
            self.agent_core = AgentExecutionCore(registry, websocket_bridge) 
            # fallback_manager removed - no longer needed
            self.fallback_manager = None
            self.flow_logger = get_supervisor_flow_logger()
            self.execution_tracker = get_execution_tracker()
            
            logger.debug(f"Initialized components for UserExecutionEngine {self.engine_id}")
            
        except Exception as e:
            logger.error(f"Failed to initialize components for UserExecutionEngine: {e}")
            raise ValueError(f"Component initialization failed: {e}")
    
    async def execute_agent(self, 
                           context: AgentExecutionContext,
                           state: DeepAgentState) -> AgentExecutionResult:
        """Execute a single agent with complete user isolation.
        
        This method provides complete per-user isolation:
        - Only this user's executions are tracked
        - User-specific concurrency limits enforced  
        - WebSocket events sent only to this user
        - No state leakage between different users
        
        Args:
            context: Agent execution context (must match user context)
            state: Deep agent state for execution
            
        Returns:
            AgentExecutionResult: Results of agent execution
            
        Raises:
            ValueError: If context doesn't match user or is invalid
            RuntimeError: If execution fails
        """
        if not self._is_active:
            raise ValueError(f"UserExecutionEngine {self.engine_id} is no longer active")
        
        # Validate execution context matches our user
        self._validate_execution_context(context)
        
        queue_start_time = time.time()
        
        # Create execution tracking record with user context
        execution_id = self.execution_tracker.create_execution(
            agent_name=context.agent_name,
            thread_id=context.thread_id,
            user_id=context.user_id,
            timeout_seconds=int(self.AGENT_EXECUTION_TIMEOUT),
            metadata={
                'run_id': context.run_id, 
                'context': context.metadata,
                'user_engine_id': self.engine_id,
                'user_execution_context': self.context.get_correlation_id()
            }
        )
        
        # Store execution ID in context
        context.execution_id = execution_id
        
        # Add to active runs (user-scoped only)
        self.active_runs[execution_id] = context
        
        # Use per-user semaphore for concurrency control
        async with self.semaphore:
            queue_wait_time = time.time() - queue_start_time
            self.execution_stats['queue_wait_times'].append(queue_wait_time)
            self.execution_stats['total_executions'] += 1
            self.execution_stats['concurrent_executions'] += 1
            
            # Mark execution as starting
            self.execution_tracker.start_execution(execution_id)
            
            # Send queue wait notification if significant delay (user-specific)
            if queue_wait_time > 1.0:
                await self._send_user_agent_thinking(
                    context,
                    f"Request queued due to user load - starting now (waited {queue_wait_time:.1f}s)",
                    step_number=0
                )
            
            try:
                # Use periodic update manager for long-running operations
                async with self.periodic_update_manager.track_operation(
                    context,
                    f"{context.agent_name}_execution",
                    "agent_execution",
                    expected_duration_ms=int(self.AGENT_EXECUTION_TIMEOUT * 1000),
                    operation_description=f"Executing {context.agent_name} agent for user {self.context.user_id}"
                ):
                    # Send agent started notification via user emitter
                    await self._send_user_agent_started(context)
                    
                    # Send initial thinking update
                    await self._send_user_agent_thinking(
                        context,
                        f"Starting execution of {context.agent_name} agent...",
                        step_number=1
                    )
                    
                    execution_start = time.time()
                    
                    # Update execution state to running
                    self.execution_tracker.update_execution_state(
                        execution_id, ExecutionState.RUNNING
                    )
                    
                    # Execute with timeout and user context
                    result = await asyncio.wait_for(
                        self._execute_with_error_handling(context, state, execution_id),
                        timeout=self.AGENT_EXECUTION_TIMEOUT
                    )
                    
                    execution_time = time.time() - execution_start
                    self.execution_stats['execution_times'].append(execution_time)
                    
                    # Mark execution state based on result
                    if result.success:
                        self.execution_tracker.update_execution_state(
                            execution_id, ExecutionState.COMPLETED, result=result.data
                        )
                        await self._send_user_agent_completed(context, result)
                    else:
                        self.execution_tracker.update_execution_state(
                            execution_id, ExecutionState.FAILED, error=result.error
                        )
                        await self._send_user_agent_completed(context, result)
                    
                    # Update history (user-scoped only)
                    self._update_user_history(result)
                    return result
                    
            except asyncio.TimeoutError:
                self.execution_stats['timeout_executions'] += 1
                self.execution_stats['failed_executions'] += 1
                
                # Mark execution as timed out
                self.execution_tracker.update_execution_state(
                    execution_id, ExecutionState.TIMEOUT,
                    error=f"User execution timed out after {self.AGENT_EXECUTION_TIMEOUT}s"
                )
                
                # Create timeout result
                timeout_result = self._create_timeout_result(context)
                await self._send_user_agent_completed(context, timeout_result)
                
                self._update_user_history(timeout_result)
                return timeout_result
                
            except Exception as e:
                self.execution_stats['failed_executions'] += 1
                
                # Mark execution as failed
                self.execution_tracker.update_execution_state(
                    execution_id, ExecutionState.FAILED, error=str(e)
                )
                
                logger.error(f"User agent execution failed for {context.agent_name} "
                           f"(user: {self.context.user_id}): {e}")
                raise RuntimeError(f"Agent execution failed: {e}")
                
            finally:
                # Remove from active runs (user-scoped)
                self.active_runs.pop(execution_id, None)
                self.execution_stats['concurrent_executions'] -= 1
    
    def _validate_execution_context(self, context: AgentExecutionContext) -> None:
        """Validate execution context matches this user.
        
        Args:
            context: The agent execution context to validate
            
        Raises:
            ValueError: If context doesn't match user or is invalid
        """
        if not context.user_id or not context.user_id.strip():
            raise ValueError("Invalid execution context: user_id must be non-empty")
        
        if not context.run_id or not context.run_id.strip():
            raise ValueError("Invalid execution context: run_id must be non-empty")
        
        if context.run_id == 'registry':
            raise ValueError("Invalid execution context: run_id cannot be 'registry' placeholder")
        
        # CRITICAL: Validate context matches our user context
        if context.user_id != self.context.user_id:
            raise ValueError(
                f"User ID mismatch: execution context user_id='{context.user_id}' "
                f"vs UserExecutionEngine user_id='{self.context.user_id}'"
            )
        
        if context.run_id != self.context.run_id:
            logger.warning(
                f"Run ID mismatch: execution context run_id='{context.run_id}' "
                f"vs UserExecutionEngine run_id='{self.context.run_id}' "
                f"- this may indicate multiple runs in same user session"
            )
    
    async def _execute_with_error_handling(self, 
                                          context: AgentExecutionContext,
                                          state: DeepAgentState,
                                          execution_id: str) -> AgentExecutionResult:
        """Execute agent with error handling and user-scoped fallback.
        
        Args:
            context: Agent execution context
            state: Deep agent state
            execution_id: Execution tracking ID
            
        Returns:
            AgentExecutionResult: Results of execution
        """
        start_time = time.time()
        
        try:
            # Heartbeat for death monitoring
            self.execution_tracker.heartbeat(execution_id)
            
            # Send user-specific thinking updates during execution
            await self._send_user_agent_thinking(
                context,
                f"Processing request: {getattr(state, 'user_prompt', 'Task')[:100]}...",
                step_number=2
            )
            
            # Execute the agent using user-scoped factory
            # Create fresh agent instance for this execution
            agent = await self.agent_factory.create_agent_instance(
                agent_name=context.agent_name,
                user_context=self.context
            )
            
            # Execute with user isolation
            result = await self.agent_core.execute_agent(context, state)
            
            # Final heartbeat
            self.execution_tracker.heartbeat(execution_id)
            
            return result
            
        except Exception as e:
            logger.error(f"User agent {context.agent_name} failed for user {self.context.user_id}: {e}")
            
            # Use user-scoped fallback manager
            return await self.fallback_manager.create_fallback_result(
                context, state, e, start_time
            )
    
    async def _send_user_agent_started(self, context: AgentExecutionContext) -> None:
        """Send agent started notification via user emitter."""
        try:
            success = await self.websocket_emitter.notify_agent_started(
                agent_name=context.agent_name,
                context={
                    "status": "started",
                    "user_isolated": True,
                    "user_id": self.context.user_id,
                    "engine_id": self.engine_id,
                    "context": context.metadata or {}
                }
            )
            
            if not success:
                logger.warning(f"Failed to send user agent started notification "
                             f"for {context.agent_name} (user: {self.context.user_id})")
                
        except Exception as e:
            logger.error(f"Error sending user agent started notification: {e}")
    
    async def _send_user_agent_thinking(self, 
                                       context: AgentExecutionContext,
                                       thought: str,
                                       step_number: Optional[int] = None) -> None:
        """Send agent thinking notification via user emitter."""
        try:
            success = await self.websocket_emitter.notify_agent_thinking(
                agent_name=context.agent_name,
                reasoning=thought,
                step_number=step_number
            )
            
            if not success:
                logger.warning(f"Failed to send user agent thinking notification "
                             f"for {context.agent_name} (user: {self.context.user_id})")
                
        except Exception as e:
            logger.error(f"Error sending user agent thinking notification: {e}")
    
    async def _send_user_agent_completed(self, 
                                        context: AgentExecutionContext,
                                        result: AgentExecutionResult) -> None:
        """Send agent completed notification via user emitter."""
        try:
            success = await self.websocket_emitter.notify_agent_completed(
                agent_name=context.agent_name,
                result={
                    "agent_name": context.agent_name,
                    "success": result.success,
                    "duration_ms": result.execution_time * 1000 if result.execution_time else 0,
                    "status": "completed" if result.success else "failed",
                    "user_isolated": True,
                    "user_id": self.context.user_id,
                    "engine_id": self.engine_id,
                    "error": result.error if not result.success and result.error else None
                },
                execution_time_ms=result.execution_time * 1000 if result.execution_time else 0
            )
            
            if not success:
                logger.warning(f"Failed to send user agent completed notification "
                             f"for {context.agent_name} (user: {self.context.user_id})")
                
        except Exception as e:
            logger.error(f"Error sending user agent completed notification: {e}")
    
    def _create_timeout_result(self, context: AgentExecutionContext) -> AgentExecutionResult:
        """Create result for timed out execution."""
        return AgentExecutionResult(
            success=False,
            agent_name=context.agent_name,
            execution_time=self.AGENT_EXECUTION_TIMEOUT,
            error=f"User agent execution timed out after {self.AGENT_EXECUTION_TIMEOUT}s",
            state=None,
            metadata={
                'timeout': True,
                'user_isolated': True,
                'user_id': self.context.user_id,
                'engine_id': self.engine_id
            }
        )
    
    def _update_user_history(self, result: AgentExecutionResult) -> None:
        """Update run history with size limit (user-scoped only)."""
        self.run_history.append(result)
        if len(self.run_history) > self.MAX_HISTORY_SIZE:
            self.run_history = self.run_history[-self.MAX_HISTORY_SIZE:]
    
    def get_user_execution_stats(self) -> Dict[str, Any]:
        """Get execution statistics for this user only.
        
        Returns:
            Dictionary with user-specific execution statistics
        """
        stats = self.execution_stats.copy()
        
        # Calculate averages for this user
        if stats['queue_wait_times']:
            stats['avg_queue_wait_time'] = sum(stats['queue_wait_times']) / len(stats['queue_wait_times'])
            stats['max_queue_wait_time'] = max(stats['queue_wait_times'])
        else:
            stats['avg_queue_wait_time'] = 0.0
            stats['max_queue_wait_time'] = 0.0
            
        if stats['execution_times']:
            stats['avg_execution_time'] = sum(stats['execution_times']) / len(stats['execution_times'])
            stats['max_execution_time'] = max(stats['execution_times'])
        else:
            stats['avg_execution_time'] = 0.0
            stats['max_execution_time'] = 0.0
        
        # Add user and engine metadata
        stats.update({
            'engine_id': self.engine_id,
            'user_id': self.context.user_id,
            'run_id': self.context.run_id,
            'thread_id': self.context.thread_id,
            'active_runs_count': len(self.active_runs),
            'history_count': len(self.run_history),
            'created_at': self.created_at.isoformat(),
            'is_active': self._is_active,
            'max_concurrent': self.max_concurrent,
            'user_correlation_id': self.context.get_correlation_id()
        })
        
        return stats
    
    async def cleanup(self) -> None:
        """Clean up user engine resources.
        
        This should be called when the user request is complete to ensure
        proper cleanup of user-specific resources.
        """
        if not self._is_active:
            return
        
        try:
            logger.info(f"Cleaning up UserExecutionEngine {self.engine_id} for user {self.context.user_id}")
            
            # Cancel any remaining active runs
            if self.active_runs:
                logger.warning(f"Cancelling {len(self.active_runs)} active runs for user {self.context.user_id}")
                for execution_id, context in self.active_runs.items():
                    try:
                        self.execution_tracker.update_execution_state(
                            execution_id, ExecutionState.CANCELLED,
                            error="User engine cleanup"
                        )
                    except Exception as e:
                        logger.error(f"Error cancelling execution {execution_id}: {e}")
            
            # Shutdown components
            if hasattr(self, 'periodic_update_manager'):
                await self.periodic_update_manager.shutdown()
            
            # Clean up user WebSocket emitter
            if self.websocket_emitter:
                await self.websocket_emitter.cleanup()
            
            # Clean up data access capabilities
            await UserExecutionEngineExtensions.cleanup_data_access(self)
            
            # Clear all user state
            self.active_runs.clear()
            self.run_history.clear()
            self.execution_stats.clear()
            
            # Mark as inactive
            self._is_active = False
            
            logger.info(f"âœ… Cleaned up UserExecutionEngine {self.engine_id} for user {self.context.user_id}")
            
        except Exception as e:
            logger.error(f"Error cleaning up UserExecutionEngine {self.engine_id}: {e}")
            raise
    
    def is_active(self) -> bool:
        """Check if this user engine is still active."""
        return self._is_active
    
    def get_user_context(self) -> UserExecutionContext:
        """Get the user execution context for this engine."""
        return self.context
    
    def __str__(self) -> str:
        """String representation of the user engine."""
        return (f"UserExecutionEngine(engine_id={self.engine_id}, "
                f"user_id={self.context.user_id}, "
                f"active_runs={len(self.active_runs)}, "
                f"is_active={self._is_active})")
    
    def __repr__(self) -> str:
        """Detailed string representation of the user engine."""
        return self.__str__()