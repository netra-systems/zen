"""Integration Test: Thread Auto-Creation on First Message
BVJ: $10K MRR - Complex thread management causes 25% user drop-off
Components: ThreadService → Database → Message Association → State Persistence
Critical: Seamless thread creation for new users without friction
"""

import sys
from pathlib import Path

# Test framework import - using pytest fixtures instead

import asyncio
import uuid
from datetime import datetime, timezone
from typing import Any, Dict, Optional
from unittest.mock import AsyncMock, MagicMock, Mock, patch

import pytest
from netra_backend.app.schemas import Thread, User
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from netra_backend.app.db.models_postgres import Message, Run, Thread, User
from netra_backend.app.services.message_handlers import MessageHandlerService

from netra_backend.app.services.thread_service import ThreadService
from test_framework.mock_utils import mock_justified

@pytest.mark.asyncio
class TestThreadAutoCreation:
    """Test automatic thread creation on first user message."""
    
    @pytest.fixture
    async def db_session(self):
        """Create test database session."""
        # L3: Using in-memory SQLite for real DB operations
        engine = create_async_engine("sqlite+aiosqlite:///:memory:")
        async_session = sessionmaker(engine, class_=AsyncSession)
        
        async with engine.begin() as conn:
            # Create tables
            await conn.run_sync(Thread.metadata.create_all)
            await conn.run_sync(Message.metadata.create_all)
            await conn.run_sync(Run.metadata.create_all)
        
        async with async_session() as session:
            try:
                yield session
            finally:
                if hasattr(session, "close"):
                    await session.close()
    
    @pytest.fixture
    async def thread_service(self, db_session):
        """Create thread service with test database."""
        service = ThreadService()
        service.db_session = db_session
        yield service
    
    @pytest.fixture
    @pytest.mark.asyncio
    async def test_user(self):
        """Create test user for thread operations."""
        return User(
            id="thread_test_user_001",
            email="thread@test.netrasystems.ai",
            username="threaduser",
            is_active=True,
            created_at=datetime.now(timezone.utc)
        )
    
    @pytest.mark.asyncio
    async def test_no_existing_thread_creates_new(
        self, thread_service, db_session, test_user
    ):
        """Test thread creation when no thread exists for user."""
        
        # Step 1: Verify no threads exist
        threads = await thread_service.get_user_threads(test_user.id)
        assert len(threads) == 0
        
        # Step 2: Trigger thread auto-creation
        thread = await thread_service.get_or_create_thread(
            user_id=test_user.id,
            title="First Conversation"
        )
        
        # Step 3: Verify thread created
        assert thread is not None
        assert thread.user_id == test_user.id
        assert thread.title == "First Conversation"
        assert thread.id is not None
        
        # Step 4: Verify persistence
        threads = await thread_service.get_user_threads(test_user.id)
        assert len(threads) == 1
        assert threads[0].id == thread.id
    
    @pytest.mark.asyncio
    async def test_message_association_with_auto_thread(
        self, thread_service, db_session, test_user
    ):
        """Test message association with automatically created thread."""
        
        # Step 1: Create thread automatically
        thread = await thread_service.get_or_create_thread(
            user_id=test_user.id,
            title="Auto Thread"
        )
        
        # Step 2: Create first message
        message = await thread_service.create_message(
            thread_id=thread.id,
            content="This is my first message",
            role="user",
            user_id=test_user.id
        )
        
        # Step 3: Verify message association
        assert message.thread_id == thread.id
        assert message.content == "This is my first message"
        assert message.role == "user"
        
        # Step 4: Retrieve messages for thread
        messages = await thread_service.get_thread_messages(thread.id)
        assert len(messages) == 1
        assert messages[0].id == message.id
    
    @pytest.mark.asyncio
    async def test_concurrent_thread_creation_safety(
        self, thread_service, test_user
    ):
        """Test thread creation safety under concurrent requests."""
        
        # Create multiple concurrent requests
        async def create_thread_request():
            return await thread_service.get_or_create_thread(
                user_id=test_user.id,
                title="Concurrent Thread"
            )
        
        # Execute concurrently
        tasks = [create_thread_request() for _ in range(5)]
        threads = await asyncio.gather(*tasks)
        
        # Verify only one thread created (idempotent)
        unique_thread_ids = set(t.id for t in threads)
        assert len(unique_thread_ids) == 1
        
        # Verify all requests got same thread
        first_thread = threads[0]
        for thread in threads:
            assert thread.id == first_thread.id
    
    @pytest.mark.asyncio
    async def test_thread_metadata_initialization(
        self, thread_service, test_user
    ):
        """Test proper initialization of thread metadata."""
        
        # Create thread with metadata
        thread = await thread_service.get_or_create_thread(
            user_id=test_user.id,
            title="Metadata Test",
            metadata={
                "source": "first_message",
                "client_version": "1.0.0",
                "user_agent": "test_client"
            }
        )
        
        # Verify metadata
        assert thread.metadata["source"] == "first_message"
        assert thread.metadata["client_version"] == "1.0.0"
        assert thread.metadata["user_agent"] == "test_client"
        
        # Verify timestamps
        assert thread.created_at is not None
        assert thread.updated_at is not None
        assert thread.last_message_at is None  # No messages yet
    
    @pytest.mark.asyncio
    async def test_state_persistence_across_sessions(
        self, thread_service, db_session, test_user
    ):
        """Test thread state persistence across database sessions."""
        
        # Create thread in first session
        thread = await thread_service.get_or_create_thread(
            user_id=test_user.id,
            title="Persistent Thread"
        )
        thread_id = thread.id
        
        # Add message
        await thread_service.create_message(
            thread_id=thread_id,
            content="Persistent message",
            role="user",
            user_id=test_user.id
        )
        
        # Commit and close session
        await db_session.commit()
        
        # Create new session and retrieve
        # L3: Creating new session to test persistence
        # Mock: Database session isolation for transaction testing without real database dependency
        new_session = Mock(spec=AsyncSession)
        new_thread_service = ThreadService()
        new_thread_service.db_session = new_session
        
        # Mock retrieval with persisted data
        with patch.object(new_thread_service, 'get_thread') as mock_get:
            mock_get.return_value = thread
            
            retrieved_thread = await new_thread_service.get_thread(thread_id)
            assert retrieved_thread.id == thread_id
            assert retrieved_thread.title == "Persistent Thread"
    
    @pytest.mark.asyncio
    async def test_thread_creation_with_run_tracking(
        self, thread_service, test_user
    ):
        """Test thread creation with associated run tracking."""
        
        # Create thread
        thread = await thread_service.get_or_create_thread(
            user_id=test_user.id,
            title="Run Tracking Thread"
        )
        
        # Create run for thread
        run = await thread_service.create_run(
            thread_id=thread.id,
            status="in_progress"
        )
        
        # Verify run association
        assert run.thread_id == thread.id
        assert run.status == "in_progress"
        assert run.id is not None
        
        # Update run status
        await thread_service.update_run_status(run.id, "completed")
        
        # Verify update
        updated_run = await thread_service.get_run(run.id)
        assert updated_run.status == "completed"
    
    @pytest.mark.asyncio
    async def test_error_handling_during_creation(
        self, thread_service, test_user
    ):
        """Test error handling during thread creation."""
        
        # Simulate database error
        # L2: Mocking DB error to test error handling
        with patch.object(thread_service, 'create_thread') as mock_create:
            mock_create.side_effect = Exception("Database connection lost")
            
            with pytest.raises(Exception, match="Database connection lost"):
                await thread_service.get_or_create_thread(
                    user_id=test_user.id,
                    title="Error Test"
                )
        
        # Verify rollback (no partial state)
        threads = await thread_service.get_user_threads(test_user.id)
        assert len(threads) == 0
    
    @pytest.mark.asyncio
    async def test_thread_title_generation(self, thread_service, test_user):
        """Test automatic title generation for threads."""
        
        # Create thread without title
        thread = await thread_service.get_or_create_thread(
            user_id=test_user.id,
            title=None  # No title provided
        )
        
        # Verify auto-generated title
        assert thread.title is not None
        assert "New Conversation" in thread.title or "Thread" in thread.title
        
        # Create with first message for better title
        message_content = "How can I optimize my LLM costs?"
        thread2 = await thread_service.get_or_create_thread(
            user_id=test_user.id,
            title=None,
            first_message=message_content
        )
        
        # Verify context-aware title
        assert thread2.title is not None
        # Title should be derived from message or have default