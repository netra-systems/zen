"""
Real Auth Database Integrity Tests

Business Value: Platform/Internal - Data Integrity & System Reliability - Validates
database consistency and transaction integrity for authentication data using real services.

Coverage Target: 90%
Test Category: Integration with Real Services - DATA INTEGRITY CRITICAL
Infrastructure Required: Docker (PostgreSQL, Redis, Auth Service, Backend)

This test suite validates database transaction integrity, referential integrity,
concurrent access patterns, and data consistency for authentication operations.

CRITICAL: Tests data integrity to prevent authentication data corruption and
ensure reliable authentication operations under all conditions.
"""
import asyncio
import json
import secrets
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, Optional, List
from concurrent.futures import ThreadPoolExecutor
import pytest
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text, inspect
from sqlalchemy.exc import IntegrityError
from netra_backend.app.core.auth_constants import AuthConstants, JWTConstants, HeaderConstants
from netra_backend.app.auth_dependencies import get_request_scoped_db_session_for_fastapi
from shared.isolated_environment import IsolatedEnvironment
from test_framework.docker_test_manager import UnifiedDockerManager
from test_framework.async_test_helpers import AsyncTestDatabase
env = IsolatedEnvironment()
docker_manager = UnifiedDockerManager()

@pytest.mark.integration
@pytest.mark.real_services
@pytest.mark.database_integrity
@pytest.mark.critical
@pytest.mark.asyncio
class TestRealAuthDatabaseIntegrity:
    """
    Real auth database integrity tests using Docker services.
    
    Tests transaction integrity, referential constraints, concurrent access,
    data consistency, and recovery scenarios using real PostgreSQL database.
    """

    @pytest.fixture(scope='class', autouse=True)
    async def setup_docker_services(self):
        """Start Docker services for database integrity testing."""
        print('[U+1F433] Starting Docker services for database integrity tests...')
        services = ['backend', 'auth', 'postgres', 'redis']
        try:
            await docker_manager.start_services_async(services=services, health_check=True, timeout=120)
            await asyncio.sleep(5)
            print(' PASS:  Docker services ready for database integrity tests')
            yield
        except Exception as e:
            pytest.fail(f' FAIL:  Failed to start Docker services for database integrity tests: {e}')
        finally:
            print('[U+1F9F9] Cleaning up Docker services after database integrity tests...')
            await docker_manager.cleanup_async()

    @pytest.fixture
    async def real_db_session(self):
        """Get real database session for integrity testing."""
        async for session in get_request_scoped_db_session_for_fastapi():
            yield session

    @pytest.fixture
    async def test_db_helper(self, real_db_session):
        """Create database test helper for integrity operations."""
        helper = AsyncTestDatabase(real_db_session)
        yield helper

    def create_test_user_data(self, user_id: int) -> Dict[str, Any]:
        """Create test user data for database operations."""
        return {'id': user_id, 'email': f'user{user_id}@netrasystems.ai', 'full_name': f'Test User {user_id}', 'password_hash': secrets.token_hex(32), 'is_active': True, 'created_at': datetime.utcnow(), 'last_login_at': None, 'failed_login_attempts': 0, 'account_locked_until': None, 'oauth_provider': 'google', 'oauth_external_id': f'oauth_{user_id}_{secrets.token_hex(8)}'}

    def create_test_session_data(self, user_id: int, session_id: str=None) -> Dict[str, Any]:
        """Create test session data for database operations."""
        if not session_id:
            session_id = secrets.token_hex(16)
        return {'id': session_id, 'user_id': user_id, 'session_token': secrets.token_hex(32), 'refresh_token': secrets.token_hex(32), 'created_at': datetime.utcnow(), 'expires_at': datetime.utcnow() + timedelta(hours=24), 'last_activity': datetime.utcnow(), 'ip_address': '127.0.0.1', 'user_agent': 'pytest-integrity-test', 'is_active': True}

    @pytest.mark.asyncio
    async def test_user_creation_transaction_integrity(self, real_db_session):
        """Test transaction integrity for user creation operations."""
        test_user_id = 100001
        user_data = self.create_test_user_data(test_user_id)
        try:
            async with real_db_session.begin():
                user_query = text('\n                    INSERT INTO users (id, email, full_name, password_hash, is_active, created_at, oauth_provider, oauth_external_id)\n                    VALUES (:id, :email, :full_name, :password_hash, :is_active, :created_at, :oauth_provider, :oauth_external_id)\n                    RETURNING id\n                ')
                result = await real_db_session.execute(user_query, user_data)
                created_user = result.fetchone()
                if created_user:
                    print(f' PASS:  User {created_user[0]} created successfully in transaction')
                    session_data = self.create_test_session_data(created_user[0])
                    session_query = text('\n                        INSERT INTO user_sessions (id, user_id, session_token, refresh_token, created_at, expires_at, last_activity, ip_address, user_agent, is_active)\n                        VALUES (:id, :user_id, :session_token, :refresh_token, :created_at, :expires_at, :last_activity, :ip_address, :user_agent, :is_active)\n                        RETURNING id\n                    ')
                    session_result = await real_db_session.execute(session_query, session_data)
                    created_session = session_result.fetchone()
                    if created_session:
                        print(f' PASS:  Session {created_session[0]} created for user {created_user[0]}')
            verify_user = await real_db_session.execute(text('SELECT id, email FROM users WHERE id = :user_id'), {'user_id': test_user_id})
            user_row = verify_user.fetchone()
            assert user_row is not None, 'User should exist after transaction commit'
            assert user_row[1] == user_data['email']
            print(' PASS:  Transaction integrity validated - Data persisted after commit')
        except Exception as e:
            print(f' FAIL:  Transaction failed as expected or encountered error: {e}')
            verify_rollback = await real_db_session.execute(text('SELECT id FROM users WHERE id = :user_id'), {'user_id': test_user_id})
            rollback_result = verify_rollback.fetchone()
            if rollback_result is None:
                print(' PASS:  Transaction rollback verified - No data persisted after failure')
        finally:
            try:
                await real_db_session.execute(text('DELETE FROM user_sessions WHERE user_id = :user_id'), {'user_id': test_user_id})
                await real_db_session.execute(text('DELETE FROM users WHERE id = :user_id'), {'user_id': test_user_id})
                await real_db_session.commit()
            except:
                pass

    @pytest.mark.asyncio
    async def test_referential_integrity_constraints(self, real_db_session):
        """Test referential integrity constraints for authentication tables."""
        test_user_id = 100002
        user_data = self.create_test_user_data(test_user_id)
        try:
            user_query = text('\n                INSERT INTO users (id, email, full_name, password_hash, is_active, created_at, oauth_provider, oauth_external_id)\n                VALUES (:id, :email, :full_name, :password_hash, :is_active, :created_at, :oauth_provider, :oauth_external_id)\n                RETURNING id\n            ')
            result = await real_db_session.execute(user_query, user_data)
            await real_db_session.commit()
            created_user = result.fetchone()
            assert created_user is not None
            print(f' PASS:  User {created_user[0]} created for referential integrity test')
            session_data = self.create_test_session_data(created_user[0])
            session_query = text('\n                INSERT INTO user_sessions (id, user_id, session_token, refresh_token, created_at, expires_at, last_activity, ip_address, user_agent, is_active)\n                VALUES (:id, :user_id, :session_token, :refresh_token, :created_at, :expires_at, :last_activity, :ip_address, :user_agent, :is_active)\n                RETURNING id\n            ')
            session_result = await real_db_session.execute(session_query, session_data)
            await real_db_session.commit()
            created_session = session_result.fetchone()
            print(f' PASS:  Valid foreign key reference - Session created for existing user')
            invalid_user_id = 999999
            invalid_session_data = self.create_test_session_data(invalid_user_id)
            try:
                await real_db_session.execute(session_query, invalid_session_data)
                await real_db_session.commit()
                pytest.fail(' FAIL:  Referential integrity constraint not enforced - invalid foreign key accepted')
            except IntegrityError as e:
                print(' PASS:  Referential integrity constraint enforced - Invalid foreign key rejected')
                await real_db_session.rollback()
            delete_user_query = text('DELETE FROM users WHERE id = :user_id')
            await real_db_session.execute(delete_user_query, {'user_id': created_user[0]})
            await real_db_session.commit()
            orphaned_sessions = await real_db_session.execute(text('SELECT id FROM user_sessions WHERE user_id = :user_id'), {'user_id': created_user[0]})
            orphan_result = orphaned_sessions.fetchone()
            if orphan_result is None:
                print(' PASS:  Cascade delete working - Related sessions deleted with user')
            else:
                print(' WARNING: [U+FE0F] Cascade delete not configured - Manual cleanup required')
                await real_db_session.execute(text('DELETE FROM user_sessions WHERE user_id = :user_id'), {'user_id': created_user[0]})
                await real_db_session.commit()
            print(' PASS:  Referential integrity constraints validated')
        except Exception as e:
            print(f' FAIL:  Referential integrity test encountered error: {e}')
            await real_db_session.rollback()
        finally:
            try:
                await real_db_session.execute(text('DELETE FROM user_sessions WHERE user_id = :user_id'), {'user_id': test_user_id})
                await real_db_session.execute(text('DELETE FROM users WHERE id = :user_id'), {'user_id': test_user_id})
                await real_db_session.commit()
            except:
                pass

    @pytest.mark.asyncio
    async def test_concurrent_user_operations_integrity(self, real_db_session):
        """Test database integrity under concurrent user operations."""
        base_user_id = 100100
        concurrent_users = 5

        async def create_user_concurrently(user_offset: int) -> Dict[str, Any]:
            """Create user data concurrently."""
            user_id = base_user_id + user_offset
            user_data = self.create_test_user_data(user_id)
            try:
                async for session in get_request_scoped_db_session_for_fastapi():
                    async with session.begin():
                        user_query = text('\n                            INSERT INTO users (id, email, full_name, password_hash, is_active, created_at, oauth_provider, oauth_external_id)\n                            VALUES (:id, :email, :full_name, :password_hash, :is_active, :created_at, :oauth_provider, :oauth_external_id)\n                            RETURNING id\n                        ')
                        result = await session.execute(user_query, user_data)
                        created_user = result.fetchone()
                        if created_user:
                            session_data = self.create_test_session_data(created_user[0])
                            session_query = text('\n                                INSERT INTO user_sessions (id, user_id, session_token, refresh_token, created_at, expires_at, last_activity, ip_address, user_agent, is_active)\n                                VALUES (:id, :user_id, :session_token, :refresh_token, :created_at, :expires_at, :last_activity, :ip_address, :user_agent, :is_active)\n                                RETURNING id\n                            ')
                            session_result = await session.execute(session_query, session_data)
                            created_session = session_result.fetchone()
                            return {'user_id': created_user[0], 'session_id': created_session[0] if created_session else None, 'success': True}
                    break
            except Exception as e:
                return {'user_id': user_id, 'error': str(e), 'success': False}
        try:
            tasks = [create_user_concurrently(i) for i in range(concurrent_users)]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            successful_creations = []
            failed_creations = []
            for result in results:
                if isinstance(result, Exception):
                    failed_creations.append(str(result))
                elif isinstance(result, dict):
                    if result.get('success'):
                        successful_creations.append(result)
                    else:
                        failed_creations.append(result)
            print(f' PASS:  Concurrent operations completed - {len(successful_creations)} successful, {len(failed_creations)} failed')
            for success in successful_creations:
                verify_user = await real_db_session.execute(text('SELECT id, email FROM users WHERE id = :user_id'), {'user_id': success['user_id']})
                user_row = verify_user.fetchone()
                assert user_row is not None, f"User {success['user_id']} should exist after concurrent creation"
                if success['session_id']:
                    verify_session = await real_db_session.execute(text('SELECT id, user_id FROM user_sessions WHERE id = :session_id'), {'session_id': success['session_id']})
                    session_row = verify_session.fetchone()
                    assert session_row is not None, f"Session {success['session_id']} should exist"
                    assert session_row[1] == success['user_id'], 'Session should belong to correct user'
            print(' PASS:  Concurrent operations integrity validated')
        finally:
            for i in range(concurrent_users):
                user_id = base_user_id + i
                try:
                    await real_db_session.execute(text('DELETE FROM user_sessions WHERE user_id = :user_id'), {'user_id': user_id})
                    await real_db_session.execute(text('DELETE FROM users WHERE id = :user_id'), {'user_id': user_id})
                except:
                    pass
            await real_db_session.commit()

    @pytest.mark.asyncio
    async def test_session_token_uniqueness_constraints(self, real_db_session):
        """Test uniqueness constraints for session tokens."""
        test_user_id1 = 100201
        test_user_id2 = 100202
        users_data = [self.create_test_user_data(test_user_id1), self.create_test_user_data(test_user_id2)]
        created_users = []
        try:
            for user_data in users_data:
                user_query = text('\n                    INSERT INTO users (id, email, full_name, password_hash, is_active, created_at, oauth_provider, oauth_external_id)\n                    VALUES (:id, :email, :full_name, :password_hash, :is_active, :created_at, :oauth_provider, :oauth_external_id)\n                    RETURNING id\n                ')
                result = await real_db_session.execute(user_query, user_data)
                created_user = result.fetchone()
                created_users.append(created_user[0])
            await real_db_session.commit()
            print(f' PASS:  Created {len(created_users)} users for uniqueness constraint testing')
            duplicate_token = secrets.token_hex(32)
            session1_data = self.create_test_session_data(created_users[0])
            session1_data['session_token'] = duplicate_token
            session_query = text('\n                INSERT INTO user_sessions (id, user_id, session_token, refresh_token, created_at, expires_at, last_activity, ip_address, user_agent, is_active)\n                VALUES (:id, :user_id, :session_token, :refresh_token, :created_at, :expires_at, :last_activity, :ip_address, :user_agent, :is_active)\n                RETURNING id\n            ')
            result1 = await real_db_session.execute(session_query, session1_data)
            created_session1 = result1.fetchone()
            await real_db_session.commit()
            print(f' PASS:  First session created with token: {duplicate_token[:16]}...')
            session2_data = self.create_test_session_data(created_users[1])
            session2_data['session_token'] = duplicate_token
            try:
                await real_db_session.execute(session_query, session2_data)
                await real_db_session.commit()
                print(' WARNING: [U+FE0F] Session token uniqueness constraint not enforced - duplicate tokens allowed')
                verify_duplicates = await real_db_session.execute(text('SELECT id, user_id FROM user_sessions WHERE session_token = :token'), {'token': duplicate_token})
                duplicate_sessions = verify_duplicates.fetchall()
                if len(duplicate_sessions) > 1:
                    print(f' WARNING: [U+FE0F] Found {len(duplicate_sessions)} sessions with duplicate tokens')
            except IntegrityError as e:
                print(' PASS:  Session token uniqueness constraint enforced - Duplicate token rejected')
                await real_db_session.rollback()
            duplicate_refresh_token = secrets.token_hex(32)
            session3_data = self.create_test_session_data(created_users[0])
            session3_data['refresh_token'] = duplicate_refresh_token
            session3_data['session_token'] = secrets.token_hex(32)
            result3 = await real_db_session.execute(session_query, session3_data)
            await real_db_session.commit()
            session4_data = self.create_test_session_data(created_users[1])
            session4_data['refresh_token'] = duplicate_refresh_token
            session4_data['session_token'] = secrets.token_hex(32)
            try:
                await real_db_session.execute(session_query, session4_data)
                await real_db_session.commit()
                print(' WARNING: [U+FE0F] Refresh token uniqueness constraint not enforced')
            except IntegrityError as e:
                print(' PASS:  Refresh token uniqueness constraint enforced')
                await real_db_session.rollback()
            print(' PASS:  Token uniqueness constraints validated')
        finally:
            for user_id in [test_user_id1, test_user_id2]:
                try:
                    await real_db_session.execute(text('DELETE FROM user_sessions WHERE user_id = :user_id'), {'user_id': user_id})
                    await real_db_session.execute(text('DELETE FROM users WHERE id = :user_id'), {'user_id': user_id})
                except:
                    pass
            await real_db_session.commit()

    @pytest.mark.asyncio
    async def test_database_connection_recovery_and_resilience(self, real_db_session):
        """Test database connection recovery and resilience patterns."""
        test_user_id = 100301
        try:
            user_data = self.create_test_user_data(test_user_id)
            user_query = text('\n                INSERT INTO users (id, email, full_name, password_hash, is_active, created_at, oauth_provider, oauth_external_id)\n                VALUES (:id, :email, :full_name, :password_hash, :is_active, :created_at, :oauth_provider, :oauth_external_id)\n                RETURNING id\n            ')
            result = await real_db_session.execute(user_query, user_data)
            await real_db_session.commit()
            created_user = result.fetchone()
            print(f' PASS:  Normal database operation successful - User {created_user[0]} created')
            health_check = await real_db_session.execute(text('SELECT 1 as health_check'))
            health_result = health_check.fetchone()
            assert health_result[0] == 1, 'Database health check should return 1'
            print(' PASS:  Database connection health check passed')
            try:
                async with real_db_session.begin():
                    await real_db_session.execute(text('UPDATE users SET last_login_at = :now WHERE id = :user_id'), {'now': datetime.utcnow(), 'user_id': created_user[0]})
                    await real_db_session.execute(text('INSERT INTO non_existent_table VALUES (1)'))
            except Exception as e:
                print(f' PASS:  Transaction error handled gracefully: {type(e).__name__}')
                verify_rollback = await real_db_session.execute(text('SELECT last_login_at FROM users WHERE id = :user_id'), {'user_id': created_user[0]})
                rollback_result = verify_rollback.fetchone()
                if rollback_result[0] is None:
                    print(' PASS:  Transaction rollback successful - Changes reverted')
                else:
                    print(' WARNING: [U+FE0F] Transaction rollback may not have worked completely')
            recovery_test = await real_db_session.execute(text('SELECT COUNT(*) FROM users WHERE id = :user_id'), {'user_id': created_user[0]})
            recovery_result = recovery_test.fetchone()
            assert recovery_result[0] == 1, 'Should be able to query after failed transaction'
            print(' PASS:  Database connection recovered after failed transaction')
            print(' PASS:  Database resilience patterns validated')
        finally:
            try:
                await real_db_session.execute(text('DELETE FROM users WHERE id = :user_id'), {'user_id': test_user_id})
                await real_db_session.commit()
            except:
                pass
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')