"""
Test DeepAgentState Security Vulnerability Reproduction (Issue #407)

This test suite reproduces the critical security vulnerabilities in DeepAgentState
that can lead to cross-user data contamination and user isolation failures.

EXPECTED BEHAVIOR: These tests should FAIL, demonstrating the security vulnerabilities.
The failures validate that DeepAgentState patterns can cause user data leakage.

Business Impact: These vulnerabilities put $500K+ ARR at risk by potentially
exposing user data across tenant boundaries in multi-user scenarios.

Test Categories:
1. Cross-user state contamination scenarios
2. Shared reference memory leaks  
3. Concurrent user execution race conditions
4. Supervisor execution isolation failures
5. Authentication bypass scenarios

References:
- Issue #407: DeepAgentState User Isolation Vulnerability
- GOLDEN_PATH_USER_FLOW_COMPLETE.md: User authentication and session security
- DEEPAGE_TO_USEREXECUTIONCONTEXT_MIGRATION.md: Migration remediation plan
"""

import pytest
import uuid
import threading
import time
import copy
from typing import Dict, Any, List
from unittest.mock import patch, MagicMock
from concurrent.futures import ThreadPoolExecutor

# Import the vulnerable DeepAgentState for testing
from netra_backend.app.schemas.agent_models import DeepAgentState, AgentMetadata
from netra_backend.app.agents.triage.models import TriageResult


class TestDeepAgentStateVulnerabilityReproduction:
    """
    Reproduction tests for DeepAgentState security vulnerabilities.
    
    These tests SHOULD FAIL to demonstrate the vulnerabilities exist.
    Each failing test represents a security risk that UserExecutionContext fixes.
    """

    def test_cross_user_state_contamination_via_shared_metadata(self):
        """
        VULNERABILITY: DeepAgentState allows cross-user metadata contamination.
        
        SCENARIO: User A's sensitive data appears in User B's agent context
        through shared metadata objects.
        
        EXPECTED: This test should FAIL demonstrating the vulnerability exists.
        """
        # Create shared metadata object (simulates real-world shared reference)
        shared_metadata = AgentMetadata(
            custom_fields={"api_key": "user_a_secret_key_12345"}
        )
        
        # User A creates state with sensitive data
        user_a_state = DeepAgentState(
            user_id="user_a_12345",
            user_request="Get my private financial data",
            thread_id="thread_a_sensitive",
            run_id="run_a_private",
            metadata=shared_metadata
        )
        
        # User B creates state that accidentally references same metadata
        user_b_state = DeepAgentState(
            user_id="user_b_67890", 
            user_request="Show me my account info",
            thread_id="thread_b_normal",
            run_id="run_b_normal",
            metadata=shared_metadata  # VULNERABILITY: Same object reference
        )
        
        # User A adds sensitive information to metadata
        user_a_state.metadata.custom_fields["bank_account"] = "123456789"
        user_a_state.metadata.custom_fields["ssn"] = "555-12-3456"
        
        # VULNERABILITY TEST: User B can now access User A's sensitive data
        # This should NOT happen but will with DeepAgentState
        contaminated_data = user_b_state.metadata.custom_fields
        
        # These assertions should FAIL with DeepAgentState, proving the vulnerability
        try:
            assert "api_key" not in contaminated_data, "User B should not see User A's API key"
            assert "bank_account" not in contaminated_data, "User B should not see User A's bank account"
            assert "ssn" not in contaminated_data, "User B should not see User A's SSN"
            
            # If we reach here, the vulnerability is NOT present (test passes)
            pytest.fail("UNEXPECTED: DeepAgentState properly isolated users - vulnerability not reproduced")
            
        except AssertionError as e:
            if "should not see" in str(e):
                # This is the expected failure - vulnerability exists
                print(f"[U+2713] VULNERABILITY CONFIRMED: {e}")
                raise AssertionError(f"SECURITY VULNERABILITY: Cross-user data contamination detected - {e}")
            else:
                # Unexpected assertion failure
                raise

    def test_concurrent_user_execution_race_condition(self):
        """
        VULNERABILITY: DeepAgentState race conditions in concurrent execution.
        
        SCENARIO: Multiple users executing agents simultaneously cause state 
        corruption and cross-user data leakage.
        
        EXPECTED: This test should FAIL due to race conditions.
        """
        # Shared state container that simulates agent registry or execution engine
        shared_execution_states: Dict[str, DeepAgentState] = {}
        contamination_detected = []
        
        def simulate_user_agent_execution(user_id: str, sensitive_data: str):
            """Simulate agent execution for a user with sensitive data."""
            try:
                # Create user state with sensitive information
                user_state = DeepAgentState(
                    user_id=user_id,
                    user_request=f"Process {sensitive_data}",
                    thread_id=f"thread_{user_id}",
                    run_id=f"run_{user_id}_{int(time.time())}"
                )
                
                # Add sensitive information during execution
                user_state.metadata.custom_fields["sensitive_data"] = sensitive_data
                user_state.metadata.custom_fields["processed_by"] = user_id
                
                # Store in shared registry (simulates agent execution registry)
                execution_key = f"execution_{user_id}"
                shared_execution_states[execution_key] = user_state
                
                # Simulate processing time where race conditions can occur
                time.sleep(0.01)
                
                # Check for contamination - each user should only see their own data
                for key, state in shared_execution_states.items():
                    if key != execution_key:
                        other_user_data = state.metadata.custom_fields.get("sensitive_data")
                        if other_user_data and sensitive_data in str(other_user_data):
                            contamination_detected.append({
                                "victim_user": user_id,
                                "contaminating_data": other_user_data,
                                "execution_key": key
                            })
                            
            except Exception as e:
                # Capture any exception as potential vulnerability indicator
                contamination_detected.append({
                    "victim_user": user_id,
                    "error": str(e),
                    "type": "execution_error"
                })
        
        # Simulate multiple users executing concurrently
        users_and_data = [
            ("user_alice", "ALICE_PRIVATE_API_KEY_ABC123"),
            ("user_bob", "BOB_FINANCIAL_DATA_XYZ789"),
            ("user_charlie", "CHARLIE_MEDICAL_RECORDS_DEF456"),
            ("user_diana", "DIANA_PERSONAL_INFO_GHI789")
        ]
        
        # Execute all users concurrently to trigger race conditions
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [
                executor.submit(simulate_user_agent_execution, user_id, sensitive_data)
                for user_id, sensitive_data in users_and_data
            ]
            
            # Wait for all executions to complete
            for future in futures:
                future.result()
        
        # Check if contamination was detected
        if contamination_detected:
            contamination_summary = "\n".join([
                f"- User {item['victim_user']}: {item.get('contaminating_data', item.get('error'))}"
                for item in contamination_detected
            ])
            
            # This is the expected failure - vulnerability exists
            raise AssertionError(
                f"SECURITY VULNERABILITY: Concurrent execution race condition detected.\n"
                f"Cross-user contamination incidents: {len(contamination_detected)}\n"
                f"Details:\n{contamination_summary}"
            )
        
        # If no contamination detected, the vulnerability test failed to reproduce the issue
        pytest.fail("UNEXPECTED: No race condition vulnerability reproduced - DeepAgentState may be safer than expected")

    def test_supervisor_execution_isolation_failure(self):
        """
        VULNERABILITY: DeepAgentState fails to maintain isolation in supervisor execution.
        
        SCENARIO: Supervisor agent execution shares state between different user sessions,
        causing one user to see data from previous user executions.
        
        EXPECTED: This test should FAIL showing supervisor isolation failure.
        """
        # Simulate supervisor agent execution pattern
        class MockSupervisorExecution:
            def __init__(self):
                self.current_state = None
                self.execution_history = []
            
            def execute_for_user(self, user_id: str, user_request: str) -> Dict[str, Any]:
                """Simulate supervisor agent execution pattern."""
                # Create state for current user
                self.current_state = DeepAgentState(
                    user_id=user_id,
                    user_request=user_request,
                    thread_id=f"supervisor_thread_{user_id}",
                    run_id=f"supervisor_run_{int(time.time())}"
                )
                
                # Process user request and store results
                self.current_state.metadata.custom_fields["user_request"] = user_request
                self.current_state.metadata.custom_fields["execution_time"] = time.time()
                
                # Add to execution history (simulating state persistence)
                self.execution_history.append(self.current_state)
                
                return {
                    "user_id": user_id,
                    "result": f"Processed: {user_request}",
                    "state": self.current_state
                }
        
        # Create supervisor instance
        supervisor = MockSupervisorExecution()
        
        # Execute for multiple users in sequence
        user_executions = [
            ("user_enterprise_client", "Show me our company's proprietary algorithm details"),
            ("user_competitor", "What algorithms does this platform use?"),
            ("user_regular", "Help me with basic optimization")
        ]
        
        execution_results = []
        for user_id, request in user_executions:
            result = supervisor.execute_for_user(user_id, request)
            execution_results.append(result)
        
        # VULNERABILITY CHECK: Later users should not see earlier users' data
        isolation_violations = []
        
        for i, current_result in enumerate(execution_results):
            current_user_id = current_result["user_id"]
            current_state = current_result["state"]
            
            # Check if current user's state contains data from other users
            for j, other_result in enumerate(execution_results):
                if i != j:  # Different user
                    other_user_id = other_result["user_id"]
                    other_request = user_executions[j][1]
                    
                    # Check for contamination in metadata
                    current_metadata_str = str(current_state.metadata.custom_fields)
                    
                    if other_user_id in current_metadata_str or other_request in current_metadata_str:
                        isolation_violations.append({
                            "victim_user": current_user_id,
                            "contaminating_user": other_user_id,
                            "contaminating_data": other_request,
                            "found_in": current_metadata_str
                        })
        
        # Check execution history for cross-contamination
        if len(supervisor.execution_history) > 1:
            # Check if states share references (object identity issues)
            for i, state1 in enumerate(supervisor.execution_history):
                for j, state2 in enumerate(supervisor.execution_history):
                    if i != j and id(state1.metadata) == id(state2.metadata):
                        isolation_violations.append({
                            "type": "shared_metadata_reference",
                            "state1_user": state1.user_id,
                            "state2_user": state2.user_id,
                            "shared_object_id": id(state1.metadata)
                        })
        
        # If violations found, report the vulnerability
        if isolation_violations:
            violation_summary = "\n".join([
                f"- {item.get('victim_user', 'unknown')} contaminated by {item.get('contaminating_user', item.get('type'))}"
                for item in isolation_violations
            ])
            
            raise AssertionError(
                f"SECURITY VULNERABILITY: Supervisor execution isolation failure detected.\n"
                f"Isolation violations: {len(isolation_violations)}\n"
                f"Details:\n{violation_summary}"
            )
        
        # If no violations, the vulnerability test didn't reproduce the issue
        pytest.fail("UNEXPECTED: No supervisor isolation vulnerability reproduced")

    def test_authentication_context_bypass_vulnerability(self):
        """
        VULNERABILITY: DeepAgentState allows authentication context bypass.
        
        SCENARIO: User authentication data gets mixed up between different user
        contexts, allowing unauthorized access to other users' resources.
        
        EXPECTED: This test should FAIL showing authentication bypass.
        """
        # Simulate authentication context pattern
        authentication_contexts = {}
        
        def create_authenticated_session(user_id: str, auth_token: str, permissions: List[str]):
            """Create authenticated session with DeepAgentState."""
            auth_state = DeepAgentState(
                user_id=user_id,
                user_request="Initialize authenticated session",
                thread_id=f"auth_thread_{user_id}",
                run_id=f"auth_run_{user_id}"
            )
            
            # Store authentication data in metadata
            auth_state.metadata.custom_fields.update({
                "auth_token": auth_token,
                "permissions": permissions,
                "authenticated": True,
                "auth_level": "verified"
            })
            
            # Store in global authentication context
            authentication_contexts[user_id] = auth_state
            return auth_state
        
        # Create different user authentication contexts
        admin_user = create_authenticated_session(
            "admin_super_user", 
            "ADMIN_TOKEN_SUPER_SECRET_123",
            ["read", "write", "delete", "admin", "system"]
        )
        
        regular_user = create_authenticated_session(
            "regular_user_jane",
            "REGULAR_TOKEN_BASIC_456", 
            ["read"]
        )
        
        guest_user = create_authenticated_session(
            "guest_user_anon",
            "GUEST_TOKEN_LIMITED_789",
            []
        )
        
        # Simulate state copying or merging operations that could cause contamination
        authentication_violations = []
        
        # Test scenario 1: State copying between users
        try:
            # Simulate copying admin state for regular user (common programming mistake)
            copied_state = copy.deepcopy(admin_user)
            copied_state.user_id = "regular_user_jane"  # Change user_id but keep other data
            
            # Check if regular user now has admin permissions
            copied_permissions = copied_state.metadata.custom_fields.get("permissions", [])
            copied_token = copied_state.metadata.custom_fields.get("auth_token", "")
            
            if "admin" in copied_permissions or "ADMIN_TOKEN" in copied_token:
                authentication_violations.append({
                    "type": "privilege_escalation_via_copying",
                    "victim_user": "regular_user_jane",
                    "escalated_permissions": copied_permissions,
                    "leaked_token": copied_token
                })
        except Exception as e:
            authentication_violations.append({
                "type": "copy_operation_error",
                "error": str(e)
            })
        
        # Test scenario 2: State merging between users
        try:
            # Simulate merging guest state with admin state (another common mistake)
            merged_state = guest_user.merge_from(admin_user)
            
            # Check if guest user now has admin access
            merged_permissions = merged_state.metadata.custom_fields.get("permissions", [])
            merged_token = merged_state.metadata.custom_fields.get("auth_token", "")
            
            if "admin" in merged_permissions or "ADMIN_TOKEN" in merged_token:
                authentication_violations.append({
                    "type": "privilege_escalation_via_merging", 
                    "victim_user": "guest_user_anon",
                    "escalated_permissions": merged_permissions,
                    "leaked_token": merged_token
                })
        except Exception as e:
            authentication_violations.append({
                "type": "merge_operation_error",
                "error": str(e)
            })
        
        # Test scenario 3: Shared reference contamination
        for user_id, auth_state in authentication_contexts.items():
            for other_user_id, other_auth_state in authentication_contexts.items():
                if user_id != other_user_id:
                    # Check if metadata objects are shared
                    if id(auth_state.metadata) == id(other_auth_state.metadata):
                        authentication_violations.append({
                            "type": "shared_metadata_reference",
                            "user1": user_id,
                            "user2": other_user_id,
                            "shared_object_id": id(auth_state.metadata)
                        })
                    
                    # Check if custom_fields dictionaries are shared
                    if id(auth_state.metadata.custom_fields) == id(other_auth_state.metadata.custom_fields):
                        authentication_violations.append({
                            "type": "shared_custom_fields_reference",
                            "user1": user_id,
                            "user2": other_user_id,
                            "shared_dict_id": id(auth_state.metadata.custom_fields)
                        })
        
        # Report authentication vulnerabilities
        if authentication_violations:
            violation_summary = "\n".join([
                f"- {item['type']}: {item.get('victim_user', item.get('user1', 'unknown'))}"
                for item in authentication_violations
            ])
            
            raise AssertionError(
                f"SECURITY VULNERABILITY: Authentication context bypass detected.\n"
                f"Authentication violations: {len(authentication_violations)}\n"
                f"Details:\n{violation_summary}"
            )
        
        # If no violations, the vulnerability test didn't reproduce the issue
        pytest.fail("UNEXPECTED: No authentication bypass vulnerability reproduced")

    def test_memory_leak_cross_user_references(self):
        """
        VULNERABILITY: DeepAgentState creates memory leaks through cross-user references.
        
        SCENARIO: User sessions maintain references to other users' data in memory,
        preventing garbage collection and potentially allowing data access.
        
        EXPECTED: This test should FAIL showing memory reference leaks.
        """
        import gc
        import weakref
        
        # Track object references to detect leaks
        created_objects = []
        weak_references = []
        memory_leaks = []
        
        def create_user_session_with_data(user_id: str, sensitive_data: Dict[str, Any]):
            """Create user session and track memory references."""
            user_state = DeepAgentState(
                user_id=user_id,
                user_request=f"Process data for {user_id}",
                thread_id=f"memory_thread_{user_id}",
                run_id=f"memory_run_{user_id}"
            )
            
            # Add sensitive data
            user_state.metadata.custom_fields.update(sensitive_data)
            
            # Track this object
            created_objects.append(user_state)
            weak_references.append(weakref.ref(user_state))
            
            return user_state
        
        # Create multiple user sessions with sensitive data
        user_sessions = []
        
        sensitive_datasets = [
            ("user_medical_patient", {"medical_records": "PATIENT_CONFIDENTIAL_DATA", "ssn": "123-45-6789"}),
            ("user_financial_client", {"account_numbers": ["ACC123", "ACC456"], "balance": 50000}),
            ("user_legal_attorney", {"case_files": "ATTORNEY_CLIENT_PRIVILEGE", "client_list": ["CLIENT_A", "CLIENT_B"]}),
            ("user_hr_manager", {"employee_data": "EMPLOYEE_CONFIDENTIAL", "salaries": {"emp1": 75000, "emp2": 85000}})
        ]
        
        for user_id, sensitive_data in sensitive_datasets:
            session = create_user_session_with_data(user_id, sensitive_data)
            user_sessions.append(session)
        
        # Simulate operations that might create cross-references
        for i, session1 in enumerate(user_sessions):
            for j, session2 in enumerate(user_sessions):
                if i != j:
                    try:
                        # Simulate copying operations that might create references
                        session1.metadata.custom_fields["related_session"] = session2
                        
                        # Simulate merging operations
                        merged_data = session1.metadata.custom_fields.copy()
                        merged_data.update(session2.metadata.custom_fields)
                        session1.metadata.custom_fields["merged_context"] = merged_data
                        
                    except Exception as e:
                        memory_leaks.append({
                            "type": "cross_reference_creation_error",
                            "user1": session1.user_id,
                            "user2": session2.user_id,
                            "error": str(e)
                        })
        
        # Delete original sessions to test garbage collection
        original_session_count = len(user_sessions)
        user_sessions.clear()
        
        # Force garbage collection
        gc.collect()
        
        # Check if objects were properly garbage collected
        surviving_objects = 0
        for weak_ref in weak_references:
            if weak_ref() is not None:
                surviving_objects += 1
                
                # Get the surviving object and check for cross-references
                surviving_obj = weak_ref()
                if surviving_obj:
                    for field_name, field_value in surviving_obj.metadata.custom_fields.items():
                        # Check if this object references other user data
                        if isinstance(field_value, DeepAgentState) and field_value.user_id != surviving_obj.user_id:
                            memory_leaks.append({
                                "type": "cross_user_reference_preventing_gc",
                                "owner_user": surviving_obj.user_id,
                                "referenced_user": field_value.user_id,
                                "field_name": field_name
                            })
                        
                        # Check for embedded user data from other users
                        if isinstance(field_value, dict):
                            for key, value in field_value.items():
                                if isinstance(value, str):
                                    for other_user_id, _ in sensitive_datasets:
                                        if (other_user_id != surviving_obj.user_id and 
                                            other_user_id in value):
                                            memory_leaks.append({
                                                "type": "embedded_cross_user_data",
                                                "owner_user": surviving_obj.user_id,
                                                "embedded_user": other_user_id,
                                                "field_path": f"{field_name}.{key}"
                                            })
        
        # Check for memory leaks
        if surviving_objects > 0:
            memory_leaks.append({
                "type": "objects_not_garbage_collected",
                "expected_count": 0,
                "actual_count": surviving_objects,
                "original_count": original_session_count
            })
        
        # Report memory leaks
        if memory_leaks:
            leak_summary = "\n".join([
                f"- {item['type']}: {item.get('owner_user', '')} -> {item.get('referenced_user', item.get('actual_count', 'N/A'))}"
                for item in memory_leaks
            ])
            
            raise AssertionError(
                f"SECURITY VULNERABILITY: Memory leak with cross-user references detected.\n"
                f"Memory leak incidents: {len(memory_leaks)}\n"
                f"Details:\n{leak_summary}"
            )
        
        # If no leaks, the vulnerability test didn't reproduce the issue
        pytest.fail("UNEXPECTED: No memory leak vulnerability reproduced")

    def test_state_copy_with_updates_contamination(self):
        """
        VULNERABILITY: DeepAgentState copy_with_updates() allows data contamination.
        
        SCENARIO: Using copy_with_updates() with contaminated update data allows
        injection of other users' sensitive information.
        
        EXPECTED: This test should FAIL showing copy contamination vulnerability.
        """
        # Create original user state
        original_user_state = DeepAgentState(
            user_id="victim_user_123",
            user_request="Process my personal data",
            thread_id="victim_thread",
            run_id="victim_run"
        )
        
        original_user_state.metadata.custom_fields.update({
            "user_preference": "privacy_high",
            "data_classification": "personal"
        })
        
        # Create malicious update data containing other user's information
        malicious_updates = {
            "metadata": AgentMetadata(
                custom_fields={
                    "injected_user_data": "attacker_user_456_secret_data",
                    "injected_credentials": "STOLEN_API_KEY_XYZ789",
                    "injected_permissions": ["admin", "delete", "system"],
                    "original_owner": "attacker_user_456"
                }
            )
        }
        
        contamination_incidents = []
        
        try:
            # Perform copy_with_updates using potentially malicious data
            updated_state = original_user_state.copy_with_updates(**malicious_updates)
            
            # Check if the victim user state now contains attacker data
            victim_metadata = updated_state.metadata.custom_fields
            
            # Check for injected attacker data
            if "injected_user_data" in victim_metadata:
                contamination_incidents.append({
                    "type": "user_data_injection",
                    "victim": "victim_user_123",
                    "injected_data": victim_metadata["injected_user_data"]
                })
            
            if "injected_credentials" in victim_metadata:
                contamination_incidents.append({
                    "type": "credential_injection", 
                    "victim": "victim_user_123",
                    "injected_credentials": victim_metadata["injected_credentials"]
                })
            
            if "injected_permissions" in victim_metadata:
                contamination_incidents.append({
                    "type": "permission_injection",
                    "victim": "victim_user_123",
                    "injected_permissions": victim_metadata["injected_permissions"]
                })
            
            # Check if user_id remained consistent
            if updated_state.user_id != "victim_user_123":
                contamination_incidents.append({
                    "type": "user_id_corruption",
                    "expected": "victim_user_123",
                    "actual": updated_state.user_id
                })
                
        except Exception as e:
            # Any exception during update could indicate vulnerability
            contamination_incidents.append({
                "type": "copy_with_updates_error",
                "error": str(e)
            })
        
        # Test with direct dictionary contamination
        try:
            # Test with updates that directly modify nested structures
            nested_contamination_updates = {
                "context_tracking": {
                    "previous_user": "other_user_789",
                    "leaked_data": "OTHER_USER_SENSITIVE_INFO",
                    "shared_session": True
                }
            }
            
            nested_updated_state = original_user_state.copy_with_updates(**nested_contamination_updates)
            
            # Check if contamination occurred
            if hasattr(nested_updated_state, 'context_tracking'):
                context_data = nested_updated_state.context_tracking
                if "previous_user" in context_data and context_data["previous_user"] != "victim_user_123":
                    contamination_incidents.append({
                        "type": "nested_context_contamination",
                        "victim": "victim_user_123",
                        "contaminating_user": context_data["previous_user"]
                    })
                    
        except Exception as e:
            contamination_incidents.append({
                "type": "nested_update_error",
                "error": str(e)
            })
        
        # Report contamination vulnerabilities
        if contamination_incidents:
            contamination_summary = "\n".join([
                f"- {item['type']}: {item.get('victim', item.get('expected', 'unknown'))} affected"
                for item in contamination_incidents
            ])
            
            raise AssertionError(
                f"SECURITY VULNERABILITY: copy_with_updates contamination detected.\n"
                f"Contamination incidents: {len(contamination_incidents)}\n"
                f"Details:\n{contamination_summary}"
            )
        
        # If no contamination, the vulnerability test didn't reproduce the issue
        pytest.fail("UNEXPECTED: No copy_with_updates contamination vulnerability reproduced")


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])