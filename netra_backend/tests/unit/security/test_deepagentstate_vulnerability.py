"""Unit tests to reproduce DeepAgentState cross-user contamination vulnerability.

Issue: #953 - SSOT-legacy-deepagentstate-critical-user-isolation-vulnerability
Priority: P0 - Golden Path Security Critical
Business Impact: $500K+ ARR at risk due to user isolation vulnerabilities

These tests SHOULD FAIL initially to prove the vulnerability exists.
"""

import pytest
import asyncio
from unittest.mock import Mock, AsyncMock
from typing import Any, Dict

# Import the vulnerable DeepAgentState for testing
from netra_backend.app.schemas.agent_models import DeepAgentState


class TestDeepAgentStateVulnerability:
    """Unit tests to reproduce the DeepAgentState vulnerability."""

    async def test_deepagentstate_cross_user_contamination_basic(self):
        """REPRODUCE VULNERABILITY: DeepAgentState allows basic cross-user data leakage.

        This test SHOULD FAIL initially, proving the vulnerability exists.
        """
        # Create two DeepAgentState instances for different users with sensitive data
        user1_state = DeepAgentState(
            user_id="enterprise_user_123",
            user_request="Analyze my confidential financial costs",
            agent_context={
                "sensitive_data": "user1_private_financial_info",
                "aws_account": "123456789",
                "monthly_budget": 500000
            }
        )

        user2_state = DeepAgentState(
            user_id="enterprise_user_456",
            user_request="Generate synthetic medical data",
            agent_context={
                "sensitive_data": "user2_private_medical_info",
                "hospital_id": "987654321",
                "patient_records": "classified"
            }
        )

        # Test 1: Check if states are truly isolated (they should be, but may not be)
        assert user1_state.user_id != user2_state.user_id, "Basic user ID isolation failed"

        # Test 2: Simulate merge operation that could cause contamination
        merged_state = user1_state.merge_from(user2_state)

        # VULNERABILITY CHECK: User1 should NOT have access to User2's medical data
        merged_context_str = str(merged_state.agent_context)

        # This assertion SHOULD FAIL if vulnerability exists
        assert "user2_private_medical_info" not in merged_context_str, \
               "CRITICAL VULNERABILITY: User1 can access User2's private medical data!"

        assert "987654321" not in merged_context_str, \
               "CRITICAL VULNERABILITY: User1 can access User2's hospital ID!"

        assert "classified" not in merged_context_str, \
               "CRITICAL VULNERABILITY: User1 can access User2's classified patient records!"

    async def test_deepagentstate_memory_reference_sharing(self):
        """REPRODUCE VULNERABILITY: DeepAgentState shares memory references between users.

        This test checks if agent_context dictionaries are shared by reference,
        allowing one user to modify another user's data.
        """
        # Create base context that might be shared
        base_context = {"shared_reference": "initial_value"}

        user1_state = DeepAgentState(
            user_id="user_001",
            user_request="Process confidential data",
            agent_context=base_context.copy()
        )

        user2_state = DeepAgentState(
            user_id="user_002",
            user_request="Process different confidential data",
            agent_context=base_context.copy()
        )

        # Modify user1's context - should not affect user2
        user1_state.agent_context["user1_secret"] = "classified_financial_data"
        user1_state.agent_context["shared_reference"] = "user1_modified"

        # Check if user2's context was contaminated
        user2_context_str = str(user2_state.agent_context)

        # These should NOT fail if isolation is working correctly
        assert "classified_financial_data" not in user2_context_str, \
               "VULNERABILITY: User2 can see User1's classified financial data!"

        assert user2_state.agent_context["shared_reference"] != "user1_modified", \
               "VULNERABILITY: Shared reference contamination between users!"

    async def test_deepagentstate_concurrent_modification(self):
        """REPRODUCE VULNERABILITY: Concurrent modifications can cause cross-contamination."""

        user1_state = DeepAgentState(
            user_id="concurrent_user_1",
            user_request="Analyze AWS infrastructure",
            agent_context={"aws_keys": "secret_access_key_1", "account": "prod_account_1"}
        )

        user2_state = DeepAgentState(
            user_id="concurrent_user_2",
            user_request="Analyze Azure infrastructure",
            agent_context={"azure_keys": "secret_access_key_2", "account": "prod_account_2"}
        )

        # Simulate concurrent operations that might cause contamination
        async def modify_user1():
            user1_state.agent_context.update({
                "processing_status": "active",
                "temp_data": "user1_temp_sensitive_data"
            })
            return user1_state

        async def modify_user2():
            user2_state.agent_context.update({
                "processing_status": "active",
                "temp_data": "user2_temp_sensitive_data"
            })
            return user2_state

        # Run concurrent modifications
        modified_states = await asyncio.gather(modify_user1(), modify_user2())
        state1, state2 = modified_states

        # Check for cross-contamination
        state1_str = str(state1.agent_context)
        state2_str = str(state2.agent_context)

        # These should NOT fail if isolation works
        assert "secret_access_key_2" not in state1_str, \
               "VULNERABILITY: User1 accessed User2's Azure keys!"

        assert "secret_access_key_1" not in state2_str, \
               "VULNERABILITY: User2 accessed User1's AWS keys!"

        assert "user2_temp_sensitive_data" not in state1_str, \
               "VULNERABILITY: User1 accessed User2's temporary sensitive data!"

        assert "user1_temp_sensitive_data" not in state2_str, \
               "VULNERABILITY: User2 accessed User1's temporary sensitive data!"

    async def test_deepagentstate_synthetic_data_contamination(self):
        """REPRODUCE VULNERABILITY: Synthetic data results contamination between users."""

        # Create states representing different enterprises with sensitive synthetic data needs
        enterprise1_state = DeepAgentState(
            user_id="enterprise_banking_001",
            user_request="Generate synthetic financial transaction data",
            agent_context={
                "industry": "banking",
                "data_classification": "PII_financial",
                "compliance": ["PCI_DSS", "SOX"],
                "customer_base": "fortune_500_banking"
            }
        )

        enterprise2_state = DeepAgentState(
            user_id="enterprise_healthcare_002",
            user_request="Generate synthetic patient medical records",
            agent_context={
                "industry": "healthcare",
                "data_classification": "PHI_medical",
                "compliance": ["HIPAA", "HITECH"],
                "patient_data": "medical_records_database"
            }
        )

        # Simulate synthetic data generation results
        enterprise1_state.synthetic_data_result = {
            "generated_records": 10000,
            "data_type": "financial_transactions",
            "compliance_validated": True,
            "sample_data": "account_123456: $50000 transaction to healthcare_provider"
        }

        enterprise2_state.synthetic_data_result = {
            "generated_records": 5000,
            "data_type": "patient_records",
            "compliance_validated": True,
            "sample_data": "patient_789: diabetes, medication: insulin, bank_account: 123456"
        }

        # Check for cross-industry data contamination
        enterprise1_result_str = str(enterprise1_state.synthetic_data_result)
        enterprise2_result_str = str(enterprise2_state.synthetic_data_result)

        # CRITICAL: Banking enterprise should NOT see healthcare data
        assert "patient_789" not in enterprise1_result_str, \
               "CRITICAL VULNERABILITY: Banking enterprise accessed healthcare patient data!"

        assert "diabetes" not in enterprise1_result_str, \
               "CRITICAL VULNERABILITY: Banking enterprise accessed medical diagnosis!"

        assert "insulin" not in enterprise1_result_str, \
               "CRITICAL VULNERABILITY: Banking enterprise accessed medication data!"

        # CRITICAL: Healthcare enterprise should NOT see banking data
        assert "account_123456" not in enterprise2_result_str or \
               "healthcare_provider" not in enterprise1_result_str, \
               "CRITICAL VULNERABILITY: Healthcare enterprise accessed banking transaction data!"

    async def test_deepagentstate_execution_flow_contamination(self):
        """REPRODUCE VULNERABILITY: Agent execution flow data contamination."""

        # Create states for different user execution flows
        user1_flow = DeepAgentState(
            user_id="flow_user_001",
            user_request="Optimize my cloud costs",
            agent_context={
                "execution_flow": "cost_optimization",
                "cloud_provider": "aws",
                "current_spend": 75000,
                "optimization_target": 25
            }
        )

        user2_flow = DeepAgentState(
            user_id="flow_user_002",
            user_request="Security vulnerability scan",
            agent_context={
                "execution_flow": "security_scan",
                "scan_targets": ["prod", "staging"],
                "security_level": "high",
                "vulnerabilities_found": 15
            }
        )

        # Simulate execution flow updates that might contaminate
        user1_flow.execution_history = [
            {"step": 1, "action": "cost_analysis", "result": "identified 75k monthly spend"},
            {"step": 2, "action": "optimization", "result": "potential 25% savings identified"}
        ]

        user2_flow.execution_history = [
            {"step": 1, "action": "vulnerability_scan", "result": "15 high-risk vulnerabilities found"},
            {"step": 2, "action": "risk_assessment", "result": "critical security gaps identified"}
        ]

        # Check for execution flow contamination
        user1_history_str = str(user1_flow.execution_history)
        user2_history_str = str(user2_flow.execution_history)

        # User1 (cost optimization) should NOT see security scan data
        assert "vulnerability_scan" not in user1_history_str, \
               "VULNERABILITY: Cost optimization user saw security scan data!"

        assert "15 high-risk vulnerabilities" not in user1_history_str, \
               "VULNERABILITY: Cost optimization user saw vulnerability results!"

        assert "critical security gaps" not in user1_history_str, \
               "VULNERABILITY: Cost optimization user saw security risk assessment!"

        # User2 (security scan) should NOT see cost optimization data
        assert "cost_analysis" not in user2_history_str, \
               "VULNERABILITY: Security scan user saw cost analysis data!"

        assert "75k monthly spend" not in user2_history_str, \
               "VULNERABILITY: Security scan user saw financial spend data!"

        assert "25% savings" not in user2_history_str, \
               "VULNERABILITY: Security scan user saw cost optimization results!"


# Additional helper to test deep object contamination
def test_deepagentstate_deep_object_reference_sharing():
    """Test if DeepAgentState shares deep object references that enable contamination."""

    # Create nested object that might be shared
    shared_config = {
        "database": {
            "host": "prod-db.company.com",
            "credentials": {"username": "admin", "password": "secret123"}
        },
        "api_keys": {
            "aws": "AKIA...",
            "openai": "sk-..."
        }
    }

    user1_state = DeepAgentState(
        user_id="deep_user_1",
        user_request="Database optimization",
        agent_context={"config": shared_config}
    )

    user2_state = DeepAgentState(
        user_id="deep_user_2",
        user_request="API integration",
        agent_context={"config": shared_config}
    )

    # Modify nested object in user1's context
    user1_state.agent_context["config"]["database"]["credentials"]["password"] = "user1_modified_secret"
    user1_state.agent_context["config"]["api_keys"]["user1_specific"] = "user1_api_key"

    # Check if user2's nested data was affected (vulnerability)
    user2_password = user2_state.agent_context["config"]["database"]["credentials"]["password"]
    user2_api_keys = user2_state.agent_context["config"]["api_keys"]

    # These should NOT fail if deep isolation works
    assert user2_password != "user1_modified_secret", \
           "DEEP VULNERABILITY: User1's password change affected User2's database config!"

    assert "user1_specific" not in user2_api_keys, \
           "DEEP VULNERABILITY: User1's API key appeared in User2's config!"


if __name__ == "__main__":
    # Run the vulnerability tests to see which fail
    pytest.main([__file__, "-v", "--tb=short"])