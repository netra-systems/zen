"""
KV Cache Audit E2E Test Suite
Tests KV cache auditing and optimization using real LLM agents.
Maximum 300 lines, functions â‰¤8 lines.
"""

# Add project root to path
import sys
from pathlib import Path

from netra_backend.tests.test_utils import setup_test_path

PROJECT_ROOT = Path(__file__).parent.parent.parent
if str(PROJECT_ROOT) not in sys.path:
    sys.path.insert(0, str(PROJECT_ROOT))

setup_test_path()

import asyncio
import uuid
from datetime import datetime, timezone
from typing import Dict, List, Optional

import pytest
import pytest_asyncio
from schemas import SubAgentLifecycle
from ws_manager import WebSocketManager

from netra_backend.app.agents.data_sub_agent.agent import DataSubAgent
from netra_backend.app.agents.state import DeepAgentState

# Add project root to path
from netra_backend.app.agents.triage_sub_agent.agent import TriageSubAgent
from netra_backend.app.core.exceptions import NetraException
from netra_backend.app.llm.llm_manager import LLMManager
from netra_backend.app.services.quality_gate_service import (
    ContentType,
    QualityGateService,
    QualityLevel,
)

# Add project root to path


@pytest.fixture
def kv_cache_audit_setup(real_llm_manager, real_websocket_manager, real_tool_dispatcher):
    """Setup real agent environment for KV cache audit testing."""
    # Import additional agents to avoid circular dependencies
    from netra_backend.app.agents.actions_to_meet_goals_sub_agent import (
        ActionsToMeetGoalsSubAgent,
    )
    from netra_backend.app.agents.optimizations_core_sub_agent import (
        OptimizationsCoreSubAgent,
    )
    from netra_backend.app.agents.reporting_sub_agent import ReportingSubAgent
    
    agents = {
        'triage': TriageSubAgent(real_llm_manager, real_tool_dispatcher),
        'data': DataSubAgent(real_llm_manager, real_tool_dispatcher),
        'optimization': OptimizationsCoreSubAgent(real_llm_manager, real_tool_dispatcher),
        'actions': ActionsToMeetGoalsSubAgent(real_llm_manager, real_tool_dispatcher),
        'reporting': ReportingSubAgent(real_llm_manager, real_tool_dispatcher)
    }
    return _build_kv_cache_setup(agents, real_llm_manager, real_websocket_manager)


def _build_kv_cache_setup(agents: Dict, llm: LLMManager, ws: WebSocketManager) -> Dict:
    """Build complete setup dictionary for KV cache testing."""
    return {
        'agents': agents, 'llm': llm, 'websocket': ws,
        'run_id': str(uuid.uuid4()), 'user_id': 'kv-cache-test-user'
    }


@pytest.mark.real_llm
class TestKVCacheAuditWorkflow:
    """Test KV cache audit and optimization workflows."""
    
    async def test_ep_006_kv_cache_audit_real_llm(self, kv_cache_audit_setup):
        """Test EP-006: KV cache audit for optimization opportunities using real LLM."""
        setup = kv_cache_audit_setup
        state = _create_ep_006_state()
        results = await _execute_kv_cache_audit_workflow(setup, state)
        await _validate_ep_006_results(results, state, setup)
    
    async def test_kv_cache_usage_analysis(self, kv_cache_audit_setup):
        """Test KV cache usage pattern analysis."""
        setup = kv_cache_audit_setup
        state = _create_usage_analysis_state()
        results = await _execute_kv_cache_audit_workflow(setup, state)
        _validate_usage_analysis_results(results, state)
    
    async def test_kv_cache_optimization_recommendations(self, kv_cache_audit_setup):
        """Test KV cache optimization recommendation generation."""
        setup = kv_cache_audit_setup
        state = _create_optimization_recommendations_state()
        results = await _execute_kv_cache_audit_workflow(setup, state)
        _validate_optimization_recommendations_results(results, state)


def _create_ep_006_state() -> DeepAgentState:
    """Create state for EP-006 example prompt test."""
    return DeepAgentState(
        user_request="I want to audit all uses of KV caching in my system to find optimization opportunities.",
        metadata={'test_type': 'ep_006', 'prompt_id': 'EP-006', 'audit_type': 'kv_cache', 'scope': 'system_wide'}
    )


def _create_usage_analysis_state() -> DeepAgentState:
    """Create state for KV cache usage analysis test."""
    return DeepAgentState(
        user_request="Analyze current KV cache usage patterns and identify inefficiencies.",
        metadata={'test_type': 'usage_analysis', 'cache_type': 'kv', 'analysis_scope': 'patterns'}
    )


def _create_optimization_recommendations_state() -> DeepAgentState:
    """Create state for KV cache optimization recommendations test."""
    return DeepAgentState(
        user_request="Provide specific recommendations for optimizing KV cache performance and utilization.",
        metadata={'test_type': 'optimization_recommendations', 'focus': 'performance_utilization'}
    )


async def _execute_kv_cache_audit_workflow(setup: Dict, state: DeepAgentState) -> List[Dict]:
    """Execute complete KV cache audit workflow with all 5 agents."""
    results = []
    workflow_steps = ['triage', 'data', 'optimization', 'actions', 'reporting']
    for step_name in workflow_steps:
        step_result = await _execute_audit_workflow_step(setup, step_name, state)
        results.append(step_result)
    return results


async def _execute_audit_workflow_step(setup: Dict, step_name: str, state: DeepAgentState) -> Dict:
    """Execute single audit workflow step with real agent."""
    agent = setup['agents'][step_name]
    # Fix WebSocket interface compatibility
    _ensure_websocket_compatibility(setup['websocket'])
    
    agent.websocket_manager = setup['websocket']
    agent.user_id = setup['user_id']
    
    execution_result = await agent.run(state, setup['run_id'], True)
    return _create_audit_execution_result(step_name, agent, state, execution_result)


def _ensure_websocket_compatibility(websocket_manager):
    """Ensure WebSocket manager has compatible interface methods."""
    if hasattr(websocket_manager, 'send_message') and not hasattr(websocket_manager, 'send_to_thread'):
        websocket_manager.send_to_thread = websocket_manager.send_message
    elif hasattr(websocket_manager, 'send_to_thread') and not hasattr(websocket_manager, 'send_message'):
        websocket_manager.send_message = websocket_manager.send_to_thread


def _create_audit_execution_result(step_name: str, agent, state: DeepAgentState, result) -> Dict:
    """Create audit execution result dictionary."""
    return {
        'step': step_name, 'agent_state': agent.state, 'workflow_state': state,
        'execution_result': result, 'state_updated': state is not None
    }


async def _validate_ep_006_results(results: List[Dict], state: DeepAgentState, setup: Dict):
    """Validate EP-006 results with enhanced quality checks."""
    assert len(results) == 5, "All 5 workflow steps must execute"
    _validate_kv_cache_audit_results(results, state)
    await _validate_response_quality_ep_006(results, setup)


def _validate_kv_cache_audit_results(results: List[Dict], state: DeepAgentState):
    """Validate KV cache audit workflow results."""
    _validate_triage_identifies_kv_cache_scope(results[0], state)
    _validate_data_analysis_captures_cache_metrics(results[1], state)
    _validate_optimization_proposes_cache_solutions(results[2], state)
    _validate_actions_provides_cache_implementation(results[3], state)
    _validate_reporting_summarizes_cache_audit(results[4], state)


def _validate_triage_identifies_kv_cache_scope(result: Dict, state: DeepAgentState):
    """Validate triage identifies KV cache audit scope."""
    assert result['agent_state'] == SubAgentLifecycle.COMPLETED
    assert hasattr(state, 'user_request')
    assert 'kv caching' in state.user_request.lower() or 'kv cache' in state.user_request.lower()


def _validate_data_analysis_captures_cache_metrics(result: Dict, state: DeepAgentState):
    """Validate data analysis captures relevant cache metrics."""
    assert result['agent_state'] == SubAgentLifecycle.COMPLETED
    assert result['state_updated']
    assert hasattr(state, 'messages') or hasattr(state, 'analysis_data')


def _validate_optimization_proposes_cache_solutions(result: Dict, state: DeepAgentState):
    """Validate optimization agent proposes cache optimization solutions."""
    assert result['agent_state'] == SubAgentLifecycle.COMPLETED
    assert result['state_updated']
    # Optimization agent may return None but should update state
    assert hasattr(state, 'optimizations_result') or result['execution_result'] is not None


def _validate_actions_provides_cache_implementation(result: Dict, state: DeepAgentState):
    """Validate actions agent provides cache optimization implementation steps."""
    assert result['agent_state'] == SubAgentLifecycle.COMPLETED
    assert result['state_updated']
    # Actions agent should either return result or update state
    assert hasattr(state, 'action_plan_result') or result['execution_result'] is not None


def _validate_reporting_summarizes_cache_audit(result: Dict, state: DeepAgentState):
    """Validate reporting agent summarizes cache audit results."""
    assert result['agent_state'] == SubAgentLifecycle.COMPLETED
    assert result['state_updated']
    assert hasattr(state, 'user_request') or hasattr(state, 'messages')


def _validate_usage_analysis_results(results: List[Dict], state: DeepAgentState):
    """Validate KV cache usage analysis results."""
    assert len(results) > 0, "No results returned from workflow"
    assert any('cache' in str(result).lower() for result in results)
    assert 'usage patterns' in state.user_request.lower()


def _validate_optimization_recommendations_results(results: List[Dict], state: DeepAgentState):
    """Validate KV cache optimization recommendations results."""
    assert len(results) > 0, "No results returned from workflow"
    assert any('optimization' in str(result).lower() for result in results)
    assert 'recommendations' in state.user_request.lower()


async def _validate_response_quality_ep_006(results: List[Dict], setup: Dict):
    """Validate response quality for EP-006 using quality gate service."""
    quality_service = QualityGateService()
    final_result = results[-1]  # Reporting result
    
    if hasattr(final_result.get('workflow_state', {}), 'final_response'):
        response_text = str(final_result['workflow_state'].final_response)
        is_valid, score, feedback = await quality_service.validate_content(
            content=response_text, content_type=ContentType.AUDIT_REPORT, quality_level=QualityLevel.MEDIUM
        )
        assert is_valid, f"EP-006 response quality validation failed: {feedback}"
        assert score >= 70, f"EP-006 quality score too low: {score}"


@pytest.mark.real_llm
class TestKVCacheAuditEdgeCases:
    """Test edge cases in KV cache audit workflows."""
    
    async def test_empty_cache_system_audit(self, kv_cache_audit_setup):
        """Test audit behavior with systems that have no KV cache usage."""
        setup = kv_cache_audit_setup
        state = _create_empty_cache_state()
        results = await _execute_kv_cache_audit_workflow(setup, state)
        _validate_empty_cache_handling(results, state)
    
    async def test_high_cache_utilization_audit(self, kv_cache_audit_setup):
        """Test audit behavior with high cache utilization systems."""
        setup = kv_cache_audit_setup
        state = _create_high_utilization_state()
        results = await _execute_kv_cache_audit_workflow(setup, state)
        _validate_high_utilization_analysis(results, state)


def _create_empty_cache_state() -> DeepAgentState:
    """Create state for empty cache system audit."""
    return DeepAgentState(
        user_request="Audit KV cache usage in a system with minimal cache implementation.",
        metadata={'test_type': 'empty_cache', 'cache_usage': 'minimal'}
    )


def _create_high_utilization_state() -> DeepAgentState:
    """Create state for high utilization cache audit."""
    return DeepAgentState(
        user_request="Audit KV cache usage in a system with very high cache utilization rates.",
        metadata={'test_type': 'high_utilization', 'cache_usage': 'high'}
    )


def _validate_empty_cache_handling(results: List[Dict], state: DeepAgentState):
    """Validate handling of systems with minimal cache usage."""
    assert len(results) >= 1, "At least triage should execute"
    assert any(r['agent_state'] == SubAgentLifecycle.COMPLETED for r in results)
    assert 'minimal' in state.metadata.get('cache_usage', '')


def _validate_high_utilization_analysis(results: List[Dict], state: DeepAgentState):
    """Validate analysis of high cache utilization systems."""
    assert len(results) >= 3, "Core workflow should execute"
    assert any(r['agent_state'] == SubAgentLifecycle.COMPLETED for r in results[:3])
    assert 'high' in state.metadata.get('cache_usage', '')


@pytest.mark.real_llm
class TestKVCacheWorkflowIntegrity:
    """Test overall workflow integrity for KV cache audit."""
    
    async def test_complete_audit_workflow_validation(self, kv_cache_audit_setup):
        """Test complete audit workflow validation."""
        setup = kv_cache_audit_setup
        state = _create_ep_006_state()
        results = await _execute_kv_cache_audit_workflow(setup, state)
        _validate_complete_audit_workflow(results, state)


def _validate_complete_audit_workflow(results: List[Dict], state: DeepAgentState):
    """Validate complete audit workflow execution."""
    assert len(results) == 5, "All 5 workflow steps should execute"
    assert all(r['workflow_state'] is state for r in results)
    assert state.user_request is not None
    assert hasattr(state, 'metadata')
    assert any('kv' in str(result).lower() for result in results)