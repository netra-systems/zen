<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="122" failures="142" skipped="0" tests="879" time="19.210" timestamp="2025-09-08T18:31:41.513279-07:00" hostname="Shivanginis-MacBook-Pro.local"><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_user_registration_business_rules" time="0.083" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_subscription_tier_access_control" time="0.000" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_login_attempt_business_logic" time="0.000" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_account_lifecycle_management" time="0.000" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_business_rule_compliance_validation" time="0.000" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthCrossServiceValidation" name="test_cross_service_token_validation_business_logic" time="0.001" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthSecurityPolicyValidation" name="test_password_policy_business_rules" time="0.002" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthSecurityPolicyValidation" name="test_session_security_policy" time="0.001" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthIntegrationBusinessLogic" name="test_oauth_integration_business_rules" time="0.000" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthAuditBusinessLogic" name="test_audit_logging_business_rules" time="0.001" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthAuditBusinessLogic" name="test_compliance_reporting_business_logic" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_environment" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_jwt_secret" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_jwt_algorithm" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_jwt_access_expiry_minutes" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_jwt_refresh_expiry_days" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_jwt_service_expiry_minutes" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_service_secret" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_service_id" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_database_url" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_redis_url" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_cors_origins" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_api_base_url" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_get_frontend_url" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_is_development" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_is_production" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigBasics" name="test_is_test" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigGoogleOAuth" name="test_get_google_client_id" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigGoogleOAuth" name="test_get_google_client_secret" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigGoogleOAuth" name="test_google_oauth_enabled" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigGoogleOAuth" name="test_get_google_oauth_redirect_uri" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigGoogleOAuth" name="test_get_google_oauth_scopes" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_host" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_port" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_name" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_user" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_password" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_pool_size" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_max_overflow" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDatabase" name="test_use_sqlite_in_test" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_host" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_port" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_db" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_password" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigRedis" name="test_redis_enabled" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigRedis" name="test_redis_disabled_in_test" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_ttl" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_bcrypt_rounds" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_password_min_length" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_max_login_attempts" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_account_lockout_duration" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_session_timeout" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_require_email_verification" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_token_blacklist_ttl" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_rate_limit_requests" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigSecurity" name="test_get_allowed_origins" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDefaults" name="test_default_values_when_env_empty" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDefaults" name="test_type_conversion" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDefaults" name="test_boolean_conversion" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDefaults" name="test_list_conversion" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigDefaults" name="test_environment_specific_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigValidation" name="test_validate_jwt_secret_length" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigValidation" name="test_validate_service_secret_length" time="0.000" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigValidation" name="test_validate_database_url_format" time="0.001" /><testcase classname="tests.unit.test_auth_config_comprehensive.TestAuthConfigValidation" name="test_validate_redis_url_format" time="0.001" /><testcase classname="tests.unit.test_auth_endpoint_response_consistency.TestAuthEndpointResponseFormats" name="test_login_endpoint_response_format" time="0.023" /><testcase classname="tests.unit.test_auth_endpoint_validation_security.TestAuthEndpointInputValidation" name="test_login_endpoint_validates_required_fields" time="0.014" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestAuthEnvironmentInitialization" name="test_initialization_with_minimal_config" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestAuthEnvironmentInitialization" name="test_initialization_validates_config" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestAuthEnvironmentInitialization" name="test_validation_logs_missing_required_vars" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_secret_key_uses_unified_manager" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_secret_key_falls_back_on_unified_failure" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_secret_key_environment_specific" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_secret_key_generates_dev_fallback" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_secret_key_generates_test_fallback" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_secret_key_fails_for_staging_without_config" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_secret_key_fails_for_production_without_config" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_algorithm_environment_specific" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_algorithm_respects_explicit_config" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_expiration_minutes_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_expiration_minutes_respects_config" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_jwt_expiration_minutes_handles_invalid_config" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTConfiguration" name="test_get_refresh_token_expiration_days_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecretKeyConfiguration" name="test_get_secret_key_with_explicit_config" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecretKeyConfiguration" name="test_get_secret_key_generates_dev_fallback" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecretKeyConfiguration" name="test_get_secret_key_generates_test_fallback" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecretKeyConfiguration" name="test_get_secret_key_fails_for_staging_without_config" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecretKeyConfiguration" name="test_get_bcrypt_rounds_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_database_url_uses_sqlite_for_test" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_database_url_uses_builder_for_non_test" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_database_url_fails_gracefully_when_builder_fails" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_postgres_host_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_postgres_port_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_postgres_port_handles_invalid_config" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_postgres_user_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_postgres_password_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestDatabaseConfiguration" name="test_get_postgres_db_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRedisConfiguration" name="test_get_redis_url_environment_defaults" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_auth_environment_comprehensive.py:474: in test_get_redis_url_environment_defaults
    with pytest.raises(expected):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRedisConfiguration" name="test_get_redis_host_environment_defaults" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_auth_environment_comprehensive.py:493: in test_get_redis_host_environment_defaults
    with pytest.raises(expected):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRedisConfiguration" name="test_get_redis_port_environment_defaults" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_auth_environment_comprehensive.py:512: in test_get_redis_port_environment_defaults
    with pytest.raises(expected):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRedisConfiguration" name="test_get_redis_port_handles_invalid_config" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_auth_environment_comprehensive.py:521: in test_get_redis_port_handles_invalid_config
    with pytest.raises(ValueError, match="REDIS_PORT must be a valid integer"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRedisConfiguration" name="test_get_session_ttl_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestOAuthConfiguration" name="test_get_oauth_google_client_id_tries_environment_specific_keys" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestOAuthConfiguration" name="test_get_oauth_google_client_id_falls_back_to_generic" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestOAuthConfiguration" name="test_get_oauth_google_client_id_returns_empty_for_missing_config" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestOAuthConfiguration" name="test_get_oauth_google_client_secret_environment_specific_behavior" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestOAuthConfiguration" name="test_get_oauth_github_client_id_simple_getter" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestOAuthConfiguration" name="test_get_oauth_github_client_secret_simple_getter" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestServiceURLConfiguration" name="test_get_auth_service_port_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestServiceURLConfiguration" name="test_get_auth_service_host_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestServiceURLConfiguration" name="test_get_backend_url_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestServiceURLConfiguration" name="test_get_frontend_url_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestServiceURLConfiguration" name="test_get_auth_service_url_constructs_from_host_and_port" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestServiceURLConfiguration" name="test_get_auth_service_url_production_default" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestServiceURLConfiguration" name="test_get_oauth_redirect_uri_deprecated_warning" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentDetection" name="test_get_environment_returns_lowercase" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentDetection" name="test_get_environment_defaults_to_development" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentDetection" name="test_is_production_detection" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentDetection" name="test_is_staging_detection" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentDetection" name="test_is_development_detection" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentDetection" name="test_is_testing_detection" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestCORSConfiguration" name="test_get_cors_origins_from_config" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestCORSConfiguration" name="test_get_cors_origins_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestLoggingConfiguration" name="test_get_log_level_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestLoggingConfiguration" name="test_get_log_level_respects_config" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestLoggingConfiguration" name="test_should_enable_debug_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestLoggingConfiguration" name="test_should_enable_debug_respects_config" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRateLimitingConfiguration" name="test_get_login_rate_limit_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRateLimitingConfiguration" name="test_get_login_rate_limit_period_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRateLimitingConfiguration" name="test_get_max_failed_login_attempts_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRateLimitingConfiguration" name="test_get_account_lockout_duration_default" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestRateLimitingConfiguration" name="test_get_account_lockout_duration_handles_invalid" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestPasswordPolicyConfiguration" name="test_get_min_password_length_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestPasswordPolicyConfiguration" name="test_require_password_complexity_environment_defaults" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEmailConfiguration" name="test_get_smtp_host_simple_getter" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEmailConfiguration" name="test_get_smtp_port_handles_conversion" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEmailConfiguration" name="test_get_smtp_from_email_default" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEmailConfiguration" name="test_is_smtp_enabled_checks_required_fields" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestGenericAccessors" name="test_get_method" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestGenericAccessors" name="test_set_method" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestGenericAccessors" name="test_exists_method" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestGenericAccessors" name="test_get_all_method" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestValidationMethod" name="test_validate_success_with_all_required" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestValidationMethod" name="test_validate_fails_with_missing_jwt_secret" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestValidationMethod" name="test_validate_warns_about_insecure_defaults_in_production" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestValidationMethod" name="test_validate_warns_about_long_jwt_expiration" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestValidationMethod" name="test_validate_warns_about_weak_password_policy" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSingletonBehavior" name="test_get_auth_env_returns_same_instance" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSingletonBehavior" name="test_convenience_functions_use_singleton" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_handles_environment_variable_not_found_gracefully" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_handles_invalid_integer_configurations" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_oauth_redirect_uri_with_different_providers" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_database_url_builder_with_missing_dependencies" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_unified_jwt_secret_with_import_error" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_cors_origins_with_whitespace_in_config" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_environment_detection_case_insensitive" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_port_configuration_with_explicit_values" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_url_explicit_overrides" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_auth_service_url_localhost_conversion" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_integer_configuration_explicit_values" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_validate_method_comprehensive_coverage" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_database_url_builder_error_scenarios" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestErrorHandlingAndEdgeCases" name="test_all_explicit_configuration_getters" time="0.001"><failure message="AssertionError: assert 'redis://localhost:6380/2' == 'redis://custom:6379/0'&#10;  &#10;  - redis://custom:6379/0&#10;  + redis://localhost:6380/2">tests/unit/test_auth_environment_comprehensive.py:1428: in test_all_explicit_configuration_getters
    assert result == test_value
E   AssertionError: assert 'redis://localhost:6380/2' == 'redis://custom:6379/0'
E     
E     - redis://custom:6379/0
E     + redis://localhost:6380/2</failure></testcase><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTSecretFallbackScenarios" name="test_jwt_secret_tries_all_fallback_keys" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTSecretFallbackScenarios" name="test_jwt_secret_fails_for_unknown_environment" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestJWTSecretFallbackScenarios" name="test_jwt_secret_strips_whitespace" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentSpecificBehaviorEdgeCases" name="test_environment_fallback_patterns" time="0.002" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentSpecificBehaviorEdgeCases" name="test_testing_environment_detection_with_env_var" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentSpecificBehaviorEdgeCases" name="test_password_complexity_boolean_conversion" time="0.001"><failure message="assert True is False">tests/unit/test_auth_environment_comprehensive.py:1545: in test_password_complexity_boolean_conversion
    assert result is False
E   assert True is False</failure></testcase><testcase classname="tests.unit.test_auth_environment_comprehensive.TestEnvironmentSpecificBehaviorEdgeCases" name="test_debug_enable_boolean_conversion" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecurityValidationComprehensive" name="test_validate_method_environment_reporting" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecurityValidationComprehensive" name="test_validate_catches_all_security_issues" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestConfigurationOverridePatterns" name="test_oauth_google_tries_all_key_patterns" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestConfigurationOverridePatterns" name="test_cors_origins_parsing_edge_cases" time="0.000" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecretGenerationAndFallbacks" name="test_secret_key_generation_consistency" time="0.001" /><testcase classname="tests.unit.test_auth_environment_comprehensive.TestSecretGenerationAndFallbacks" name="test_jwt_secret_generation_environment_specific" time="0.002" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentStartupPerformance" name="test_auth_environment_initialization_performance" time="0.002" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentStartupPerformance" name="test_configuration_access_performance" time="0.001" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentStartupPerformance" name="test_concurrent_configuration_access_performance" time="0.013" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentMemoryPerformance" name="test_memory_usage_optimization" time="0.158"><failure message="AssertionError: Poor cleanup efficiency: 0.24&#10;assert 0.2375 &gt; 0.8">tests/unit/test_auth_environment_performance_comprehensive.py:249: in test_memory_usage_optimization
    assert cleanup_efficiency &gt; 0.8, \
E   AssertionError: Poor cleanup efficiency: 0.24
E   assert 0.2375 &gt; 0.8</failure></testcase><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentMemoryPerformance" name="test_singleton_memory_efficiency" time="0.096" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentMemoryPerformance" name="test_configuration_caching_efficiency" time="0.002" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentValidationPerformance" name="test_configuration_validation_performance" time="0.003" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentValidationPerformance" name="test_repeated_validation_performance" time="0.003" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentScalabilityPerformance" name="test_multiple_environment_creation_performance" time="0.003" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentScalabilityPerformance" name="test_configuration_method_performance_under_load" time="0.020" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentResourceLeakPrevention" name="test_long_running_configuration_access_stability" time="0.020" /><testcase classname="tests.unit.test_auth_environment_performance_comprehensive.TestAuthEnvironmentResourceLeakPrevention" name="test_memory_stability_under_continuous_load" time="0.582"><failure message="AssertionError: Excessive memory growth: 2400 objects over 1000 iterations&#10;assert 2400 &lt; 500">tests/unit/test_auth_environment_performance_comprehensive.py:604: in test_memory_stability_under_continuous_load
    assert memory_growth &lt; 500, \
E   AssertionError: Excessive memory growth: 2400 objects over 1000 iterations
E   assert 2400 &lt; 500</failure></testcase><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_create_user" time="0.043" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_authenticate_user" time="0.069" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_authenticate_with_wrong_password_fails" time="0.066" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_create_access_token" time="0.035" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_create_refresh_token" time="0.035" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_validate_token" time="0.035" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_refresh_tokens" time="0.035" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_blacklist_token" time="0.035" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_hash_and_verify_password" time="0.085" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_register_user" time="0.037" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_duplicate_registration_fails" time="0.068" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_invalidate_user_sessions" time="0.035" /><testcase classname="tests.unit.test_auth_service_basic.TestAuthServiceCore" name="test_create_service_token" time="0.001" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_service_authentication_business_rules" time="0.002" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_user_permission_business_logic" time="0.001" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_user_lifecycle_business_events" time="0.005" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_oauth_user_creation_business_flow" time="0.001" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_circuit_breaker_business_protection" time="0.001" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_retry_logic_business_resilience" time="4.011" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_token_refresh_business_continuity" time="0.010" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_complete_business_authentication_flow" time="0.088"><failure message="assert False is True&#10; +  where False = TokenResponse(valid=False, user_id=None, email=None, permissions=[], expires_at=None).valid">tests/unit/test_auth_service_business_logic.py:317: in test_complete_business_authentication_flow
    assert service_validation.valid is True
E   assert False is True
E    +  where False = TokenResponse(valid=False, user_id=None, email=None, permissions=[], expires_at=None).valid</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_register_user" time="0.036" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_register_duplicate_email_fails" time="0.068" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_login_with_valid_credentials" time="0.041"><failure message="assert None is not None">tests/unit/test_auth_service_comprehensive.py:51: in test_login_with_valid_credentials
    assert auth_token is not None
E   assert None is not None</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_login_with_invalid_password_fails" time="0.037" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_login_with_nonexistent_user_fails" time="0.002" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_validate_token" time="0.036"><failure message="AttributeError: 'NoneType' object has no attribute 'access_token'">tests/unit/test_auth_service_comprehensive.py:74: in test_validate_token
    user = await self.service.validate_token(auth_token.access_token)
                                             ^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'access_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_validate_invalid_token_returns_none" time="0.002"><failure message="assert TokenResponse(valid=False, user_id=None, email=None, permissions=[], expires_at=None) is None">tests/unit/test_auth_service_comprehensive.py:83: in test_validate_invalid_token_returns_none
    assert user is None
E   assert TokenResponse(valid=False, user_id=None, email=None, permissions=[], expires_at=None) is None</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_refresh_tokens" time="0.036"><failure message="AttributeError: 'NoneType' object has no attribute 'refresh_token'">tests/unit/test_auth_service_comprehensive.py:90: in test_refresh_tokens
    new_auth_token = await self.service.refresh_tokens(auth_token.refresh_token)
                                                       ^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'refresh_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_refresh_with_invalid_token_fails" time="0.002" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_logout" time="0.036"><failure message="AttributeError: 'NoneType' object has no attribute 'access_token'">tests/unit/test_auth_service_comprehensive.py:106: in test_logout
    result = await self.service.logout(auth_token.access_token)
                                       ^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'access_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_logout_with_invalid_token" time="0.002" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_get_user_by_id" time="0.036"><failure message="AttributeError: 'dict' object has no attribute 'id'">tests/unit/test_auth_service_comprehensive.py:122: in test_get_user_by_id
    user = await self.service.get_user_by_id(registered_user.id)
                                             ^^^^^^^^^^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'id'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_get_user_by_nonexistent_id_returns_none" time="0.005" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_get_user_by_email" time="0.039"><failure message="AttributeError: 'dict' object has no attribute 'email'">tests/unit/test_auth_service_comprehensive.py:139: in test_get_user_by_email
    assert user.email == self.email
           ^^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'email'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceBasics" name="test_get_user_by_nonexistent_email_returns_none" time="0.004" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceSessions" name="test_create_session" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'get_user_sessions'">tests/unit/test_auth_service_comprehensive.py:166: in test_create_session
    sessions = await self.service.get_user_sessions(user.id)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'get_user_sessions'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceSessions" name="test_validate_session" time="0.037"><failure message="AttributeError: 'NoneType' object has no attribute 'access_token'">tests/unit/test_auth_service_comprehensive.py:177: in test_validate_session
    payload = jwt_handler.validate_token(auth_token.access_token, "access")
                                         ^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'access_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceSessions" name="test_invalidate_session_on_logout" time="0.036"><failure message="AttributeError: 'NoneType' object has no attribute 'access_token'">tests/unit/test_auth_service_comprehensive.py:188: in test_invalidate_session_on_logout
    await self.service.logout(auth_token.access_token)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'access_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceSessions" name="test_get_user_sessions" time="0.037"><failure message="AttributeError: 'AuthService' object has no attribute 'get_user_sessions'">tests/unit/test_auth_service_comprehensive.py:201: in test_get_user_sessions
    sessions = await self.service.get_user_sessions(user.id)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'get_user_sessions'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceSessions" name="test_cleanup_expired_sessions" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'cleanup_expired_sessions'">tests/unit/test_auth_service_comprehensive.py:210: in test_cleanup_expired_sessions
    await self.service.cleanup_expired_sessions()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'cleanup_expired_sessions'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePasswordManagement" name="test_update_password" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_password'. Did you mean: 'validate_password'?">tests/unit/test_auth_service_comprehensive.py:231: in test_update_password
    result = await self.service.update_password(user.id, self.password, new_password)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_password'. Did you mean: 'validate_password'?</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePasswordManagement" name="test_update_password_with_wrong_old_password_fails" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_password'. Did you mean: 'validate_password'?">tests/unit/test_auth_service_comprehensive.py:241: in test_update_password_with_wrong_old_password_fails
    result = await self.service.update_password(user.id, "WrongOldPassword!", "NewPassword456!")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_password'. Did you mean: 'validate_password'?</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePasswordManagement" name="test_password_hash_verification" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'repository'">tests/unit/test_auth_service_comprehensive.py:248: in test_password_hash_verification
    db_user = await self.service.repository.get_user_by_email(self.email)
                    ^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'repository'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePasswordManagement" name="test_password_hash_differs_from_plaintext" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'repository'">tests/unit/test_auth_service_comprehensive.py:257: in test_password_hash_differs_from_plaintext
    db_user = await self.service.repository.get_user_by_email(self.email)
                    ^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'repository'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePasswordManagement" name="test_weak_password_validation" time="0.001" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePasswordManagement" name="test_password_requirements" time="0.001" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_update_user_profile" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_profile'">tests/unit/test_auth_service_comprehensive.py:301: in test_update_user_profile
    updated_user = await self.service.update_user_profile(
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_profile'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_update_user_email" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_email'">tests/unit/test_auth_service_comprehensive.py:315: in test_update_user_email
    updated_user = await self.service.update_user_email(user.id, new_email)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_email'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_update_to_duplicate_email_fails" time="0.074"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_email'">tests/unit/test_auth_service_comprehensive.py:326: in test_update_to_duplicate_email_fails
    await self.service.update_user_email(user1.id, email2)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_email'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_delete_user" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'delete_user'. Did you mean: 'create_user'?">tests/unit/test_auth_service_comprehensive.py:332: in test_delete_user
    result = await self.service.delete_user(user.id)
                   ^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'delete_user'. Did you mean: 'create_user'?</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_delete_nonexistent_user" time="0.001"><failure message="AttributeError: 'AuthService' object has no attribute 'delete_user'. Did you mean: 'create_user'?">tests/unit/test_auth_service_comprehensive.py:341: in test_delete_nonexistent_user
    result = await self.service.delete_user(str(uuid.uuid4()))
                   ^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'delete_user'. Did you mean: 'create_user'?</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_activate_user" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'deactivate_user'">tests/unit/test_auth_service_comprehensive.py:349: in test_activate_user
    await self.service.deactivate_user(user.id)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'deactivate_user'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_deactivate_user" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'deactivate_user'">tests/unit/test_auth_service_comprehensive.py:360: in test_deactivate_user
    result = await self.service.deactivate_user(user.id)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'deactivate_user'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceUserManagement" name="test_login_with_deactivated_user_fails" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'deactivate_user'">tests/unit/test_auth_service_comprehensive.py:369: in test_login_with_deactivated_user_fails
    await self.service.deactivate_user(user.id)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'deactivate_user'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePermissions" name="test_default_user_permissions" time="0.036"><failure message="AttributeError: 'dict' object has no attribute 'role'">tests/unit/test_auth_service_comprehensive.py:389: in test_default_user_permissions
    assert user.role == "user"
           ^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'role'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePermissions" name="test_update_user_role" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_role'">tests/unit/test_auth_service_comprehensive.py:396: in test_update_user_role
    updated_user = await self.service.update_user_role(user.id, "admin")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_role'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePermissions" name="test_update_user_permissions" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_permissions'">tests/unit/test_auth_service_comprehensive.py:404: in test_update_user_permissions
    updated_user = await self.service.update_user_permissions(user.id, new_permissions)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_permissions'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePermissions" name="test_add_user_permission" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'add_user_permission'">tests/unit/test_auth_service_comprehensive.py:411: in test_add_user_permission
    updated_user = await self.service.add_user_permission(user.id, "write")
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'add_user_permission'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePermissions" name="test_remove_user_permission" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_permissions'">tests/unit/test_auth_service_comprehensive.py:418: in test_remove_user_permission
    await self.service.update_user_permissions(user.id, ["read", "write", "delete"])
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_permissions'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePermissions" name="test_check_user_permission" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_permissions'">tests/unit/test_auth_service_comprehensive.py:428: in test_check_user_permission
    await self.service.update_user_permissions(user.id, ["read", "write"])
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_permissions'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServicePermissions" name="test_token_includes_permissions" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_user_permissions'">tests/unit/test_auth_service_comprehensive.py:438: in test_token_includes_permissions
    await self.service.update_user_permissions(user.id, ["read", "write"])
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_user_permissions'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceEmailVerification" name="test_user_created_unverified" time="0.036"><failure message="AttributeError: 'dict' object has no attribute 'email_verified'">tests/unit/test_auth_service_comprehensive.py:463: in test_user_created_unverified
    assert user.email_verified is False
           ^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'dict' object has no attribute 'email_verified'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceEmailVerification" name="test_generate_verification_token" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'generate_verification_token'">tests/unit/test_auth_service_comprehensive.py:469: in test_generate_verification_token
    token = await self.service.generate_verification_token(user.id)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'generate_verification_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceEmailVerification" name="test_verify_email_with_valid_token" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'generate_verification_token'">tests/unit/test_auth_service_comprehensive.py:477: in test_verify_email_with_valid_token
    token = await self.service.generate_verification_token(user.id)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'generate_verification_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceEmailVerification" name="test_verify_email_with_invalid_token_fails" time="0.001"><failure message="AttributeError: 'AuthService' object has no attribute 'verify_email'">tests/unit/test_auth_service_comprehensive.py:486: in test_verify_email_with_invalid_token_fails
    result = await self.service.verify_email("invalid_verification_token")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'verify_email'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceEmailVerification" name="test_resend_verification_email" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'resend_verification_email'">tests/unit/test_auth_service_comprehensive.py:493: in test_resend_verification_email
    result = await self.service.resend_verification_email(user.email)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'resend_verification_email'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceEmailVerification" name="test_login_with_unverified_email_warning" time="0.037"><failure message="assert None is not None">tests/unit/test_auth_service_comprehensive.py:502: in test_login_with_unverified_email_warning
    assert auth_token is not None
E   assert None is not None</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceRateLimiting" name="test_login_attempts_tracking" time="0.039"><failure message="AttributeError: 'AuthService' object has no attribute 'get_failed_login_attempts'">tests/unit/test_auth_service_comprehensive.py:527: in test_login_attempts_tracking
    attempts = await self.service.get_failed_login_attempts(self.email)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'get_failed_login_attempts'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceRateLimiting" name="test_account_lockout_after_max_attempts" time="0.040" /><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceRateLimiting" name="test_reset_failed_attempts_on_success" time="0.037"><failure message="AttributeError: 'AuthService' object has no attribute 'get_failed_login_attempts'">tests/unit/test_auth_service_comprehensive.py:553: in test_reset_failed_attempts_on_success
    attempts = await self.service.get_failed_login_attempts(self.email)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'get_failed_login_attempts'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceRateLimiting" name="test_unlock_account" time="0.037"><failure message="AttributeError: 'AuthService' object has no attribute 'lock_account'">tests/unit/test_auth_service_comprehensive.py:561: in test_unlock_account
    await self.service.lock_account(user.id)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'lock_account'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceAuditLogging" name="test_login_audit_log" time="0.037"><failure message="AttributeError: 'AuthService' object has no attribute 'get_audit_logs'. Did you mean: '_audit_log'?">tests/unit/test_auth_service_comprehensive.py:586: in test_login_audit_log
    logs = await self.service.get_audit_logs(user.id)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'get_audit_logs'. Did you mean: '_audit_log'?</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceAuditLogging" name="test_logout_audit_log" time="0.036"><failure message="AttributeError: 'NoneType' object has no attribute 'access_token'">tests/unit/test_auth_service_comprehensive.py:594: in test_logout_audit_log
    await self.service.logout(auth_token.access_token)
                              ^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'access_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceAuditLogging" name="test_password_change_audit_log" time="0.036"><failure message="AttributeError: 'AuthService' object has no attribute 'update_password'. Did you mean: 'validate_password'?">tests/unit/test_auth_service_comprehensive.py:602: in test_password_change_audit_log
    await self.service.update_password(user.id, self.password, "NewPassword123!")
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'update_password'. Did you mean: 'validate_password'?</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceAuditLogging" name="test_failed_login_audit_log" time="0.037"><failure message="AttributeError: 'AuthService' object has no attribute 'get_audit_logs_by_email'">tests/unit/test_auth_service_comprehensive.py:611: in test_failed_login_audit_log
    logs = await self.service.get_audit_logs_by_email(self.email)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'get_audit_logs_by_email'</failure></testcase><testcase classname="tests.unit.test_auth_service_comprehensive.TestAuthServiceAuditLogging" name="test_get_recent_audit_logs" time="0.037"><failure message="AttributeError: 'AuthService' object has no attribute 'get_recent_audit_logs'">tests/unit/test_auth_service_comprehensive.py:619: in test_get_recent_audit_logs
    recent_logs = await self.service.get_recent_audit_logs(user.id, hours=1)
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'AuthService' object has no attribute 'get_recent_audit_logs'</failure></testcase><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_auth_config_provides_critical_business_configuration" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_auth_config_adapts_to_environment_specific_business_needs" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_oauth_configuration_enables_user_onboarding_business_value" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_security_configuration_protects_business_assets" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_session_configuration_balances_security_and_usability" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_database_configuration_supports_business_scalability" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_redis_configuration_enables_session_management_business_value" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_cors_configuration_enables_frontend_integration_business_value" time="0.001" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_configuration_logging_masks_secrets_for_security" time="0.002" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_unified_auth_interface_provides_business_authentication_capabilities" time="0.002" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_auth_interface_token_creation_supports_business_workflows" time="0.002" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_token_validation_protects_business_operations" time="0.002" /><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceInitialization" name="test_auth_service_init_creates_real_instances" time="0.003"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c53c0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c53c0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceInitialization" name="test_database_initialization_handles_missing_db_gracefully" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x10f77c6c0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x10f77c6c0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceInitialization" name="test_jwt_handler_initialization_with_real_secret" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110395560&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110395560&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserAuthentication" name="test_authenticate_user_with_valid_credentials_succeeds" time="0.069"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110584ba0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110584ba0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserAuthentication" name="test_authenticate_user_with_invalid_password_fails_hard" time="0.067"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d6b50&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d6b50&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserAuthentication" name="test_authenticate_user_with_nonexistent_email_fails_hard" time="0.005"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103a4fb0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103a4fb0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserAuthentication" name="test_authenticate_user_with_empty_email_fails_hard" time="0.006"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103975e0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103975e0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserAuthentication" name="test_authenticate_user_with_empty_password_fails_hard" time="0.068"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103258a0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103258a0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserAuthentication" name="test_authenticate_user_with_none_values_fails_hard" time="0.009"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1105845f0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1105845f0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserAuthentication" name="test_authenticate_user_dev_fallback_works" time="0.005"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c4790&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c4790&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserCreation" name="test_create_user_with_valid_data_succeeds" time="0.036"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110399150&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110399150&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserCreation" name="test_create_user_with_duplicate_email_fails_hard" time="0.039"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110256740&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110256740&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserCreation" name="test_create_user_with_invalid_email_formats_fails_hard" time="0.002"><failure message="TypeError: expected string or bytes-like object, got 'NoneType'">tests/unit/test_auth_service_core_comprehensive.py:256: in test_create_user_with_invalid_email_formats_fails_hard
    user_id = await self.service.create_user(
auth_core/services/auth_service.py:179: in create_user
    if not re.match(email_pattern, email):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/re/__init__.py:167: in match
    return _compile(pattern, flags).match(string)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: expected string or bytes-like object, got 'NoneType'</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserCreation" name="test_create_user_with_invalid_email_formats_fails_hard" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x10f77cc70&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x10f77cc70&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserCreation" name="test_create_user_with_weak_passwords_succeeds_but_validates" time="0.102"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1104718a0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1104718a0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceUserCreation" name="test_create_user_without_database_falls_back_to_memory" time="0.030"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bd7d0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bd7d0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordSecurity" name="test_hash_password_produces_different_hashes" time="0.057"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103be810&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103be810&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordSecurity" name="test_verify_password_with_correct_password_succeeds" time="0.058"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bd560&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bd560&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordSecurity" name="test_verify_password_with_wrong_password_fails_hard" time="0.058"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bde50&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bde50&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordSecurity" name="test_verify_password_with_malformed_hash_fails_hard" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110586260&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110586260&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordSecurity" name="test_password_validation_enforces_security_rules" time="0.001"><failure message="AssertionError: Good password should pass: Password must contain at least one special character&#10;assert False is True">tests/unit/test_auth_service_core_comprehensive.py:365: in test_password_validation_enforces_security_rules
    assert is_valid is True, f"{description}: {message}"
E   AssertionError: Good password should pass: Password must contain at least one special character
E   assert False is True</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordSecurity" name="test_password_validation_enforces_security_rules" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c7510&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c7510&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceTokenOperations" name="test_create_access_token_generates_valid_jwt" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110470e10&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110470e10&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceTokenOperations" name="test_create_refresh_token_generates_valid_jwt" time="0.002"><failure message="assert None is not None">tests/unit/test_auth_service_core_comprehensive.py:410: in test_create_refresh_token_generates_valid_jwt
    assert payload is not None
E   assert None is not None</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceTokenOperations" name="test_create_refresh_token_generates_valid_jwt" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110396190&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110396190&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceTokenOperations" name="test_create_service_token_generates_valid_jwt" time="0.002"><failure message="assert None is not None">tests/unit/test_auth_service_core_comprehensive.py:428: in test_create_service_token_generates_valid_jwt
    assert payload is not None
E   assert None is not None</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceTokenOperations" name="test_create_service_token_generates_valid_jwt" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x11039a0c0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x11039a0c0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceTokenOperations" name="test_blacklist_token_prevents_reuse" time="0.003"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d6e90&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d6e90&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLoginFlow" name="test_login_complete_flow_with_valid_credentials" time="0.036"><failure message="TypeError: AuthService.login() missing 1 required positional argument: 'password'">tests/unit/test_auth_service_core_comprehensive.py:477: in test_login_complete_flow_with_valid_credentials
    response = await self.service.login(login_request)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthService.login() missing 1 required positional argument: 'password'</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLoginFlow" name="test_login_complete_flow_with_valid_credentials" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c5220&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c5220&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLoginFlow" name="test_login_with_invalid_credentials_returns_none" time="0.001"><failure message="TypeError: AuthService.login() missing 1 required positional argument: 'password'">tests/unit/test_auth_service_core_comprehensive.py:497: in test_login_with_invalid_credentials_returns_none
    response = await self.service.login(login_request)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthService.login() missing 1 required positional argument: 'password'</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLoginFlow" name="test_login_with_invalid_credentials_returns_none" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103275e0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103275e0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLoginFlow" name="test_login_with_malformed_request_fails_hard" time="0.001"><failure message="TypeError: AuthService.login() missing 1 required positional argument: 'password'">tests/unit/test_auth_service_core_comprehensive.py:506: in test_login_with_malformed_request_fails_hard
    response = await self.service.login(None)
                     ^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthService.login() missing 1 required positional argument: 'password'</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLoginFlow" name="test_login_with_malformed_request_fails_hard" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d7370&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d7370&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLogoutFlow" name="test_logout_with_valid_token_succeeds" time="0.036"><failure message="TypeError: AuthService.login() missing 1 required positional argument: 'password'">tests/unit/test_auth_service_core_comprehensive.py:536: in test_logout_with_valid_token_succeeds
    login_response = await self.service.login(login_request)
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthService.login() missing 1 required positional argument: 'password'</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLogoutFlow" name="test_logout_with_valid_token_succeeds" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d64d0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d64d0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLogoutFlow" name="test_logout_with_invalid_token_fails_gracefully" time="0.001"><failure message="TypeError: AuthService.logout() got an unexpected keyword argument 'refresh_token'">tests/unit/test_auth_service_core_comprehensive.py:557: in test_logout_with_invalid_token_fails_gracefully
    success = await self.service.logout(
E   TypeError: AuthService.logout() got an unexpected keyword argument 'refresh_token'</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceLogoutFlow" name="test_logout_with_invalid_token_fails_gracefully" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x11039acf0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x11039acf0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceSessionManagement" name="test_create_session_generates_valid_session" time="0.001"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c6b50&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c6b50&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceSessionManagement" name="test_delete_session_removes_session" time="0.001"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bf440&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bf440&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceSessionManagement" name="test_delete_nonexistent_session_fails_gracefully" time="0.001"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bcba0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bcba0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceSessionManagement" name="test_invalidate_user_sessions_removes_all_user_sessions" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c4ee0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c4ee0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceCircuitBreaker" name="test_circuit_breaker_initial_state_is_closed" time="0.001"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110472f60&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110472f60&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceCircuitBreaker" name="test_record_failure_increases_failure_count" time="0.001"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110471560&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110471560&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceCircuitBreaker" name="test_record_success_resets_failure_count" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110470ee0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110470ee0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceCircuitBreaker" name="test_circuit_breaker_opens_after_threshold_failures" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110472dc0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110472dc0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceCircuitBreaker" name="test_reset_circuit_breaker_closes_circuit" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d52f0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d52f0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceCircuitBreaker" name="test_reset_all_circuit_breakers_closes_all" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d7370&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d7370&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceEmailValidation" name="test_validate_email_with_valid_emails_succeeds" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x111436e90&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x111436e90&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceEmailValidation" name="test_validate_email_with_invalid_emails_fails_hard" time="0.001"><failure message="AssertionError: Should be invalid: .invalid@example.com&#10;assert True is False">tests/unit/test_auth_service_core_comprehensive.py:758: in test_validate_email_with_invalid_emails_fails_hard
    assert is_valid is False, f"Should be invalid: {email}"
E   AssertionError: Should be invalid: .invalid@example.com
E   assert True is False</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceEmailValidation" name="test_validate_email_with_invalid_emails_fails_hard" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bcba0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bcba0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordResetFlow" name="test_request_password_reset_with_valid_email" time="0.036"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110395560&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110395560&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordResetFlow" name="test_request_password_reset_with_nonexistent_email" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d58a0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d58a0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordResetFlow" name="test_confirm_password_reset_with_valid_token" time="0.001"><failure message="pydantic_core._pydantic_core.ValidationError: 1 validation error for PasswordResetConfirm&#10;reset_token&#10;  Field required [type=missing, input_value={'token': 'test-token', '...ord': 'NewPassword123!'}, input_type=dict]&#10;    For further information visit https://errors.pydantic.dev/2.11/v/missing">tests/unit/test_auth_service_core_comprehensive.py:793: in test_confirm_password_reset_with_valid_token
    reset_confirm = PasswordResetConfirm(
E   pydantic_core._pydantic_core.ValidationError: 1 validation error for PasswordResetConfirm
E   reset_token
E     Field required [type=missing, input_value={'token': 'test-token', '...ord': 'NewPassword123!'}, input_type=dict]
E       For further information visit https://errors.pydantic.dev/2.11/v/missing</failure></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServicePasswordResetFlow" name="test_confirm_password_reset_with_valid_token" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110473850&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110473850&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceConcurrencyAndRaceConditions" name="test_concurrent_user_creation_same_email_prevents_duplicates" time="0.206"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bc110&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1103bc110&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceConcurrencyAndRaceConditions" name="test_concurrent_authentication_same_user_succeeds" time="0.134"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x111436190&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x111436190&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceConcurrencyAndRaceConditions" name="test_concurrent_token_operations_maintain_consistency" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d6dc0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102d6dc0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceConcurrencyAndRaceConditions" name="test_concurrent_session_operations_maintain_consistency" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c52f0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1102c52f0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceErrorHandlingAndBoundaryConditions" name="test_operations_with_extremely_long_inputs_fail_gracefully" time="0.036"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1114182b0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1114182b0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceErrorHandlingAndBoundaryConditions" name="test_operations_with_special_characters_handle_correctly" time="0.069"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110397100&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110397100&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceErrorHandlingAndBoundaryConditions" name="test_operations_with_unicode_characters_handle_correctly" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1114375e0&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x1114375e0&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_core_comprehensive.TestAuthServiceErrorHandlingAndBoundaryConditions" name="test_memory_usage_with_large_number_of_sessions" time="0.002"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110473030&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestAuthServiceCore.teardown_method' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:858: in pytest_runtest_teardown
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestAuthServiceCore.teardown_method at 0x110473030&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_health_check_script_basic_functionality" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_health_check_script_environment_port_handling" time="0.003" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_health_check_script_failure_scenarios" time="0.002" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_readiness_check_script_functionality" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_endpoints_response_formats" time="0.029" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_check_database_dependency_validation" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_check_oauth_validation" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_check_performance_timing" time="0.000" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_check_environment_differences" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_auth_postgres_health_check_success" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_auth_postgres_health_check_failure" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_oauth_providers_health_check" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_jwt_configuration_health_check" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_overall_auth_health_status_aggregation" time="0.002" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthCheckBusinessValue" name="test_health_monitoring_prevents_service_outages" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthCheckBusinessValue" name="test_health_check_supports_deployment_automation" time="0.000" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthCheckBusinessValue" name="test_health_check_enables_monitoring_and_alerting" time="0.001" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_password_validation_requirements" time="0.001" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_email_validation_security" time="0.001" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_authentication_rate_limiting_simulation" time="0.020" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_user_creation_security_validation" time="0.069"><failure message="ValueError: User with this email already registered">tests/unit/test_auth_service_security_validation.py:138: in test_user_creation_security_validation
    user_id2 = await self.auth_service.register_user(
auth_core/services/auth_service.py:497: in register_user
    raise e
auth_core/services/auth_service.py:470: in register_user
    raise ValueError("User with this email already registered")
E   ValueError: User with this email already registered</failure></testcase><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_password_hashing_security" time="0.308" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_session_security_and_isolation" time="0.001" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_complete_authentication_security_flow" time="0.069"><failure message="AssertionError: assert '66f898c0-d2b9-4971-914a-719e3cb0e5c1' == {'user_id': '66f898c0-d2b9-4971-914a-719e3cb0e5c1', 'email': 'security-test@example.com', 'message': 'User registered successfully', 'requires_verification': True}">tests/unit/test_auth_service_security_validation.py:239: in test_complete_authentication_security_flow
    assert authenticated_user_id == user_id
E   AssertionError: assert '66f898c0-d2b9-4971-914a-719e3cb0e5c1' == {'user_id': '66f898c0-d2b9-4971-914a-719e3cb0e5c1', 'email': 'security-test@example.com', 'message': 'User registered successfully', 'requires_verification': True}</failure></testcase><testcase classname="tests.unit.test_auth_service_startup_configuration.TestAuthServiceStartupConfiguration" name="test_auth_config_complete_valid_configuration" time="0.002"><failure message="TypeError: quote_from_bytes() expected bytes">tests/unit/test_auth_service_startup_configuration.py:184: in test_auth_config_complete_valid_configuration
    redis_url = config.get_redis_url()
                ^^^^^^^^^^^^^^^^^^^^^^
auth_core/config.py:136: in get_redis_url
    return get_auth_env().get_redis_url()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_core/auth_environment.py:455: in get_redis_url
    redis_url = builder.get_url_for_environment()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../shared/redis_configuration_builder.py:400: in get_url_for_environment
    return self.development.auto_url
           ^^^^^^^^^^^^^^^^^^^^^^^^^
../shared/redis_configuration_builder.py:264: in auto_url
    return self.parent.connection.sync_url
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../shared/redis_configuration_builder.py:165: in sync_url
    password_part = f":{quote(password, safe='')}"
                        ^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/urllib/parse.py:907: in quote
    return quote_from_bytes(string, safe)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/urllib/parse.py:937: in quote_from_bytes
    raise TypeError("quote_from_bytes() expected bytes")
E   TypeError: quote_from_bytes() expected bytes</failure></testcase><testcase classname="tests.unit.test_auth_service_startup_configuration.TestAuthServiceStartupConfiguration" name="test_auth_config_missing_critical_oauth_values" time="0.003" /><testcase classname="tests.unit.test_auth_service_startup_configuration.TestAuthServiceStartupConfiguration" name="test_auth_config_invalid_configuration_values" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_auth_service_startup_configuration.py:433: in test_auth_config_invalid_configuration_values
    with pytest.raises(ValueError, match="REDIS_PORT must be a valid integer"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_auth_service_startup_configuration.TestAuthServiceStartupConfiguration" name="test_auth_config_environment_specific_requirements" time="0.004"><failure message="TypeError: quote_from_bytes() expected bytes">tests/unit/test_auth_service_startup_configuration.py:535: in test_auth_config_environment_specific_requirements
    config.get_redis_url()
auth_core/config.py:136: in get_redis_url
    return get_auth_env().get_redis_url()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_core/auth_environment.py:455: in get_redis_url
    redis_url = builder.get_url_for_environment()
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../shared/redis_configuration_builder.py:400: in get_url_for_environment
    return self.development.auto_url
           ^^^^^^^^^^^^^^^^^^^^^^^^^
../shared/redis_configuration_builder.py:264: in auto_url
    return self.parent.connection.sync_url
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../shared/redis_configuration_builder.py:165: in sync_url
    password_part = f":{quote(password, safe='')}"
                        ^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/urllib/parse.py:907: in quote
    return quote_from_bytes(string, safe)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/urllib/parse.py:937: in quote_from_bytes
    raise TypeError("quote_from_bytes() expected bytes")
E   TypeError: quote_from_bytes() expected bytes</failure></testcase><testcase classname="tests.unit.test_auth_service_startup_configuration.TestAuthServiceStartupConfiguration" name="test_auth_config_security_configuration_validation" time="0.002" /><testcase classname="tests.unit.test_auth_service_startup_configuration.TestAuthServiceStartupConfiguration" name="test_auth_config_database_configuration_validation" time="0.002"><failure message="AssertionError: assert False&#10; +  where False = &lt;built-in method startswith of str object at 0x11068a790&gt;('sqlite+aiosqlite:///:memory:')&#10; +    where &lt;built-in method startswith of str object at 0x11068a790&gt; = 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test.db'.startswith">tests/unit/test_auth_service_startup_configuration.py:819: in test_auth_config_database_configuration_validation
    assert db_url.startswith('sqlite+aiosqlite:///:memory:')
E   AssertionError: assert False
E    +  where False = &lt;built-in method startswith of str object at 0x11068a790&gt;('sqlite+aiosqlite:///:memory:')
E    +    where &lt;built-in method startswith of str object at 0x11068a790&gt; = 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test.db'.startswith</failure></testcase><testcase classname="tests.unit.test_auth_service_startup_configuration.TestAuthServiceStartupConfiguration" name="test_auth_config_startup_configuration_error_handling" time="0.005" /><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_service_startup_sequence_validation" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_configuration_validation_comprehensive" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_environment_specific_configuration" time="0.001"><failure message="TypeError: AuthConfig() takes no arguments">tests/unit/test_auth_startup_configuration_comprehensive.py:187: in test_environment_specific_configuration
    env_config = AuthConfig(auth_env)
                 ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</failure></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_dependency_health_checks" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_startup_performance_optimization" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_health_check_endpoints" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_graceful_shutdown_sequence" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_configuration_hot_reload" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_startup_failure_recovery" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_startup_monitoring_and_metrics" time="0.001"><error message="failed on setup with &quot;TypeError: AuthConfig() takes no arguments&quot;">tests/unit/test_auth_startup_configuration_comprehensive.py:72: in auth_config
    return AuthConfig(auth_env)
           ^^^^^^^^^^^^^^^^^^^^
E   TypeError: AuthConfig() takes no arguments</error></testcase><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigCore" name="test_config_instance_creation" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigCore" name="test_get_config_function" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigCore" name="test_environment_property_access" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigCore" name="test_static_methods_exist" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigEnvironment" name="test_get_environment_delegates_to_auth_env" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigEnvironment" name="test_environment_specific_checks" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigEnvironment" name="test_environment_consistency" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigOAuth" name="test_get_google_client_id" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigOAuth" name="test_get_google_client_secret" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigOAuth" name="test_is_google_oauth_enabled" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigOAuth" name="test_get_google_oauth_redirect_uri" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigOAuth" name="test_get_google_oauth_scopes" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigOAuth" name="test_oauth_with_environment_variables" time="0.002"><failure message="AssertionError: assert 'test-oauth-client-id-for-automated-testing' == 'test_client_id'&#10;  &#10;  - test_client_id&#10;  + test-oauth-client-id-for-automated-testing">tests/unit/test_config_comprehensive.py:185: in test_oauth_with_environment_variables
    assert client_id == "test_client_id"
E   AssertionError: assert 'test-oauth-client-id-for-automated-testing' == 'test_client_id'
E     
E     - test_client_id
E     + test-oauth-client-id-for-automated-testing</failure></testcase><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigJWT" name="test_get_jwt_secret" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigJWT" name="test_get_jwt_algorithm" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigJWT" name="test_get_jwt_access_expiry_minutes" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigJWT" name="test_get_jwt_refresh_expiry_days" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigJWT" name="test_get_jwt_service_expiry_minutes" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigJWT" name="test_jwt_configuration_consistency" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigService" name="test_get_service_secret" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigService" name="test_get_service_id" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigService" name="test_service_id_environment_specific" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigURLs" name="test_get_frontend_url" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigURLs" name="test_get_auth_service_url" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigURLs" name="test_get_api_base_url" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigURLs" name="test_url_format_validation" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_url" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_raw_database_url" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_database_url_conversion" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_host" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_port" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_name" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_user" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_password" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_pool_size" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_get_database_max_overflow" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDatabase" name="test_database_pool_environment_specific" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_url" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_get_session_ttl_hours" time="0.001"><failure message="assert 0 &gt; 0">tests/unit/test_config_comprehensive.py:450: in test_get_session_ttl_hours
    assert ttl_hours &gt; 0
E   assert 0 &gt; 0</failure></testcase><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_is_redis_disabled" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_host" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_port" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_db" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_password" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_is_redis_enabled" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_get_redis_default_ttl" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigRedis" name="test_redis_environment_specific" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_get_bcrypt_rounds" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_get_password_min_length" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_get_max_login_attempts" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_get_account_lockout_duration_minutes" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_get_session_timeout_minutes" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_require_email_verification" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_get_token_blacklist_ttl_hours" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_get_rate_limit_requests_per_minute" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigSecurity" name="test_security_environment_specific" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigCORS" name="test_get_cors_origins" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigCORS" name="test_get_allowed_origins" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigCORS" name="test_cors_environment_specific" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigLogging" name="test_log_configuration" time="0.002" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigLogging" name="test_log_configuration_masks_secrets" time="0.003" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigErrorHandling" name="test_handles_missing_auth_env" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigErrorHandling" name="test_handles_auth_env_method_errors" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigErrorHandling" name="test_handles_type_conversion_errors" time="0.001"><failure message="AssertionError: assert False&#10; +  where False = isinstance('not_a_number', int)">tests/unit/test_config_comprehensive.py:684: in test_handles_type_conversion_errors
    assert isinstance(result, int)
E   AssertionError: assert False
E    +  where False = isinstance('not_a_number', int)</failure></testcase><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigErrorHandling" name="test_environment_fallbacks" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigDeprecatedMethods" name="test_deprecated_oauth_redirect_uri_warning" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigIntegration" name="test_jwt_and_service_secrets_consistency" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigIntegration" name="test_database_url_and_components_consistency" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigIntegration" name="test_redis_url_and_components_consistency" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigIntegration" name="test_service_urls_environment_consistency" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigIntegration" name="test_ttl_and_timeout_consistency" time="0.001"><failure message="assert 5 &lt;= 0">tests/unit/test_config_comprehensive.py:788: in test_ttl_and_timeout_consistency
    assert session_timeout_minutes &lt;= session_ttl_minutes
E   assert 5 &lt;= 0</failure></testcase><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigBusinessValue" name="test_production_security_standards" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigBusinessValue" name="test_oauth_business_readiness" time="0.001"><failure message="AssertionError: OAuth redirect should use HTTPS in production&#10;assert ('https://' in 'http://auth:8081/auth/callback/google' or False)&#10; +  where False = &lt;function AuthConfig.is_development at 0x10f1b9f80&gt;()&#10; +    where &lt;function AuthConfig.is_development at 0x10f1b9f80&gt; = AuthConfig.is_development">tests/unit/test_config_comprehensive.py:829: in test_oauth_business_readiness
    assert "https://" in redirect_uri or AuthConfig.is_development(), "OAuth redirect should use HTTPS in production"
E   AssertionError: OAuth redirect should use HTTPS in production
E   assert ('https://' in 'http://auth:8081/auth/callback/google' or False)
E    +  where False = &lt;function AuthConfig.is_development at 0x10f1b9f80&gt;()
E    +    where &lt;function AuthConfig.is_development at 0x10f1b9f80&gt; = AuthConfig.is_development</failure></testcase><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigBusinessValue" name="test_database_performance_configuration" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigBusinessValue" name="test_session_management_business_logic" time="0.001" /><testcase classname="tests.unit.test_config_comprehensive.TestAuthConfigBusinessValue" name="test_rate_limiting_business_protection" time="0.001"><failure message="AssertionError: Max attempts too permissive&#10;assert 100 &lt;= 10">tests/unit/test_config_comprehensive.py:871: in test_rate_limiting_business_protection
    assert max_attempts &lt;= 10, "Max attempts too permissive"
E   AssertionError: Max attempts too permissive
E   assert 100 &lt;= 10</failure></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_initialization" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 35&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_initialization(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic database connection initialization&quot;&quot;&quot;&#10;          # Create new connection instance&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Verify initial state&#10;          assert db_conn.engine is None&#10;          assert db_conn.async_session_maker is None&#10;          assert db_conn._initialized is False&#10;&#10;          # Initialize connection&#10;          await db_conn.initialize()&#10;&#10;          # Verify post-initialization state&#10;          assert db_conn.engine is not None&#10;          assert db_conn.async_session_maker is not None&#10;          assert db_conn._initialized is True&#10;&#10;          # Clean up&#10;          await db_conn.close()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 35
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_initialization(self, real_services_fixture):
          """Test basic database connection initialization"""
          # Create new connection instance
          db_conn = AuthDatabaseConnection()

          # Verify initial state
          assert db_conn.engine is None
          assert db_conn.async_session_maker is None
          assert db_conn._initialized is False

          # Initialize connection
          await db_conn.initialize()

          # Verify post-initialization state
          assert db_conn.engine is not None
          assert db_conn.async_session_maker is not None
          assert db_conn._initialized is True

          # Clean up
          await db_conn.close()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_idempotent_initialization" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 58&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_idempotent_initialization(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that initialization is idempotent (can be called multiple times safely)&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Initialize multiple times&#10;          await db_conn.initialize()&#10;          engine1 = db_conn.engine&#10;          session_maker1 = db_conn.async_session_maker&#10;&#10;          await db_conn.initialize()  # Second call&#10;          engine2 = db_conn.engine&#10;          session_maker2 = db_conn.async_session_maker&#10;&#10;          # Should be the same objects (idempotent)&#10;          assert engine1 is engine2&#10;          assert session_maker1 is session_maker2&#10;          assert db_conn._initialized is True&#10;&#10;          await db_conn.close()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 58
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_idempotent_initialization(self, real_services_fixture):
          """Test that initialization is idempotent (can be called multiple times safely)"""
          db_conn = AuthDatabaseConnection()

          # Initialize multiple times
          await db_conn.initialize()
          engine1 = db_conn.engine
          session_maker1 = db_conn.async_session_maker

          await db_conn.initialize()  # Second call
          engine2 = db_conn.engine
          session_maker2 = db_conn.async_session_maker

          # Should be the same objects (idempotent)
          assert engine1 is engine2
          assert session_maker1 is session_maker2
          assert db_conn._initialized is True

          await db_conn.close()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_environment_detection" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 80&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_environment_detection(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test environment detection and configuration&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Test environment variables are detected&#10;          env = get_env()&#10;          expected_env = env.get(&quot;ENVIRONMENT&quot;, &quot;development&quot;).lower()&#10;&#10;          assert db_conn.environment == expected_env&#10;          assert isinstance(db_conn.is_cloud_run, bool)&#10;          assert isinstance(db_conn.is_test_mode, bool)&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 80
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_environment_detection(self, real_services_fixture):
          """Test environment detection and configuration"""
          db_conn = AuthDatabaseConnection()

          # Test environment variables are detected
          env = get_env()
          expected_env = env.get("ENVIRONMENT", "development").lower()

          assert db_conn.environment == expected_env
          assert isinstance(db_conn.is_cloud_run, bool)
          assert isinstance(db_conn.is_test_mode, bool)
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_test_mode" time="0.013"><failure message="AssertionError: assert False&#10; +  where False = &lt;built-in method startswith of str object at 0x1105df900&gt;('sqlite+aiosqlite:///:memory:')&#10; +    where &lt;built-in method startswith of str object at 0x1105df900&gt; = 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db'.startswith&#10; +      where 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' = str(sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db)&#10; +        where sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db = &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x10f7fe910&gt;.url&#10; +          where &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x10f7fe910&gt; = &lt;auth_service.auth_core.database.connection.AuthDatabaseConnection object at 0x1113680b0&gt;.engine">tests/unit/test_database_connection_comprehensive.py:108: in test_database_connection_test_mode
    assert str(db_conn.engine.url).startswith("sqlite+aiosqlite:///:memory:")
E   AssertionError: assert False
E    +  where False = &lt;built-in method startswith of str object at 0x1105df900&gt;('sqlite+aiosqlite:///:memory:')
E    +    where &lt;built-in method startswith of str object at 0x1105df900&gt; = 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db'.startswith
E    +      where 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' = str(sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db)
E    +        where sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db = &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x10f7fe910&gt;.url
E    +          where &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x10f7fe910&gt; = &lt;auth_service.auth_core.database.connection.AuthDatabaseConnection object at 0x1113680b0&gt;.engine</failure></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_timeout_handling" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 112&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_timeout_handling(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test connection timeout handling&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Test with very short timeout (should still succeed with real DB)&#10;          await db_conn.initialize(timeout=5.0)&#10;&#10;          assert db_conn._initialized is True&#10;          await db_conn.close()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 112
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_timeout_handling(self, real_services_fixture):
          """Test connection timeout handling"""
          db_conn = AuthDatabaseConnection()

          # Test with very short timeout (should still succeed with real DB)
          await db_conn.initialize(timeout=5.0)

          assert db_conn._initialized is True
          await db_conn.close()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_initialization_failure" time="0.002" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_get_session_context_manager" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 149&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_session_context_manager(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session context manager functionality&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Session should be active&#10;              assert session is not None&#10;&#10;              # Test basic query&#10;              result = await session.execute(text(&quot;SELECT 1 as test&quot;))&#10;              value = result.scalar()&#10;              assert value == 1&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 149
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_session_context_manager(self, real_services_fixture):
          """Test session context manager functionality"""
          async with auth_db.get_session() as session:
              # Session should be active
              assert session is not None

              # Test basic query
              result = await session.execute(text("SELECT 1 as test"))
              value = result.scalar()
              assert value == 1
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_transaction_commit" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 162&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_transaction_commit(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session transaction commit&quot;&quot;&quot;&#10;          # Create test user in transaction&#10;          async with auth_db.get_session() as session:&#10;              user = AuthUser(email=&quot;session_commit_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;              user_id = user.id&#10;&#10;          # Verify user was committed&#10;          async with auth_db.get_session() as session:&#10;              retrieved_user = await session.get(AuthUser, user_id)&#10;              assert retrieved_user is not None&#10;              assert retrieved_user.email == &quot;session_commit_test@example.com&quot;&#10;&#10;              # Clean up&#10;              await session.delete(retrieved_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 162
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_transaction_commit(self, real_services_fixture):
          """Test session transaction commit"""
          # Create test user in transaction
          async with auth_db.get_session() as session:
              user = AuthUser(email="session_commit_test@example.com")
              session.add(user)
              await session.commit()
              user_id = user.id

          # Verify user was committed
          async with auth_db.get_session() as session:
              retrieved_user = await session.get(AuthUser, user_id)
              assert retrieved_user is not None
              assert retrieved_user.email == "session_commit_test@example.com"

              # Clean up
              await session.delete(retrieved_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_transaction_rollback" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 183&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_transaction_rollback(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session transaction rollback on error&quot;&quot;&quot;&#10;          user_id = None&#10;&#10;          try:&#10;              async with auth_db.get_session() as session:&#10;                  user = AuthUser(email=&quot;session_rollback_test@example.com&quot;)&#10;                  session.add(user)&#10;                  await session.flush()  # Get ID without committing&#10;                  user_id = user.id&#10;&#10;                  # Force an error to trigger rollback&#10;                  raise Exception(&quot;Test error to trigger rollback&quot;)&#10;          except Exception as e:&#10;              assert &quot;Test error to trigger rollback&quot; in str(e)&#10;&#10;          # Verify user was rolled back (doesn't exist)&#10;          async with auth_db.get_session() as session:&#10;              retrieved_user = await session.get(AuthUser, user_id) if user_id else None&#10;              assert retrieved_user is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 183
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_transaction_rollback(self, real_services_fixture):
          """Test session transaction rollback on error"""
          user_id = None

          try:
              async with auth_db.get_session() as session:
                  user = AuthUser(email="session_rollback_test@example.com")
                  session.add(user)
                  await session.flush()  # Get ID without committing
                  user_id = user.id

                  # Force an error to trigger rollback
                  raise Exception("Test error to trigger rollback")
          except Exception as e:
              assert "Test error to trigger rollback" in str(e)

          # Verify user was rolled back (doesn't exist)
          async with auth_db.get_session() as session:
              retrieved_user = await session.get(AuthUser, user_id) if user_id else None
              assert retrieved_user is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_isolation" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 206&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_isolation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that different sessions are isolated&quot;&quot;&quot;&#10;          # Create user in first session&#10;          async with auth_db.get_session() as session1:&#10;              user = AuthUser(email=&quot;session_isolation_test@example.com&quot;)&#10;              session1.add(user)&#10;              await session1.flush()  # Don't commit yet&#10;&#10;              # Second session shouldn't see uncommitted data&#10;              async with auth_db.get_session() as session2:&#10;                  result = await session2.execute(&#10;                      text(&quot;SELECT COUNT(*) FROM auth_users WHERE email = 'session_isolation_test@example.com'&quot;)&#10;                  )&#10;                  count = result.scalar()&#10;                  assert count == 0  # Shouldn't see uncommitted data&#10;&#10;              # Commit in first session&#10;              await session1.commit()&#10;              user_id = user.id&#10;&#10;          # Now second session should see committed data&#10;          async with auth_db.get_session() as session:&#10;              retrieved_user = await session.get(AuthUser, user_id)&#10;              assert retrieved_user is not None&#10;&#10;              # Clean up&#10;              await session.delete(retrieved_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 206
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_isolation(self, real_services_fixture):
          """Test that different sessions are isolated"""
          # Create user in first session
          async with auth_db.get_session() as session1:
              user = AuthUser(email="session_isolation_test@example.com")
              session1.add(user)
              await session1.flush()  # Don't commit yet

              # Second session shouldn't see uncommitted data
              async with auth_db.get_session() as session2:
                  result = await session2.execute(
                      text("SELECT COUNT(*) FROM auth_users WHERE email = 'session_isolation_test@example.com'")
                  )
                  count = result.scalar()
                  assert count == 0  # Shouldn't see uncommitted data

              # Commit in first session
              await session1.commit()
              user_id = user.id

          # Now second session should see committed data
          async with auth_db.get_session() as session:
              retrieved_user = await session.get(AuthUser, user_id)
              assert retrieved_user is not None

              # Clean up
              await session.delete(retrieved_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_concurrent_access" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 237&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_concurrent_access(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test concurrent session access&quot;&quot;&quot;&#10;          async def create_user(suffix):&#10;              async with auth_db.get_session() as session:&#10;                  user = AuthUser(email=f&quot;concurrent_test_{suffix}@example.com&quot;)&#10;                  session.add(user)&#10;                  await session.commit()&#10;                  return user.id&#10;&#10;          # Create multiple users concurrently&#10;          user_ids = await asyncio.gather(&#10;              create_user(&quot;1&quot;),&#10;              create_user(&quot;2&quot;),&#10;              create_user(&quot;3&quot;)&#10;          )&#10;&#10;          # Verify all users were created&#10;          async with auth_db.get_session() as session:&#10;              for user_id in user_ids:&#10;                  user = await session.get(AuthUser, user_id)&#10;                  assert user is not None&#10;&#10;                  # Clean up&#10;                  await session.delete(user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 237
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_concurrent_access(self, real_services_fixture):
          """Test concurrent session access"""
          async def create_user(suffix):
              async with auth_db.get_session() as session:
                  user = AuthUser(email=f"concurrent_test_{suffix}@example.com")
                  session.add(user)
                  await session.commit()
                  return user.id

          # Create multiple users concurrently
          user_ids = await asyncio.gather(
              create_user("1"),
              create_user("2"),
              create_user("3")
          )

          # Verify all users were created
          async with auth_db.get_session() as session:
              for user_id in user_ids:
                  user = await session.get(AuthUser, user_id)
                  assert user is not None

                  # Clean up
                  await session.delete(user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_get_db_session_dependency" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 265&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_db_session_dependency(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test FastAPI dependency function&quot;&quot;&quot;&#10;          session_generator = get_db_session()&#10;          session = await session_generator.__anext__()&#10;&#10;          assert session is not None&#10;&#10;          # Test basic query&#10;          result = await session.execute(text(&quot;SELECT 1 as test&quot;))&#10;          value = result.scalar()&#10;          assert value == 1&#10;&#10;          # Clean up the generator&#10;          try:&#10;              await session_generator.__anext__()&#10;          except StopAsyncIteration:&#10;              pass  # Expected&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 265
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_db_session_dependency(self, real_services_fixture):
          """Test FastAPI dependency function"""
          session_generator = get_db_session()
          session = await session_generator.__anext__()

          assert session is not None

          # Test basic query
          result = await session.execute(text("SELECT 1 as test"))
          value = result.scalar()
          assert value == 1

          # Clean up the generator
          try:
              await session_generator.__anext__()
          except StopAsyncIteration:
              pass  # Expected
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionPoolingAndPerformance" name="test_connection_pooling_multiple_sessions" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 295&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_connection_pooling_multiple_sessions(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that multiple sessions use connection pooling efficiently&quot;&quot;&quot;&#10;          # Create multiple sessions sequentially&#10;          session_results = []&#10;&#10;          for i in range(5):&#10;              async with auth_db.get_session() as session:&#10;                  result = await session.execute(text(f&quot;SELECT {i} as test&quot;))&#10;                  value = result.scalar()&#10;                  session_results.append(value)&#10;&#10;          # Verify all sessions worked correctly&#10;          assert session_results == [0, 1, 2, 3, 4]&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 289&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for pooling tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 295
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_connection_pooling_multiple_sessions(self, real_services_fixture):
          """Test that multiple sessions use connection pooling efficiently"""
          # Create multiple sessions sequentially
          session_results = []

          for i in range(5):
              async with auth_db.get_session() as session:
                  result = await session.execute(text(f"SELECT {i} as test"))
                  value = result.scalar()
                  session_results.append(value)

          # Verify all sessions worked correctly
          assert session_results == [0, 1, 2, 3, 4]
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 289
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for pooling tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionPoolingAndPerformance" name="test_connection_reuse" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 311&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_connection_reuse(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that connections are reused from pool&quot;&quot;&quot;&#10;          connection_pids = []&#10;&#10;          # Get connection PIDs from multiple sessions&#10;          for _ in range(3):&#10;              async with auth_db.get_session() as session:&#10;                  # Get backend process ID if available (PostgreSQL specific)&#10;                  try:&#10;                      result = await session.execute(text(&quot;SELECT pg_backend_pid()&quot;))&#10;                      pid = result.scalar()&#10;                      connection_pids.append(pid)&#10;                  except Exception:&#10;                      # Skip if not PostgreSQL or function not available&#10;                      connection_pids.append(None)&#10;&#10;          # Remove None values (non-PostgreSQL connections)&#10;          valid_pids = [pid for pid in connection_pids if pid is not None]&#10;&#10;          if valid_pids:&#10;              # In a pool, we might reuse connections, so we could see repeated PIDs&#10;              assert len(valid_pids) &gt;= 1&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 289&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for pooling tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 311
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_connection_reuse(self, real_services_fixture):
          """Test that connections are reused from pool"""
          connection_pids = []

          # Get connection PIDs from multiple sessions
          for _ in range(3):
              async with auth_db.get_session() as session:
                  # Get backend process ID if available (PostgreSQL specific)
                  try:
                      result = await session.execute(text("SELECT pg_backend_pid()"))
                      pid = result.scalar()
                      connection_pids.append(pid)
                  except Exception:
                      # Skip if not PostgreSQL or function not available
                      connection_pids.append(None)

          # Remove None values (non-PostgreSQL connections)
          valid_pids = [pid for pid in connection_pids if pid is not None]

          if valid_pids:
              # In a pool, we might reuse connections, so we could see repeated PIDs
              assert len(valid_pids) &gt;= 1
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 289
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for pooling tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionPoolingAndPerformance" name="test_session_cleanup_on_error" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 336&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_cleanup_on_error(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that sessions are properly cleaned up on errors&quot;&quot;&quot;&#10;          initial_pool_size = 0&#10;&#10;          # Get initial pool state if available&#10;          if hasattr(auth_db.engine, 'pool'):&#10;              try:&#10;                  initial_pool_size = auth_db.engine.pool.checkedin()&#10;              except:&#10;                  pass&#10;&#10;          # Create session that raises error&#10;          try:&#10;              async with auth_db.get_session() as session:&#10;                  # Force an error&#10;                  await session.execute(text(&quot;SELECT * FROM nonexistent_table&quot;))&#10;          except Exception:&#10;              pass  # Expected error&#10;&#10;          # Pool should be cleaned up properly&#10;          if hasattr(auth_db.engine, 'pool'):&#10;              try:&#10;                  final_pool_size = auth_db.engine.pool.checkedin()&#10;                  # Pool size should be restored (connection returned to pool)&#10;                  assert final_pool_size &gt;= initial_pool_size&#10;              except:&#10;                  pass  # Skip if pool inspection not available&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 289&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for pooling tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 336
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_cleanup_on_error(self, real_services_fixture):
          """Test that sessions are properly cleaned up on errors"""
          initial_pool_size = 0

          # Get initial pool state if available
          if hasattr(auth_db.engine, 'pool'):
              try:
                  initial_pool_size = auth_db.engine.pool.checkedin()
              except:
                  pass

          # Create session that raises error
          try:
              async with auth_db.get_session() as session:
                  # Force an error
                  await session.execute(text("SELECT * FROM nonexistent_table"))
          except Exception:
              pass  # Expected error

          # Pool should be cleaned up properly
          if hasattr(auth_db.engine, 'pool'):
              try:
                  final_pool_size = auth_db.engine.pool.checkedin()
                  # Pool size should be restored (connection returned to pool)
                  assert final_pool_size &gt;= initial_pool_size
              except:
                  pass  # Skip if pool inspection not available
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 289
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for pooling tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_test_connection" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 376&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_test_connection(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test connection health check&quot;&quot;&quot;&#10;          result = await auth_db.test_connection()&#10;          assert result is True&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 376
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_test_connection(self, real_services_fixture):
          """Test connection health check"""
          result = await auth_db.test_connection()
          assert result is True
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_test_connection_with_timeout" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 383&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_test_connection_with_timeout(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test connection health check with custom timeout&quot;&quot;&quot;&#10;          result = await auth_db.test_connection(timeout=5.0)&#10;          assert result is True&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 383
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_test_connection_with_timeout(self, real_services_fixture):
          """Test connection health check with custom timeout"""
          result = await auth_db.test_connection(timeout=5.0)
          assert result is True
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_is_ready" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 390&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_is_ready(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test database readiness check&quot;&quot;&quot;&#10;          result = await auth_db.is_ready()&#10;          assert result is True&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 390
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_is_ready(self, real_services_fixture):
          """Test database readiness check"""
          result = await auth_db.is_ready()
          assert result is True
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_is_ready_with_timeout" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 397&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_is_ready_with_timeout(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test database readiness check with custom timeout&quot;&quot;&quot;&#10;          result = await auth_db.is_ready(timeout=5.0)&#10;          assert result is True&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 397
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_is_ready_with_timeout(self, real_services_fixture):
          """Test database readiness check with custom timeout"""
          result = await auth_db.is_ready(timeout=5.0)
          assert result is True
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_get_status" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 404&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_status(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test database status reporting&quot;&quot;&quot;&#10;          status = auth_db.get_status()&#10;&#10;          assert isinstance(status, dict)&#10;          assert &quot;status&quot; in status&#10;          assert status[&quot;status&quot;] == &quot;active&quot;&#10;          assert &quot;environment&quot; in status&#10;          assert &quot;is_cloud_run&quot; in status&#10;          assert &quot;is_test_mode&quot; in status&#10;          assert isinstance(status[&quot;is_cloud_run&quot;], bool)&#10;          assert isinstance(status[&quot;is_test_mode&quot;], bool)&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 404
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_status(self, real_services_fixture):
          """Test database status reporting"""
          status = auth_db.get_status()

          assert isinstance(status, dict)
          assert "status" in status
          assert status["status"] == "active"
          assert "environment" in status
          assert "is_cloud_run" in status
          assert "is_test_mode" in status
          assert isinstance(status["is_cloud_run"], bool)
          assert isinstance(status["is_test_mode"], bool)
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_get_connection_health" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 419&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_connection_health(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test detailed connection health information&quot;&quot;&quot;&#10;          health = await auth_db.get_connection_health()&#10;&#10;          assert isinstance(health, dict)&#10;          assert &quot;initialized&quot; in health&#10;          assert health[&quot;initialized&quot;] is True&#10;          assert &quot;environment&quot; in health&#10;          assert &quot;engine_exists&quot; in health&#10;          assert health[&quot;engine_exists&quot;] is True&#10;          assert &quot;timestamp&quot; in health&#10;          assert &quot;connectivity_test&quot; in health&#10;          assert health[&quot;connectivity_test&quot;] == &quot;passed&quot;&#10;          assert &quot;status&quot; in health&#10;          assert health[&quot;status&quot;] == &quot;healthy&quot;&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 419
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_connection_health(self, real_services_fixture):
          """Test detailed connection health information"""
          health = await auth_db.get_connection_health()

          assert isinstance(health, dict)
          assert "initialized" in health
          assert health["initialized"] is True
          assert "environment" in health
          assert "engine_exists" in health
          assert health["engine_exists"] is True
          assert "timestamp" in health
          assert "connectivity_test" in health
          assert health["connectivity_test"] == "passed"
          assert "status" in health
          assert health["status"] == "healthy"
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_get_connection_health_uninitialized" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 437&#10;      @pytest.mark.unit&#10;      async def test_get_connection_health_uninitialized(self):&#10;          &quot;&quot;&quot;Test connection health when not initialized&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;          health = await db_conn.get_connection_health()&#10;&#10;          assert health[&quot;initialized&quot;] is False&#10;          assert health[&quot;status&quot;] == &quot;not_initialized&quot;&#10;          assert health[&quot;engine_exists&quot;] is False&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 437
      @pytest.mark.unit
      async def test_get_connection_health_uninitialized(self):
          """Test connection health when not initialized"""
          db_conn = AuthDatabaseConnection()
          health = await db_conn.get_connection_health()

          assert health["initialized"] is False
          assert health["status"] == "not_initialized"
          assert health["engine_exists"] is False
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_mock_engine_handling" time="0.002" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_connection_validation_with_mock" time="0.001" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_cleanup_partial_initialization" time="0.001" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_close_with_timeout" time="0.001" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_close_already_closed" time="0.001" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_close_with_dispose_error" time="0.001" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_session_error_handling_edge_cases" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 542&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_error_handling_edge_cases(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session error handling edge cases&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Test session with invalid SQL&#10;          try:&#10;              async with auth_db.get_session() as session:&#10;                  await session.execute(text(&quot;INVALID SQL STATEMENT&quot;))&#10;          except Exception as e:&#10;              # Should handle SQL errors gracefully&#10;              assert isinstance(e, SQLAlchemyError)&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 542
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_error_handling_edge_cases(self, real_services_fixture):
          """Test session error handling edge cases"""
          if not auth_db._initialized:
              await auth_db.initialize()

          # Test session with invalid SQL
          try:
              async with auth_db.get_session() as session:
                  await session.execute(text("INVALID SQL STATEMENT"))
          except Exception as e:
              # Should handle SQL errors gracefully
              assert isinstance(e, SQLAlchemyError)
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_test_connection_failure" time="0.001"><failure message="pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x11130a640&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:850: in pytest_runtest_call
    yield
../venv/lib/python3.12/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
../venv/lib/python3.12/site-packages/_pytest/capture.py:900: in pytest_runtest_call
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
../venv/lib/python3.12/site-packages/_pytest/skipping.py:263: in pytest_runtest_call
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:158: in pytest_runtest_call
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x11130a640&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</failure></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_test_connection_timeout" time="0.001"><failure message="pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x11130b540&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:850: in pytest_runtest_call
    yield
../venv/lib/python3.12/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
../venv/lib/python3.12/site-packages/_pytest/capture.py:900: in pytest_runtest_call
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
../venv/lib/python3.12/site-packages/_pytest/skipping.py:263: in pytest_runtest_call
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:158: in pytest_runtest_call
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x11130b540&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</failure></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_is_ready_timeout" time="0.001" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionTableManagement" name="test_create_tables_idempotent" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 601&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_create_tables_idempotent(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that create_tables is idempotent&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;          await db_conn.initialize()&#10;&#10;          # Create tables multiple times - should not fail&#10;          await db_conn.create_tables()&#10;          await db_conn.create_tables()  # Second call should be safe&#10;&#10;          await db_conn.close()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 601
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_create_tables_idempotent(self, real_services_fixture):
          """Test that create_tables is idempotent"""
          db_conn = AuthDatabaseConnection()
          await db_conn.initialize()

          # Create tables multiple times - should not fail
          await db_conn.create_tables()
          await db_conn.create_tables()  # Second call should be safe

          await db_conn.close()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionTableManagement" name="test_create_tables_with_mock_engine" time="0.002" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionTableManagement" name="test_table_existence_check" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 626&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_table_existence_check(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test table existence checking in PostgreSQL&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;          await db_conn.initialize()&#10;&#10;          # Tables should exist after initialization&#10;          async with db_conn.engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;&quot;&quot;&#10;                  SELECT EXISTS (&#10;                      SELECT FROM information_schema.tables&#10;                      WHERE table_schema = 'public'&#10;                      AND table_name = 'auth_users'&#10;                  );&#10;              &quot;&quot;&quot;))&#10;              table_exists = result.scalar()&#10;              assert table_exists is True&#10;&#10;          await db_conn.close()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 626
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_table_existence_check(self, real_services_fixture):
          """Test table existence checking in PostgreSQL"""
          db_conn = AuthDatabaseConnection()
          await db_conn.initialize()

          # Tables should exist after initialization
          async with db_conn.engine.connect() as conn:
              result = await conn.execute(text("""
                  SELECT EXISTS (
                      SELECT FROM information_schema.tables
                      WHERE table_schema = 'public'
                      AND table_name = 'auth_users'
                  );
              """))
              table_exists = result.scalar()
              assert table_exists is True

          await db_conn.close()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionCompatibilityAliases" name="test_compatibility_aliases" time="0.000" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionCompatibilityAliases" name="test_global_auth_db_instance" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 662&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_global_auth_db_instance(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that global auth_db instance works correctly&quot;&quot;&quot;&#10;          from auth_service.auth_core.database.connection import auth_db&#10;&#10;          # Should be an instance of AuthDatabaseConnection&#10;          assert isinstance(auth_db, AuthDatabaseConnection)&#10;&#10;          # Should be able to use it&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          async with auth_db.get_session() as session:&#10;              result = await session.execute(text(&quot;SELECT 1&quot;))&#10;              assert result.scalar() == 1&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_comprehensive.py, line 662
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_global_auth_db_instance(self, real_services_fixture):
          """Test that global auth_db instance works correctly"""
          from auth_service.auth_core.database.connection import auth_db

          # Should be an instance of AuthDatabaseConnection
          assert isinstance(auth_db, AuthDatabaseConnection)

          # Should be able to use it
          if not auth_db._initialized:
              await auth_db.initialize()

          async with auth_db.get_session() as session:
              result = await session.execute(text("SELECT 1"))
              assert result.scalar() == 1
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestAuthDatabaseConfig" name="test_auth_database_config_constants" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestAuthDatabaseConfig" name="test_auth_database_config_values_reasonable" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_with_auth_config" time="0.000"><failure message="AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from '/Users/anthony/Documents/GitHub/netra-apex/auth_service/auth_core/database/connection_events.py'&gt; does not have the attribute 'AuthConfig'">tests/unit/test_database_connection_events_comprehensive.py:80: in test_get_settings_with_auth_config
    with patch('auth_service.auth_core.database.connection_events.AuthConfig') as mock_config:
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: in get_original
    raise AttributeError(
E   AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from '/Users/anthony/Documents/GitHub/netra-apex/auth_service/auth_core/database/connection_events.py'&gt; does not have the attribute 'AuthConfig'</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_with_partial_auth_config" time="0.000"><failure message="AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from '/Users/anthony/Documents/GitHub/netra-apex/auth_service/auth_core/database/connection_events.py'&gt; does not have the attribute 'AuthConfig'">tests/unit/test_database_connection_events_comprehensive.py:95: in test_get_settings_with_partial_auth_config
    with patch('auth_service.auth_core.database.connection_events.AuthConfig') as mock_config:
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: in get_original
    raise AttributeError(
E   AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from '/Users/anthony/Documents/GitHub/netra-apex/auth_service/auth_core/database/connection_events.py'&gt; does not have the attribute 'AuthConfig'</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_import_error" time="0.000"><failure message="AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from '/Users/anthony/Documents/GitHub/netra-apex/auth_service/auth_core/database/connection_events.py'&gt; does not have the attribute 'AuthConfig'">tests/unit/test_database_connection_events_comprehensive.py:111: in test_get_settings_import_error
    with patch('auth_service.auth_core.database.connection_events.AuthConfig', side_effect=ImportError):
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1431: in get_original
    raise AttributeError(
E   AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from '/Users/anthony/Documents/GitHub/netra-apex/auth_service/auth_core/database/connection_events.py'&gt; does not have the attribute 'AuthConfig'</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_module_level_initialization" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_execute_auth_timeout_statements" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_close_cursor_safely_success" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_close_cursor_safely_error" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_configure_auth_connection_timeouts_success" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_configure_auth_connection_timeouts_error" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionPIDHandling" name="test_set_auth_connection_pid_with_backend_pid" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionPIDHandling" name="test_set_auth_connection_pid_no_backend_pid" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionPIDHandling" name="test_set_auth_connection_pid_error" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_no_pool" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_normal_usage" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_high_usage" time="0.000"><failure message="AssertionError: Expected 'warning' to have been called.">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:913: in assert_called
    raise AssertionError(msg)
E   AssertionError: Expected 'warning' to have been called.

During handling of the above exception, another exception occurred:
tests/unit/test_database_connection_events_comprehensive.py:276: in test_monitor_auth_pool_usage_high_usage
    mock_logger.warning.assert_called()
E   AssertionError: Expected 'warning' to have been called.</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_missing_methods" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_error" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_connection_established_with_settings" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_connection_established_no_settings" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_checkout_if_enabled_enabled" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_checkout_if_enabled_disabled" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEngineEventSetup" name="test_setup_auth_async_engine_events_success" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEngineEventSetup" name="test_setup_auth_async_engine_events_none_engine" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEngineEventSetup" name="test_setup_auth_async_engine_events_error" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlersIntegration" name="test_connect_event_handler_postgresql" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlersIntegration" name="test_connect_event_handler_sqlite" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlersIntegration" name="test_checkout_event_handler" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestRealEngineIntegration" name="test_setup_events_on_real_engine" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_events_comprehensive.py, line 508&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_setup_events_on_real_engine(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test setting up events on real database engine&quot;&quot;&quot;&#10;          # Create real engine for testing&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;&#10;          try:&#10;              # Setup events (should not raise error)&#10;              setup_auth_async_engine_events(engine)&#10;&#10;              # Test that engine still works after event setup&#10;              async with engine.connect() as conn:&#10;                  result = await conn.execute(text(&quot;SELECT 1&quot;))&#10;                  value = result.scalar()&#10;                  assert value == 1&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_events_comprehensive.py, line 508
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_setup_events_on_real_engine(self, real_services_fixture):
          """Test setting up events on real database engine"""
          # Create real engine for testing
          engine = AuthDatabaseManager.create_async_engine()

          try:
              # Setup events (should not raise error)
              setup_auth_async_engine_events(engine)

              # Test that engine still works after event setup
              async with engine.connect() as conn:
                  result = await conn.execute(text("SELECT 1"))
                  value = result.scalar()
                  assert value == 1

          finally:
              await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestRealEngineIntegration" name="test_events_trigger_on_real_connections" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_events_comprehensive.py, line 528&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_events_trigger_on_real_connections(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that events are actually triggered on real connections&quot;&quot;&quot;&#10;          # Create engine with events&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;          setup_auth_async_engine_events(engine)&#10;&#10;          try:&#10;              # Use connection to trigger events&#10;              async with engine.connect() as conn:&#10;                  result = await conn.execute(text(&quot;SELECT current_database()&quot;))&#10;                  db_name = result.scalar()&#10;                  assert db_name is not None&#10;&#10;              # Events should have been triggered (we can't easily verify this&#10;              # without mocking, but at least we know they don't break functionality)&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_events_comprehensive.py, line 528
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_events_trigger_on_real_connections(self, real_services_fixture):
          """Test that events are actually triggered on real connections"""
          # Create engine with events
          engine = AuthDatabaseManager.create_async_engine()
          setup_auth_async_engine_events(engine)

          try:
              # Use connection to trigger events
              async with engine.connect() as conn:
                  result = await conn.execute(text("SELECT current_database()"))
                  db_name = result.scalar()
                  assert db_name is not None

              # Events should have been triggered (we can't easily verify this
              # without mocking, but at least we know they don't break functionality)

          finally:
              await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestRealEngineIntegration" name="test_multiple_connections_with_events" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_events_comprehensive.py, line 549&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_multiple_connections_with_events(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test multiple connections with events enabled&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;          setup_auth_async_engine_events(engine)&#10;&#10;          try:&#10;              # Create multiple connections&#10;              for i in range(3):&#10;                  async with engine.connect() as conn:&#10;                      result = await conn.execute(text(f&quot;SELECT {i + 1}&quot;))&#10;                      value = result.scalar()&#10;                      assert value == i + 1&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_connection_events_comprehensive.py, line 549
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_multiple_connections_with_events(self, real_services_fixture):
          """Test multiple connections with events enabled"""
          engine = AuthDatabaseManager.create_async_engine()
          setup_auth_async_engine_events(engine)

          try:
              # Create multiple connections
              for i in range(3):
                  async with engine.connect() as conn:
                      result = await conn.execute(text(f"SELECT {i + 1}"))
                      value = result.scalar()
                      assert value == i + 1

          finally:
              await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_pool_events_setup" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_connection_info_logging" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_event_handler_exception_handling" time="0.000" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_module_exports" time="0.000" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 31&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_create_async_engine(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic async engine creation&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;&#10;          assert isinstance(engine, AsyncEngine)&#10;          assert engine is not None&#10;&#10;          # Verify engine configuration&#10;          assert isinstance(engine.pool, NullPool)&#10;          assert engine.echo is False&#10;&#10;          # Test engine connectivity&#10;          async with engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;SELECT 1&quot;))&#10;              value = result.scalar()&#10;              assert value == 1&#10;&#10;          await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 31
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_create_async_engine(self, real_services_fixture):
          """Test basic async engine creation"""
          engine = AuthDatabaseManager.create_async_engine()

          assert isinstance(engine, AsyncEngine)
          assert engine is not None

          # Verify engine configuration
          assert isinstance(engine.pool, NullPool)
          assert engine.echo is False

          # Test engine connectivity
          async with engine.connect() as conn:
              result = await conn.execute(text("SELECT 1"))
              value = result.scalar()
              assert value == 1

          await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine_with_kwargs" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 52&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_create_async_engine_with_kwargs(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test engine creation with custom kwargs&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine(&#10;              echo=True,&#10;              pool_timeout=60&#10;          )&#10;&#10;          assert isinstance(engine, AsyncEngine)&#10;          assert engine.echo is True&#10;&#10;          # Test connectivity&#10;          async with engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;SELECT 42&quot;))&#10;              value = result.scalar()&#10;              assert value == 42&#10;&#10;          await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 52
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_create_async_engine_with_kwargs(self, real_services_fixture):
          """Test engine creation with custom kwargs"""
          engine = AuthDatabaseManager.create_async_engine(
              echo=True,
              pool_timeout=60
          )

          assert isinstance(engine, AsyncEngine)
          assert engine.echo is True

          # Test connectivity
          async with engine.connect() as conn:
              result = await conn.execute(text("SELECT 42"))
              value = result.scalar()
              assert value == 42

          await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine_no_url_error" time="0.001" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine_empty_url_error" time="0.001" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_normal_mode" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 90&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      def test_get_database_url_normal_mode(self, real_services_fixture):&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 90
      @pytest.mark.unit
      @pytest.mark.real_services
      def test_get_database_url_normal_mode(self, real_services_fixture):
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_fast_test_mode" time="0.001"><failure message="AssertionError: assert 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' == 'sqlite+aiosqlite:///:memory:'&#10;  &#10;  - sqlite+aiosqlite:///:memory:&#10;  + sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db">tests/unit/test_database_manager_comprehensive.py:114: in test_get_database_url_fast_test_mode
    assert url == "sqlite+aiosqlite:///:memory:"
E   AssertionError: assert 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' == 'sqlite+aiosqlite:///:memory:'
E     
E     - sqlite+aiosqlite:///:memory:
E     + sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_environment_variables" time="0.001"><failure message="AssertionError: assert 'postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db' == 'postgresql://test_user:test_pass@localhost:5432/test_db'&#10;  &#10;  - postgresql://test_user:test_pass@localhost:5432/test_db&#10;  + postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db&#10;  ?           ++++++++">tests/unit/test_database_manager_comprehensive.py:141: in test_get_database_url_environment_variables
    assert url == "postgresql://test_user:test_pass@localhost:5432/test_db"
E   AssertionError: assert 'postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db' == 'postgresql://test_user:test_pass@localhost:5432/test_db'
E     
E     - postgresql://test_user:test_pass@localhost:5432/test_db
E     + postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db
E     ?           ++++++++</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_validation_failure" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_database_manager_comprehensive.py:164: in test_get_database_url_validation_failure
    with pytest.raises(ValueError, match="Database configuration error"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_no_url_generated" time="0.002"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_database_manager_comprehensive.py:183: in test_get_database_url_no_url_generated
    with pytest.raises(ValueError, match="DatabaseURLBuilder failed to generate URL"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_development" time="0.001"><failure message="TypeError: 'NoneType' object is not subscriptable">tests/unit/test_database_manager_comprehensive.py:208: in test_environment_detection_development
    call_args = mock_builder_class.call_args[0][0]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: 'NoneType' object is not subscriptable</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_staging" time="0.001"><failure message="ValueError: Database configuration error in staging environment: Missing required variables for staging: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.">tests/unit/test_database_manager_comprehensive.py:226: in test_environment_detection_staging
    url = AuthDatabaseManager.get_database_url()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_core/database/database_manager.py:77: in get_database_url
    raise ValueError(
E   ValueError: Database configuration error in staging environment: Missing required variables for staging: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_production" time="0.001"><failure message="ValueError: Database configuration error in production environment: Missing required variables for production: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.">tests/unit/test_database_manager_comprehensive.py:247: in test_environment_detection_production
    url = AuthDatabaseManager.get_database_url()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_core/database/database_manager.py:77: in get_database_url
    raise ValueError(
E   ValueError: Database configuration error in production environment: Missing required variables for production: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_default" time="0.001"><failure message="TypeError: 'NoneType' object is not subscriptable">tests/unit/test_database_manager_comprehensive.py:271: in test_environment_detection_default
    call_args = mock_builder_class.call_args[0][0]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: 'NoneType' object is not subscriptable</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerIntegrationWithSharedComponents" name="test_integration_with_database_url_builder" time="0.001" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerIntegrationWithSharedComponents" name="test_integration_with_isolated_environment" time="0.001"><failure message="AssertionError: assert 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' == 'sqlite+aiosqlite:///:memory:'&#10;  &#10;  - sqlite+aiosqlite:///:memory:&#10;  + sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db">tests/unit/test_database_manager_comprehensive.py:324: in test_integration_with_isolated_environment
    assert url == "sqlite+aiosqlite:///:memory:"
E   AssertionError: assert 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' == 'sqlite+aiosqlite:///:memory:'
E     
E     - sqlite+aiosqlite:///:memory:
E     + sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerIntegrationWithSharedComponents" name="test_url_masking_for_logging" time="0.001"><failure message="AssertionError: expected call not found.&#10;Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')&#10;  Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')&#10;&#10;pytest introspection follows:&#10;&#10;Args:&#10;assert ('sqlite+aiosqlite:///:memory:',) == ('postgresql://user:password@host:5432/db',)&#10;  &#10;  At index 0 diff: 'sqlite+aiosqlite:///:memory:' != 'postgresql://user:password@host:5432/db'&#10;  &#10;  Full diff:&#10;    (&#10;  -     'postgresql://user:password@host:5432/db',&#10;  +     'sqlite+aiosqlite:///:memory:',&#10;    )">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:944: in assert_called_with
    raise AssertionError(_error_message()) from cause
E   AssertionError: expected call not found.
E   Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')
E     Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')

During handling of the above exception, another exception occurred:
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:956: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AssertionError: expected call not found.
E   Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')
E     Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')
E   
E   pytest introspection follows:
E   
E   Args:
E   assert ('sqlite+aiosqlite:///:memory:',) == ('postgresql://user:password@host:5432/db',)
E     
E     At index 0 diff: 'sqlite+aiosqlite:///:memory:' != 'postgresql://user:password@host:5432/db'
E     
E     Full diff:
E       (
E     -     'postgresql://user:password@host:5432/db',
E     +     'sqlite+aiosqlite:///:memory:',
E       )

During handling of the above exception, another exception occurred:
tests/unit/test_database_manager_comprehensive.py:352: in test_url_masking_for_logging
    mock_mask.assert_called_once_with("postgresql://user:password@host:5432/db")
E   AssertionError: expected call not found.
E   Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')
E     Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')
E   
E   pytest introspection follows:
E   
E   Args:
E   assert ('sqlite+aiosqlite:///:memory:',) == ('postgresql://user:password@host:5432/db',)
E     
E     At index 0 diff: 'sqlite+aiosqlite:///:memory:' != 'postgresql://user:password@host:5432/db'
E     
E     Full diff:
E       (
E     -     'postgresql://user:password@host:5432/db',
E     +     'sqlite+aiosqlite:///:memory:',
E       )</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_missing_environment_variables" time="0.001"><failure message="AttributeError: 'NoneType' object has no attribute 'lower'">tests/unit/test_database_manager_comprehensive.py:371: in test_missing_environment_variables
    AuthDatabaseManager.get_database_url()
auth_core/database/database_manager.py:44: in get_database_url
    fast_test_mode = env.get("AUTH_FAST_TEST_MODE", "false").lower() == "true"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'lower'</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_invalid_environment_values" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">tests/unit/test_database_manager_comprehensive.py:391: in test_invalid_environment_values
    with pytest.raises(ValueError, match="Database configuration error"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_database_url_builder_exception" time="0.001"><failure message="Failed: DID NOT RAISE &lt;class 'Exception'&gt;">tests/unit/test_database_manager_comprehensive.py:406: in test_database_url_builder_exception
    with pytest.raises(Exception, match="Builder initialization failed"):
E   Failed: DID NOT RAISE &lt;class 'Exception'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_fast_test_mode_variations" time="0.001"><failure message="AssertionError: assert 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' == 'sqlite+aiosqlite:///:memory:'&#10;  &#10;  - sqlite+aiosqlite:///:memory:&#10;  + sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db">tests/unit/test_database_manager_comprehensive.py:433: in test_fast_test_mode_variations
    assert url == "sqlite+aiosqlite:///:memory:"
E   AssertionError: assert 'sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db' == 'sqlite+aiosqlite:///:memory:'
E     
E     - sqlite+aiosqlite:///:memory:
E     + sqlite+aiosqlite:////var/folders/z2/qgyzc8gx6kn1mkh6kfhlb6qw0000gp/T/auth_service_test_54348.db</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_engine_creation_full_flow" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 450&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_engine_creation_full_flow(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test complete engine creation flow with real database&quot;&quot;&quot;&#10;          # Test URL construction&#10;          url = AuthDatabaseManager.get_database_url()&#10;          assert url is not None&#10;&#10;          # Test engine creation&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;          assert engine is not None&#10;&#10;          # Test engine usage&#10;          async with engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;SELECT version()&quot;))&#10;              version = result.scalar()&#10;              assert version is not None&#10;              assert &quot;PostgreSQL&quot; in version&#10;&#10;          await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 450
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_engine_creation_full_flow(self, real_services_fixture):
          """Test complete engine creation flow with real database"""
          # Test URL construction
          url = AuthDatabaseManager.get_database_url()
          assert url is not None

          # Test engine creation
          engine = AuthDatabaseManager.create_async_engine()
          assert engine is not None

          # Test engine usage
          async with engine.connect() as conn:
              result = await conn.execute(text("SELECT version()"))
              version = result.scalar()
              assert version is not None
              assert "PostgreSQL" in version

          await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_multiple_engine_creation" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 471&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_multiple_engine_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test creating multiple engines (should work independently)&quot;&quot;&quot;&#10;          engines = []&#10;&#10;          try:&#10;              # Create multiple engines&#10;              for i in range(3):&#10;                  engine = AuthDatabaseManager.create_async_engine()&#10;                  engines.append(engine)&#10;&#10;                  # Each should work independently&#10;                  async with engine.connect() as conn:&#10;                      result = await conn.execute(text(f&quot;SELECT {i + 1}&quot;))&#10;                      value = result.scalar()&#10;                      assert value == i + 1&#10;&#10;          finally:&#10;              # Clean up all engines&#10;              for engine in engines:&#10;                  await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 471
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_multiple_engine_creation(self, real_services_fixture):
          """Test creating multiple engines (should work independently)"""
          engines = []

          try:
              # Create multiple engines
              for i in range(3):
                  engine = AuthDatabaseManager.create_async_engine()
                  engines.append(engine)

                  # Each should work independently
                  async with engine.connect() as conn:
                      result = await conn.execute(text(f"SELECT {i + 1}"))
                      value = result.scalar()
                      assert value == i + 1

          finally:
              # Clean up all engines
              for engine in engines:
                  await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_engine_with_custom_configuration" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 494&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_engine_with_custom_configuration(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test engine creation with custom configuration&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine(&#10;              echo=False,  # Disable logging&#10;              pool_timeout=30,  # Custom timeout&#10;          )&#10;&#10;          try:&#10;              # Test custom configuration works&#10;              assert engine.echo is False&#10;&#10;              # Test connectivity&#10;              async with engine.connect() as conn:&#10;                  result = await conn.execute(text(&quot;SELECT current_database()&quot;))&#10;                  db_name = result.scalar()&#10;                  assert db_name is not None&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_manager_comprehensive.py, line 494
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_engine_with_custom_configuration(self, real_services_fixture):
          """Test engine creation with custom configuration"""
          engine = AuthDatabaseManager.create_async_engine(
              echo=False,  # Disable logging
              pool_timeout=30,  # Custom timeout
          )

          try:
              # Test custom configuration works
              assert engine.echo is False

              # Test connectivity
              async with engine.connect() as conn:
                  result = await conn.execute(text("SELECT current_database()"))
                  db_name = result.scalar()
                  assert db_name is not None

          finally:
              await engine.dispose()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_environment_specific_url_construction" time="0.001"><failure message="AssertionError: assert 'postgresql+asyncpg://postgres:postgres@localhost:5432/netra_dev' == 'postgresql://development_url'&#10;  &#10;  - postgresql://development_url&#10;  + postgresql+asyncpg://postgres:postgres@localhost:5432/netra_dev">tests/unit/test_database_manager_comprehensive.py:537: in test_environment_specific_url_construction
    assert url == f"postgresql://{env}_url"
E   AssertionError: assert 'postgresql+asyncpg://postgres:postgres@localhost:5432/netra_dev' == 'postgresql://development_url'
E     
E     - postgresql://development_url
E     + postgresql+asyncpg://postgres:postgres@localhost:5432/netra_dev</failure></testcase><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_user_model_supports_comprehensive_user_management" time="0.001"><failure message="AssertionError: Failed attempts tracking required for security&#10;assert None == 0&#10; +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x1115a8ad0&gt;.failed_login_attempts">tests/unit/test_database_models_business_value.py:62: in test_auth_user_model_supports_comprehensive_user_management
    assert user.failed_login_attempts == 0, "Failed attempts tracking required for security"
E   AssertionError: Failed attempts tracking required for security
E   assert None == 0
E    +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x1115a8ad0&gt;.failed_login_attempts</failure></testcase><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_user_model_supports_oauth_business_integration" time="0.001" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_session_model_enables_secure_session_management" time="0.001" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_audit_log_model_supports_security_compliance" time="0.001" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_password_reset_token_model_enables_secure_password_recovery" time="0.001" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_support_data_integrity_for_business_operations" time="0.001"><failure message="AssertionError: Users should be active by default for business operations&#10;assert None is True&#10; +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x10f960c20&gt;.is_active">tests/unit/test_database_models_business_value.py:261: in test_database_models_support_data_integrity_for_business_operations
    assert new_user.is_active is True, "Users should be active by default for business operations"
E   AssertionError: Users should be active by default for business operations
E   assert None is True
E    +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x10f960c20&gt;.is_active</failure></testcase><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_support_time_zone_aware_operations" time="0.001" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_support_business_query_patterns" time="0.001" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_handle_json_metadata_for_business_flexibility" time="0.001" /><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_model_creation" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 54&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_model_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic AuthUser model creation with all fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              user = AuthUser(&#10;                  email=&quot;test_model_user@example.com&quot;,&#10;                  full_name=&quot;Test Model User&quot;,&#10;                  hashed_password=&quot;hashed_password_123&quot;,&#10;                  auth_provider=&quot;local&quot;,&#10;                  is_active=True,&#10;                  is_verified=False,&#10;                  failed_login_attempts=0&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify all fields are set correctly&#10;              assert user.id is not None&#10;              assert len(user.id) == 36  # UUID4 format&#10;              assert user.email == &quot;test_model_user@example.com&quot;&#10;              assert user.full_name == &quot;Test Model User&quot;&#10;              assert user.hashed_password == &quot;hashed_password_123&quot;&#10;              assert user.auth_provider == &quot;local&quot;&#10;              assert user.is_active is True&#10;              assert user.is_verified is False&#10;              assert user.failed_login_attempts == 0&#10;              assert user.created_at is not None&#10;              assert user.updated_at is not None&#10;              assert user.last_login_at is None&#10;              assert user.locked_until is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 54
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_model_creation(self, real_services_fixture):
          """Test basic AuthUser model creation with all fields"""
          async with auth_db.get_session() as session:
              user = AuthUser(
                  email="test_model_user@example.com",
                  full_name="Test Model User",
                  hashed_password="hashed_password_123",
                  auth_provider="local",
                  is_active=True,
                  is_verified=False,
                  failed_login_attempts=0
              )

              session.add(user)
              await session.commit()

              # Verify all fields are set correctly
              assert user.id is not None
              assert len(user.id) == 36  # UUID4 format
              assert user.email == "test_model_user@example.com"
              assert user.full_name == "Test Model User"
              assert user.hashed_password == "hashed_password_123"
              assert user.auth_provider == "local"
              assert user.is_active is True
              assert user.is_verified is False
              assert user.failed_login_attempts == 0
              assert user.created_at is not None
              assert user.updated_at is not None
              assert user.last_login_at is None
              assert user.locked_until is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_model_defaults" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 87&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_model_defaults(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test AuthUser model default values&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              user = AuthUser(email=&quot;test_defaults@example.com&quot;)&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify defaults&#10;              assert user.auth_provider == &quot;local&quot;&#10;              assert user.is_active is True&#10;              assert user.is_verified is False&#10;              assert user.failed_login_attempts == 0&#10;              assert user.full_name is None&#10;              assert user.hashed_password is None&#10;              assert user.provider_user_id is None&#10;              assert user.provider_data is None&#10;              assert user.last_login_at is None&#10;              assert user.locked_until is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 87
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_model_defaults(self, real_services_fixture):
          """Test AuthUser model default values"""
          async with auth_db.get_session() as session:
              user = AuthUser(email="test_defaults@example.com")

              session.add(user)
              await session.commit()

              # Verify defaults
              assert user.auth_provider == "local"
              assert user.is_active is True
              assert user.is_verified is False
              assert user.failed_login_attempts == 0
              assert user.full_name is None
              assert user.hashed_password is None
              assert user.provider_user_id is None
              assert user.provider_data is None
              assert user.last_login_at is None
              assert user.locked_until is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_email_uniqueness" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 109&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_email_uniqueness(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that email field enforces uniqueness constraint&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create first user&#10;              user1 = AuthUser(email=&quot;duplicate_test@example.com&quot;)&#10;              session.add(user1)&#10;              await session.commit()&#10;&#10;              # Attempt to create second user with same email&#10;              user2 = AuthUser(email=&quot;duplicate_test@example.com&quot;)&#10;              session.add(user2)&#10;&#10;              # Should raise IntegrityError due to unique constraint&#10;              with pytest.raises(IntegrityError):&#10;                  await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 109
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_email_uniqueness(self, real_services_fixture):
          """Test that email field enforces uniqueness constraint"""
          async with auth_db.get_session() as session:
              # Create first user
              user1 = AuthUser(email="duplicate_test@example.com")
              session.add(user1)
              await session.commit()

              # Attempt to create second user with same email
              user2 = AuthUser(email="duplicate_test@example.com")
              session.add(user2)

              # Should raise IntegrityError due to unique constraint
              with pytest.raises(IntegrityError):
                  await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_oauth_fields" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 127&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_oauth_fields(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test OAuth-specific fields in AuthUser model&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              provider_data = {&#10;                  &quot;sub&quot;: &quot;google_12345&quot;,&#10;                  &quot;name&quot;: &quot;OAuth Test User&quot;,&#10;                  &quot;picture&quot;: &quot;https://example.com/pic.jpg&quot;,&#10;                  &quot;locale&quot;: &quot;en&quot;&#10;              }&#10;&#10;              user = AuthUser(&#10;                  email=&quot;oauth_test@example.com&quot;,&#10;                  full_name=&quot;OAuth Test User&quot;,&#10;                  auth_provider=&quot;google&quot;,&#10;                  provider_user_id=&quot;google_12345&quot;,&#10;                  provider_data=provider_data,&#10;                  is_verified=True  # OAuth users are pre-verified&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify OAuth fields&#10;              assert user.auth_provider == &quot;google&quot;&#10;              assert user.provider_user_id == &quot;google_12345&quot;&#10;              assert user.provider_data == provider_data&#10;              assert user.is_verified is True&#10;              assert user.hashed_password is None  # OAuth users don't have passwords&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 127
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_oauth_fields(self, real_services_fixture):
          """Test OAuth-specific fields in AuthUser model"""
          async with auth_db.get_session() as session:
              provider_data = {
                  "sub": "google_12345",
                  "name": "OAuth Test User",
                  "picture": "https://example.com/pic.jpg",
                  "locale": "en"
              }

              user = AuthUser(
                  email="oauth_test@example.com",
                  full_name="OAuth Test User",
                  auth_provider="google",
                  provider_user_id="google_12345",
                  provider_data=provider_data,
                  is_verified=True  # OAuth users are pre-verified
              )

              session.add(user)
              await session.commit()

              # Verify OAuth fields
              assert user.auth_provider == "google"
              assert user.provider_user_id == "google_12345"
              assert user.provider_data == provider_data
              assert user.is_verified is True
              assert user.hashed_password is None  # OAuth users don't have passwords
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_security_fields" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 158&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_security_fields(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test security-related fields (failed attempts, locking)&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              lock_time = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              user = AuthUser(&#10;                  email=&quot;security_test@example.com&quot;,&#10;                  failed_login_attempts=5,&#10;                  locked_until=lock_time,&#10;                  is_active=False&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify security fields&#10;              assert user.failed_login_attempts == 5&#10;              assert user.locked_until == lock_time&#10;              assert user.is_active is False&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 158
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_security_fields(self, real_services_fixture):
          """Test security-related fields (failed attempts, locking)"""
          async with auth_db.get_session() as session:
              lock_time = datetime.now(timezone.utc) + timedelta(hours=1)

              user = AuthUser(
                  email="security_test@example.com",
                  failed_login_attempts=5,
                  locked_until=lock_time,
                  is_active=False
              )

              session.add(user)
              await session.commit()

              # Verify security fields
              assert user.failed_login_attempts == 5
              assert user.locked_until == lock_time
              assert user.is_active is False
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_timestamps" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 180&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_timestamps(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test timestamp fields behavior&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user&#10;              user = AuthUser(email=&quot;timestamp_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              original_created = user.created_at&#10;              original_updated = user.updated_at&#10;&#10;              assert original_created is not None&#10;              assert original_updated is not None&#10;&#10;              # Update user&#10;              user.full_name = &quot;Updated Name&quot;&#10;              await session.commit()&#10;&#10;              # Check that updated_at changed but created_at didn't&#10;              assert user.created_at == original_created&#10;              assert user.updated_at &gt; original_updated&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 180
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_timestamps(self, real_services_fixture):
          """Test timestamp fields behavior"""
          async with auth_db.get_session() as session:
              # Create user
              user = AuthUser(email="timestamp_test@example.com")
              session.add(user)
              await session.commit()

              original_created = user.created_at
              original_updated = user.updated_at

              assert original_created is not None
              assert original_updated is not None

              # Update user
              user.full_name = "Updated Name"
              await session.commit()

              # Check that updated_at changed but created_at didn't
              assert user.created_at == original_created
              assert user.updated_at &gt; original_updated
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_json_provider_data" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 204&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_json_provider_data(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test JSON field storage for provider_data&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              complex_data = {&#10;                  &quot;sub&quot;: &quot;google_12345&quot;,&#10;                  &quot;name&quot;: &quot;Complex User&quot;,&#10;                  &quot;picture&quot;: &quot;https://example.com/pic.jpg&quot;,&#10;                  &quot;emails&quot;: [&quot;primary@example.com&quot;, &quot;secondary@example.com&quot;],&#10;                  &quot;groups&quot;: [&quot;admin&quot;, &quot;user&quot;],&#10;                  &quot;metadata&quot;: {&#10;                      &quot;last_login&quot;: &quot;2024-01-01T12:00:00Z&quot;,&#10;                      &quot;preferences&quot;: {&#10;                          &quot;theme&quot;: &quot;dark&quot;,&#10;                          &quot;notifications&quot;: True&#10;                      }&#10;                  },&#10;                  &quot;numbers&quot;: [1, 2, 3, 42],&#10;                  &quot;boolean_flag&quot;: True&#10;              }&#10;&#10;              user = AuthUser(&#10;                  email=&quot;json_test@example.com&quot;,&#10;                  provider_data=complex_data&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Retrieve and verify JSON data integrity&#10;              retrieved_user = await session.get(AuthUser, user.id)&#10;              assert retrieved_user.provider_data == complex_data&#10;              assert retrieved_user.provider_data[&quot;metadata&quot;][&quot;preferences&quot;][&quot;theme&quot;] == &quot;dark&quot;&#10;              assert retrieved_user.provider_data[&quot;numbers&quot;] == [1, 2, 3, 42]&#10;              assert retrieved_user.provider_data[&quot;boolean_flag&quot;] is True&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 204
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_json_provider_data(self, real_services_fixture):
          """Test JSON field storage for provider_data"""
          async with auth_db.get_session() as session:
              complex_data = {
                  "sub": "google_12345",
                  "name": "Complex User",
                  "picture": "https://example.com/pic.jpg",
                  "emails": ["primary@example.com", "secondary@example.com"],
                  "groups": ["admin", "user"],
                  "metadata": {
                      "last_login": "2024-01-01T12:00:00Z",
                      "preferences": {
                          "theme": "dark",
                          "notifications": True
                      }
                  },
                  "numbers": [1, 2, 3, 42],
                  "boolean_flag": True
              }

              user = AuthUser(
                  email="json_test@example.com",
                  provider_data=complex_data
              )

              session.add(user)
              await session.commit()

              # Retrieve and verify JSON data integrity
              retrieved_user = await session.get(AuthUser, user.id)
              assert retrieved_user.provider_data == complex_data
              assert retrieved_user.provider_data["metadata"]["preferences"]["theme"] == "dark"
              assert retrieved_user.provider_data["numbers"] == [1, 2, 3, 42]
              assert retrieved_user.provider_data["boolean_flag"] is True
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_model_creation" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 259&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_model_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic AuthSession model creation&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              session_obj = AuthSession(&#10;                  user_id=self.test_user.id,&#10;                  refresh_token_hash=&quot;hashed_token_123&quot;,&#10;                  ip_address=&quot;127.0.0.1&quot;,&#10;                  user_agent=&quot;TestAgent/1.0&quot;,&#10;                  device_id=&quot;test_device_123&quot;,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Verify all fields&#10;              assert session_obj.id is not None&#10;              assert len(session_obj.id) == 36  # UUID4 format&#10;              assert session_obj.user_id == self.test_user.id&#10;              assert session_obj.refresh_token_hash == &quot;hashed_token_123&quot;&#10;              assert session_obj.ip_address == &quot;127.0.0.1&quot;&#10;              assert session_obj.user_agent == &quot;TestAgent/1.0&quot;&#10;              assert session_obj.device_id == &quot;test_device_123&quot;&#10;              assert session_obj.expires_at == expires_at&#10;              assert session_obj.is_active is True&#10;              assert session_obj.created_at is not None&#10;              assert session_obj.last_activity is not None&#10;              assert session_obj.revoked_at is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 259
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_model_creation(self, real_services_fixture):
          """Test basic AuthSession model creation"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              session_obj = AuthSession(
                  user_id=self.test_user.id,
                  refresh_token_hash="hashed_token_123",
                  ip_address="127.0.0.1",
                  user_agent="TestAgent/1.0",
                  device_id="test_device_123",
                  expires_at=expires_at
              )

              session.add(session_obj)
              await session.commit()

              # Verify all fields
              assert session_obj.id is not None
              assert len(session_obj.id) == 36  # UUID4 format
              assert session_obj.user_id == self.test_user.id
              assert session_obj.refresh_token_hash == "hashed_token_123"
              assert session_obj.ip_address == "127.0.0.1"
              assert session_obj.user_agent == "TestAgent/1.0"
              assert session_obj.device_id == "test_device_123"
              assert session_obj.expires_at == expires_at
              assert session_obj.is_active is True
              assert session_obj.created_at is not None
              assert session_obj.last_activity is not None
              assert session_obj.revoked_at is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_model_defaults" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 292&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_model_defaults(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test AuthSession model default values&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              session_obj = AuthSession(&#10;                  user_id=self.test_user.id,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Verify defaults&#10;              assert session_obj.is_active is True&#10;              assert session_obj.refresh_token_hash is None&#10;              assert session_obj.ip_address is None&#10;              assert session_obj.user_agent is None&#10;              assert session_obj.device_id is None&#10;              assert session_obj.revoked_at is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 292
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_model_defaults(self, real_services_fixture):
          """Test AuthSession model default values"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              session_obj = AuthSession(
                  user_id=self.test_user.id,
                  expires_at=expires_at
              )

              session.add(session_obj)
              await session.commit()

              # Verify defaults
              assert session_obj.is_active is True
              assert session_obj.refresh_token_hash is None
              assert session_obj.ip_address is None
              assert session_obj.user_agent is None
              assert session_obj.device_id is None
              assert session_obj.revoked_at is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_revocation" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 315&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_revocation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session revocation functionality&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              session_obj = AuthSession(&#10;                  user_id=self.test_user.id,&#10;                  expires_at=expires_at,&#10;                  device_id=&quot;test_revoke_device&quot;&#10;              )&#10;&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Revoke session&#10;              revoke_time = datetime.now(timezone.utc)&#10;              session_obj.is_active = False&#10;              session_obj.revoked_at = revoke_time&#10;              await session.commit()&#10;&#10;              # Verify revocation&#10;              assert session_obj.is_active is False&#10;              assert session_obj.revoked_at == revoke_time&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 315
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_revocation(self, real_services_fixture):
          """Test session revocation functionality"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              session_obj = AuthSession(
                  user_id=self.test_user.id,
                  expires_at=expires_at,
                  device_id="test_revoke_device"
              )

              session.add(session_obj)
              await session.commit()

              # Revoke session
              revoke_time = datetime.now(timezone.utc)
              session_obj.is_active = False
              session_obj.revoked_at = revoke_time
              await session.commit()

              # Verify revocation
              assert session_obj.is_active is False
              assert session_obj.revoked_at == revoke_time
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_multiple_per_user" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 341&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_multiple_per_user(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that users can have multiple active sessions&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              # Create multiple sessions for same user&#10;              sessions = []&#10;              for i in range(3):&#10;                  session_obj = AuthSession(&#10;                      user_id=self.test_user.id,&#10;                      expires_at=expires_at,&#10;                      device_id=f&quot;test_device_{i}&quot;,&#10;                      ip_address=f&quot;192.168.1.{i+1}&quot;&#10;                  )&#10;                  sessions.append(session_obj)&#10;                  session.add(session_obj)&#10;&#10;              await session.commit()&#10;&#10;              # Verify all sessions exist&#10;              for i, session_obj in enumerate(sessions):&#10;                  assert session_obj.device_id == f&quot;test_device_{i}&quot;&#10;                  assert session_obj.ip_address == f&quot;192.168.1.{i+1}&quot;&#10;                  assert session_obj.user_id == self.test_user.id&#10;                  assert session_obj.is_active is True&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 341
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_multiple_per_user(self, real_services_fixture):
          """Test that users can have multiple active sessions"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              # Create multiple sessions for same user
              sessions = []
              for i in range(3):
                  session_obj = AuthSession(
                      user_id=self.test_user.id,
                      expires_at=expires_at,
                      device_id=f"test_device_{i}",
                      ip_address=f"192.168.1.{i+1}"
                  )
                  sessions.append(session_obj)
                  session.add(session_obj)

              await session.commit()

              # Verify all sessions exist
              for i, session_obj in enumerate(sessions):
                  assert session_obj.device_id == f"test_device_{i}"
                  assert session_obj.ip_address == f"192.168.1.{i+1}"
                  assert session_obj.user_id == self.test_user.id
                  assert session_obj.is_active is True
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_model_creation" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 387&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_model_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic AuthAuditLog model creation&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              metadata = {&quot;action&quot;: &quot;test_action&quot;, &quot;resource&quot;: &quot;user&quot;}&#10;&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_login&quot;,&#10;                  user_id=self.test_user.id,&#10;                  success=True,&#10;                  event_metadata=metadata,&#10;                  ip_address=&quot;127.0.0.1&quot;,&#10;                  user_agent=&quot;TestAgent/1.0&quot;&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify all fields&#10;              assert audit_log.id is not None&#10;              assert len(audit_log.id) == 36  # UUID4 format&#10;              assert audit_log.event_type == &quot;test_login&quot;&#10;              assert audit_log.user_id == self.test_user.id&#10;              assert audit_log.success is True&#10;              assert audit_log.event_metadata == metadata&#10;              assert audit_log.ip_address == &quot;127.0.0.1&quot;&#10;              assert audit_log.user_agent == &quot;TestAgent/1.0&quot;&#10;              assert audit_log.error_message is None&#10;              assert audit_log.created_at is not None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 387
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_model_creation(self, real_services_fixture):
          """Test basic AuthAuditLog model creation"""
          async with auth_db.get_session() as session:
              metadata = {"action": "test_action", "resource": "user"}

              audit_log = AuthAuditLog(
                  event_type="test_login",
                  user_id=self.test_user.id,
                  success=True,
                  event_metadata=metadata,
                  ip_address="127.0.0.1",
                  user_agent="TestAgent/1.0"
              )

              session.add(audit_log)
              await session.commit()

              # Verify all fields
              assert audit_log.id is not None
              assert len(audit_log.id) == 36  # UUID4 format
              assert audit_log.event_type == "test_login"
              assert audit_log.user_id == self.test_user.id
              assert audit_log.success is True
              assert audit_log.event_metadata == metadata
              assert audit_log.ip_address == "127.0.0.1"
              assert audit_log.user_agent == "TestAgent/1.0"
              assert audit_log.error_message is None
              assert audit_log.created_at is not None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_failure_case" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 418&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_failure_case(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test audit log for failed events&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_login_failed&quot;,&#10;                  user_id=self.test_user.id,&#10;                  success=False,&#10;                  error_message=&quot;Invalid credentials&quot;,&#10;                  ip_address=&quot;192.168.1.100&quot;&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify failure fields&#10;              assert audit_log.success is False&#10;              assert audit_log.error_message == &quot;Invalid credentials&quot;&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 418
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_failure_case(self, real_services_fixture):
          """Test audit log for failed events"""
          async with auth_db.get_session() as session:
              audit_log = AuthAuditLog(
                  event_type="test_login_failed",
                  user_id=self.test_user.id,
                  success=False,
                  error_message="Invalid credentials",
                  ip_address="192.168.1.100"
              )

              session.add(audit_log)
              await session.commit()

              # Verify failure fields
              assert audit_log.success is False
              assert audit_log.error_message == "Invalid credentials"
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_without_user" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 438&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_without_user(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test audit log for system events without user&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_system_event&quot;,&#10;                  success=True,&#10;                  event_metadata={&quot;system&quot;: &quot;auth_service&quot;}&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify system event&#10;              assert audit_log.user_id is None&#10;              assert audit_log.event_type == &quot;test_system_event&quot;&#10;              assert audit_log.success is True&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 438
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_without_user(self, real_services_fixture):
          """Test audit log for system events without user"""
          async with auth_db.get_session() as session:
              audit_log = AuthAuditLog(
                  event_type="test_system_event",
                  success=True,
                  event_metadata={"system": "auth_service"}
              )

              session.add(audit_log)
              await session.commit()

              # Verify system event
              assert audit_log.user_id is None
              assert audit_log.event_type == "test_system_event"
              assert audit_log.success is True
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_json_metadata" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 457&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_json_metadata(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test JSON metadata storage in audit log&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              complex_metadata = {&#10;                  &quot;action&quot;: &quot;password_change&quot;,&#10;                  &quot;old_password_strength&quot;: &quot;strong&quot;,&#10;                  &quot;new_password_strength&quot;: &quot;very_strong&quot;,&#10;                  &quot;security_checks&quot;: {&#10;                      &quot;common_password&quot;: False,&#10;                      &quot;breached&quot;: False,&#10;                      &quot;similar_to_old&quot;: False&#10;                  },&#10;                  &quot;attempt_count&quot;: 1,&#10;                  &quot;browser_fingerprint&quot;: {&#10;                      &quot;user_agent&quot;: &quot;Mozilla/5.0...&quot;,&#10;                      &quot;screen_resolution&quot;: &quot;1920x1080&quot;,&#10;                      &quot;timezone&quot;: &quot;UTC-5&quot;&#10;                  }&#10;              }&#10;&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_complex_event&quot;,&#10;                  user_id=self.test_user.id,&#10;                  success=True,&#10;                  event_metadata=complex_metadata&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify JSON data integrity&#10;              retrieved_log = await session.get(AuthAuditLog, audit_log.id)&#10;              assert retrieved_log.event_metadata == complex_metadata&#10;              assert retrieved_log.event_metadata[&quot;security_checks&quot;][&quot;breached&quot;] is False&#10;              assert retrieved_log.event_metadata[&quot;attempt_count&quot;] == 1&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 457
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_json_metadata(self, real_services_fixture):
          """Test JSON metadata storage in audit log"""
          async with auth_db.get_session() as session:
              complex_metadata = {
                  "action": "password_change",
                  "old_password_strength": "strong",
                  "new_password_strength": "very_strong",
                  "security_checks": {
                      "common_password": False,
                      "breached": False,
                      "similar_to_old": False
                  },
                  "attempt_count": 1,
                  "browser_fingerprint": {
                      "user_agent": "Mozilla/5.0...",
                      "screen_resolution": "1920x1080",
                      "timezone": "UTC-5"
                  }
              }

              audit_log = AuthAuditLog(
                  event_type="test_complex_event",
                  user_id=self.test_user.id,
                  success=True,
                  event_metadata=complex_metadata
              )

              session.add(audit_log)
              await session.commit()

              # Verify JSON data integrity
              retrieved_log = await session.get(AuthAuditLog, audit_log.id)
              assert retrieved_log.event_metadata == complex_metadata
              assert retrieved_log.event_metadata["security_checks"]["breached"] is False
              assert retrieved_log.event_metadata["attempt_count"] == 1
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_creation" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 513&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic PasswordResetToken model creation&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              token = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;hashed_reset_token_123&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Verify all fields&#10;              assert token.id is not None&#10;              assert len(token.id) == 36  # UUID4 format&#10;              assert token.user_id == self.test_user.id&#10;              assert token.token_hash == &quot;hashed_reset_token_123&quot;&#10;              assert token.email == self.test_user.email&#10;              assert token.expires_at == expires_at&#10;              assert token.is_used is False&#10;              assert token.created_at is not None&#10;              assert token.used_at is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 513
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_creation(self, real_services_fixture):
          """Test basic PasswordResetToken model creation"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              token = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="hashed_reset_token_123",
                  email=self.test_user.email,
                  expires_at=expires_at
              )

              session.add(token)
              await session.commit()

              # Verify all fields
              assert token.id is not None
              assert len(token.id) == 36  # UUID4 format
              assert token.user_id == self.test_user.id
              assert token.token_hash == "hashed_reset_token_123"
              assert token.email == self.test_user.email
              assert token.expires_at == expires_at
              assert token.is_used is False
              assert token.created_at is not None
              assert token.used_at is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_defaults" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 541&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_defaults(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test PasswordResetToken model default values&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              token = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;hashed_reset_token_456&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Verify defaults&#10;              assert token.is_used is False&#10;              assert token.used_at is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 541
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_defaults(self, real_services_fixture):
          """Test PasswordResetToken model default values"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              token = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="hashed_reset_token_456",
                  email=self.test_user.email,
                  expires_at=expires_at
              )

              session.add(token)
              await session.commit()

              # Verify defaults
              assert token.is_used is False
              assert token.used_at is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_usage" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 562&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_usage(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test token usage tracking&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              token = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;hashed_reset_token_789&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Mark token as used&#10;              used_time = datetime.now(timezone.utc)&#10;              token.is_used = True&#10;              token.used_at = used_time&#10;              await session.commit()&#10;&#10;              # Verify usage tracking&#10;              assert token.is_used is True&#10;              assert token.used_at == used_time&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 562
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_usage(self, real_services_fixture):
          """Test token usage tracking"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              token = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="hashed_reset_token_789",
                  email=self.test_user.email,
                  expires_at=expires_at
              )

              session.add(token)
              await session.commit()

              # Mark token as used
              used_time = datetime.now(timezone.utc)
              token.is_used = True
              token.used_at = used_time
              await session.commit()

              # Verify usage tracking
              assert token.is_used is True
              assert token.used_at == used_time
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_uniqueness" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 589&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_uniqueness(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that token_hash enforces uniqueness constraint&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              # Create first token&#10;              token1 = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;duplicate_token_hash&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;              session.add(token1)&#10;              await session.commit()&#10;&#10;              # Attempt to create second token with same hash&#10;              token2 = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;duplicate_token_hash&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;              session.add(token2)&#10;&#10;              # Should raise IntegrityError due to unique constraint&#10;              with pytest.raises(IntegrityError):&#10;                  await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 589
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_uniqueness(self, real_services_fixture):
          """Test that token_hash enforces uniqueness constraint"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              # Create first token
              token1 = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="duplicate_token_hash",
                  email=self.test_user.email,
                  expires_at=expires_at
              )
              session.add(token1)
              await session.commit()

              # Attempt to create second token with same hash
              token2 = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="duplicate_token_hash",
                  email=self.test_user.email,
                  expires_at=expires_at
              )
              session.add(token2)

              # Should raise IntegrityError due to unique constraint
              with pytest.raises(IntegrityError):
                  await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelIntegration" name="test_user_session_audit_integration" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 634&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_user_session_audit_integration(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test integration between User, Session, and Audit models&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user&#10;              user = AuthUser(email=&quot;integration_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create session&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;              session_obj = AuthSession(&#10;                  user_id=user.id,&#10;                  expires_at=expires_at,&#10;                  device_id=&quot;integration_device&quot;,&#10;                  ip_address=&quot;192.168.1.1&quot;&#10;              )&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Create audit log&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;integration_login&quot;,&#10;                  user_id=user.id,&#10;                  success=True,&#10;                  event_metadata={&quot;session_id&quot;: session_obj.id},&#10;                  ip_address=&quot;192.168.1.1&quot;&#10;              )&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify all models are linked correctly&#10;              assert session_obj.user_id == user.id&#10;              assert audit_log.user_id == user.id&#10;              assert audit_log.event_metadata[&quot;session_id&quot;] == session_obj.id&#10;              assert session_obj.ip_address == audit_log.ip_address&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 623&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up all test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 634
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_user_session_audit_integration(self, real_services_fixture):
          """Test integration between User, Session, and Audit models"""
          async with auth_db.get_session() as session:
              # Create user
              user = AuthUser(email="integration_test@example.com")
              session.add(user)
              await session.commit()

              # Create session
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)
              session_obj = AuthSession(
                  user_id=user.id,
                  expires_at=expires_at,
                  device_id="integration_device",
                  ip_address="192.168.1.1"
              )
              session.add(session_obj)
              await session.commit()

              # Create audit log
              audit_log = AuthAuditLog(
                  event_type="integration_login",
                  user_id=user.id,
                  success=True,
                  event_metadata={"session_id": session_obj.id},
                  ip_address="192.168.1.1"
              )
              session.add(audit_log)
              await session.commit()

              # Verify all models are linked correctly
              assert session_obj.user_id == user.id
              assert audit_log.user_id == user.id
              assert audit_log.event_metadata["session_id"] == session_obj.id
              assert session_obj.ip_address == audit_log.ip_address
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 623
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              # Clean up all test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'"))
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelIntegration" name="test_user_password_reset_integration" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 672&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_user_password_reset_integration(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test integration between User and PasswordResetToken models&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user&#10;              user = AuthUser(email=&quot;integration_reset@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create password reset token&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;              token = PasswordResetToken(&#10;                  user_id=user.id,&#10;                  token_hash=&quot;integration_token_hash&quot;,&#10;                  email=user.email,&#10;                  expires_at=expires_at&#10;              )&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Verify integration&#10;              assert token.user_id == user.id&#10;              assert token.email == user.email&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 623&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up all test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 672
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_user_password_reset_integration(self, real_services_fixture):
          """Test integration between User and PasswordResetToken models"""
          async with auth_db.get_session() as session:
              # Create user
              user = AuthUser(email="integration_reset@example.com")
              session.add(user)
              await session.commit()

              # Create password reset token
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)
              token = PasswordResetToken(
                  user_id=user.id,
                  token_hash="integration_token_hash",
                  email=user.email,
                  expires_at=expires_at
              )
              session.add(token)
              await session.commit()

              # Verify integration
              assert token.user_id == user.id
              assert token.email == user.email
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 623
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              # Clean up all test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'"))
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelIntegration" name="test_model_cascade_behavior" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 697&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_model_cascade_behavior(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test model behavior when related data exists (no foreign key constraints)&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with related data&#10;              user = AuthUser(email=&quot;integration_cascade@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create related records&#10;              session_obj = AuthSession(&#10;                  user_id=user.id,&#10;                  expires_at=datetime.now(timezone.utc) + timedelta(days=30),&#10;                  device_id=&quot;integration_cascade_device&quot;&#10;              )&#10;              session.add(session_obj)&#10;&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;integration_cascade_event&quot;,&#10;                  user_id=user.id,&#10;                  success=True&#10;              )&#10;              session.add(audit_log)&#10;&#10;              reset_token = PasswordResetToken(&#10;                  user_id=user.id,&#10;                  token_hash=&quot;integration_cascade_token&quot;,&#10;                  email=user.email,&#10;                  expires_at=datetime.now(timezone.utc) + timedelta(hours=1)&#10;              )&#10;              session.add(reset_token)&#10;              await session.commit()&#10;&#10;              # Delete user (no cascade constraints, so related records remain orphaned)&#10;              await session.delete(user)&#10;              await session.commit()&#10;&#10;              # Verify related records still exist but are orphaned&#10;              orphaned_session = await session.get(AuthSession, session_obj.id)&#10;              orphaned_audit = await session.get(AuthAuditLog, audit_log.id)&#10;              orphaned_token = await session.get(PasswordResetToken, reset_token.id)&#10;&#10;              assert orphaned_session is not None&#10;              assert orphaned_audit is not None&#10;              assert orphaned_token is not None&#10;&#10;              # Clean up orphaned records&#10;              await session.delete(orphaned_session)&#10;              await session.delete(orphaned_audit)&#10;              await session.delete(orphaned_token)&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 623&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up all test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 697
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_model_cascade_behavior(self, real_services_fixture):
          """Test model behavior when related data exists (no foreign key constraints)"""
          async with auth_db.get_session() as session:
              # Create user with related data
              user = AuthUser(email="integration_cascade@example.com")
              session.add(user)
              await session.commit()

              # Create related records
              session_obj = AuthSession(
                  user_id=user.id,
                  expires_at=datetime.now(timezone.utc) + timedelta(days=30),
                  device_id="integration_cascade_device"
              )
              session.add(session_obj)

              audit_log = AuthAuditLog(
                  event_type="integration_cascade_event",
                  user_id=user.id,
                  success=True
              )
              session.add(audit_log)

              reset_token = PasswordResetToken(
                  user_id=user.id,
                  token_hash="integration_cascade_token",
                  email=user.email,
                  expires_at=datetime.now(timezone.utc) + timedelta(hours=1)
              )
              session.add(reset_token)
              await session.commit()

              # Delete user (no cascade constraints, so related records remain orphaned)
              await session.delete(user)
              await session.commit()

              # Verify related records still exist but are orphaned
              orphaned_session = await session.get(AuthSession, session_obj.id)
              orphaned_audit = await session.get(AuthAuditLog, audit_log.id)
              orphaned_token = await session.get(PasswordResetToken, reset_token.id)

              assert orphaned_session is not None
              assert orphaned_audit is not None
              assert orphaned_token is not None

              # Clean up orphaned records
              await session.delete(orphaned_session)
              await session.delete(orphaned_audit)
              await session.delete(orphaned_token)
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 623
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              # Clean up all test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'"))
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_email_case_sensitivity" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 761&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_email_case_sensitivity(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test email case sensitivity in database&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with lowercase email&#10;              user1 = AuthUser(email=&quot;edge_case@example.com&quot;)&#10;              session.add(user1)&#10;              await session.commit()&#10;&#10;              # Try to create user with uppercase email (should be treated as different)&#10;              user2 = AuthUser(email=&quot;EDGE_CASE@EXAMPLE.COM&quot;)&#10;              session.add(user2)&#10;              await session.commit()&#10;&#10;              # Verify both users exist (database is case-sensitive)&#10;              lowercase_user = await session.execute(&#10;                  select(AuthUser).where(AuthUser.email == &quot;edge_case@example.com&quot;)&#10;              )&#10;              uppercase_user = await session.execute(&#10;                  select(AuthUser).where(AuthUser.email == &quot;EDGE_CASE@EXAMPLE.COM&quot;)&#10;              )&#10;&#10;              assert lowercase_user.scalar_one_or_none() is not None&#10;              assert uppercase_user.scalar_one_or_none() is not None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 761
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_email_case_sensitivity(self, real_services_fixture):
          """Test email case sensitivity in database"""
          async with auth_db.get_session() as session:
              # Create user with lowercase email
              user1 = AuthUser(email="edge_case@example.com")
              session.add(user1)
              await session.commit()

              # Try to create user with uppercase email (should be treated as different)
              user2 = AuthUser(email="EDGE_CASE@EXAMPLE.COM")
              session.add(user2)
              await session.commit()

              # Verify both users exist (database is case-sensitive)
              lowercase_user = await session.execute(
                  select(AuthUser).where(AuthUser.email == "edge_case@example.com")
              )
              uppercase_user = await session.execute(
                  select(AuthUser).where(AuthUser.email == "EDGE_CASE@EXAMPLE.COM")
              )

              assert lowercase_user.scalar_one_or_none() is not None
              assert uppercase_user.scalar_one_or_none() is not None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_long_text_fields" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 787&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_long_text_fields(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test handling of long text in string fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with very long name and user agent&#10;              long_name = &quot;A&quot; * 1000  # Very long name&#10;              long_user_agent = &quot;Mozilla/5.0 &quot; + &quot;X&quot; * 2000  # Very long user agent&#10;&#10;              user = AuthUser(&#10;                  email=&quot;edge_long_fields@example.com&quot;,&#10;                  full_name=long_name&#10;              )&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create session with long user agent&#10;              session_obj = AuthSession(&#10;                  user_id=user.id,&#10;                  user_agent=long_user_agent,&#10;                  expires_at=datetime.now(timezone.utc) + timedelta(days=30)&#10;              )&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Verify data is stored correctly (database handles long strings)&#10;              assert user.full_name == long_name&#10;              assert session_obj.user_agent == long_user_agent&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 787
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_long_text_fields(self, real_services_fixture):
          """Test handling of long text in string fields"""
          async with auth_db.get_session() as session:
              # Create user with very long name and user agent
              long_name = "A" * 1000  # Very long name
              long_user_agent = "Mozilla/5.0 " + "X" * 2000  # Very long user agent

              user = AuthUser(
                  email="edge_long_fields@example.com",
                  full_name=long_name
              )
              session.add(user)
              await session.commit()

              # Create session with long user agent
              session_obj = AuthSession(
                  user_id=user.id,
                  user_agent=long_user_agent,
                  expires_at=datetime.now(timezone.utc) + timedelta(days=30)
              )
              session.add(session_obj)
              await session.commit()

              # Verify data is stored correctly (database handles long strings)
              assert user.full_name == long_name
              assert session_obj.user_agent == long_user_agent
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_null_handling" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 816&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_null_handling(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test handling of NULL values in optional fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with minimal required fields&#10;              user = AuthUser(email=&quot;edge_null_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify NULL fields are handled correctly&#10;              assert user.full_name is None&#10;              assert user.hashed_password is None&#10;              assert user.provider_user_id is None&#10;              assert user.provider_data is None&#10;              assert user.last_login_at is None&#10;              assert user.locked_until is None&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 816
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_null_handling(self, real_services_fixture):
          """Test handling of NULL values in optional fields"""
          async with auth_db.get_session() as session:
              # Create user with minimal required fields
              user = AuthUser(email="edge_null_test@example.com")
              session.add(user)
              await session.commit()

              # Verify NULL fields are handled correctly
              assert user.full_name is None
              assert user.hashed_password is None
              assert user.provider_user_id is None
              assert user.provider_data is None
              assert user.last_login_at is None
              assert user.locked_until is None
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_timezone_handling" time="0.000"><error message="failed on setup with &quot;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 834&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_timezone_handling(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test timezone handling in datetime fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with specific timezone&#10;              specific_time = datetime(2024, 1, 1, 12, 0, 0, tzinfo=timezone.utc)&#10;&#10;              user = AuthUser(&#10;                  email=&quot;edge_timezone@example.com&quot;,&#10;                  last_login_at=specific_time&#10;              )&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Retrieve and verify timezone is preserved&#10;              retrieved_user = await session.get(AuthUser, user.id)&#10;              assert retrieved_user.last_login_at == specific_time&#10;              assert retrieved_user.last_login_at.tzinfo == timezone.utc&#10;file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213&quot;">file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 834
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_timezone_handling(self, real_services_fixture):
          """Test timezone handling in datetime fields"""
          async with auth_db.get_session() as session:
              # Create user with specific timezone
              specific_time = datetime(2024, 1, 1, 12, 0, 0, tzinfo=timezone.utc)

              user = AuthUser(
                  email="edge_timezone@example.com",
                  last_login_at=specific_time
              )
              session.add(user)
              await session.commit()

              # Retrieve and verify timezone is preserved
              retrieved_user = await session.get(AuthUser, user.id)
              assert retrieved_user.last_login_at == specific_time
              assert retrieved_user.last_login_at.tzinfo == timezone.utc
file /Users/anthony/Documents/GitHub/netra-apex/auth_service/tests/unit/test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file /Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _artifacts_recorder, _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _pw_artifacts_folder, _session_faker, _session_scoped_runner, _verify_url, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, base_url, browser, browser_channel, browser_context_args, browser_name, browser_type, browser_type_launch_args, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, connect_options, context, cov, database_connection, database_transaction, delete_output_dir, device, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, is_chromium, is_firefox, is_webkit, isolated_test_env, isolated_test_users, launch_browser, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, new_context, no_cover, output_path, package_mocker, page, performance_monitor, playwright, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

/Users/anthony/Documents/GitHub/netra-apex/test_framework/fixtures/real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_get_by_email_nonexistent" time="0.010" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_get_by_id_nonexistent" time="0.009" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_create_oauth_user" time="0.012" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_create_oauth_user_existing_updates" time="0.015" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_create_local_user" time="0.010" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_create_local_user_duplicate_email" time="0.014" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_update_login_time" time="0.015" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_failed_login_attempts" time="0.023" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthUserRepository" name="test_account_locking_after_failed_attempts" time="0.025" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthSessionRepository" name="test_create_session" time="0.010" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthSessionRepository" name="test_get_active_session" time="0.011" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthSessionRepository" name="test_revoke_session" time="0.014" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthSessionRepository" name="test_revoke_user_sessions" time="0.019" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthSessionRepository" name="test_cleanup_expired_sessions" time="0.014" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthAuditRepository" name="test_log_event" time="0.010" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthAuditRepository" name="test_log_failed_event" time="0.009" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthAuditRepository" name="test_get_user_events" time="0.016" /><testcase classname="tests.unit.test_database_repository_comprehensive.TestAuthAuditRepository" name="test_log_event_without_user" time="0.009" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_empty_url" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_none_url" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_invalid_scheme" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_postgresql_scheme" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_postgres_scheme" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_cloud_sql_url" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_cloud_sql_url_with_ssl_params" time="0.000"><failure message="AssertionError: assert 'SSL parameters will be automatically removed' in ['SSL parameters will be automatically removed for Cloud SQL Unix sockets']">tests/unit/test_database_staging_validation_comprehensive.py:94: in test_validate_cloud_sql_url_with_ssl_params
    assert "SSL parameters will be automatically removed" in result["recommendations"]
E   AssertionError: assert 'SSL parameters will be automatically removed' in ['SSL parameters will be automatically removed for Cloud SQL Unix sockets']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_tcp_url_with_sslmode" time="0.000"><failure message="AssertionError: assert 'sslmode will be converted to ssl' in ['sslmode will be converted to ssl for asyncpg compatibility']">tests/unit/test_database_staging_validation_comprehensive.py:105: in test_validate_tcp_url_with_sslmode
    assert "sslmode will be converted to ssl" in result["recommendations"]
E   AssertionError: assert 'sslmode will be converted to ssl' in ['sslmode will be converted to ssl for asyncpg compatibility']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_tcp_url_with_ssl_param" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_tcp_url_no_ssl" time="0.000"><failure message="AssertionError: assert 'No SSL parameters specified' in ['No SSL parameters specified for TCP connection']">tests/unit/test_database_staging_validation_comprehensive.py:126: in test_validate_tcp_url_no_ssl
    assert "No SSL parameters specified" in result["warnings"]
E   AssertionError: assert 'No SSL parameters specified' in ['No SSL parameters specified for TCP connection']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_localhost_warning" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_no_port_warning" time="0.000"><failure message="AssertionError: assert 'Port not specified' in ['No SSL parameters specified for TCP connection', 'Port not specified, will use default']">tests/unit/test_database_staging_validation_comprehensive.py:146: in test_validate_no_port_warning
    assert "Port not specified" in result["warnings"]
E   AssertionError: assert 'Port not specified' in ['No SSL parameters specified for TCP connection', 'Port not specified, will use default']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_no_hostname" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_malformed_cloud_sql_path" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_cloud_sql_missing_db_name" time="0.000"><failure message="AssertionError: assert 'Database name not specified' in []">tests/unit/test_database_staging_validation_comprehensive.py:175: in test_validate_cloud_sql_missing_db_name
    assert "Database name not specified" in result["warnings"]
E   AssertionError: assert 'Database name not specified' in []</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_no_username" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_no_password" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_problematic_username_pattern" time="0.000"><failure message="assert &quot;Invalid username pattern 'user_pr-4'&quot; in [&quot;Invalid username pattern 'user_pr-4' - this will cause authentication failures&quot;, 'Using insecure default password']">tests/unit/test_database_staging_validation_comprehensive.py:209: in test_validate_credentials_problematic_username_pattern
    assert "Invalid username pattern 'user_pr-4'" in result["credential_issues"]
E   assert "Invalid username pattern 'user_pr-4'" in ["Invalid username pattern 'user_pr-4' - this will cause authentication failures", 'Using insecure default password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_pr_pattern_username" time="0.000"><failure message="assert 'appears to be misconfigured PR-specific user' in [&quot;Invalid username pattern 'user_pr-123' - appears to be misconfigured PR-specific user&quot;, 'Using insecure default password']">tests/unit/test_database_staging_validation_comprehensive.py:219: in test_validate_credentials_pr_pattern_username
    assert "appears to be misconfigured PR-specific user" in result["credential_issues"]
E   assert 'appears to be misconfigured PR-specific user' in ["Invalid username pattern 'user_pr-123' - appears to be misconfigured PR-specific user", 'Using insecure default password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_postgres_username" time="0.000"><failure message="assert &quot;Username 'postgres' is acceptable for Cloud SQL&quot; in [&quot;Username 'postgres' is acceptable for Cloud SQL but ensure password is secure&quot;]">tests/unit/test_database_staging_validation_comprehensive.py:229: in test_validate_credentials_postgres_username
    assert "Username 'postgres' is acceptable for Cloud SQL" in result["recommendations"]
E   assert "Username 'postgres' is acceptable for Cloud SQL" in ["Username 'postgres' is acceptable for Cloud SQL but ensure password is secure"]</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_root_username" time="0.000"><failure message="assert False is True">tests/unit/test_database_staging_validation_comprehensive.py:237: in test_validate_credentials_root_username
    assert result["valid"] is True
E   assert False is True</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_insecure_password" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_short_password" time="0.000"><failure message="AssertionError: assert 'Use password with at least 8 characters' in ['Use password with at least 8 characters for security']">tests/unit/test_database_staging_validation_comprehensive.py:259: in test_validate_credentials_short_password
    assert "Use password with at least 8 characters" in result["recommendations"]
E   AssertionError: assert 'Use password with at least 8 characters' in ['Use password with at least 8 characters for security']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_numeric_password" time="0.000"><failure message="AssertionError: assert 'Password contains only numbers' in ['Using insecure default password']">tests/unit/test_database_staging_validation_comprehensive.py:268: in test_validate_credentials_numeric_password
    assert "Password contains only numbers" in result["credential_issues"]
E   AssertionError: assert 'Password contains only numbers' in ['Using insecure default password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_test_password" time="0.000"><failure message="AssertionError: assert 'appears to be a test/development password' in ['Password appears to be a test/development password']">tests/unit/test_database_staging_validation_comprehensive.py:278: in test_validate_credentials_test_password
    assert "appears to be a test/development password" in result["credential_issues"]
E   AssertionError: assert 'appears to be a test/development password' in ['Password appears to be a test/development password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_placeholder_password" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_variable_placeholder" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_staging_specific_checks" time="0.000"><failure message="assert 'Username appears to be development-specific' in ['Username appears to be development-specific in staging environment', &quot;Password contains 'dev' which may indicate development credentials&quot;]">tests/unit/test_database_staging_validation_comprehensive.py:306: in test_validate_credentials_staging_specific_checks
    assert "Username appears to be development-specific" in result["warnings"]
E   assert 'Username appears to be development-specific' in ['Username appears to be development-specific in staging environment', "Password contains 'dev' which may indicate development credentials"]</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_secure_example" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_parsing_error" time="0.000"><failure message="KeyError: 'error'">tests/unit/test_database_staging_validation_comprehensive.py:327: in test_validate_credentials_parsing_error
    assert "Credential validation failed" in result["error"]
                                             ^^^^^^^^^^^^^^^
E   KeyError: 'error'</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_cloud_sql_with_ssl_params" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_cloud_sql_ssl_not_removed" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_tcp_sslmode_conversion" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_tcp_sslmode_not_converted" time="0.000"><failure message="ModuleNotFoundError: No module named 'str'">tests/unit/test_database_staging_validation_comprehensive.py:369: in test_ssl_compatibility_tcp_sslmode_not_converted
    with patch('str.replace', return_value=tcp_url):
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/importlib/__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1324: in _find_and_load_unlocked
    ???
E   ModuleNotFoundError: No module named 'str'</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_tcp_with_ssl_param" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_error_handling" time="0.000"><failure message="assert True is False">tests/unit/test_database_staging_validation_comprehensive.py:391: in test_ssl_compatibility_error_handling
    assert result["valid"] is False
E   assert True is False</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_with_url" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_without_url" time="0.001"><failure message="AssertionError: assert 'postgresql://env_user:env_pass@env_host:5432/env_d...' == 'postgresql://env_user:env_pass@env_host:5432/env_db'&#10;  &#10;  - postgresql://env_user:env_pass@env_host:5432/env_db&#10;  ?                                                   ^&#10;  + postgresql://env_user:env_pass@env_host:5432/env_d...&#10;  ?                                                   ^^^">tests/unit/test_database_staging_validation_comprehensive.py:429: in test_pre_deployment_validation_without_url
    assert report["database_url"] == "postgresql://env_user:env_pass@env_host:5432/env_db"
E   AssertionError: assert 'postgresql://env_user:env_pass@env_host:5432/env_d...' == 'postgresql://env_user:env_pass@env_host:5432/env_db'
E     
E     - postgresql://env_user:env_pass@env_host:5432/env_db
E     ?                                                   ^
E     + postgresql://env_user:env_pass@env_host:5432/env_d...
E     ?                                                   ^^^</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_url_format_failure" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_credential_failure" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_ssl_failure" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_warnings_only" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_success" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_long_url_truncation" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_passed" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_failed" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_warning" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_unknown_status" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestValidateStagingDeploymentFunction" name="test_validate_staging_deployment_success" time="0.000"><failure message="AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n'&#10; +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n', err='').out">tests/unit/test_database_staging_validation_comprehensive.py:598: in test_validate_staging_deployment_success
    assert "Validation passed" in captured.out
E   AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n'
E    +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n', err='').out</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestValidateStagingDeploymentFunction" name="test_validate_staging_deployment_warning" time="0.000"><failure message="AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n'&#10; +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n', err='').out">tests/unit/test_database_staging_validation_comprehensive.py:616: in test_validate_staging_deployment_warning
    assert "Validation passed" in captured.out
E   AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n'
E    +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n', err='').out</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestValidateStagingDeploymentFunction" name="test_validate_staging_deployment_failure" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_url_format_validation_exception" time="0.000"><failure message="AssertionError: assert 'URL parsing failed: Parse error' in 'Invalid scheme: '">tests/unit/test_database_staging_validation_comprehensive.py:646: in test_url_format_validation_exception
    assert "URL parsing failed: Parse error" in result["error"]
E   AssertionError: assert 'URL parsing failed: Parse error' in 'Invalid scheme: '</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_credential_validation_exception" time="0.000"><failure message="KeyError: 'error'">tests/unit/test_database_staging_validation_comprehensive.py:655: in test_credential_validation_exception
    assert "Credential validation failed: Parse error" in result["error"]
                                                          ^^^^^^^^^^^^^^^
E   KeyError: 'error'</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_cloud_sql_database_name_extraction_edge_cases" time="0.000"><failure message="AssertionError: assert 'Database name not specified' in []">tests/unit/test_database_staging_validation_comprehensive.py:668: in test_cloud_sql_database_name_extraction_edge_cases
    assert "Database name not specified" in result2["warnings"]
E   AssertionError: assert 'Database name not specified' in []</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_regex_patterns_comprehensive" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_environment_specific_validation_branches" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_password_security_checks_comprehensive" time="0.000" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestMainModuleBehavior" name="test_main_module_success" time="0.000"><failure message="FileNotFoundError: [Errno 2] No such file or directory: 'auth_service/auth_core/database/staging_validation.py'">tests/unit/test_database_staging_validation_comprehensive.py:743: in test_main_module_success
    exec(open('auth_service/auth_core/database/staging_validation.py').read().split('if __name__ == "__main__":')[1])
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   FileNotFoundError: [Errno 2] No such file or directory: 'auth_service/auth_core/database/staging_validation.py'</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestMainModuleBehavior" name="test_main_module_failure" time="0.000"><failure message="FileNotFoundError: [Errno 2] No such file or directory: 'auth_service/auth_core/database/staging_validation.py'">tests/unit/test_database_staging_validation_comprehensive.py:756: in test_main_module_failure
    exec(open('auth_service/auth_core/database/staging_validation.py').read().split('if __name__ == "__main__":')[1])
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   FileNotFoundError: [Errno 2] No such file or directory: 'auth_service/auth_core/database/staging_validation.py'</failure></testcase><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_docker_detection_via_cgroup" time="0.005" /><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_docker_detection_via_dockerenv_file" time="0.004" /><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_docker_detection_via_env_variable" time="0.004" /><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_docker_hostname_resolution_with_components" time="0.004"><failure message="AssertionError: '/custom_db' not found in 'postgresql+asyncpg://test_user:test_pass@postgres:5432/test_db'">tests/unit/test_docker_hostname_resolution.py:198: in test_docker_hostname_resolution_with_components
    self.assertIn('/custom_db', db_url)
E   AssertionError: '/custom_db' not found in 'postgresql+asyncpg://test_user:test_pass@postgres:5432/test_db'</failure></testcase><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_docker_not_applied_in_production" time="0.004" /><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_docker_not_applied_in_staging" time="0.005" /><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_non_docker_environment" time="0.004" /><testcase classname="tests.unit.test_docker_hostname_resolution.TestDockerHostnameResolution" name="test_non_localhost_host_not_overridden" time="0.004" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderInitialization" name="test_provider_initializes_successfully" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderInitialization" name="test_provider_environment_detection" time="0.003" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderInitialization" name="test_provider_credentials_initialization" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderInitialization" name="test_provider_handles_missing_credentials_in_test" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderInitialization" name="test_provider_requires_credentials_in_production" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderConfiguration" name="test_is_configured_with_valid_credentials" time="0.001" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderConfiguration" name="test_is_configured_with_missing_credentials" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderConfiguration" name="test_validate_configuration_with_valid_data" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderConfiguration" name="test_validate_configuration_with_invalid_client_id" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderConfiguration" name="test_validate_configuration_with_invalid_client_secret" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderConfiguration" name="test_get_configuration_status" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderRedirectURI" name="test_get_redirect_uri_returns_valid_uri" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderRedirectURI" name="test_redirect_uri_environment_specific" time="0.003" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderRedirectURI" name="test_redirect_uri_consistency" time="0.001" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderAuthorizationURL" name="test_get_authorization_url_basic" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderAuthorizationURL" name="test_get_authorization_url_with_custom_scopes" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderAuthorizationURL" name="test_get_authorization_url_parameters" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderAuthorizationURL" name="test_get_authorization_url_without_client_id" time="0.003" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderCodeExchange" name="test_exchange_code_for_user_info_test_environment" time="0.001" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderCodeExchange" name="test_exchange_code_for_user_info_without_client_secret" time="0.003" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderCodeExchange" name="test_exchange_code_for_user_info_real_api_success" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderCodeExchange" name="test_exchange_code_for_user_info_token_request_failure" time="0.003" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderCodeExchange" name="test_exchange_code_for_user_info_no_access_token" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderCodeExchange" name="test_exchange_code_for_user_info_user_info_failure" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSelfCheck" name="test_self_check_with_valid_configuration" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSelfCheck" name="test_self_check_with_invalid_configuration" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSelfCheck" name="test_self_check_authorization_url_generation" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSelfCheck" name="test_self_check_includes_redirect_uri" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSelfCheck" name="test_self_check_client_id_privacy" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSecurity" name="test_state_parameter_required" time="0.001" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSecurity" name="test_redirect_uri_validation_by_environment" time="0.002"><failure message="AssertionError: Expected invalid for staging with http://localhost:8081/auth/callback, but was valid&#10;assert not True">tests/unit/test_google_oauth_comprehensive.py:756: in test_redirect_uri_validation_by_environment
    assert not is_valid, f"Expected invalid for {env} with {test_uri}, but was valid"
E   AssertionError: Expected invalid for staging with http://localhost:8081/auth/callback, but was valid
E   assert not True</failure></testcase><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSecurity" name="test_no_credential_exposure_in_errors" time="0.002"><failure message="Exception: Test error">tests/unit/test_google_oauth_comprehensive.py:774: in test_no_credential_exposure_in_errors
    provider.exchange_code_for_user_info("test-code", "test-state")
auth_core/oauth/google_oauth.py:166: in exchange_code_for_user_info
    token_response = requests.post(token_url, data=token_params)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1134: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1138: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:1193: in _execute_mock_call
    raise effect
E   Exception: Test error</failure></testcase><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderSecurity" name="test_input_sanitization" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderPerformance" name="test_provider_initialization_performance" time="0.002" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderPerformance" name="test_authorization_url_generation_performance" time="0.003" /><testcase classname="tests.unit.test_google_oauth_comprehensive.TestGoogleOAuthProviderPerformance" name="test_memory_usage_stability" time="0.130" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheBasics" name="test_cache_initialization" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheBasics" name="test_get_cache_key_generation" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheBasics" name="test_cache_and_retrieve_valid_payload" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheBasics" name="test_cache_and_retrieve_invalid_result" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheBasics" name="test_cache_expiration_removes_entries" time="1.104" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheBasics" name="test_jwt_token_expiration_handling" time="0.003" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheRedis" name="test_redis_cache_hit" time="0.003"><failure message="AssertionError: Expected 'get' to be called once. Called 0 times.">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:955: in assert_called_once_with
    raise AssertionError(msg)
E   AssertionError: Expected 'get' to be called once. Called 0 times.

During handling of the above exception, another exception occurred:
tests/unit/test_jwt_cache_comprehensive.py:162: in test_redis_cache_hit
    mock_redis_client.get.assert_called_once_with(f"jwt_cache:{self.cache_key}")
E   AssertionError: Expected 'get' to be called once. Called 0 times.</failure></testcase><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheRedis" name="test_redis_cache_miss" time="0.001"><failure message="assert 0 &gt; 0">tests/unit/test_jwt_cache_comprehensive.py:177: in test_redis_cache_miss
    assert self.cache._validation_stats["redis_misses"] &gt; 0
E   assert 0 &gt; 0</failure></testcase><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheRedis" name="test_redis_expired_token_removal" time="0.001"><failure message="AssertionError: Expected 'delete' to be called once. Called 0 times.">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:955: in assert_called_once_with
    raise AssertionError(msg)
E   AssertionError: Expected 'delete' to be called once. Called 0 times.

During handling of the above exception, another exception occurred:
tests/unit/test_jwt_cache_comprehensive.py:197: in test_redis_expired_token_removal
    mock_redis_client.delete.assert_called_once_with(f"jwt_cache:{self.cache_key}")
E   AssertionError: Expected 'delete' to be called once. Called 0 times.</failure></testcase><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheRedis" name="test_redis_connection_failure_fallback" time="0.001"><failure message="assert 0 &gt; 0">tests/unit/test_jwt_cache_comprehensive.py:209: in test_redis_connection_failure_fallback
    assert self.cache._validation_stats["redis_misses"] &gt; 0
E   assert 0 &gt; 0</failure></testcase><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheRedis" name="test_redis_disabled_uses_memory_only" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCachePerformance" name="test_cache_size_limit_enforcement" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCachePerformance" name="test_expired_entries_cleanup_on_size_limit" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCachePerformance" name="test_get_cache_stats_accuracy" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCachePerformance" name="test_performance_under_concurrent_access" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheUserInvalidation" name="test_invalidate_user_cache_memory_only" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheUserInvalidation" name="test_invalidate_user_cache_with_redis" time="0.002" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheUserInvalidation" name="test_invalidate_user_cache_redis_failure_graceful" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheClearAndMaintenance" name="test_clear_cache_memory_only" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheClearAndMaintenance" name="test_clear_cache_with_redis" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheClearAndMaintenance" name="test_clear_cache_redis_failure_graceful" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheAsyncOperations" name="test_async_redis_cache_write" time="0.002" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheAsyncOperations" name="test_async_redis_cache_write_failure" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheEdgeCases" name="test_cache_with_none_payload" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheEdgeCases" name="test_cache_with_invalid_json_payload" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheEdgeCases" name="test_get_cache_stats_with_zero_validations" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheEdgeCases" name="test_cache_key_with_empty_token" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheEdgeCases" name="test_memory_cache_corruption_handling" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheGlobalInstance" name="test_global_instance_exists" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheGlobalInstance" name="test_global_instance_functionality" time="0.001" /><testcase classname="tests.unit.test_jwt_cache_comprehensive.TestJWTValidationCacheGlobalInstance" name="test_global_instance_stats" time="0.001" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_service_token_creation_validation" time="0.002" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_cross_service_audience_validation" time="0.002" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_environment_bound_token_validation" time="0.002" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_service_authentication_flow_validation" time="0.002" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_token_consumption_vs_validation_security" time="0.002" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_service_signature_validation_security" time="0.001"><failure message="AssertionError: assert '4b7bf9df27aedac9ec6518ce4fb6e89e966fc3a089bfd66c69e7341b84688a24' != '4b7bf9df27aedac9ec6518ce4fb6e89e966fc3a089bfd66c69e7341b84688a24'">tests/unit/test_jwt_cross_service_validation.py:296: in test_service_signature_validation_security
    assert access_payload2["service_signature"] != access_signature
E   AssertionError: assert '4b7bf9df27aedac9ec6518ce4fb6e89e966fc3a089bfd66c69e7341b84688a24' != '4b7bf9df27aedac9ec6518ce4fb6e89e966fc3a089bfd66c69e7341b84688a24'</failure></testcase><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_clock_skew_tolerance_cross_service" time="0.002" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_complete_cross_service_security_flow" time="0.010" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_validates_token_structure_security" time="0.004" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_prevents_algorithm_confusion_attacks" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_validates_token_claims_security" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_token_blacklist_prevents_reuse" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_user_blacklist_invalidates_all_tokens" time="0.005" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_cross_service_token_validation" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_service_signature_validation" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_prevents_token_replay_attacks" time="0.003"><failure message="AssertionError: Token refresh should succeed&#10;assert None is not None">tests/unit/test_jwt_handler_batch4_comprehensive.py:362: in test_jwt_handler_prevents_token_replay_attacks
    assert new_tokens is not None, "Token refresh should succeed"
E   AssertionError: Token refresh should succeed
E   assert None is not None</failure></testcase><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_enforces_token_expiration_security" time="1.522" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_rejects_ancient_tokens_security" time="0.008" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_cache_security_validation" time="0.011" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_secure_error_handling" time="0.006" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerSecurityBatch4" name="test_jwt_handler_performance_stats_security" time="0.005" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerTokenOperationsBatch4" name="test_jwt_handler_creates_access_tokens_with_security_claims" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerTokenOperationsBatch4" name="test_jwt_handler_creates_refresh_tokens_with_user_data" time="0.003"><failure message="AssertionError: Refresh token should live longer than 24 hours&#10;assert 86400.0 &gt; (24 * 3600)&#10; +  where 86400.0 = &lt;built-in method total_seconds of datetime.timedelta object at 0x111656d60&gt;()&#10; +    where &lt;built-in method total_seconds of datetime.timedelta object at 0x111656d60&gt; = datetime.timedelta(days=1).total_seconds">tests/unit/test_jwt_handler_batch4_comprehensive.py:682: in test_jwt_handler_creates_refresh_tokens_with_user_data
    assert token_lifetime.total_seconds() &gt; 24 * 3600, "Refresh token should live longer than 24 hours"
E   AssertionError: Refresh token should live longer than 24 hours
E   assert 86400.0 &gt; (24 * 3600)
E    +  where 86400.0 = &lt;built-in method total_seconds of datetime.timedelta object at 0x111656d60&gt;()
E    +    where &lt;built-in method total_seconds of datetime.timedelta object at 0x111656d60&gt; = datetime.timedelta(days=1).total_seconds</failure></testcase><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerTokenOperationsBatch4" name="test_jwt_handler_refresh_access_token_preserves_user_data" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerTokenOperationsBatch4" name="test_jwt_handler_service_token_authentication" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerTokenOperationsBatch4" name="test_jwt_handler_validates_oauth_id_tokens" time="0.002" /><testcase classname="tests.unit.test_jwt_handler_batch4_comprehensive.TestJWTHandlerTokenOperationsBatch4" name="test_jwt_handler_user_id_extraction_utility" time="0.003" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_create_access_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_create_refresh_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_create_service_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_validate_valid_access_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_validate_invalid_token_type" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_validate_malformed_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_validate_expired_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_extract_user_id_from_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_extract_user_id_from_invalid_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_refresh_access_token_success" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_refresh_access_token_with_invalid_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_token_payload_contains_required_claims" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_token_issuer_is_correct" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_token_audience_is_correct" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBasics" name="test_token_jti_is_unique" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBlacklist" name="test_blacklist_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBlacklist" name="test_validate_blacklisted_token_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBlacklist" name="test_remove_token_from_blacklist" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBlacklist" name="test_blacklist_user" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBlacklist" name="test_validate_token_for_blacklisted_user_fails" time="0.002" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBlacklist" name="test_remove_user_from_blacklist" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerBlacklist" name="test_get_blacklist_info" time="0.000" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_token_with_none_algorithm_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_token_with_wrong_algorithm_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_token_with_invalid_issuer_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_token_with_invalid_audience_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_token_too_old_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_token_issued_in_future_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_id_token_basic" time="0.000" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_id_token_wrong_issuer_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_validate_id_token_expired_fails" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurity" name="test_mock_token_rejected_in_production" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerPerformance" name="test_get_performance_stats" time="0.000" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerPerformance" name="test_validate_token_caching" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerPerformance" name="test_token_structure_validation" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerPerformance" name="test_enhanced_jwt_claims_validation_fast" time="0.000" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_create_refresh_token_without_email" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_validate_token_for_consumption_with_replay_protection" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_cross_service_token_validation" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_service_signature_generation" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_cleanup_expired_token_ids" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_environment_binding_in_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_service_id_in_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_validate_token_jwt_alias" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_token_with_empty_permissions" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerEdgeCases" name="test_token_with_no_permissions" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecretManagement" name="test_get_jwt_secret_production_requires_secret" time="0.002" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecretManagement" name="test_get_jwt_secret_staging_requires_secret" time="0.002" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecretManagement" name="test_get_jwt_secret_production_requires_minimum_length" time="0.002" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecretManagement" name="test_get_jwt_secret_development_allows_empty" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecretManagement" name="test_get_jwt_secret_test_allows_empty" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_sync_blacklists_from_redis_success" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_load_blacklists_from_redis_success" time="0.002"><failure message="assert 0 &gt;= 2&#10; +  where 0 = len(set())&#10; +    where set() = &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x11116ee10&gt;._token_blacklist&#10; +      where &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x11116ee10&gt; = &lt;test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations object at 0x10fb5d340&gt;.handler">tests/unit/test_jwt_handler_comprehensive.py:627: in test_load_blacklists_from_redis_success
    assert len(self.handler._token_blacklist) &gt;= 2
E   assert 0 &gt;= 2
E    +  where 0 = len(set())
E    +    where set() = &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x11116ee10&gt;._token_blacklist
E    +      where &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x11116ee10&gt; = &lt;test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations object at 0x10fb5d340&gt;.handler</failure></testcase><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_load_blacklists_from_redis_disabled" time="0.002" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_persist_token_blacklist_success" time="0.002"><failure message="AssertionError: Expected 'sadd' to have been called once. Called 0 times.">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:923: in assert_called_once
    raise AssertionError(msg)
E   AssertionError: Expected 'sadd' to have been called once. Called 0 times.

During handling of the above exception, another exception occurred:
tests/unit/test_jwt_handler_comprehensive.py:649: in test_persist_token_blacklist_success
    mock_redis_client.sadd.assert_called_once()
E   AssertionError: Expected 'sadd' to have been called once. Called 0 times.</failure></testcase><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_persist_user_blacklist_success" time="0.002"><failure message="AssertionError: Expected 'sadd' to have been called once. Called 0 times.">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/unittest/mock.py:923: in assert_called_once
    raise AssertionError(msg)
E   AssertionError: Expected 'sadd' to have been called once. Called 0 times.

During handling of the above exception, another exception occurred:
tests/unit/test_jwt_handler_comprehensive.py:662: in test_persist_user_blacklist_success
    mock_redis_client.sadd.assert_called_once()
E   AssertionError: Expected 'sadd' to have been called once. Called 0 times.</failure></testcase><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_check_token_in_redis_found" time="0.002"><failure message="assert False is True">tests/unit/test_jwt_handler_comprehensive.py:674: in test_check_token_in_redis_found
    assert result is True
E   assert False is True</failure></testcase><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_check_user_in_redis_not_found" time="0.002" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_run_async_in_background_with_running_loop" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAsyncOperations" name="test_run_async_in_background_without_loop" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_enhanced_jwt_claims_full" time="0.001"><error message="failed on setup with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestJWTHandlerAsyncOperations.test_run_async_in_background_without_loop.&lt;locals&gt;.test_coro at 0x11162e820&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">/opt/homebrew/Cellar/python@3.12/3.12.3/Frameworks/Python.framework/Versions/3.12/lib/python3.12/warnings.py:553: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'TestJWTHandlerAsyncOperations.test_run_async_in_background_without_loop.&lt;locals&gt;.test_coro' was never awaited

The above exception was the direct cause of the following exception:
../venv/lib/python3.12/site-packages/_pytest/runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
../venv/lib/python3.12/site-packages/_pytest/runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../venv/lib/python3.12/site-packages/_pytest/logging.py:843: in pytest_runtest_setup
    yield
../venv/lib/python3.12/site-packages/_pytest/capture.py:895: in pytest_runtest_setup
    return (yield)
            ^^^^^
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:153: in pytest_runtest_setup
    collect_unraisable(item.config)
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:79: in collect_unraisable
    raise errors[0]
../venv/lib/python3.12/site-packages/_pytest/unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object TestJWTHandlerAsyncOperations.test_run_async_in_background_without_loop.&lt;locals&gt;.test_coro at 0x11162e820&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_enhanced_jwt_claims_invalid_issuer" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_enhanced_jwt_claims_invalid_audience" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_enhanced_jwt_claims_environment_mismatch" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_enhanced_jwt_claims_service_id_mismatch" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_enhanced_jwt_claims_missing_jti_allowed" time="0.001"><failure message="assert False is True">tests/unit/test_jwt_handler_comprehensive.py:787: in test_validate_enhanced_jwt_claims_missing_jti_allowed
    assert result is True
E   assert False is True</failure></testcase><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_cross_service_token_development_permissive" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_cross_service_token_future_issued" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_cross_service_token_too_old" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerAdvancedValidation" name="test_validate_cross_service_token_with_replay_protection" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerTokenIdTracking" name="test_track_and_check_token_id" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerTokenIdTracking" name="test_cleanup_expired_token_ids_threshold" time="0.007" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerTokenIdTracking" name="test_cleanup_expired_token_ids_manual" time="0.001"><failure message="AssertionError: assert 100 == 0&#10; +  where 100 = len({'manual_token_21', 'manual_token_89', 'manual_token_28', 'manual_token_93', 'manual_token_75', 'manual_token_63', 'manual_token_29', 'manual_token_9', 'manual_token_97', 'manual_token_47', 'manual_token_23', 'manual_token_83', 'manual_token_60', 'manual_token_37', 'manual_token_11', 'manual_token_43', 'manual_token_16', 'manual_token_61', 'manual_token_76', 'manual_token_72', 'manual_token_92', 'manual_token_32', 'manual_token_18', 'manual_token_20', 'manual_token_80', 'manual_token_22', 'manual_token_64', 'manual_token_46', 'manual_token_90', 'manual_token_77', 'manual_token_41', 'manual_token_53', 'manual_token_86', 'manual_token_71', 'manual_token_36', 'manual_token_88', 'manual_token_10', 'manual_token_39', 'manual_token_5', 'manual_token_31', 'manual_token_59', 'manual_token_19', 'manual_token_4', 'manual_token_42', 'manual_token_8', 'manual_token_48', 'manual_token_3', 'manual_token_35', 'manual_token_0', 'manual_token_68', 'manual_token_87', 'manual_token_82', 'manual_token_91', 'manual_token_54', 'manual_token_6', 'manual_token_73', 'manual_token_95', 'manual_token_99', 'manual_token_57', 'manual_token_58', 'manual_token_26', 'manual_token_15', 'manual_token_12', 'manual_token_7', 'manual_token_65', 'manual_token_40', 'manual_token_69', 'manual_token_1', 'manual_token_79', 'manual_token_45', 'manual_token_30', 'manual_token_52', 'manual_token_98', 'manual_token_44', 'manual_token_25', 'manual_token_56', 'manual_token_66', 'manual_token_81', 'manual_token_14', 'manual_token_24', 'manual_token_74', 'manual_token_27', 'manual_token_55', 'manual_token_2', 'manual_token_50', 'manual_token_49', 'manual_token_84', 'manual_token_85', 'manual_token_34', 'manual_token_38', 'manual_token_62', 'manual_token_96', 'manual_token_67', 'manual_token_51', 'manual_token_70', 'manual_token_94', 'manual_token_78', 'manual_token_17', 'manual_token_33', 'manual_token_13'})&#10; +    where {'manual_token_21', 'manual_token_89', 'manual_token_28', 'manual_token_93', 'manual_token_75', 'manual_token_63', 'manual_token_29', 'manual_token_9', 'manual_token_97', 'manual_token_47', 'manual_token_23', 'manual_token_83', 'manual_token_60', 'manual_token_37', 'manual_token_11', 'manual_token_43', 'manual_token_16', 'manual_token_61', 'manual_token_76', 'manual_token_72', 'manual_token_92', 'manual_token_32', 'manual_token_18', 'manual_token_20', 'manual_token_80', 'manual_token_22', 'manual_token_64', 'manual_token_46', 'manual_token_90', 'manual_token_77', 'manual_token_41', 'manual_token_53', 'manual_token_86', 'manual_token_71', 'manual_token_36', 'manual_token_88', 'manual_token_10', 'manual_token_39', 'manual_token_5', 'manual_token_31', 'manual_token_59', 'manual_token_19', 'manual_token_4', 'manual_token_42', 'manual_token_8', 'manual_token_48', 'manual_token_3', 'manual_token_35', 'manual_token_0', 'manual_token_68', 'manual_token_87', 'manual_token_82', 'manual_token_91', 'manual_token_54', 'manual_token_6', 'manual_token_73', 'manual_token_95', 'manual_token_99', 'manual_token_57', 'manual_token_58', 'manual_token_26', 'manual_token_15', 'manual_token_12', 'manual_token_7', 'manual_token_65', 'manual_token_40', 'manual_token_69', 'manual_token_1', 'manual_token_79', 'manual_token_45', 'manual_token_30', 'manual_token_52', 'manual_token_98', 'manual_token_44', 'manual_token_25', 'manual_token_56', 'manual_token_66', 'manual_token_81', 'manual_token_14', 'manual_token_24', 'manual_token_74', 'manual_token_27', 'manual_token_55', 'manual_token_2', 'manual_token_50', 'manual_token_49', 'manual_token_84', 'manual_token_85', 'manual_token_34', 'manual_token_38', 'manual_token_62', 'manual_token_96', 'manual_token_67', 'manual_token_51', 'manual_token_70', 'manual_token_94', 'manual_token_78', 'manual_token_17', 'manual_token_33', 'manual_token_13'} = &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x111607c20&gt;._used_token_ids&#10; +      where &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x111607c20&gt; = &lt;test_jwt_handler_comprehensive.TestJWTHandlerTokenIdTracking object at 0x10fb7c800&gt;.handler">tests/unit/test_jwt_handler_comprehensive.py:888: in test_cleanup_expired_token_ids_manual
    assert len(self.handler._used_token_ids) == 0
E   AssertionError: assert 100 == 0
E    +  where 100 = len({'manual_token_21', 'manual_token_89', 'manual_token_28', 'manual_token_93', 'manual_token_75', 'manual_token_63', 'manual_token_29', 'manual_token_9', 'manual_token_97', 'manual_token_47', 'manual_token_23', 'manual_token_83', 'manual_token_60', 'manual_token_37', 'manual_token_11', 'manual_token_43', 'manual_token_16', 'manual_token_61', 'manual_token_76', 'manual_token_72', 'manual_token_92', 'manual_token_32', 'manual_token_18', 'manual_token_20', 'manual_token_80', 'manual_token_22', 'manual_token_64', 'manual_token_46', 'manual_token_90', 'manual_token_77', 'manual_token_41', 'manual_token_53', 'manual_token_86', 'manual_token_71', 'manual_token_36', 'manual_token_88', 'manual_token_10', 'manual_token_39', 'manual_token_5', 'manual_token_31', 'manual_token_59', 'manual_token_19', 'manual_token_4', 'manual_token_42', 'manual_token_8', 'manual_token_48', 'manual_token_3', 'manual_token_35', 'manual_token_0', 'manual_token_68', 'manual_token_87', 'manual_token_82', 'manual_token_91', 'manual_token_54', 'manual_token_6', 'manual_token_73', 'manual_token_95', 'manual_token_99', 'manual_token_57', 'manual_token_58', 'manual_token_26', 'manual_token_15', 'manual_token_12', 'manual_token_7', 'manual_token_65', 'manual_token_40', 'manual_token_69', 'manual_token_1', 'manual_token_79', 'manual_token_45', 'manual_token_30', 'manual_token_52', 'manual_token_98', 'manual_token_44', 'manual_token_25', 'manual_token_56', 'manual_token_66', 'manual_token_81', 'manual_token_14', 'manual_token_24', 'manual_token_74', 'manual_token_27', 'manual_token_55', 'manual_token_2', 'manual_token_50', 'manual_token_49', 'manual_token_84', 'manual_token_85', 'manual_token_34', 'manual_token_38', 'manual_token_62', 'manual_token_96', 'manual_token_67', 'manual_token_51', 'manual_token_70', 'manual_token_94', 'manual_token_78', 'manual_token_17', 'manual_token_33', 'manual_token_13'})
E    +    where {'manual_token_21', 'manual_token_89', 'manual_token_28', 'manual_token_93', 'manual_token_75', 'manual_token_63', 'manual_token_29', 'manual_token_9', 'manual_token_97', 'manual_token_47', 'manual_token_23', 'manual_token_83', 'manual_token_60', 'manual_token_37', 'manual_token_11', 'manual_token_43', 'manual_token_16', 'manual_token_61', 'manual_token_76', 'manual_token_72', 'manual_token_92', 'manual_token_32', 'manual_token_18', 'manual_token_20', 'manual_token_80', 'manual_token_22', 'manual_token_64', 'manual_token_46', 'manual_token_90', 'manual_token_77', 'manual_token_41', 'manual_token_53', 'manual_token_86', 'manual_token_71', 'manual_token_36', 'manual_token_88', 'manual_token_10', 'manual_token_39', 'manual_token_5', 'manual_token_31', 'manual_token_59', 'manual_token_19', 'manual_token_4', 'manual_token_42', 'manual_token_8', 'manual_token_48', 'manual_token_3', 'manual_token_35', 'manual_token_0', 'manual_token_68', 'manual_token_87', 'manual_token_82', 'manual_token_91', 'manual_token_54', 'manual_token_6', 'manual_token_73', 'manual_token_95', 'manual_token_99', 'manual_token_57', 'manual_token_58', 'manual_token_26', 'manual_token_15', 'manual_token_12', 'manual_token_7', 'manual_token_65', 'manual_token_40', 'manual_token_69', 'manual_token_1', 'manual_token_79', 'manual_token_45', 'manual_token_30', 'manual_token_52', 'manual_token_98', 'manual_token_44', 'manual_token_25', 'manual_token_56', 'manual_token_66', 'manual_token_81', 'manual_token_14', 'manual_token_24', 'manual_token_74', 'manual_token_27', 'manual_token_55', 'manual_token_2', 'manual_token_50', 'manual_token_49', 'manual_token_84', 'manual_token_85', 'manual_token_34', 'manual_token_38', 'manual_token_62', 'manual_token_96', 'manual_token_67', 'manual_token_51', 'manual_token_70', 'manual_token_94', 'manual_token_78', 'manual_token_17', 'manual_token_33', 'manual_token_13'} = &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x111607c20&gt;._used_token_ids
E    +      where &lt;auth_service.auth_core.core.jwt_handler.JWTHandler object at 0x111607c20&gt; = &lt;test_jwt_handler_comprehensive.TestJWTHandlerTokenIdTracking object at 0x10fb7c800&gt;.handler</failure></testcase><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurityConsolidated" name="test_validate_token_security_consolidated_valid" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurityConsolidated" name="test_validate_token_security_consolidated_invalid_structure" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurityConsolidated" name="test_validate_jwt_structure_valid_token" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurityConsolidated" name="test_validate_jwt_structure_invalid_base64" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurityConsolidated" name="test_validate_jwt_structure_invalid_json" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerSecurityConsolidated" name="test_validate_jwt_structure_empty_parts" time="0.001" /><testcase classname="tests.unit.test_jwt_handler_comprehensive.TestJWTHandlerMockTokenSecurity" name="test_validate_token_rejects_mock_tokens" time="0.001" /><testcase time="0.001" /><testcase classname="pytest" name="internal" time="0.000"><error message="internal error">Traceback (most recent call last):
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/main.py", line 289, in wrap_session
    session.exitstatus = doit(config, session) or 0
                         ^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/main.py", line 343, in _main
    config.hook.pytest_runtestloop(session=session)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_hooks.py", line 512, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 167, in _multicall
    raise exception
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/logging.py", line 801, in pytest_runtestloop
    return (yield)  # Run all the tests.
            ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/terminal.py", line 688, in pytest_runtestloop
    result = yield
             ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pytest_cov/plugin.py", line 340, in pytest_runtestloop
    result = yield
             ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 121, in _multicall
    res = hook_impl.function(*args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/main.py", line 367, in pytest_runtestloop
    item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_hooks.py", line 512, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 167, in _multicall
    raise exception
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/warnings.py", line 90, in pytest_runtest_protocol
    return (yield)
            ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/assertion/__init__.py", line 192, in pytest_runtest_protocol
    return (yield)
            ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 53, in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_result.py", line 103, in get_result
    raise exc.with_traceback(tb)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 38, in run_old_style_hookwrapper
    res = yield
          ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/unittest.py", line 475, in pytest_runtest_protocol
    return (yield)
            ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 139, in _multicall
    teardown.throw(exception)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/faulthandler.py", line 88, in pytest_runtest_protocol
    return (yield)
            ^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 121, in _multicall
    res = hook_impl.function(*args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/runner.py", line 117, in pytest_runtest_protocol
    runtestprotocol(item, nextitem=nextitem)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/runner.py", line 136, in runtestprotocol
    reports.append(call_and_report(item, "call", log))
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/runner.py", line 250, in call_and_report
    ihook.pytest_runtest_logreport(report=report)
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_hooks.py", line 512, in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_manager.py", line 120, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 167, in _multicall
    raise exception
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/pluggy/_callers.py", line 121, in _multicall
    res = hook_impl.function(*args)
          ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/terminal.py", line 679, in pytest_runtest_logreport
    self.flush()
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/terminal.py", line 512, in flush
    self._tw.flush()
  File "/Users/anthony/Documents/GitHub/netra-apex/venv/lib/python3.12/site-packages/_pytest/_io/terminalwriter.py", line 184, in flush
    self._file.flush()
BrokenPipeError: [Errno 32] Broken pipe</error></testcase></testsuite></testsuites>