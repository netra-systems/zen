"""
Comprehensive Multi-Environment OAuth Integration Tests

Business Value Justification (BVJ):
- Segment: All (Free, Early, Mid, Enterprise) 
- Business Goal: Ensure OAuth flows work correctly across all deployment environments
- Value Impact: Prevents $75K+ MRR loss from OAuth authentication failures during deployments
- Strategic Impact: Validates OAuth security model prevents cross-environment credential leakage
- Revenue Impact: OAuth failures = complete user lockout = 100% revenue impact until resolved

CRITICAL MULTI-ENVIRONMENT SECURITY REQUIREMENTS:
Multi-environment OAuth security is fundamental to platform security:
- Development credentials CANNOT be used in staging/production
- Staging credentials CANNOT be used in production
- Production credentials CANNOT leak to other environments
- Each environment has isolated OAuth callback URLs
- Environment-specific redirect URI validation
- Configuration inheritance rules prevent accidental cross-pollination

INTEGRATION TESTING METHODOLOGY:
- Real AuthEnvironment and GoogleOAuthProvider instances
- Real IsolatedEnvironment configuration management
- Real multi-environment configuration scenarios
- Real OAuth flow validation (without external API calls)
- Real environment isolation testing
- Real configuration validation across environment transitions

CLAUDE.MD COMPLIANCE:
- Uses SSOT BaseTestCase for isolated environment management
- NO business logic mocks - tests real integration behavior  
- Real services integration patterns
- Tests fail hard when security requirements violated
- Comprehensive cross-environment validation scenarios
"""
import pytest
import os
import time
from typing import Dict, Any, List, Tuple, Optional
from unittest.mock import patch, Mock, MagicMock
from test_framework.ssot.base_test_case import SSotBaseTestCase
from auth_service.auth_core.oauth.google_oauth import GoogleOAuthProvider, GoogleOAuthError
from auth_service.auth_core.auth_environment import AuthEnvironment, get_auth_env
from auth_service.auth_core.secret_loader import AuthSecretLoader
from shared.isolated_environment import get_env

class MultiEnvironmentOAuthConfigurationIntegrationTests(SSotBaseTestCase):
    """Test OAuth configuration integration across multiple environments."""

    def setup_method(self, method=None):
        """Setup for each test method with realistic multi-env configuration."""
        super().setup_method(method)
        self.env_credentials = {'development': {'client_id': 'dev-123456789-abcdefghijklmnop.apps.googleusercontent.com', 'client_secret': 'GOCSPX-dev-abcdefghijklmnopqrstuvwx', 'auth_service_url': 'http://localhost:8081'}, 'test': {'client_id': 'test-123456789-abcdefghijklmnop.apps.googleusercontent.com', 'client_secret': 'GOCSPX-test-abcdefghijklmnopqrstuvwx', 'auth_service_url': 'http://localhost:8082'}, 'staging': {'client_id': 'staging-123456789-abcdefghijklmnop.apps.googleusercontent.com', 'client_secret': 'GOCSPX-staging-abcdefghijklmnopqrstuvwx', 'auth_service_url': 'https://auth.staging.netrasystems.ai'}, 'production': {'client_id': 'prod-123456789-abcdefghijklmnop.apps.googleusercontent.com', 'client_secret': 'GOCSPX-prod-abcdefghijklmnopqrstuvwx', 'auth_service_url': 'https://auth.netrasystems.ai'}}

    def test_oauth_configuration_environment_isolation(self):
        """Test OAuth configuration maintains strict environment isolation."""
        environments = ['development', 'test', 'staging', 'production']
        provider_configs = {}
        for env in environments:
            creds = self.env_credentials[env]
            with self.temp_env_vars(ENVIRONMENT=env, AUTH_SERVICE_URL=creds['auth_service_url']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = creds['client_id']
                    mock_secret.return_value = creds['client_secret']
                    provider = GoogleOAuthProvider()
                    config = provider.get_configuration_status()
                    provider_configs[env] = {'client_id': provider.client_id, 'client_secret': provider.client_secret, 'redirect_uri': provider.get_redirect_uri(), 'environment': provider.env, 'config_status': config}
                    assert provider.env == env
                    assert provider.client_id == creds['client_id']
                    assert provider.client_secret == creds['client_secret']
                    redirect_uri = provider.get_redirect_uri()
                    if redirect_uri:
                        assert creds['auth_service_url'] in redirect_uri
        for env1 in environments:
            for env2 in environments:
                if env1 != env2:
                    config1 = provider_configs[env1]
                    config2 = provider_configs[env2]
                    assert config1['client_id'] != config2['client_id'], f'Client ID leaked between {env1} and {env2}'
                    assert config1['client_secret'] != config2['client_secret'], f'Client secret leaked between {env1} and {env2}'
                    if config1['redirect_uri'] and config2['redirect_uri']:
                        assert config1['redirect_uri'] != config2['redirect_uri'], f'Redirect URI leaked between {env1} and {env2}'
        self.record_metric('environments_tested', len(environments))
        self.record_metric('cross_environment_validations', len(environments) * (len(environments) - 1))

    def test_oauth_environment_transition_security(self):
        """Test OAuth security during environment transitions (deployment scenarios)."""
        transition_scenarios = [('development', 'staging'), ('staging', 'production'), ('test', 'staging'), ('production', 'staging')]
        for from_env, to_env in transition_scenarios:
            from_creds = self.env_credentials[from_env]
            with self.temp_env_vars(ENVIRONMENT=from_env, AUTH_SERVICE_URL=from_creds['auth_service_url']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = from_creds['client_id']
                    mock_secret.return_value = from_creds['client_secret']
                    provider1 = GoogleOAuthProvider()
                    config1 = provider1.get_configuration_status()
            to_creds = self.env_credentials[to_env]
            with self.temp_env_vars(ENVIRONMENT=to_env, AUTH_SERVICE_URL=to_creds['auth_service_url']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = to_creds['client_id']
                    mock_secret.return_value = to_creds['client_secret']
                    provider2 = GoogleOAuthProvider()
                    config2 = provider2.get_configuration_status()
            assert provider1.env == from_env
            assert provider2.env == to_env
            assert provider1.client_id != provider2.client_id, f'Client ID carried over from {from_env} to {to_env}'
            assert provider1.client_secret != provider2.client_secret, f'Client secret carried over from {from_env} to {to_env}'
            if provider1.get_redirect_uri() and provider2.get_redirect_uri():
                assert provider1.get_redirect_uri() != provider2.get_redirect_uri(), f'Redirect URI carried over from {from_env} to {to_env}'
        self.record_metric('transition_scenarios_tested', len(transition_scenarios))

    def test_oauth_configuration_validation_across_environments(self):
        """Test OAuth configuration validation works correctly in each environment."""
        validation_results = {}
        for env in ['development', 'test', 'staging', 'production']:
            creds = self.env_credentials[env]
            with self.temp_env_vars(ENVIRONMENT=env, AUTH_SERVICE_URL=creds['auth_service_url']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = creds['client_id']
                    mock_secret.return_value = creds['client_secret']
                    provider = GoogleOAuthProvider()
                    is_valid, message = provider.validate_configuration()
                    self_check = provider.self_check()
                    validation_results[env] = {'is_valid': is_valid, 'message': message, 'self_check': self_check, 'is_configured': provider.is_configured(), 'redirect_uri': provider.get_redirect_uri()}
                    assert is_valid, f'OAuth configuration invalid in {env}: {message}'
                    assert provider.is_configured(), f'OAuth not properly configured in {env}'
                    assert self_check['is_healthy'], f'OAuth self-check failed in {env}: {self_check}'
                    redirect_uri = provider.get_redirect_uri()
                    if redirect_uri:
                        if env == 'production':
                            assert 'localhost' not in redirect_uri, f'Production redirect URI contains localhost: {redirect_uri}'
                            assert 'staging' not in redirect_uri, f'Production redirect URI contains staging: {redirect_uri}'
                        elif env == 'staging':
                            assert 'netrasystems.ai' in redirect_uri or 'localhost' in redirect_uri, f'Staging redirect URI invalid: {redirect_uri}'
        self.record_metric('environment_validations_completed', len(validation_results))
        for env, result in validation_results.items():
            assert result['is_valid'], f'Environment {env} failed validation'

    def test_oauth_authorization_url_generation_multi_environment(self):
        """Test OAuth authorization URL generation across environments."""
        auth_urls = {}
        for env in ['development', 'staging', 'production']:
            creds = self.env_credentials[env]
            with self.temp_env_vars(ENVIRONMENT=env, AUTH_SERVICE_URL=creds['auth_service_url']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = creds['client_id']
                    mock_secret.return_value = creds['client_secret']
                    provider = GoogleOAuthProvider()
                    state = f'{env}-test-state-123'
                    auth_url = provider.get_authorization_url(state)
                    auth_urls[env] = {'url': auth_url, 'state': state, 'redirect_uri': provider.get_redirect_uri()}
                    assert auth_url.startswith('https://accounts.google.com/o/oauth2/auth')
                    assert f"client_id={creds['client_id']}" in auth_url
                    assert f'state={state}' in auth_url
                    if provider.get_redirect_uri():
                        redirect_uri = provider.get_redirect_uri()
                        assert redirect_uri in auth_url, f'Redirect URI {redirect_uri} not found in auth URL'
                        assert creds['auth_service_url'] in redirect_uri, f'Auth service URL not in redirect URI: {redirect_uri}'
        environments = list(auth_urls.keys())
        for i, env1 in enumerate(environments):
            for env2 in environments[i + 1:]:
                url1 = auth_urls[env1]['url']
                url2 = auth_urls[env2]['url']
                assert url1 != url2, f'Auth URLs identical between {env1} and {env2}'
        self.record_metric('auth_urls_generated', len(auth_urls))

class MultiEnvironmentOAuthAuthSecretLoaderIntegrationTests(SSotBaseTestCase):
    """Test OAuth integration with AuthSecretLoader across environments."""

    def setup_method(self, method=None):
        """Setup for each test method."""
        super().setup_method(method)

    def test_auth_secret_loader_environment_specific_credentials(self):
        """Test AuthSecretLoader provides environment-specific OAuth credentials."""
        environments = ['development', 'test', 'staging', 'production']
        loaded_credentials = {}
        for env in environments:
            env_vars = {'ENVIRONMENT': env, f'GOOGLE_OAUTH_CLIENT_ID_{env.upper()}': f'{env}-client-id.apps.googleusercontent.com', f'GOOGLE_OAUTH_CLIENT_SECRET_{env.upper()}': f'GOCSPX-{env}-client-secret'}
            with self.temp_env_vars(**env_vars):
                with patch('auth_service.auth_core.secret_loader.get_central_validator') as mock_get_validator:
                    mock_validator = Mock()
                    mock_validator.get_oauth_client_id.return_value = env_vars[f'GOOGLE_OAUTH_CLIENT_ID_{env.upper()}']
                    mock_validator.get_oauth_client_secret.return_value = env_vars[f'GOOGLE_OAUTH_CLIENT_SECRET_{env.upper()}']
                    mock_validator.get_environment.return_value = Mock(value=env)
                    mock_get_validator.return_value = mock_validator
                    client_id = AuthSecretLoader.get_google_client_id()
                    client_secret = AuthSecretLoader.get_google_client_secret()
                    loaded_credentials[env] = {'client_id': client_id, 'client_secret': client_secret}
                    assert client_id == env_vars[f'GOOGLE_OAUTH_CLIENT_ID_{env.upper()}']
                    assert client_secret == env_vars[f'GOOGLE_OAUTH_CLIENT_SECRET_{env.upper()}']
        for env1 in environments:
            for env2 in environments:
                if env1 != env2:
                    creds1 = loaded_credentials[env1]
                    creds2 = loaded_credentials[env2]
                    assert creds1['client_id'] != creds2['client_id'], f'Client ID contamination between {env1} and {env2}'
                    assert creds1['client_secret'] != creds2['client_secret'], f'Client secret contamination between {env1} and {env2}'
        self.record_metric('secret_loader_environments_tested', len(environments))

    def test_auth_secret_loader_oauth_integration_with_provider(self):
        """Test full integration between AuthSecretLoader and GoogleOAuthProvider."""
        test_scenarios = [{'env': 'staging', 'client_id': 'staging-oauth-integration.apps.googleusercontent.com', 'client_secret': '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cret', 'auth_url': 'https://auth.staging.netrasystems.ai'}, {'env': 'production', 'client_id': 'prod-oauth-integration.apps.googleusercontent.com', 'client_secret': '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t', 'auth_url': 'https://auth.netrasystems.ai'}]
        for scenario in test_scenarios:
            with self.temp_env_vars(ENVIRONMENT=scenario['env'], AUTH_SERVICE_URL=scenario['auth_url']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = scenario['client_id']
                    mock_secret.return_value = scenario['client_secret']
                    provider = GoogleOAuthProvider()
                    assert provider.client_id == scenario['client_id']
                    assert provider.client_secret == scenario['client_secret']
                    assert provider.env == scenario['env']
                    assert provider.is_configured()
                    is_valid, message = provider.validate_configuration()
                    assert is_valid, f"OAuth validation failed for {scenario['env']}: {message}"
                    state = f"integration-test-{scenario['env']}"
                    auth_url = provider.get_authorization_url(state)
                    assert scenario['client_id'] in auth_url
                    assert state in auth_url
                    assert provider.get_redirect_uri() in auth_url
                    self_check = provider.self_check()
                    assert self_check['is_healthy']
                    assert self_check['environment'] == scenario['env']
        self.record_metric('integration_scenarios_tested', len(test_scenarios))

class MultiEnvironmentOAuthErrorHandlingIntegrationTests(SSotBaseTestCase):
    """Test OAuth error handling integration across environments."""

    def setup_method(self, method=None):
        """Setup for each test method."""
        super().setup_method(method)

    def test_oauth_missing_credentials_error_handling_by_environment(self):
        """Test OAuth missing credentials error handling varies by environment."""
        error_scenarios = [{'env': 'development', 'client_id': None, 'client_secret': None, 'should_raise': False, 'expected_configured': False}, {'env': 'test', 'client_id': None, 'client_secret': None, 'should_raise': False, 'expected_configured': False}, {'env': 'staging', 'client_id': None, 'client_secret': None, 'should_raise': True, 'expected_configured': None}, {'env': 'production', 'client_id': None, 'client_secret': None, 'should_raise': True, 'expected_configured': None}]
        for scenario in error_scenarios:
            with self.temp_env_vars(ENVIRONMENT=scenario['env']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = scenario['client_id']
                    mock_secret.return_value = scenario['client_secret']
                    if scenario['should_raise']:
                        with self.expect_exception(GoogleOAuthError, f"not configured for {scenario['env']}"):
                            GoogleOAuthProvider()
                    else:
                        provider = GoogleOAuthProvider()
                        assert provider.env == scenario['env']
                        assert provider.is_configured() == scenario['expected_configured']
                        assert provider.client_id == scenario['client_id']
                        assert provider.client_secret == scenario['client_secret']
                        is_valid, message = provider.validate_configuration()
                        assert not is_valid
                        assert len(message) > 0
        self.record_metric('error_scenarios_tested', len(error_scenarios))

    def test_oauth_partial_credentials_error_handling(self):
        """Test OAuth partial credentials error handling across environments."""
        partial_credential_scenarios = [{'env': 'staging', 'client_id': 'staging-partial.apps.googleusercontent.com', 'client_secret': None, 'expected_error': 'client secret not configured'}, {'env': 'production', 'client_id': None, 'client_secret': 'GOCSPX-prod-partial-secret', 'expected_error': 'client ID not configured'}]
        for scenario in partial_credential_scenarios:
            with self.temp_env_vars(ENVIRONMENT=scenario['env']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = scenario['client_id']
                    mock_secret.return_value = scenario['client_secret']
                    with self.expect_exception(GoogleOAuthError, scenario['expected_error']):
                        GoogleOAuthProvider()
        self.record_metric('partial_credential_scenarios_tested', len(partial_credential_scenarios))

class MultiEnvironmentOAuthEndToEndIntegrationTests(SSotBaseTestCase):
    """Test end-to-end OAuth integration across environments."""

    def setup_method(self, method=None):
        """Setup for each test method."""
        super().setup_method(method)

    def test_complete_oauth_flow_integration_multi_environment(self):
        """Test complete OAuth flow integration works in each environment."""
        complete_flow_scenarios = [{'env': 'development', 'client_id': 'dev-complete.apps.googleusercontent.com', 'client_secret': 'GOCSPX-dev-complete-secret', 'auth_service_url': 'http://localhost:8081', 'state': 'dev-complete-flow-state'}, {'env': 'staging', 'client_id': 'staging-complete.apps.googleusercontent.com', 'client_secret': 'GOCSPX-staging-complete-secret', 'auth_service_url': 'https://auth.staging.netrasystems.ai', 'state': 'staging-complete-flow-state'}]
        for scenario in complete_flow_scenarios:
            with self.temp_env_vars(ENVIRONMENT=scenario['env'], AUTH_SERVICE_URL=scenario['auth_service_url']):
                with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                    mock_id.return_value = scenario['client_id']
                    mock_secret.return_value = scenario['client_secret']
                    provider = GoogleOAuthProvider()
                    is_valid, message = provider.validate_configuration()
                    assert is_valid, f"OAuth configuration invalid for {scenario['env']}: {message}"
                    auth_url = provider.get_authorization_url(scenario['state'])
                    assert auth_url.startswith('https://accounts.google.com/o/oauth2/auth')
                    assert scenario['client_id'] in auth_url
                    assert scenario['state'] in auth_url
                    test_code = 'test-authorization-code'
                    user_info = provider.exchange_code_for_user_info(test_code, scenario['state'])
                    assert user_info is not None
                    assert user_info['email'] == 'test@example.com'
                    assert user_info['name'] == 'Test User'
                    self_check = provider.self_check()
                    assert self_check['is_healthy']
                    assert self_check['environment'] == scenario['env']
        self.record_metric('complete_flow_scenarios_tested', len(complete_flow_scenarios))

    def test_oauth_configuration_persistence_across_requests(self):
        """Test OAuth configuration persistence across multiple requests in same environment."""
        with self.temp_env_vars(ENVIRONMENT='staging', AUTH_SERVICE_URL='https://auth.staging.netrasystems.ai'):
            staging_client_id = 'staging-persistence.apps.googleusercontent.com'
            staging_client_secret = 'GOCSPX-staging-persistence-secret'
            with patch.object(AuthSecretLoader, 'get_google_client_id') as mock_id, patch.object(AuthSecretLoader, 'get_google_client_secret') as mock_secret:
                mock_id.return_value = staging_client_id
                mock_secret.return_value = staging_client_secret
                providers = []
                configurations = []
                for i in range(5):
                    provider = GoogleOAuthProvider()
                    config = provider.get_configuration_status()
                    providers.append(provider)
                    configurations.append(config)
                    assert provider.client_id == staging_client_id
                    assert provider.client_secret == staging_client_secret
                    assert provider.env == 'staging'
                base_config = configurations[0]
                for i, config in enumerate(configurations[1:], 1):
                    assert config['client_id_configured'] == base_config['client_id_configured']
                    assert config['client_secret_configured'] == base_config['client_secret_configured']
                    assert config['is_configured'] == base_config['is_configured']
                    assert config['environment'] == base_config['environment']
        self.record_metric('persistence_providers_tested', len(providers))
if __name__ == '__main__':
    'MIGRATED: Use SSOT unified test runner'
    print('MIGRATION NOTICE: Please use SSOT unified test runner')
    print('Command: python tests/unified_test_runner.py --category <category>')