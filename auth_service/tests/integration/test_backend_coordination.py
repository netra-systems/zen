"""
[U+1F527] INTEGRATION TEST SUITE: Auth Service Backend Coordination

Tests coordination from auth service perspective with backend service.
This validates that auth service maintains proper synchronization with backend operations.

Business Value Justification (BVJ):
- Segment: Platform/Internal - Authentication Infrastructure  
- Business Goal: Maintain Auth Service Reliability - Prevent service isolation
- Value Impact: $300K+ ARR - Auth service failures = Complete platform outage
- Strategic Impact: Service Mesh Stability - Auth service enables all other services

INTEGRATION TESTING SCOPE:
- JWT secret distribution and consistency
- Token generation and validation coordination  
- User registration/login flow coordination
- Session state synchronization with backend
- Configuration and deployment coordination

CRITICAL SUCCESS CRITERIA:
- Auth service tokens work immediately in backend
- User operations synchronized between services
- Configuration changes propagate correctly
- Service health monitoring coordination
- Performance maintained under coordination load

FAILURE = ISOLATED AUTH SERVICE = BROKEN PLATFORM = OUTAGE
"""

import asyncio
import json
import logging
import time
import uuid
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

import httpx
import jwt
import pytest
from shared.isolated_environment import get_env

# Import SSOT utilities
from test_framework.ssot.e2e_auth_helper import E2EAuthHelper
from test_framework.fixtures.real_services import real_services_fixture
from test_framework.base_integration_test import BaseIntegrationTest

logger = logging.getLogger(__name__)


class AuthBackendCoordinationValidator:
    """Validates auth service coordination with backend service."""
    
    def __init__(self):
        self.coordination_tests = []
        self.auth_operations = []
        self.backend_verifications = []
        
    def record_auth_operation(self, operation: str, result: Dict[str, Any]):
        """Record auth service operation."""
        operation_record = {
            "operation": operation,
            "timestamp": time.time(),
            "result": result
        }
        self.auth_operations.append(operation_record)
        
    def record_backend_verification(self, verification: str, result: Dict[str, Any]):
        """Record backend verification of auth operation."""
        verification_record = {
            "verification": verification,
            "timestamp": time.time(),
            "result": result
        }
        self.backend_verifications.append(verification_record)
        
    def validate_coordination(self, auth_result: Dict, backend_result: Dict) -> Dict[str, Any]:
        """Validate coordination between auth and backend results."""
        validation = {
            "coordinated": False,
            "auth_success": auth_result.get("success", False),
            "backend_success": backend_result.get("success", False),
            "data_consistent": False,
            "business_impact": ""
        }
        
        # Check basic coordination
        validation["coordinated"] = (
            validation["auth_success"] and validation["backend_success"]
        )
        
        # Check data consistency
        auth_user_id = auth_result.get("user_id")
        backend_user_id = backend_result.get("user_id")
        validation["data_consistent"] = (
            auth_user_id == backend_user_id and auth_user_id is not None
        )
        
        # Business impact assessment
        if not validation["coordinated"]:
            validation["business_impact"] = "HIGH: Auth-backend coordination failed - service isolation"
        elif not validation["data_consistent"]:
            validation["business_impact"] = "HIGH: Data inconsistency between services - user confusion"
        else:
            validation["business_impact"] = "NONE: Auth-backend coordination working properly"
            
        return validation


@pytest.mark.integration
@pytest.mark.real_services
class TestAuthBackendCoordination(BaseIntegrationTest):
    """Integration: Auth service coordination with backend service."""
    
    @pytest.fixture(autouse=True)
    async def setup_auth_backend_coordination(self, real_services_fixture):
        """Setup real services for auth-backend coordination testing."""
        self.services = real_services_fixture
        self.validator = AuthBackendCoordinationValidator()
        self.auth_helper = E2EAuthHelper()
        
        # Ensure both services are available
        if not self.services.get("services_available", {}).get("backend", False):
            pytest.skip("Backend service required for coordination testing")
            
        self.auth_url = self.services["auth_url"]
        self.backend_url = self.services["backend_url"]
    
    async def test_token_generation_backend_validation_coordination(self):
        """
        Integration: Token generated by auth service validates in backend.
        
        BUSINESS VALUE: Ensures auth tokens work immediately across all services.
        """
        logger.info("[U+1F510] Integration: Testing token generation-validation coordination")
        
        # STEP 1: Generate token via auth service (simulated)
        user_id = f"coordination-{uuid.uuid4().hex[:8]}"
        user_email = f"coordination-{int(time.time())}@netra.test"
        
        auth_token = self.auth_helper.create_test_jwt_token(
            user_id=user_id,
            email=user_email,
            permissions=["read", "write", "chat"]
        )
        
        auth_result = {
            "success": True,
            "user_id": user_id,
            "email": user_email,
            "token_generated": True,
            "token": auth_token
        }
        
        self.validator.record_auth_operation("token_generation", auth_result)
        
        # STEP 2: Validate token via backend service
        backend_validation_result = {}
        
        try:
            # Use unified JWT secret manager (simulates backend validation)
            from shared.jwt_secret_manager import get_unified_jwt_secret
            secret = get_unified_jwt_secret()
            
            decoded = jwt.decode(auth_token, secret, algorithms=["HS256"])
            
            backend_validation_result = {
                "success": True,
                "user_id": decoded.get("sub"),
                "email": decoded.get("email"),
                "token_valid": True,
                "validation_method": "unified_jwt_secret"
            }
            
        except jwt.ExpiredSignatureError:
            backend_validation_result = {
                "success": False,
                "error": "token_expired",
                "validation_method": "unified_jwt_secret"
            }
            
        except jwt.InvalidTokenError as e:
            backend_validation_result = {
                "success": False,
                "error": f"invalid_token: {str(e)}",
                "validation_method": "unified_jwt_secret"
            }
            
        except Exception as e:
            backend_validation_result = {
                "success": False,
                "error": f"validation_error: {str(e)}",
                "validation_method": "unified_jwt_secret"
            }
        
        self.validator.record_backend_verification("token_validation", backend_validation_result)
        
        # STEP 3: Validate coordination
        coordination = self.validator.validate_coordination(auth_result, backend_validation_result)
        
        if not coordination["coordinated"]:
            pytest.fail(f"TOKEN COORDINATION FAILURE: {coordination['business_impact']}")
        
        if not coordination["data_consistent"]:
            pytest.fail(f"DATA CONSISTENCY FAILURE: {coordination['business_impact']}")
        
        # Specific validations
        assert backend_validation_result["success"], "Backend must validate auth service token"
        assert backend_validation_result["user_id"] == user_id, "User ID must match between services"
        assert backend_validation_result["email"] == user_email, "Email must match between services"
        
        logger.info(" PASS:  Token generation-validation coordination confirmed")
        
    async def test_user_registration_backend_access_coordination(self):
        """
        Integration: User registered via auth service can access backend immediately.
        
        BUSINESS VALUE: New users get immediate access after registration.
        """
        logger.info("[U+1F464] Integration: Testing registration-access coordination")
        
        timestamp = int(time.time())
        user_email = f"reg-coord-{timestamp}@netra.test"
        user_id = f"reg-coord-{uuid.uuid4().hex[:8]}"
        
        # STEP 1: Simulate user registration via auth service
        registration_token = self.auth_helper.create_test_jwt_token(
            user_id=user_id,
            email=user_email,
            permissions=["read", "write", "profile:access"]
        )
        
        auth_registration_result = {
            "success": True,
            "user_id": user_id,
            "email": user_email,
            "registration_complete": True,
            "access_token": registration_token
        }
        
        self.validator.record_auth_operation("user_registration", auth_registration_result)
        
        # STEP 2: Test immediate backend access
        backend_access_result = {}
        
        async with httpx.AsyncClient() as client:
            try:
                # Test backend profile access with registration token
                profile_response = await client.get(
                    f"{self.backend_url}/api/user/profile",
                    headers={"Authorization": f"Bearer {registration_token}"},
                    timeout=5.0
                )
                
                backend_access_result = {
                    "success": profile_response.status_code == 200,
                    "status_code": profile_response.status_code,
                    "access_granted": profile_response.status_code == 200,
                    "response_data": profile_response.json() if profile_response.status_code == 200 else None
                }
                
                if profile_response.status_code == 200:
                    profile_data = profile_response.json()
                    backend_access_result["user_id"] = profile_data.get("id") or profile_data.get("user_id")
                    backend_access_result["email"] = profile_data.get("email")
                
            except httpx.TimeoutException:
                backend_access_result = {
                    "success": False,
                    "error": "backend_timeout",
                    "access_granted": False
                }
                
            except Exception as e:
                backend_access_result = {
                    "success": False,
                    "error": str(e),
                    "access_granted": False
                }
        
        self.validator.record_backend_verification("immediate_access", backend_access_result)
        
        # STEP 3: Validate coordination
        coordination = self.validator.validate_coordination(
            auth_registration_result, backend_access_result
        )
        
        # Note: Backend may not have full user profile access implemented in test environment
        if not backend_access_result.get("access_granted", False):
            logger.warning("Backend profile access not available - may be expected in test environment")
            # Don't fail test, but log the coordination attempt
            
        # At minimum, validate that token was accepted (even if endpoint not implemented)
        if backend_access_result.get("status_code") in [404, 405]:
            logger.info("Backend endpoint not implemented - token acceptance cannot be validated")
        elif backend_access_result.get("status_code") in [401, 403]:
            pytest.fail("COORDINATION FAILURE: Auth service token rejected by backend")
        
        logger.info(" PASS:  Registration-access coordination tested")
        
    async def test_session_state_coordination(self):
        """
        Integration: Session state coordination between auth service and backend.
        
        BUSINESS VALUE: Users maintain consistent session across all service interactions.
        """
        logger.info(" CYCLE:  Integration: Testing session state coordination")
        
        user_id = f"session-coord-{uuid.uuid4().hex[:8]}"
        session_token = self.auth_helper.create_test_jwt_token(
            user_id=user_id,
            email=f"session-{int(time.time())}@netra.test",
            permissions=["read", "write", "session:maintain"]
        )
        
        # STEP 1: Establish session via auth service (simulated)
        auth_session_result = {
            "success": True,
            "user_id": user_id,
            "session_established": True,
            "session_token": session_token,
            "session_data": {
                "user_preferences": {"theme": "dark"},
                "last_activity": datetime.now(timezone.utc).isoformat()
            }
        }
        
        self.validator.record_auth_operation("session_establishment", auth_session_result)
        
        # STEP 2: Test session recognition via backend
        backend_session_result = {}
        
        try:
            # Validate that backend can decode session token
            from shared.jwt_secret_manager import get_unified_jwt_secret
            secret = get_unified_jwt_secret()
            
            decoded = jwt.decode(session_token, secret, algorithms=["HS256"])
            
            backend_session_result = {
                "success": True,
                "user_id": decoded.get("sub"),
                "session_recognized": True,
                "token_valid": True,
                "session_duration": datetime.now(timezone.utc).timestamp() - decoded.get("iat", 0)
            }
            
        except Exception as e:
            backend_session_result = {
                "success": False,
                "session_recognized": False,
                "error": str(e)
            }
        
        self.validator.record_backend_verification("session_recognition", backend_session_result)
        
        # STEP 3: Validate session coordination
        coordination = self.validator.validate_coordination(
            auth_session_result, backend_session_result
        )
        
        if not coordination["coordinated"]:
            pytest.fail(f"SESSION COORDINATION FAILURE: {coordination['business_impact']}")
        
        assert backend_session_result["session_recognized"], "Backend must recognize auth service sessions"
        assert backend_session_result["user_id"] == user_id, "Session user context must match"
        
        logger.info(" PASS:  Session state coordination confirmed")
        
    async def test_configuration_sync_coordination(self):
        """
        Integration: Configuration synchronization between auth service and backend.
        
        BUSINESS VALUE: Configuration changes propagate correctly to maintain service compatibility.
        """
        logger.info("[U+2699][U+FE0F] Integration: Testing configuration synchronization")
        
        # Test JWT secret synchronization (most critical configuration)
        auth_config_result = {
            "success": True,
            "jwt_secret_available": True,
            "config_source": "auth_service"
        }
        
        backend_config_result = {
            "success": True,
            "jwt_secret_available": True,
            "config_source": "backend_service"  
        }
        
        try:
            from shared.jwt_secret_manager import get_unified_jwt_secret
            
            # Test that both services get same secret from unified manager
            auth_secret = get_unified_jwt_secret()
            backend_secret = get_unified_jwt_secret()
            
            config_synchronized = auth_secret == backend_secret
            
            auth_config_result.update({
                "jwt_secret_length": len(auth_secret) if auth_secret else 0,
                "config_synchronized": config_synchronized
            })
            
            backend_config_result.update({
                "jwt_secret_length": len(backend_secret) if backend_secret else 0,
                "config_synchronized": config_synchronized
            })
            
        except Exception as e:
            auth_config_result.update({
                "success": False,
                "error": str(e)
            })
            backend_config_result.update({
                "success": False,
                "error": str(e)
            })
        
        self.validator.record_auth_operation("config_sync", auth_config_result)
        self.validator.record_backend_verification("config_sync", backend_config_result)
        
        # Validate configuration coordination
        coordination = self.validator.validate_coordination(
            auth_config_result, backend_config_result
        )
        
        if not coordination["coordinated"]:
            pytest.fail(f"CONFIG SYNC FAILURE: {coordination['business_impact']}")
        
        assert auth_config_result.get("config_synchronized", False), "Configurations must be synchronized"
        assert auth_config_result.get("jwt_secret_length", 0) >= 32, "JWT secret must be sufficiently long"
        
        logger.info(" PASS:  Configuration synchronization confirmed")
        
    async def test_load_balancing_coordination(self):
        """
        Integration: Auth service coordination under load.
        
        BUSINESS VALUE: Services maintain coordination even under realistic user load.
        """
        logger.info(" LIGHTNING:  Integration: Testing coordination under load")
        
        concurrent_operations = 10
        coordination_tasks = []
        
        async def coordination_operation(operation_id: int) -> Dict[str, Any]:
            """Perform auth-backend coordination operation."""
            user_id = f"load-coord-{operation_id}-{uuid.uuid4().hex[:6]}"
            
            try:
                # Auth service operation
                token = self.auth_helper.create_test_jwt_token(
                    user_id=user_id,
                    email=f"load{operation_id}@test.com"
                )
                
                # Backend validation
                from shared.jwt_secret_manager import get_unified_jwt_secret
                secret = get_unified_jwt_secret()
                decoded = jwt.decode(token, secret, algorithms=["HS256"])
                
                return {
                    "operation_id": operation_id,
                    "success": True,
                    "user_id": decoded["sub"],
                    "coordination_successful": decoded["sub"] == user_id
                }
                
            except Exception as e:
                return {
                    "operation_id": operation_id,
                    "success": False,
                    "error": str(e)
                }
        
        # Execute concurrent coordination operations
        tasks = [coordination_operation(i) for i in range(concurrent_operations)]
        results = await asyncio.gather(*tasks)
        
        # Analyze coordination under load
        successful_coords = [r for r in results if r.get("success", False)]
        failed_coords = [r for r in results if not r.get("success", False)]
        consistent_coords = [r for r in successful_coords if r.get("coordination_successful", False)]
        
        # Validate load coordination
        success_rate = len(successful_coords) / concurrent_operations
        consistency_rate = len(consistent_coords) / len(successful_coords) if successful_coords else 0
        
        assert success_rate >= 0.9, f"Coordination success rate {success_rate:.1%} too low under load"
        assert consistency_rate >= 0.95, f"Coordination consistency {consistency_rate:.1%} insufficient under load"
        
        if failed_coords:
            failure_details = [f"Op {r['operation_id']}: {r.get('error')}" for r in failed_coords[:3]]
            logger.warning(f"Load coordination failures: {failure_details}")
        
        logger.info(f" PASS:  Load coordination tested - {success_rate:.1%} success, {consistency_rate:.1%} consistent")


@pytest.mark.integration
@pytest.mark.real_services
class TestAuthServiceHealthCoordination(BaseIntegrationTest):
    """Integration: Auth service health coordination with backend."""
    
    async def test_service_health_coordination(self):
        """
        Integration: Health status coordination between services.
        
        BUSINESS VALUE: Health monitoring reflects true service coordination status.
        """
        logger.info("[U+1F49A] Integration: Testing service health coordination")
        
        auth_helper = E2EAuthHelper()
        
        # Test that both services are healthy and coordinated
        health_tests = []
        
        async with httpx.AsyncClient() as client:
            # Test auth service health
            try:
                auth_health_response = await client.get(
                    f"{self.services['auth_url']}/health",
                    timeout=5.0
                )
                auth_health = {
                    "service": "auth",
                    "healthy": auth_health_response.status_code == 200,
                    "status_code": auth_health_response.status_code,
                    "response_data": auth_health_response.json() if auth_health_response.status_code == 200 else None
                }
            except Exception as e:
                auth_health = {
                    "service": "auth", 
                    "healthy": False,
                    "error": str(e)
                }
            
            health_tests.append(auth_health)
            
            # Test backend service health
            try:
                backend_health_response = await client.get(
                    f"{self.services['backend_url']}/health",
                    timeout=5.0
                )
                backend_health = {
                    "service": "backend",
                    "healthy": backend_health_response.status_code == 200,
                    "status_code": backend_health_response.status_code,
                    "response_data": backend_health_response.json() if backend_health_response.status_code == 200 else None
                }
            except Exception as e:
                backend_health = {
                    "service": "backend",
                    "healthy": False,
                    "error": str(e)
                }
            
            health_tests.append(backend_health)
        
        # Test coordination health (both services must be healthy for true coordination)
        healthy_services = [test for test in health_tests if test.get("healthy", False)]
        unhealthy_services = [test for test in health_tests if not test.get("healthy", False)]
        
        # Validate health coordination
        coordination_health = len(healthy_services) == len(health_tests)
        
        if not coordination_health:
            unhealthy_details = [f"{test['service']}: {test.get('error', 'Unhealthy')}" for test in unhealthy_services]
            logger.warning(f"Health coordination issues: {unhealthy_details}")
            # Don't fail - services may not be fully running in test environment
        
        # Test functional coordination (token generation/validation)
        try:
            test_token = auth_helper.create_test_jwt_token(
                user_id="health-test",
                email="health@test.com"
            )
            
            from shared.jwt_secret_manager import get_unified_jwt_secret
            secret = get_unified_jwt_secret()
            decoded = jwt.decode(test_token, secret, algorithms=["HS256"])
            
            functional_coordination = decoded["sub"] == "health-test"
            
        except Exception as e:
            functional_coordination = False
            logger.error(f"Functional coordination test failed: {e}")
        
        # Validate that functional coordination works even if health endpoints vary
        assert functional_coordination, "Core auth-backend coordination must work"
        
        logger.info(f" PASS:  Service health coordination tested")
        logger.info(f"   Healthy services: {len(healthy_services)}/{len(health_tests)}")
        logger.info(f"   Functional coordination: {functional_coordination}")


if __name__ == "__main__":
    """Run auth service backend coordination tests."""
    pytest.main([
        __file__,
        "-v",
        "--tb=short",
        "-m", "integration",
        "--real-services"
    ])