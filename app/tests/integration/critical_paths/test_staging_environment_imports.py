"""Critical path test for staging environment module imports.

Business Value: Platform/Internal - Deployment Stability - Ensures the backend
service can start successfully in staging without dev_launcher dependencies.

This test validates that the backend service can properly initialize in a staging
environment where dev_launcher module is not available. This prevents deployment
failures caused by attempting to import development-only modules in production
environments.
"""

import os
import sys
import pytest
from unittest import mock
from typing import Any, Dict
from fastapi import FastAPI
from fastapi.testclient import TestClient

from app.core.environment_constants import Environment, EnvironmentVariables


class TestStagingEnvironmentImports:
    """Test suite for staging environment module imports and initialization."""

    @pytest.fixture(autouse=True)
    def setup_staging_environment(self, monkeypatch):
        """Set up staging environment for tests."""
        # Save original environment
        original_env = os.environ.get(EnvironmentVariables.ENVIRONMENT)
        
        # Set staging environment
        monkeypatch.setenv(EnvironmentVariables.ENVIRONMENT, Environment.STAGING.value)
        monkeypatch.setenv(EnvironmentVariables.K_SERVICE, "backend-staging")
        
        yield
        
        # Restore original environment
        if original_env:
            monkeypatch.setenv(EnvironmentVariables.ENVIRONMENT, original_env)
        else:
            monkeypatch.delenv(EnvironmentVariables.ENVIRONMENT, raising=False)

    @pytest.fixture
    def mock_dev_launcher_import(self):
        """Mock dev_launcher module to simulate it not being available in staging."""
        # Remove dev_launcher from sys.modules if it exists
        modules_to_remove = [m for m in sys.modules if m.startswith('dev_launcher')]
        for module in modules_to_remove:
            del sys.modules[module]
        
        # Mock only the dev_launcher import to raise ImportError
        import builtins
        original_import = builtins.__import__
        
        def mock_import(name, *args, **kwargs):
            if name.startswith('dev_launcher'):
                raise ImportError(f"No module named '{name}'")
            return original_import(name, *args, **kwargs)
        
        with mock.patch('builtins.__import__', side_effect=mock_import):
            yield

    def test_middleware_setup_without_dev_launcher(self, mock_dev_launcher_import):
        """Test that middleware setup works in staging without dev_launcher.
        
        L3 Test - Validates staging-specific behavior where dev_launcher is not available.
        """
        from app.core.middleware_setup import setup_cors_middleware
        
        # Create a test FastAPI app
        app = FastAPI()
        
        # This should not raise an ImportError
        setup_cors_middleware(app)
        
        # Verify the app has CORS middleware configured  
        # The fact that we got here without ImportError means the test passed

    def test_staging_cors_configuration(self):
        """Test CORS configuration in staging environment.
        
        L3 Test - Validates that CORS is properly configured for staging.
        """
        from app.core.middleware_setup import setup_cors_middleware
        
        app = FastAPI()
        setup_cors_middleware(app)
        
        # Create test client
        client = TestClient(app)
        
        # Add a test route
        @app.get("/test")
        def test_route():
            return {"status": "ok"}
        
        # Test CORS headers for staging domain
        response = client.get(
            "/test",
            headers={"Origin": "https://staging.netrasystems.ai"}
        )
        
        # Should allow staging domain
        assert response.status_code == 200
        assert "access-control-allow-origin" in response.headers

    def test_backend_startup_in_staging(self, mock_dev_launcher_import):
        """Test that the backend service can start in staging environment.
        
        L4 Test - End-to-end validation of backend startup without dev dependencies.
        """
        # Import should not fail even without dev_launcher
        from app.core.middleware_setup import setup_cors_middleware, setup_rate_limiting, setup_security_middleware
        
        app = FastAPI()
        
        # All middleware setup should work without dev_launcher
        setup_cors_middleware(app)
        setup_rate_limiting(app)
        setup_security_middleware(app)
        
        # Verify the app is properly configured
        assert app.middleware
        assert len(app.middleware) > 0

    def test_service_discovery_fallback_in_staging(self):
        """Test that service discovery gracefully falls back in staging.
        
        L3 Test - Validates fallback behavior when service discovery is not available.
        """
        from app.core.middleware_setup import _setup_custom_cors_middleware
        from fastapi import FastAPI
        
        app = FastAPI()
        
        # Mock the import to fail
        with mock.patch('builtins.__import__', side_effect=ImportError("No module named 'dev_launcher'")):
            # This should not raise an error
            _setup_custom_cors_middleware(app)
        
        # The fact that we got here without error means the test passed

    @pytest.mark.parametrize("environment", [
        Environment.STAGING.value,
        Environment.PRODUCTION.value
    ])
    def test_no_dev_launcher_in_non_dev_environments(self, environment, monkeypatch):
        """Test that dev_launcher is not imported in non-development environments.
        
        L3 Test - Validates environment-specific import behavior.
        """
        monkeypatch.setenv(EnvironmentVariables.ENVIRONMENT, environment)
        
        from app.core.middleware_setup import _setup_custom_cors_middleware
        
        app = FastAPI()
        
        # Track if dev_launcher import was attempted
        import_attempted = False
        
        def mock_import(name, *args, **kwargs):
            nonlocal import_attempted
            if name == 'dev_launcher.service_discovery':
                import_attempted = True
                raise ImportError(f"No module named '{name}'")
            return __import__(name, *args, **kwargs)
        
        with mock.patch('builtins.__import__', side_effect=mock_import):
            _setup_custom_cors_middleware(app)
        
        # In staging/production, dev_launcher import should not be attempted
        assert not import_attempted, f"dev_launcher should not be imported in {environment}"

    def test_development_environment_uses_dev_launcher(self, monkeypatch):
        """Test that dev_launcher IS imported in development environment.
        
        L3 Test - Validates that dev_launcher is properly used in development.
        """
        monkeypatch.setenv(EnvironmentVariables.ENVIRONMENT, Environment.DEVELOPMENT.value)
        
        from app.core.middleware_setup import _setup_custom_cors_middleware
        
        app = FastAPI()
        
        # Track if dev_launcher import was attempted
        import_attempted = False
        
        def mock_import(name, *args, **kwargs):
            nonlocal import_attempted
            if name == 'dev_launcher.service_discovery':
                import_attempted = True
                # Simulate successful import with mock
                from unittest.mock import MagicMock
                module = MagicMock()
                module.ServiceDiscovery = MagicMock
                return module
            return __import__(name, *args, **kwargs)
        
        with mock.patch('builtins.__import__', side_effect=mock_import):
            _setup_custom_cors_middleware(app)
        
        # In development, dev_launcher import should be attempted
        assert import_attempted, "dev_launcher should be imported in development"

    def test_staging_environment_detection(self):
        """Test that staging environment is properly detected.
        
        L2 Test - Unit test for environment detection logic.
        """
        from app.core.environment_constants import EnvironmentDetector
        
        # Test Cloud Run staging detection
        with mock.patch.dict(os.environ, {
            EnvironmentVariables.K_SERVICE: "backend-staging",
            EnvironmentVariables.ENVIRONMENT: ""
        }):
            env = EnvironmentDetector.get_environment()
            assert env == Environment.STAGING.value
        
        # Test explicit staging environment
        with mock.patch.dict(os.environ, {
            EnvironmentVariables.ENVIRONMENT: Environment.STAGING.value
        }):
            env = EnvironmentDetector.get_environment()
            assert env == Environment.STAGING.value
        
        # Test PR-based staging
        with mock.patch.dict(os.environ, {
            EnvironmentVariables.K_SERVICE: "backend-pr-123",
            EnvironmentVariables.PR_NUMBER: "123"
        }):
            env = EnvironmentDetector.get_environment()
            assert env == Environment.STAGING.value


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])