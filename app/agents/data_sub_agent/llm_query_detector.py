"""Detect and fix LLM-generated ClickHouse queries.

LLMs may generate queries with incorrect syntax, especially for ClickHouse
Nested structures. This module detects such queries and fixes them.
"""

import re
from typing import Tuple, List, Dict, Any
from app.logging_config import central_logger as logger


class LLMQueryDetector:
    """Detects and fixes queries that appear to be LLM-generated."""
    
    # Explicit marker for LLM-generated queries
    LLM_QUERY_MARKER = "/* LLM-Generated Query */"
    
    # Patterns that suggest a query was LLM-generated
    LLM_INDICATORS = [
        # LLMs often use SQL-style array access instead of ClickHouse functions
        r'metrics\.\w+\[\w+\]',  # metrics.value[idx] instead of arrayElement
        
        # LLMs might generate simplified queries without proper subqueries
        r'SELECT\s+arrayFirstIndex.*if\s*\(\s*idx',  # Direct SELECT with if(idx...)
        
        # LLMs often miss ClickHouse-specific syntax
        r'SELECT\s+\*.*metrics\.value\[',  # SELECT * with array access
        
        # LLMs might use standard SQL instead of ClickHouse syntax
        r'ARRAY\[.*\]',  # ARRAY[...] instead of [...]
        r'\.get\(',  # .get() method instead of arrayElement
        
        # Common LLM query patterns that are incorrect
        r'metrics\[.*\]\[.*\]',  # Double array access
    ]
    
    # Query patterns that are definitely NOT from our query builder
    NON_BUILDER_PATTERNS = [
        # Our builder always uses arrayElement for array access
        (r'metrics\.value\[', 'Uses bracket notation instead of arrayElement'),
        
        # Our builder uses specific query structure with subqueries
        (r'^SELECT\s+arrayFirstIndex.*if\(idx.*metrics\.', 
         'Direct SELECT without subquery structure'),
        
        # Our builder doesn't generate lowercased function names
        (r'arrayfirstindex|arrayelement', 'Lowercased ClickHouse functions'),
    ]
    
    @classmethod
    def is_likely_llm_generated(cls, query: str) -> Tuple[bool, List[str]]:
        """Check if a query appears to be LLM-generated."""
        if cls.LLM_QUERY_MARKER in query:
            return True, ["Explicitly marked as LLM-generated"]
        if cls._is_from_query_builder(query):
            return False, []
        reasons = cls._collect_llm_indicators(query)
        reasons.extend(cls._collect_non_builder_patterns(query))
        if cls._has_suspicious_structure(query):
            reasons.append("Query structure doesn't match our templates")
        return len(reasons) > 0, reasons
    
    @classmethod
    def _collect_llm_indicators(cls, query: str) -> List[str]:
        """Collect LLM indicator patterns from query."""
        reasons = []
        for pattern in cls.LLM_INDICATORS:
            if re.search(pattern, query, re.IGNORECASE):
                reasons.append(f"Contains pattern: {pattern}")
        return reasons
    
    @classmethod
    def _collect_non_builder_patterns(cls, query: str) -> List[str]:
        """Collect non-builder patterns from query."""
        reasons = []
        for pattern, description in cls.NON_BUILDER_PATTERNS:
            if re.search(pattern, query, re.IGNORECASE):
                reasons.append(description)
        return reasons
    
    @classmethod
    def _is_from_query_builder(cls, query: str) -> bool:
        """Check if query is from our QueryBuilder."""
        if '/* Generated by Netra QueryBuilder */' in query:
            return True
        builder_markers = cls._get_builder_markers()
        key_markers_count = sum(1 for marker in builder_markers if marker in query)
        return key_markers_count >= 3  # Multiple markers = likely from QueryBuilder
    
    @classmethod
    def _get_builder_markers(cls) -> List[str]:
        """Get QueryBuilder markers for backward compatibility."""
        return [
            'arrayElement(metrics.value', 'arrayElement(metrics.name',
            'arrayFirstIndex(x ->', 'FROM workload_events',
            'corr(m1_value, m2_value)', 'toDayOfWeek(timestamp)'
        ]
    
    @classmethod
    def _has_suspicious_structure(cls, query: str) -> bool:
        """Check for suspicious query structure."""
        query_lower = query.lower()
        if cls._has_malformed_correlation(query_lower):
            return True
        if cls._has_mixed_case_issues(query):
            return True
        return False
    
    @classmethod
    def _has_malformed_correlation(cls, query_lower: str) -> bool:
        """Check for correlation queries without proper structure."""
        return ('arrayfirstindex' in query_lower and 
                'if(idx' in query_lower.replace(' ', '') and
                'from (' not in query_lower)
    
    @classmethod
    def _has_mixed_case_issues(cls, query: str) -> bool:
        """Check for mixed case issues (LLMs might inconsistently case)."""
        return 'SELECT' in query and 'select' in query
    
    @classmethod
    def fix_llm_query(cls, query: str) -> str:
        """Fix a query that appears to be LLM-generated."""
        fixed = cls._apply_syntax_fixes(query)
        if fixed != query:
            cls._log_query_fix(query, fixed)
        return fixed
    
    @classmethod
    def _apply_syntax_fixes(cls, query: str) -> str:
        """Apply all syntax fixes to query."""
        fixed = cls._fix_array_access(query)
        fixed = cls._fix_function_names(fixed)
        fixed = cls._fix_correlation_structure(fixed)
        return cls._fix_sql_style_syntax(fixed)
    
    @classmethod
    def _log_query_fix(cls, original: str, fixed: str) -> None:
        """Log query fix details."""
        logger.info("Fixed LLM-generated query")
        logger.debug(f"Original: {original[:200]}...")
        logger.debug(f"Fixed: {fixed[:200]}...")
    
    @classmethod
    def _fix_array_access(cls, query: str) -> str:
        """Fix array access to use arrayElement with proper type casting."""
        pattern = r'(\w+)\.(\w+)\[([^\]]+)\]'
        return re.sub(pattern, cls._replace_array_access, query)
    
    @classmethod
    def _replace_array_access(cls, match) -> str:
        """Replace array access pattern with arrayElement."""
        table, field, index = match.group(1), match.group(2), match.group(3)
        if table == 'metrics':
            return f"toFloat64OrZero(arrayElement({table}.{field}, {index}))"
        return match.group(0)
    
    @classmethod
    def _fix_function_names(cls, query: str) -> str:
        """Fix ClickHouse function name casing."""
        functions = cls._get_function_mappings()
        result = query
        for wrong, correct in functions.items():
            pattern = re.compile(re.escape(wrong), re.IGNORECASE)
            result = pattern.sub(correct, result)
        return result
    
    @classmethod
    def _get_function_mappings(cls) -> Dict[str, str]:
        """Get function name mappings for case fixing."""
        return {
            'arrayfirstindex': 'arrayFirstIndex', 'arrayelement': 'arrayElement',
            'arrayexists': 'arrayExists', 'arraylength': 'arrayLength',
            'todate': 'toDate', 'tointervalday': 'toIntervalDay'
        }
    
    @classmethod
    def _fix_correlation_structure(cls, query: str) -> str:
        """Fix correlation query structure if it's missing subquery."""
        if cls._is_simplified_correlation(query):
            logger.warning("Detected simplified correlation query - applying basic fixes only")
        return query
    
    @classmethod
    def _is_simplified_correlation(cls, query: str) -> bool:
        """Check if query is a simplified correlation query."""
        return ('arrayFirstIndex' in query and 
                'if(idx' in query.replace(' ', '') and
                'FROM (' not in query)
    
    @classmethod
    def _fix_sql_style_syntax(cls, query: str) -> str:
        """Fix SQL-style syntax to ClickHouse syntax."""
        # Fix ARRAY[...] to [...]
        query = re.sub(r'ARRAY\s*\[([^\]]+)\]', r'[\1]', query, flags=re.IGNORECASE)
        
        # Fix other SQL-isms as needed
        
        return query
    
    @classmethod
    def validate_and_fix(cls, query: str) -> Tuple[str, Dict[str, Any]]:
        """Validate a query and fix if LLM-generated."""
        is_llm, reasons = cls.is_likely_llm_generated(query)
        metadata = cls._build_validation_metadata(is_llm, reasons)
        if is_llm:
            return cls._handle_llm_query(query, metadata, reasons)
        return query, metadata
    
    @classmethod
    def _build_validation_metadata(cls, is_llm: bool, reasons: List[str]) -> Dict[str, Any]:
        """Build validation metadata structure."""
        return {
            'is_llm_generated': is_llm, 'detection_reasons': reasons,
            'was_fixed': False, 'expected_return_structure': None
        }
    
    @classmethod
    def _handle_llm_query(cls, query: str, metadata: Dict[str, Any], reasons: List[str]) -> Tuple[str, Dict[str, Any]]:
        """Handle LLM-generated query processing."""
        fixed_query = cls.fix_llm_query(query)
        metadata['was_fixed'] = (fixed_query != query)
        metadata['expected_return_structure'] = cls._infer_return_structure(query)
        if metadata['was_fixed']:
            cls._log_llm_detection(query, reasons)
        return fixed_query, metadata
    
    @classmethod
    def _log_llm_detection(cls, query: str, reasons: List[str]) -> None:
        """Log LLM query detection and fix."""
        reason = reasons[0] if reasons else 'unknown'
        logger.warning(f"LLM query detected and fixed: {reason}")
        logger.debug(f"Query snippet: {query[:100]}...")
    
    @classmethod
    def _infer_return_structure(cls, query: str) -> Dict[str, Any]:
        """Infer expected return structure from query."""
        structure = cls._create_base_structure()
        query_lower = query.lower()
        if 'corr(' in query_lower:
            return cls._create_correlation_structure()
        elif 'todayofweek' in query_lower:
            return cls._create_usage_patterns_structure()
        elif 'quantile' in query_lower:
            return cls._create_performance_structure()
        return structure
    
    @classmethod
    def _create_base_structure(cls) -> Dict[str, Any]:
        """Create base structure template."""
        return {'type': 'unknown', 'columns': [], 'hints': []}
    
    @classmethod
    def _create_correlation_structure(cls) -> Dict[str, Any]:
        """Create correlation structure template."""
        return {'type': 'correlation', 'columns': ['correlation_coefficient', 'sample_size'],
                'hints': ['Returns single row with correlation metrics']}
    
    @classmethod
    def _create_usage_patterns_structure(cls) -> Dict[str, Any]:
        """Create usage patterns structure template."""
        return {'type': 'usage_patterns', 'columns': ['day_of_week', 'hour_of_day', 'event_count'],
                'hints': ['Returns grouped data by time periods']}
    
    @classmethod
    def _create_performance_structure(cls) -> Dict[str, Any]:
        """Create performance structure template."""
        return {'type': 'performance_metrics', 'columns': ['time_bucket', 'latency_p50', 'latency_p95'],
                'hints': ['Returns time-series performance data']}
    
    @classmethod
    def mark_as_llm_generated(cls, query: str) -> str:
        """Explicitly mark a query as LLM-generated.
        
        Args:
            query: The query to mark
            
        Returns:
            Query with LLM marker added
        """
        if cls.LLM_QUERY_MARKER not in query:
            return f"{cls.LLM_QUERY_MARKER}\n{query}"
        return query
    
    @classmethod
    def is_explicitly_marked(cls, query: str) -> bool:
        """Check if query is explicitly marked as LLM-generated.
        
        Args:
            query: The query to check
            
        Returns:
            True if explicitly marked
        """
        return cls.LLM_QUERY_MARKER in query