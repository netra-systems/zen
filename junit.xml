<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="1" failures="0" skipped="0" tests="1" time="0.423" timestamp="2025-09-08T12:56:37.658118-07:00" hostname="Anthony"><testcase classname="tests.integration.test_auth_service_startup.TestAuthServiceStartup" name="test_auth_service_startup_sequence_integration" time="0.324"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\integration\test_auth_service_startup.py, line 123&#10;      @pytest.mark.integration&#10;      @pytest.mark.real_services&#10;      async def test_auth_service_startup_sequence_integration(self, real_services_fixture):&#10;          &quot;&quot;&quot;&#10;          Test complete auth service startup sequence validation.&#10;&#10;          BVJ: Ensures auth service completes all startup phases before accepting requests.&#10;          Without proper startup, authentication will fail and block all user access.&#10;          &quot;&quot;&quot;&#10;          startup_start = time.time()&#10;&#10;          # Phase 1: Environment initialization validation&#10;          phase1_start = time.time()&#10;&#10;          # Verify environment is properly initialized&#10;          assert self.environment is not None&#10;          assert self.environment in [&quot;test&quot;, &quot;development&quot;, &quot;staging&quot;, &quot;production&quot;]&#10;&#10;          # Verify critical environment variables are accessible&#10;          service_secret = self.auth_config.get_service_secret()&#10;          assert service_secret is not None, &quot;SERVICE_SECRET must be configured for auth service&quot;&#10;          assert len(service_secret) &gt; 0, &quot;SERVICE_SECRET cannot be empty&quot;&#10;&#10;          jwt_secret = self.auth_config.get_jwt_secret()&#10;          assert jwt_secret is not None, &quot;JWT secret must be configured&quot;&#10;          assert len(jwt_secret) &gt;= 32, &quot;JWT secret must be at least 32 characters&quot;&#10;&#10;          phase1_time = time.time() - phase1_start&#10;          self.startup_metrics[&quot;environment_init&quot;] = phase1_time&#10;          self.logger.info(f&quot;✅ Phase 1: Environment initialization completed in {phase1_time:.2f}s&quot;)&#10;&#10;          # Phase 2: Database connection initialization&#10;          phase2_start = time.time()&#10;&#10;          # Test database initialization (should be idempotent)&#10;          try:&#10;              await auth_db.initialize()&#10;              assert auth_db._initialized, &quot;Database should be initialized after initialize() call&quot;&#10;&#10;              # Verify database connectivity&#10;              db_ready = await auth_db.is_ready(timeout=10.0)&#10;              assert db_ready, &quot;Database should be ready after initialization&quot;&#10;&#10;              # Test session creation and database-agnostic query&#10;              async with auth_db.get_session() as session:&#10;                  assert session is not None, &quot;Should be able to create database session&quot;&#10;                  # Test basic query&#10;                  result = await session.execute(text(&quot;SELECT 1 as test_value&quot;))&#10;                  test_value = result.scalar()&#10;                  assert test_value == 1, &quot;Basic database query should work&quot;&#10;&#10;                  # Test table existence check (database-agnostic) - skip for async SQLite&#10;                  try:&#10;                      # For async databases, avoid synchronous inspector operations&#10;                      # that may cause greenlet issues&#10;                      if &quot;sqlite&quot; in str(session.get_bind().url):&#10;                          self.logger.info(&quot;Skipping table inspection for SQLite async - avoiding greenlet issues&quot;)&#10;                      else:&#10;                          inspector = inspect(session.get_bind())&#10;                          existing_tables = inspector.get_table_names()&#10;                          self.logger.info(f&quot;Found {len(existing_tables)} tables in database&quot;)&#10;                  except Exception as e:&#10;                      self.logger.warning(f&quot;Table inspection failed (acceptable for async DB): {e}&quot;)&#10;&#10;          except Exception as e:&#10;              pytest.fail(f&quot;Database initialization failed during startup: {e}&quot;)&#10;&#10;          phase2_time = time.time() - phase2_start&#10;          self.startup_metrics[&quot;database_init&quot;] = phase2_time&#10;          self.logger.info(f&quot;✅ Phase 2: Database initialization completed in {phase2_time:.2f}s&quot;)&#10;&#10;          # Phase 3: Redis session management setup&#10;          phase3_start = time.time()&#10;&#10;          if auth_redis_manager.enabled:&#10;              # Test Redis connection&#10;              redis_connected = await auth_redis_manager.connect()&#10;              assert redis_connected, &quot;Redis should connect successfully when enabled&quot;&#10;&#10;              # Test Redis operations&#10;              test_key = &quot;startup:test:redis_validation&quot;&#10;              test_value = f&quot;startup-test-{int(time.time())}&quot;&#10;&#10;              store_success = await auth_redis_manager.redis_client.set(test_key, test_value, ex=60)&#10;              assert store_success, &quot;Should be able to store data in Redis&quot;&#10;&#10;              retrieved_value = await auth_redis_manager.redis_client.get(test_key)&#10;              assert retrieved_value == test_value, &quot;Should retrieve stored Redis data correctly&quot;&#10;&#10;              # Test auth-specific Redis operations&#10;              session_stored = await auth_redis_manager.store_session(&#10;                  &quot;startup_test_session&quot;,&#10;                  {&quot;user_id&quot;: &quot;test&quot;, &quot;created_at&quot;: datetime.utcnow().isoformat()},&#10;                  ttl_seconds=300&#10;              )&#10;              assert session_stored, &quot;Should be able to store auth session in Redis&quot;&#10;&#10;              session_data = await auth_redis_manager.get_session(&quot;startup_test_session&quot;)&#10;              assert session_data is not None, &quot;Should retrieve stored session data&quot;&#10;              assert session_data[&quot;user_id&quot;] == &quot;test&quot;, &quot;Session data should be intact&quot;&#10;&#10;              # Cleanup test data&#10;              await auth_redis_manager.redis_client.delete(test_key)&#10;              await auth_redis_manager.delete_session(&quot;startup_test_session&quot;)&#10;          else:&#10;              self.logger.info(&quot;Redis is disabled for this environment - skipping Redis validation&quot;)&#10;&#10;          phase3_time = time.time() - phase3_start&#10;          self.startup_metrics[&quot;redis_init&quot;] = phase3_time&#10;          self.logger.info(f&quot;✅ Phase 3: Redis initialization completed in {phase3_time:.2f}s&quot;)&#10;&#10;          # Phase 4: Health endpoints validation&#10;          phase4_start = time.time()&#10;&#10;          # Test that health endpoints are responding&#10;          async with aiohttp.ClientSession() as session:&#10;              try:&#10;                  # Test basic health endpoint&#10;                  async with session.get(self.health_endpoint, timeout=aiohttp.ClientTimeout(total=10)) as response:&#10;                      assert response.status == 200, f&quot;Health endpoint should return 200, got {response.status}&quot;&#10;                      health_data = await response.json()&#10;                      assert health_data[&quot;service&quot;] == &quot;auth-service&quot;, &quot;Health response should identify service&quot;&#10;                      assert &quot;status&quot; in health_data, &quot;Health response should include status&quot;&#10;                      assert &quot;timestamp&quot; in health_data, &quot;Health response should include timestamp&quot;&#10;&#10;                  # Test readiness endpoint&#10;                  async with session.get(self.ready_endpoint, timeout=aiohttp.ClientTimeout(total=10)) as response:&#10;                      # Readiness endpoint should return 200 or 503 based on actual service state&#10;                      assert response.status in [200, 503], f&quot;Readiness endpoint should return 200 or 503, got {response.status}&quot;&#10;                      ready_data = await response.json()&#10;                      assert &quot;status&quot; in ready_data, &quot;Readiness response should include status&quot;&#10;                      assert ready_data[&quot;service&quot;] == &quot;auth-service&quot;, &quot;Readiness response should identify service&quot;&#10;&#10;              except aiohttp.ClientError as e:&#10;                  pytest.fail(f&quot;Failed to connect to auth service health endpoints: {e}&quot;)&#10;&#10;          phase4_time = time.time() - phase4_start&#10;          self.startup_metrics[&quot;health_endpoints&quot;] = phase4_time&#10;          self.logger.info(f&quot;✅ Phase 4: Health endpoints validation completed in {phase4_time:.2f}s&quot;)&#10;&#10;          # Calculate total startup time&#10;          total_startup_time = time.time() - startup_start&#10;          self.startup_metrics[&quot;total_startup&quot;] = total_startup_time&#10;&#10;          # Startup performance validation&#10;          assert total_startup_time &lt; 60.0, f&quot;Auth service startup should complete in under 60s, took {total_startup_time:.2f}s&quot;&#10;          assert phase1_time &lt; 5.0, f&quot;Environment init should complete in under 5s, took {phase1_time:.2f}s&quot;&#10;          assert phase2_time &lt; 30.0, f&quot;Database init should complete in under 30s, took {phase2_time:.2f}s&quot;&#10;          assert phase3_time &lt; 10.0, f&quot;Redis init should complete in under 10s, took {phase3_time:.2f}s&quot;&#10;          assert phase4_time &lt; 15.0, f&quot;Health endpoints should be ready in under 15s, took {phase4_time:.2f}s&quot;&#10;&#10;          self.logger.info(f&quot;#x1F389 Complete startup sequence validated in {total_startup_time:.2f}s&quot;)&#10;          self.logger.info(f&quot;Startup metrics: {json.dumps(self.startup_metrics, indent=2)}&quot;)&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, _xunit_setup_method_fixture_TestAuthServiceStartup, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\integration\test_auth_service_startup.py, line 123
      @pytest.mark.integration
      @pytest.mark.real_services
      async def test_auth_service_startup_sequence_integration(self, real_services_fixture):
          """
          Test complete auth service startup sequence validation.

          BVJ: Ensures auth service completes all startup phases before accepting requests.
          Without proper startup, authentication will fail and block all user access.
          """
          startup_start = time.time()

          # Phase 1: Environment initialization validation
          phase1_start = time.time()

          # Verify environment is properly initialized
          assert self.environment is not None
          assert self.environment in ["test", "development", "staging", "production"]

          # Verify critical environment variables are accessible
          service_secret = self.auth_config.get_service_secret()
          assert service_secret is not None, "SERVICE_SECRET must be configured for auth service"
          assert len(service_secret) &gt; 0, "SERVICE_SECRET cannot be empty"

          jwt_secret = self.auth_config.get_jwt_secret()
          assert jwt_secret is not None, "JWT secret must be configured"
          assert len(jwt_secret) &gt;= 32, "JWT secret must be at least 32 characters"

          phase1_time = time.time() - phase1_start
          self.startup_metrics["environment_init"] = phase1_time
          self.logger.info(f"✅ Phase 1: Environment initialization completed in {phase1_time:.2f}s")

          # Phase 2: Database connection initialization
          phase2_start = time.time()

          # Test database initialization (should be idempotent)
          try:
              await auth_db.initialize()
              assert auth_db._initialized, "Database should be initialized after initialize() call"

              # Verify database connectivity
              db_ready = await auth_db.is_ready(timeout=10.0)
              assert db_ready, "Database should be ready after initialization"

              # Test session creation and database-agnostic query
              async with auth_db.get_session() as session:
                  assert session is not None, "Should be able to create database session"
                  # Test basic query
                  result = await session.execute(text("SELECT 1 as test_value"))
                  test_value = result.scalar()
                  assert test_value == 1, "Basic database query should work"

                  # Test table existence check (database-agnostic) - skip for async SQLite
                  try:
                      # For async databases, avoid synchronous inspector operations
                      # that may cause greenlet issues
                      if "sqlite" in str(session.get_bind().url):
                          self.logger.info("Skipping table inspection for SQLite async - avoiding greenlet issues")
                      else:
                          inspector = inspect(session.get_bind())
                          existing_tables = inspector.get_table_names()
                          self.logger.info(f"Found {len(existing_tables)} tables in database")
                  except Exception as e:
                      self.logger.warning(f"Table inspection failed (acceptable for async DB): {e}")

          except Exception as e:
              pytest.fail(f"Database initialization failed during startup: {e}")

          phase2_time = time.time() - phase2_start
          self.startup_metrics["database_init"] = phase2_time
          self.logger.info(f"✅ Phase 2: Database initialization completed in {phase2_time:.2f}s")

          # Phase 3: Redis session management setup
          phase3_start = time.time()

          if auth_redis_manager.enabled:
              # Test Redis connection
              redis_connected = await auth_redis_manager.connect()
              assert redis_connected, "Redis should connect successfully when enabled"

              # Test Redis operations
              test_key = "startup:test:redis_validation"
              test_value = f"startup-test-{int(time.time())}"

              store_success = await auth_redis_manager.redis_client.set(test_key, test_value, ex=60)
              assert store_success, "Should be able to store data in Redis"

              retrieved_value = await auth_redis_manager.redis_client.get(test_key)
              assert retrieved_value == test_value, "Should retrieve stored Redis data correctly"

              # Test auth-specific Redis operations
              session_stored = await auth_redis_manager.store_session(
                  "startup_test_session",
                  {"user_id": "test", "created_at": datetime.utcnow().isoformat()},
                  ttl_seconds=300
              )
              assert session_stored, "Should be able to store auth session in Redis"

              session_data = await auth_redis_manager.get_session("startup_test_session")
              assert session_data is not None, "Should retrieve stored session data"
              assert session_data["user_id"] == "test", "Session data should be intact"

              # Cleanup test data
              await auth_redis_manager.redis_client.delete(test_key)
              await auth_redis_manager.delete_session("startup_test_session")
          else:
              self.logger.info("Redis is disabled for this environment - skipping Redis validation")

          phase3_time = time.time() - phase3_start
          self.startup_metrics["redis_init"] = phase3_time
          self.logger.info(f"✅ Phase 3: Redis initialization completed in {phase3_time:.2f}s")

          # Phase 4: Health endpoints validation
          phase4_start = time.time()

          # Test that health endpoints are responding
          async with aiohttp.ClientSession() as session:
              try:
                  # Test basic health endpoint
                  async with session.get(self.health_endpoint, timeout=aiohttp.ClientTimeout(total=10)) as response:
                      assert response.status == 200, f"Health endpoint should return 200, got {response.status}"
                      health_data = await response.json()
                      assert health_data["service"] == "auth-service", "Health response should identify service"
                      assert "status" in health_data, "Health response should include status"
                      assert "timestamp" in health_data, "Health response should include timestamp"

                  # Test readiness endpoint
                  async with session.get(self.ready_endpoint, timeout=aiohttp.ClientTimeout(total=10)) as response:
                      # Readiness endpoint should return 200 or 503 based on actual service state
                      assert response.status in [200, 503], f"Readiness endpoint should return 200 or 503, got {response.status}"
                      ready_data = await response.json()
                      assert "status" in ready_data, "Readiness response should include status"
                      assert ready_data["service"] == "auth-service", "Readiness response should identify service"

              except aiohttp.ClientError as e:
                  pytest.fail(f"Failed to connect to auth service health endpoints: {e}")

          phase4_time = time.time() - phase4_start
          self.startup_metrics["health_endpoints"] = phase4_time
          self.logger.info(f"✅ Phase 4: Health endpoints validation completed in {phase4_time:.2f}s")

          # Calculate total startup time
          total_startup_time = time.time() - startup_start
          self.startup_metrics["total_startup"] = total_startup_time

          # Startup performance validation
          assert total_startup_time &lt; 60.0, f"Auth service startup should complete in under 60s, took {total_startup_time:.2f}s"
          assert phase1_time &lt; 5.0, f"Environment init should complete in under 5s, took {phase1_time:.2f}s"
          assert phase2_time &lt; 30.0, f"Database init should complete in under 30s, took {phase2_time:.2f}s"
          assert phase3_time &lt; 10.0, f"Redis init should complete in under 10s, took {phase3_time:.2f}s"
          assert phase4_time &lt; 15.0, f"Health endpoints should be ready in under 15s, took {phase4_time:.2f}s"

          self.logger.info(f"#x1F389 Complete startup sequence validated in {total_startup_time:.2f}s")
          self.logger.info(f"Startup metrics: {json.dumps(self.startup_metrics, indent=2)}")
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"]
      }

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, _xunit_setup_method_fixture_TestAuthServiceStartup, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase></testsuite></testsuites>