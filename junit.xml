<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="61" failures="79" skipped="1" tests="351" time="35.323" timestamp="2025-09-08T19:20:29.470692-07:00" hostname="Anthony"><testcase classname="" name="tests.test_auth_real_services_comprehensive" time="0.000"><skipped message="collection skipped">('C:\\Users\\antho\\OneDrive\\Desktop\\Netra\\netra-core-generation-1\\auth_service\\tests\\test_auth_real_services_comprehensive.py', 51, 'Skipped: Test framework functions have been removed')</skipped></testcase><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_user_registration_business_rules" time="0.813" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_subscription_tier_access_control" time="0.002" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_login_attempt_business_logic" time="0.001" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_account_lifecycle_management" time="0.002" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthBusinessLogicValidation" name="test_business_rule_compliance_validation" time="0.002" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthCrossServiceValidation" name="test_cross_service_token_validation_business_logic" time="0.003" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthSecurityPolicyValidation" name="test_password_policy_business_rules" time="0.008" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthSecurityPolicyValidation" name="test_session_security_policy" time="0.005" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthIntegrationBusinessLogic" name="test_oauth_integration_business_rules" time="0.002" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthAuditBusinessLogic" name="test_audit_logging_business_rules" time="0.009" /><testcase classname="tests.unit.test_auth_business_logic_validation_comprehensive.TestAuthAuditBusinessLogic" name="test_compliance_reporting_business_logic" time="0.010" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_service_authentication_business_rules" time="0.019" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_user_permission_business_logic" time="0.010" /><testcase classname="tests.unit.test_auth_service_business_logic.TestAuthServiceBusinessLogic" name="test_user_lifecycle_business_events" time="0.323"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">auth_service\tests\unit\test_auth_service_business_logic.py:119: in test_user_lifecycle_business_events
    with pytest.raises(ValueError, match="User with this email already registered"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_auth_config_provides_critical_business_configuration" time="0.010" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_auth_config_adapts_to_environment_specific_business_needs" time="0.008" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_oauth_configuration_enables_user_onboarding_business_value" time="0.008" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_security_configuration_protects_business_assets" time="0.007" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_session_configuration_balances_security_and_usability" time="0.005" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_database_configuration_supports_business_scalability" time="0.010" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_redis_configuration_enables_session_management_business_value" time="0.007" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_cors_configuration_enables_frontend_integration_business_value" time="0.006" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_configuration_logging_masks_secrets_for_security" time="0.018" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_unified_auth_interface_provides_business_authentication_capabilities" time="0.011" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_auth_interface_token_creation_supports_business_workflows" time="0.017" /><testcase classname="tests.unit.test_auth_service_core_business_value.TestAuthServiceCoreBusinessValue" name="test_token_validation_protects_business_operations" time="0.020" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_health_check_script_basic_functionality" time="0.007" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_health_check_script_environment_port_handling" time="0.019" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_health_check_script_failure_scenarios" time="0.011" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthCheckScript" name="test_readiness_check_script_functionality" time="0.006" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_endpoints_response_formats" time="0.002" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_check_performance_timing" time="0.002" /><testcase classname="tests.unit.test_auth_service_health_check.TestAuthServiceHealthEndpoints" name="test_health_check_environment_differences" time="0.005" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_auth_postgres_health_check_success" time="0.009" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_auth_postgres_health_check_failure" time="0.006" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_oauth_providers_health_check" time="0.008" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_jwt_configuration_health_check" time="0.008" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthConfigModule" name="test_overall_auth_health_status_aggregation" time="0.013" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthCheckBusinessValue" name="test_health_monitoring_prevents_service_outages" time="0.006" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthCheckBusinessValue" name="test_health_check_supports_deployment_automation" time="0.001" /><testcase classname="tests.unit.test_auth_service_health_check.TestHealthCheckBusinessValue" name="test_health_check_enables_monitoring_and_alerting" time="0.007" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_password_validation_requirements" time="0.003" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_email_validation_security" time="0.003" /><testcase classname="tests.unit.test_auth_service_security_validation.TestAuthServiceSecurityValidation" name="test_authentication_rate_limiting_simulation" time="0.155" /><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_service_startup_sequence_validation" time="0.013" /><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_configuration_validation_comprehensive" time="0.066" /><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_environment_specific_configuration" time="0.019" /><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_dependency_health_checks" time="0.021"><failure message="AssertionError: assert not True&#10; +  where True = DependencyChecker.check_all_dependencies.&lt;locals&gt;.HealthResult(all_healthy=True, overall_response_time=0.1, database=DependencyChecker.check_all_dependencies.&lt;locals&gt;.ComponentHealth(healthy=True, response_time=0.05, error=''), redis=DependencyChecker.check_all_dependencies.&lt;locals&gt;.ComponentHealth(healthy=True, response_time=0.02, error=''), oauth_providers=DependencyChecker.check_all_dependencies.&lt;locals&gt;.ComponentHealth(healthy=True, response_time=0.0, error='')).all_healthy">auth_service\tests\unit\test_auth_startup_configuration_comprehensive.py:465: in test_dependency_health_checks
    assert not health_result.all_healthy
E   AssertionError: assert not True
E    +  where True = DependencyChecker.check_all_dependencies.&lt;locals&gt;.HealthResult(all_healthy=True, overall_response_time=0.1, database=DependencyChecker.check_all_dependencies.&lt;locals&gt;.ComponentHealth(healthy=True, response_time=0.05, error=''), redis=DependencyChecker.check_all_dependencies.&lt;locals&gt;.ComponentHealth(healthy=True, response_time=0.02, error=''), oauth_providers=DependencyChecker.check_all_dependencies.&lt;locals&gt;.ComponentHealth(healthy=True, response_time=0.0, error='')).all_healthy</failure></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_startup_performance_optimization" time="0.015" /><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_health_check_endpoints" time="0.008" /><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_graceful_shutdown_sequence" time="0.019"><failure message="AssertionError: assert False&#10; +  where False = &lt;MagicMock name='_close_database_connections' id='2086376896464'&gt;.called">auth_service\tests\unit\test_auth_startup_configuration_comprehensive.py:577: in test_graceful_shutdown_sequence
    assert mock_close_db.called
E   AssertionError: assert False
E    +  where False = &lt;MagicMock name='_close_database_connections' id='2086376896464'&gt;.called</failure></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_configuration_hot_reload" time="0.010"><failure message="AssertionError: assert 'log_level' in ['LOG_LEVEL']&#10; +  where 'log_level' = &lt;built-in method lower of str object at 0x000001E5962B1A30&gt;()&#10; +    where &lt;built-in method lower of str object at 0x000001E5962B1A30&gt; = 'LOG_LEVEL'.lower&#10; +  and   ['LOG_LEVEL'] = ConfigurationValidator.hot_reload_configuration.&lt;locals&gt;.ReloadResult(success=True, reloaded_configs=['LOG_LEVEL'], requires_restart=False).reloaded_configs">auth_service\tests\unit\test_auth_startup_configuration_comprehensive.py:614: in test_configuration_hot_reload
    assert config_key.lower() in reload_result.reloaded_configs
E   AssertionError: assert 'log_level' in ['LOG_LEVEL']
E    +  where 'log_level' = &lt;built-in method lower of str object at 0x000001E5962B1A30&gt;()
E    +    where &lt;built-in method lower of str object at 0x000001E5962B1A30&gt; = 'LOG_LEVEL'.lower
E    +  and   ['LOG_LEVEL'] = ConfigurationValidator.hot_reload_configuration.&lt;locals&gt;.ReloadResult(success=True, reloaded_configs=['LOG_LEVEL'], requires_restart=False).reloaded_configs</failure></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_startup_failure_recovery" time="0.012"><failure message="Exception: DB connection failed">auth_service\tests\unit\test_auth_startup_configuration_comprehensive.py:647: in test_startup_failure_recovery
    startup_result = service_initializer.initialize_service()
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_service\tests\unit\test_auth_startup_configuration_comprehensive.py:60: in initialize_service
    self._check_database_connection()
..\..\..\..\miniconda3\Lib\unittest\mock.py:1134: in __call__
    return self._mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\miniconda3\Lib\unittest\mock.py:1138: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\miniconda3\Lib\unittest\mock.py:1193: in _execute_mock_call
    raise effect
E   Exception: DB connection failed</failure></testcase><testcase classname="tests.unit.test_auth_startup_configuration_comprehensive.TestAuthStartupConfiguration" name="test_startup_monitoring_and_metrics" time="0.014" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_initialization" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 35&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_initialization(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic database connection initialization&quot;&quot;&quot;&#10;          # Create new connection instance&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Verify initial state&#10;          assert db_conn.engine is None&#10;          assert db_conn.async_session_maker is None&#10;          assert db_conn._initialized is False&#10;&#10;          # Initialize connection&#10;          await db_conn.initialize()&#10;&#10;          # Verify post-initialization state&#10;          assert db_conn.engine is not None&#10;          assert db_conn.async_session_maker is not None&#10;          assert db_conn._initialized is True&#10;&#10;          # Clean up&#10;          await db_conn.close()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 35
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_initialization(self, real_services_fixture):
          """Test basic database connection initialization"""
          # Create new connection instance
          db_conn = AuthDatabaseConnection()

          # Verify initial state
          assert db_conn.engine is None
          assert db_conn.async_session_maker is None
          assert db_conn._initialized is False

          # Initialize connection
          await db_conn.initialize()

          # Verify post-initialization state
          assert db_conn.engine is not None
          assert db_conn.async_session_maker is not None
          assert db_conn._initialized is True

          # Clean up
          await db_conn.close()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_idempotent_initialization" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 58&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_idempotent_initialization(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that initialization is idempotent (can be called multiple times safely)&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Initialize multiple times&#10;          await db_conn.initialize()&#10;          engine1 = db_conn.engine&#10;          session_maker1 = db_conn.async_session_maker&#10;&#10;          await db_conn.initialize()  # Second call&#10;          engine2 = db_conn.engine&#10;          session_maker2 = db_conn.async_session_maker&#10;&#10;          # Should be the same objects (idempotent)&#10;          assert engine1 is engine2&#10;          assert session_maker1 is session_maker2&#10;          assert db_conn._initialized is True&#10;&#10;          await db_conn.close()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 58
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_idempotent_initialization(self, real_services_fixture):
          """Test that initialization is idempotent (can be called multiple times safely)"""
          db_conn = AuthDatabaseConnection()

          # Initialize multiple times
          await db_conn.initialize()
          engine1 = db_conn.engine
          session_maker1 = db_conn.async_session_maker

          await db_conn.initialize()  # Second call
          engine2 = db_conn.engine
          session_maker2 = db_conn.async_session_maker

          # Should be the same objects (idempotent)
          assert engine1 is engine2
          assert session_maker1 is session_maker2
          assert db_conn._initialized is True

          await db_conn.close()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_environment_detection" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 80&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_environment_detection(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test environment detection and configuration&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Test environment variables are detected&#10;          env = get_env()&#10;          expected_env = env.get(&quot;ENVIRONMENT&quot;, &quot;development&quot;).lower()&#10;&#10;          assert db_conn.environment == expected_env&#10;          assert isinstance(db_conn.is_cloud_run, bool)&#10;          assert isinstance(db_conn.is_test_mode, bool)&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 80
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_environment_detection(self, real_services_fixture):
          """Test environment detection and configuration"""
          db_conn = AuthDatabaseConnection()

          # Test environment variables are detected
          env = get_env()
          expected_env = env.get("ENVIRONMENT", "development").lower()

          assert db_conn.environment == expected_env
          assert isinstance(db_conn.is_cloud_run, bool)
          assert isinstance(db_conn.is_test_mode, bool)
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_test_mode" time="0.143"><failure message="AssertionError: assert False&#10; +  where False = &lt;built-in method startswith of str object at 0x000001E5C5C76DB0&gt;('sqlite+aiosqlite:///:memory:')&#10; +    where &lt;built-in method startswith of str object at 0x000001E5C5C76DB0&gt; = 'sqlite+aiosqlite:///C:\\Users\\antho\\AppData\\Local\\Temp\\auth_service_test_1508.db'.startswith&#10; +      where 'sqlite+aiosqlite:///C:\\Users\\antho\\AppData\\Local\\Temp\\auth_service_test_1508.db' = str(sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db)&#10; +        where sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db = &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x000001E5C5C2E950&gt;.url&#10; +          where &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x000001E5C5C2E950&gt; = &lt;auth_service.auth_core.database.connection.AuthDatabaseConnection object at 0x000001E5C5C08620&gt;.engine">auth_service\tests\unit\test_database_connection_comprehensive.py:108: in test_database_connection_test_mode
    assert str(db_conn.engine.url).startswith("sqlite+aiosqlite:///:memory:")
E   AssertionError: assert False
E    +  where False = &lt;built-in method startswith of str object at 0x000001E5C5C76DB0&gt;('sqlite+aiosqlite:///:memory:')
E    +    where &lt;built-in method startswith of str object at 0x000001E5C5C76DB0&gt; = 'sqlite+aiosqlite:///C:\\Users\\antho\\AppData\\Local\\Temp\\auth_service_test_1508.db'.startswith
E    +      where 'sqlite+aiosqlite:///C:\\Users\\antho\\AppData\\Local\\Temp\\auth_service_test_1508.db' = str(sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db)
E    +        where sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db = &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x000001E5C5C2E950&gt;.url
E    +          where &lt;sqlalchemy.ext.asyncio.engine.AsyncEngine object at 0x000001E5C5C2E950&gt; = &lt;auth_service.auth_core.database.connection.AuthDatabaseConnection object at 0x000001E5C5C08620&gt;.engine</failure></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_timeout_handling" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 112&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_database_connection_timeout_handling(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test connection timeout handling&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;&#10;          # Test with very short timeout (should still succeed with real DB)&#10;          await db_conn.initialize(timeout=5.0)&#10;&#10;          assert db_conn._initialized is True&#10;          await db_conn.close()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 112
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_database_connection_timeout_handling(self, real_services_fixture):
          """Test connection timeout handling"""
          db_conn = AuthDatabaseConnection()

          # Test with very short timeout (should still succeed with real DB)
          await db_conn.initialize(timeout=5.0)

          assert db_conn._initialized is True
          await db_conn.close()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionInitialization" name="test_database_connection_initialization_failure" time="0.010" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_get_session_context_manager" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 149&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_session_context_manager(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session context manager functionality&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Session should be active&#10;              assert session is not None&#10;&#10;              # Test basic query&#10;              result = await session.execute(text(&quot;SELECT 1 as test&quot;))&#10;              value = result.scalar()&#10;              assert value == 1&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 149
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_session_context_manager(self, real_services_fixture):
          """Test session context manager functionality"""
          async with auth_db.get_session() as session:
              # Session should be active
              assert session is not None

              # Test basic query
              result = await session.execute(text("SELECT 1 as test"))
              value = result.scalar()
              assert value == 1
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_transaction_commit" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 162&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_transaction_commit(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session transaction commit&quot;&quot;&quot;&#10;          # Create test user in transaction&#10;          async with auth_db.get_session() as session:&#10;              user = AuthUser(email=&quot;session_commit_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;              user_id = user.id&#10;&#10;          # Verify user was committed&#10;          async with auth_db.get_session() as session:&#10;              retrieved_user = await session.get(AuthUser, user_id)&#10;              assert retrieved_user is not None&#10;              assert retrieved_user.email == &quot;session_commit_test@example.com&quot;&#10;&#10;              # Clean up&#10;              await session.delete(retrieved_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 162
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_transaction_commit(self, real_services_fixture):
          """Test session transaction commit"""
          # Create test user in transaction
          async with auth_db.get_session() as session:
              user = AuthUser(email="session_commit_test@example.com")
              session.add(user)
              await session.commit()
              user_id = user.id

          # Verify user was committed
          async with auth_db.get_session() as session:
              retrieved_user = await session.get(AuthUser, user_id)
              assert retrieved_user is not None
              assert retrieved_user.email == "session_commit_test@example.com"

              # Clean up
              await session.delete(retrieved_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_transaction_rollback" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 183&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_transaction_rollback(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session transaction rollback on error&quot;&quot;&quot;&#10;          user_id = None&#10;&#10;          try:&#10;              async with auth_db.get_session() as session:&#10;                  user = AuthUser(email=&quot;session_rollback_test@example.com&quot;)&#10;                  session.add(user)&#10;                  await session.flush()  # Get ID without committing&#10;                  user_id = user.id&#10;&#10;                  # Force an error to trigger rollback&#10;                  raise Exception(&quot;Test error to trigger rollback&quot;)&#10;          except Exception as e:&#10;              assert &quot;Test error to trigger rollback&quot; in str(e)&#10;&#10;          # Verify user was rolled back (doesn't exist)&#10;          async with auth_db.get_session() as session:&#10;              retrieved_user = await session.get(AuthUser, user_id) if user_id else None&#10;              assert retrieved_user is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 183
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_transaction_rollback(self, real_services_fixture):
          """Test session transaction rollback on error"""
          user_id = None

          try:
              async with auth_db.get_session() as session:
                  user = AuthUser(email="session_rollback_test@example.com")
                  session.add(user)
                  await session.flush()  # Get ID without committing
                  user_id = user.id

                  # Force an error to trigger rollback
                  raise Exception("Test error to trigger rollback")
          except Exception as e:
              assert "Test error to trigger rollback" in str(e)

          # Verify user was rolled back (doesn't exist)
          async with auth_db.get_session() as session:
              retrieved_user = await session.get(AuthUser, user_id) if user_id else None
              assert retrieved_user is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_isolation" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 206&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_isolation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that different sessions are isolated&quot;&quot;&quot;&#10;          # Create user in first session&#10;          async with auth_db.get_session() as session1:&#10;              user = AuthUser(email=&quot;session_isolation_test@example.com&quot;)&#10;              session1.add(user)&#10;              await session1.flush()  # Don't commit yet&#10;&#10;              # Second session shouldn't see uncommitted data&#10;              async with auth_db.get_session() as session2:&#10;                  result = await session2.execute(&#10;                      text(&quot;SELECT COUNT(*) FROM auth_users WHERE email = 'session_isolation_test@example.com'&quot;)&#10;                  )&#10;                  count = result.scalar()&#10;                  assert count == 0  # Shouldn't see uncommitted data&#10;&#10;              # Commit in first session&#10;              await session1.commit()&#10;              user_id = user.id&#10;&#10;          # Now second session should see committed data&#10;          async with auth_db.get_session() as session:&#10;              retrieved_user = await session.get(AuthUser, user_id)&#10;              assert retrieved_user is not None&#10;&#10;              # Clean up&#10;              await session.delete(retrieved_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 206
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_isolation(self, real_services_fixture):
          """Test that different sessions are isolated"""
          # Create user in first session
          async with auth_db.get_session() as session1:
              user = AuthUser(email="session_isolation_test@example.com")
              session1.add(user)
              await session1.flush()  # Don't commit yet

              # Second session shouldn't see uncommitted data
              async with auth_db.get_session() as session2:
                  result = await session2.execute(
                      text("SELECT COUNT(*) FROM auth_users WHERE email = 'session_isolation_test@example.com'")
                  )
                  count = result.scalar()
                  assert count == 0  # Shouldn't see uncommitted data

              # Commit in first session
              await session1.commit()
              user_id = user.id

          # Now second session should see committed data
          async with auth_db.get_session() as session:
              retrieved_user = await session.get(AuthUser, user_id)
              assert retrieved_user is not None

              # Clean up
              await session.delete(retrieved_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_session_concurrent_access" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 237&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_concurrent_access(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test concurrent session access&quot;&quot;&quot;&#10;          async def create_user(suffix):&#10;              async with auth_db.get_session() as session:&#10;                  user = AuthUser(email=f&quot;concurrent_test_{suffix}@example.com&quot;)&#10;                  session.add(user)&#10;                  await session.commit()&#10;                  return user.id&#10;&#10;          # Create multiple users concurrently&#10;          user_ids = await asyncio.gather(&#10;              create_user(&quot;1&quot;),&#10;              create_user(&quot;2&quot;),&#10;              create_user(&quot;3&quot;)&#10;          )&#10;&#10;          # Verify all users were created&#10;          async with auth_db.get_session() as session:&#10;              for user_id in user_ids:&#10;                  user = await session.get(AuthUser, user_id)&#10;                  assert user is not None&#10;&#10;                  # Clean up&#10;                  await session.delete(user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 237
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_concurrent_access(self, real_services_fixture):
          """Test concurrent session access"""
          async def create_user(suffix):
              async with auth_db.get_session() as session:
                  user = AuthUser(email=f"concurrent_test_{suffix}@example.com")
                  session.add(user)
                  await session.commit()
                  return user.id

          # Create multiple users concurrently
          user_ids = await asyncio.gather(
              create_user("1"),
              create_user("2"),
              create_user("3")
          )

          # Verify all users were created
          async with auth_db.get_session() as session:
              for user_id in user_ids:
                  user = await session.get(AuthUser, user_id)
                  assert user is not None

                  # Clean up
                  await session.delete(user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionSessionManagement" name="test_get_db_session_dependency" time="0.002"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 265&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_db_session_dependency(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test FastAPI dependency function&quot;&quot;&quot;&#10;          session_generator = get_db_session()&#10;          session = await session_generator.__anext__()&#10;&#10;          assert session is not None&#10;&#10;          # Test basic query&#10;          result = await session.execute(text(&quot;SELECT 1 as test&quot;))&#10;          value = result.scalar()&#10;          assert value == 1&#10;&#10;          # Clean up the generator&#10;          try:&#10;              await session_generator.__anext__()&#10;          except StopAsyncIteration:&#10;              pass  # Expected&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for session tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 265
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_db_session_dependency(self, real_services_fixture):
          """Test FastAPI dependency function"""
          session_generator = get_db_session()
          session = await session_generator.__anext__()

          assert session is not None

          # Test basic query
          result = await session.execute(text("SELECT 1 as test"))
          value = result.scalar()
          assert value == 1

          # Clean up the generator
          try:
              await session_generator.__anext__()
          except StopAsyncIteration:
              pass  # Expected
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 143
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for session tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionPoolingAndPerformance" name="test_connection_pooling_multiple_sessions" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 295&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_connection_pooling_multiple_sessions(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that multiple sessions use connection pooling efficiently&quot;&quot;&quot;&#10;          # Create multiple sessions sequentially&#10;          session_results = []&#10;&#10;          for i in range(5):&#10;              async with auth_db.get_session() as session:&#10;                  result = await session.execute(text(f&quot;SELECT {i} as test&quot;))&#10;                  value = result.scalar()&#10;                  session_results.append(value)&#10;&#10;          # Verify all sessions worked correctly&#10;          assert session_results == [0, 1, 2, 3, 4]&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 289&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for pooling tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 295
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_connection_pooling_multiple_sessions(self, real_services_fixture):
          """Test that multiple sessions use connection pooling efficiently"""
          # Create multiple sessions sequentially
          session_results = []

          for i in range(5):
              async with auth_db.get_session() as session:
                  result = await session.execute(text(f"SELECT {i} as test"))
                  value = result.scalar()
                  session_results.append(value)

          # Verify all sessions worked correctly
          assert session_results == [0, 1, 2, 3, 4]
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 289
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for pooling tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionPoolingAndPerformance" name="test_connection_reuse" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 311&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_connection_reuse(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that connections are reused from pool&quot;&quot;&quot;&#10;          connection_pids = []&#10;&#10;          # Get connection PIDs from multiple sessions&#10;          for _ in range(3):&#10;              async with auth_db.get_session() as session:&#10;                  # Get backend process ID if available (PostgreSQL specific)&#10;                  try:&#10;                      result = await session.execute(text(&quot;SELECT pg_backend_pid()&quot;))&#10;                      pid = result.scalar()&#10;                      connection_pids.append(pid)&#10;                  except Exception:&#10;                      # Skip if not PostgreSQL or function not available&#10;                      connection_pids.append(None)&#10;&#10;          # Remove None values (non-PostgreSQL connections)&#10;          valid_pids = [pid for pid in connection_pids if pid is not None]&#10;&#10;          if valid_pids:&#10;              # In a pool, we might reuse connections, so we could see repeated PIDs&#10;              assert len(valid_pids) &gt;= 1&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 289&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for pooling tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 311
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_connection_reuse(self, real_services_fixture):
          """Test that connections are reused from pool"""
          connection_pids = []

          # Get connection PIDs from multiple sessions
          for _ in range(3):
              async with auth_db.get_session() as session:
                  # Get backend process ID if available (PostgreSQL specific)
                  try:
                      result = await session.execute(text("SELECT pg_backend_pid()"))
                      pid = result.scalar()
                      connection_pids.append(pid)
                  except Exception:
                      # Skip if not PostgreSQL or function not available
                      connection_pids.append(None)

          # Remove None values (non-PostgreSQL connections)
          valid_pids = [pid for pid in connection_pids if pid is not None]

          if valid_pids:
              # In a pool, we might reuse connections, so we could see repeated PIDs
              assert len(valid_pids) &gt;= 1
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 289
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for pooling tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionPoolingAndPerformance" name="test_session_cleanup_on_error" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 336&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_cleanup_on_error(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that sessions are properly cleaned up on errors&quot;&quot;&quot;&#10;          initial_pool_size = 0&#10;&#10;          # Get initial pool state if available&#10;          if hasattr(auth_db.engine, 'pool'):&#10;              try:&#10;                  initial_pool_size = auth_db.engine.pool.checkedin()&#10;              except:&#10;                  pass&#10;&#10;          # Create session that raises error&#10;          try:&#10;              async with auth_db.get_session() as session:&#10;                  # Force an error&#10;                  await session.execute(text(&quot;SELECT * FROM nonexistent_table&quot;))&#10;          except Exception:&#10;              pass  # Expected error&#10;&#10;          # Pool should be cleaned up properly&#10;          if hasattr(auth_db.engine, 'pool'):&#10;              try:&#10;                  final_pool_size = auth_db.engine.pool.checkedin()&#10;                  # Pool size should be restored (connection returned to pool)&#10;                  assert final_pool_size &gt;= initial_pool_size&#10;              except:&#10;                  pass  # Skip if pool inspection not available&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 289&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for pooling tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 336
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_cleanup_on_error(self, real_services_fixture):
          """Test that sessions are properly cleaned up on errors"""
          initial_pool_size = 0

          # Get initial pool state if available
          if hasattr(auth_db.engine, 'pool'):
              try:
                  initial_pool_size = auth_db.engine.pool.checkedin()
              except:
                  pass

          # Create session that raises error
          try:
              async with auth_db.get_session() as session:
                  # Force an error
                  await session.execute(text("SELECT * FROM nonexistent_table"))
          except Exception:
              pass  # Expected error

          # Pool should be cleaned up properly
          if hasattr(auth_db.engine, 'pool'):
              try:
                  final_pool_size = auth_db.engine.pool.checkedin()
                  # Pool size should be restored (connection returned to pool)
                  assert final_pool_size &gt;= initial_pool_size
              except:
                  pass  # Skip if pool inspection not available
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 289
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for pooling tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_test_connection" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 376&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_test_connection(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test connection health check&quot;&quot;&quot;&#10;          result = await auth_db.test_connection()&#10;          assert result is True&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 376
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_test_connection(self, real_services_fixture):
          """Test connection health check"""
          result = await auth_db.test_connection()
          assert result is True
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_test_connection_with_timeout" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 383&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_test_connection_with_timeout(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test connection health check with custom timeout&quot;&quot;&quot;&#10;          result = await auth_db.test_connection(timeout=5.0)&#10;          assert result is True&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 383
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_test_connection_with_timeout(self, real_services_fixture):
          """Test connection health check with custom timeout"""
          result = await auth_db.test_connection(timeout=5.0)
          assert result is True
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_is_ready" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 390&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_is_ready(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test database readiness check&quot;&quot;&quot;&#10;          result = await auth_db.is_ready()&#10;          assert result is True&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 390
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_is_ready(self, real_services_fixture):
          """Test database readiness check"""
          result = await auth_db.is_ready()
          assert result is True
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_is_ready_with_timeout" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 397&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_is_ready_with_timeout(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test database readiness check with custom timeout&quot;&quot;&quot;&#10;          result = await auth_db.is_ready(timeout=5.0)&#10;          assert result is True&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 397
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_is_ready_with_timeout(self, real_services_fixture):
          """Test database readiness check with custom timeout"""
          result = await auth_db.is_ready(timeout=5.0)
          assert result is True
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_get_status" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 404&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_status(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test database status reporting&quot;&quot;&quot;&#10;          status = auth_db.get_status()&#10;&#10;          assert isinstance(status, dict)&#10;          assert &quot;status&quot; in status&#10;          assert status[&quot;status&quot;] == &quot;active&quot;&#10;          assert &quot;environment&quot; in status&#10;          assert &quot;is_cloud_run&quot; in status&#10;          assert &quot;is_test_mode&quot; in status&#10;          assert isinstance(status[&quot;is_cloud_run&quot;], bool)&#10;          assert isinstance(status[&quot;is_test_mode&quot;], bool)&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 404
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_status(self, real_services_fixture):
          """Test database status reporting"""
          status = auth_db.get_status()

          assert isinstance(status, dict)
          assert "status" in status
          assert status["status"] == "active"
          assert "environment" in status
          assert "is_cloud_run" in status
          assert "is_test_mode" in status
          assert isinstance(status["is_cloud_run"], bool)
          assert isinstance(status["is_test_mode"], bool)
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_get_connection_health" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 419&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_get_connection_health(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test detailed connection health information&quot;&quot;&quot;&#10;          health = await auth_db.get_connection_health()&#10;&#10;          assert isinstance(health, dict)&#10;          assert &quot;initialized&quot; in health&#10;          assert health[&quot;initialized&quot;] is True&#10;          assert &quot;environment&quot; in health&#10;          assert &quot;engine_exists&quot; in health&#10;          assert health[&quot;engine_exists&quot;] is True&#10;          assert &quot;timestamp&quot; in health&#10;          assert &quot;connectivity_test&quot; in health&#10;          assert health[&quot;connectivity_test&quot;] == &quot;passed&quot;&#10;          assert &quot;status&quot; in health&#10;          assert health[&quot;status&quot;] == &quot;healthy&quot;&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 419
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_get_connection_health(self, real_services_fixture):
          """Test detailed connection health information"""
          health = await auth_db.get_connection_health()

          assert isinstance(health, dict)
          assert "initialized" in health
          assert health["initialized"] is True
          assert "environment" in health
          assert "engine_exists" in health
          assert health["engine_exists"] is True
          assert "timestamp" in health
          assert "connectivity_test" in health
          assert health["connectivity_test"] == "passed"
          assert "status" in health
          assert health["status"] == "healthy"
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionHealthAndMonitoring" name="test_get_connection_health_uninitialized" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 437&#10;      @pytest.mark.unit&#10;      async def test_get_connection_health_uninitialized(self):&#10;          &quot;&quot;&quot;Test connection health when not initialized&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;          health = await db_conn.get_connection_health()&#10;&#10;          assert health[&quot;initialized&quot;] is False&#10;          assert health[&quot;status&quot;] == &quot;not_initialized&quot;&#10;          assert health[&quot;engine_exists&quot;] is False&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Ensure database is initialized for health tests&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 437
      @pytest.mark.unit
      async def test_get_connection_health_uninitialized(self):
          """Test connection health when not initialized"""
          db_conn = AuthDatabaseConnection()
          health = await db_conn.get_connection_health()

          assert health["initialized"] is False
          assert health["status"] == "not_initialized"
          assert health["engine_exists"] is False
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 370
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Ensure database is initialized for health tests"""
          if not auth_db._initialized:
              await auth_db.initialize()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_mock_engine_handling" time="0.012" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_connection_validation_with_mock" time="0.006" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_cleanup_partial_initialization" time="0.007" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_close_with_timeout" time="0.008" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_close_already_closed" time="0.006" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_close_with_dispose_error" time="0.007" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_session_error_handling_edge_cases" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 542&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_session_error_handling_edge_cases(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session error handling edge cases&quot;&quot;&quot;&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Test session with invalid SQL&#10;          try:&#10;              async with auth_db.get_session() as session:&#10;                  await session.execute(text(&quot;INVALID SQL STATEMENT&quot;))&#10;          except Exception as e:&#10;              # Should handle SQL errors gracefully&#10;              assert isinstance(e, SQLAlchemyError)&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 542
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_session_error_handling_edge_cases(self, real_services_fixture):
          """Test session error handling edge cases"""
          if not auth_db._initialized:
              await auth_db.initialize()

          # Test session with invalid SQL
          try:
              async with auth_db.get_session() as session:
                  await session.execute(text("INVALID SQL STATEMENT"))
          except Exception as e:
              # Should handle SQL errors gracefully
              assert isinstance(e, SQLAlchemyError)
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_test_connection_failure" time="0.012"><failure message="pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x000001E5C4B37240&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.">..\..\..\..\miniconda3\Lib\warnings.py:555: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited

The above exception was the direct cause of the following exception:
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\logging.py:850: in pytest_runtest_call
    yield
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\capture.py:900: in pytest_runtest_call
    return (yield)
            ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\skipping.py:263: in pytest_runtest_call
    return (yield)
            ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:158: in pytest_runtest_call
    collect_unraisable(item.config)
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:79: in collect_unraisable
    raise errors[0]
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x000001E5C4B37240&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</failure></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_test_connection_timeout" time="0.009"><failure message="pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x000001E5C4B36640&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.">..\..\..\..\miniconda3\Lib\warnings.py:555: in _warn_unawaited_coroutine
    warn(msg, category=RuntimeWarning, stacklevel=2, source=coro)
E   RuntimeWarning: coroutine 'AsyncMockMixin._execute_mock_call' was never awaited

The above exception was the direct cause of the following exception:
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\logging.py:850: in pytest_runtest_call
    yield
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\capture.py:900: in pytest_runtest_call
    return (yield)
            ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:53: in run_old_style_hookwrapper
    return result.get_result()
           ^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_callers.py:38: in run_old_style_hookwrapper
    res = yield
          ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\skipping.py:263: in pytest_runtest_call
    return (yield)
            ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:158: in pytest_runtest_call
    collect_unraisable(item.config)
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:79: in collect_unraisable
    raise errors[0]
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;coroutine object AsyncMockMixin._execute_mock_call at 0x000001E5C4B36640&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</failure></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionErrorHandling" name="test_is_ready_timeout" time="0.008" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionTableManagement" name="test_create_tables_idempotent" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 601&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_create_tables_idempotent(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that create_tables is idempotent&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;          await db_conn.initialize()&#10;&#10;          # Create tables multiple times - should not fail&#10;          await db_conn.create_tables()&#10;          await db_conn.create_tables()  # Second call should be safe&#10;&#10;          await db_conn.close()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 601
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_create_tables_idempotent(self, real_services_fixture):
          """Test that create_tables is idempotent"""
          db_conn = AuthDatabaseConnection()
          await db_conn.initialize()

          # Create tables multiple times - should not fail
          await db_conn.create_tables()
          await db_conn.create_tables()  # Second call should be safe

          await db_conn.close()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionTableManagement" name="test_create_tables_with_mock_engine" time="0.014" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionTableManagement" name="test_table_existence_check" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 626&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_table_existence_check(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test table existence checking in PostgreSQL&quot;&quot;&quot;&#10;          db_conn = AuthDatabaseConnection()&#10;          await db_conn.initialize()&#10;&#10;          # Tables should exist after initialization&#10;          async with db_conn.engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;&quot;&quot;&#10;                  SELECT EXISTS (&#10;                      SELECT FROM information_schema.tables&#10;                      WHERE table_schema = 'public'&#10;                      AND table_name = 'auth_users'&#10;                  );&#10;              &quot;&quot;&quot;))&#10;              table_exists = result.scalar()&#10;              assert table_exists is True&#10;&#10;          await db_conn.close()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 626
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_table_existence_check(self, real_services_fixture):
          """Test table existence checking in PostgreSQL"""
          db_conn = AuthDatabaseConnection()
          await db_conn.initialize()

          # Tables should exist after initialization
          async with db_conn.engine.connect() as conn:
              result = await conn.execute(text("""
                  SELECT EXISTS (
                      SELECT FROM information_schema.tables
                      WHERE table_schema = 'public'
                      AND table_name = 'auth_users'
                  );
              """))
              table_exists = result.scalar()
              assert table_exists is True

          await db_conn.close()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionCompatibilityAliases" name="test_compatibility_aliases" time="0.001" /><testcase classname="tests.unit.test_database_connection_comprehensive.TestAuthDatabaseConnectionCompatibilityAliases" name="test_global_auth_db_instance" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 662&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_global_auth_db_instance(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that global auth_db instance works correctly&quot;&quot;&quot;&#10;          from auth_service.auth_core.database.connection import auth_db&#10;&#10;          # Should be an instance of AuthDatabaseConnection&#10;          assert isinstance(auth_db, AuthDatabaseConnection)&#10;&#10;          # Should be able to use it&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          async with auth_db.get_session() as session:&#10;              result = await session.execute(text(&quot;SELECT 1&quot;))&#10;              assert result.scalar() == 1&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_comprehensive.py, line 662
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_global_auth_db_instance(self, real_services_fixture):
          """Test that global auth_db instance works correctly"""
          from auth_service.auth_core.database.connection import auth_db

          # Should be an instance of AuthDatabaseConnection
          assert isinstance(auth_db, AuthDatabaseConnection)

          # Should be able to use it
          if not auth_db._initialized:
              await auth_db.initialize()

          async with auth_db.get_session() as session:
              result = await session.execute(text("SELECT 1"))
              assert result.scalar() == 1
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestAuthDatabaseConfig" name="test_auth_database_config_constants" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestAuthDatabaseConfig" name="test_auth_database_config_values_reasonable" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_with_auth_config" time="0.001"><failure message="AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from 'C:\\Users\\antho\\OneDrive\\Desktop\\Netra\\netra-core-generation-1\\auth_service\\auth_core\\database\\connection_events.py'&gt; does not have the attribute 'AuthConfig'">auth_service\tests\unit\test_database_connection_events_comprehensive.py:80: in test_get_settings_with_auth_config
    with patch('auth_service.auth_core.database.connection_events.AuthConfig') as mock_config:
..\..\..\..\miniconda3\Lib\unittest\mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
..\..\..\..\miniconda3\Lib\unittest\mock.py:1431: in get_original
    raise AttributeError(
E   AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from 'C:\\Users\\antho\\OneDrive\\Desktop\\Netra\\netra-core-generation-1\\auth_service\\auth_core\\database\\connection_events.py'&gt; does not have the attribute 'AuthConfig'</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_with_partial_auth_config" time="0.001"><failure message="AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from 'C:\\Users\\antho\\OneDrive\\Desktop\\Netra\\netra-core-generation-1\\auth_service\\auth_core\\database\\connection_events.py'&gt; does not have the attribute 'AuthConfig'">auth_service\tests\unit\test_database_connection_events_comprehensive.py:95: in test_get_settings_with_partial_auth_config
    with patch('auth_service.auth_core.database.connection_events.AuthConfig') as mock_config:
..\..\..\..\miniconda3\Lib\unittest\mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
..\..\..\..\miniconda3\Lib\unittest\mock.py:1431: in get_original
    raise AttributeError(
E   AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from 'C:\\Users\\antho\\OneDrive\\Desktop\\Netra\\netra-core-generation-1\\auth_service\\auth_core\\database\\connection_events.py'&gt; does not have the attribute 'AuthConfig'</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_import_error" time="0.001"><failure message="AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from 'C:\\Users\\antho\\OneDrive\\Desktop\\Netra\\netra-core-generation-1\\auth_service\\auth_core\\database\\connection_events.py'&gt; does not have the attribute 'AuthConfig'">auth_service\tests\unit\test_database_connection_events_comprehensive.py:111: in test_get_settings_import_error
    with patch('auth_service.auth_core.database.connection_events.AuthConfig', side_effect=ImportError):
..\..\..\..\miniconda3\Lib\unittest\mock.py:1458: in __enter__
    original, local = self.get_original()
                      ^^^^^^^^^^^^^^^^^^^
..\..\..\..\miniconda3\Lib\unittest\mock.py:1431: in get_original
    raise AttributeError(
E   AttributeError: &lt;module 'auth_service.auth_core.database.connection_events' from 'C:\\Users\\antho\\OneDrive\\Desktop\\Netra\\netra-core-generation-1\\auth_service\\auth_core\\database\\connection_events.py'&gt; does not have the attribute 'AuthConfig'</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestGetSettings" name="test_get_settings_module_level_initialization" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_execute_auth_timeout_statements" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_close_cursor_safely_success" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_close_cursor_safely_error" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_configure_auth_connection_timeouts_success" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestTimeoutConfiguration" name="test_configure_auth_connection_timeouts_error" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionPIDHandling" name="test_set_auth_connection_pid_with_backend_pid" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionPIDHandling" name="test_set_auth_connection_pid_no_backend_pid" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionPIDHandling" name="test_set_auth_connection_pid_error" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_no_pool" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_normal_usage" time="0.003" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_high_usage" time="0.002"><failure message="AssertionError: Expected 'warning' to have been called.">..\..\..\..\miniconda3\Lib\unittest\mock.py:913: in assert_called
    raise AssertionError(msg)
E   AssertionError: Expected 'warning' to have been called.

During handling of the above exception, another exception occurred:
auth_service\tests\unit\test_database_connection_events_comprehensive.py:276: in test_monitor_auth_pool_usage_high_usage
    mock_logger.warning.assert_called()
E   AssertionError: Expected 'warning' to have been called.</failure></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_missing_methods" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestPoolMonitoring" name="test_monitor_auth_pool_usage_error" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_connection_established_with_settings" time="0.003" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_connection_established_no_settings" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_checkout_if_enabled_enabled" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestConnectionLogging" name="test_log_auth_checkout_if_enabled_disabled" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEngineEventSetup" name="test_setup_auth_async_engine_events_success" time="0.006" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEngineEventSetup" name="test_setup_auth_async_engine_events_none_engine" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEngineEventSetup" name="test_setup_auth_async_engine_events_error" time="0.004" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlersIntegration" name="test_connect_event_handler_postgresql" time="0.004" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlersIntegration" name="test_connect_event_handler_sqlite" time="0.004" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlersIntegration" name="test_checkout_event_handler" time="0.004" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestRealEngineIntegration" name="test_setup_events_on_real_engine" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_events_comprehensive.py, line 508&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_setup_events_on_real_engine(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test setting up events on real database engine&quot;&quot;&quot;&#10;          # Create real engine for testing&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;&#10;          try:&#10;              # Setup events (should not raise error)&#10;              setup_auth_async_engine_events(engine)&#10;&#10;              # Test that engine still works after event setup&#10;              async with engine.connect() as conn:&#10;                  result = await conn.execute(text(&quot;SELECT 1&quot;))&#10;                  value = result.scalar()&#10;                  assert value == 1&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_events_comprehensive.py, line 508
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_setup_events_on_real_engine(self, real_services_fixture):
          """Test setting up events on real database engine"""
          # Create real engine for testing
          engine = AuthDatabaseManager.create_async_engine()

          try:
              # Setup events (should not raise error)
              setup_auth_async_engine_events(engine)

              # Test that engine still works after event setup
              async with engine.connect() as conn:
                  result = await conn.execute(text("SELECT 1"))
                  value = result.scalar()
                  assert value == 1

          finally:
              await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestRealEngineIntegration" name="test_events_trigger_on_real_connections" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_events_comprehensive.py, line 528&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_events_trigger_on_real_connections(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that events are actually triggered on real connections&quot;&quot;&quot;&#10;          # Create engine with events&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;          setup_auth_async_engine_events(engine)&#10;&#10;          try:&#10;              # Use connection to trigger events&#10;              async with engine.connect() as conn:&#10;                  result = await conn.execute(text(&quot;SELECT current_database()&quot;))&#10;                  db_name = result.scalar()&#10;                  assert db_name is not None&#10;&#10;              # Events should have been triggered (we can't easily verify this&#10;              # without mocking, but at least we know they don't break functionality)&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_events_comprehensive.py, line 528
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_events_trigger_on_real_connections(self, real_services_fixture):
          """Test that events are actually triggered on real connections"""
          # Create engine with events
          engine = AuthDatabaseManager.create_async_engine()
          setup_auth_async_engine_events(engine)

          try:
              # Use connection to trigger events
              async with engine.connect() as conn:
                  result = await conn.execute(text("SELECT current_database()"))
                  db_name = result.scalar()
                  assert db_name is not None

              # Events should have been triggered (we can't easily verify this
              # without mocking, but at least we know they don't break functionality)

          finally:
              await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestRealEngineIntegration" name="test_multiple_connections_with_events" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_events_comprehensive.py, line 549&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_multiple_connections_with_events(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test multiple connections with events enabled&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;          setup_auth_async_engine_events(engine)&#10;&#10;          try:&#10;              # Create multiple connections&#10;              for i in range(3):&#10;                  async with engine.connect() as conn:&#10;                      result = await conn.execute(text(f&quot;SELECT {i + 1}&quot;))&#10;                      value = result.scalar()&#10;                      assert value == i + 1&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_connection_events_comprehensive.py, line 549
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_multiple_connections_with_events(self, real_services_fixture):
          """Test multiple connections with events enabled"""
          engine = AuthDatabaseManager.create_async_engine()
          setup_auth_async_engine_events(engine)

          try:
              # Create multiple connections
              for i in range(3):
                  async with engine.connect() as conn:
                      result = await conn.execute(text(f"SELECT {i + 1}"))
                      value = result.scalar()
                      assert value == i + 1

          finally:
              await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_pool_events_setup" time="0.005" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_connection_info_logging" time="0.002" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_event_handler_exception_handling" time="0.001" /><testcase classname="tests.unit.test_database_connection_events_comprehensive.TestEventHandlerEdgeCases" name="test_module_exports" time="0.001" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 31&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_create_async_engine(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic async engine creation&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;&#10;          assert isinstance(engine, AsyncEngine)&#10;          assert engine is not None&#10;&#10;          # Verify engine configuration&#10;          assert isinstance(engine.pool, NullPool)&#10;          assert engine.echo is False&#10;&#10;          # Test engine connectivity&#10;          async with engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;SELECT 1&quot;))&#10;              value = result.scalar()&#10;              assert value == 1&#10;&#10;          await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 31
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_create_async_engine(self, real_services_fixture):
          """Test basic async engine creation"""
          engine = AuthDatabaseManager.create_async_engine()

          assert isinstance(engine, AsyncEngine)
          assert engine is not None

          # Verify engine configuration
          assert isinstance(engine.pool, NullPool)
          assert engine.echo is False

          # Test engine connectivity
          async with engine.connect() as conn:
              result = await conn.execute(text("SELECT 1"))
              value = result.scalar()
              assert value == 1

          await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine_with_kwargs" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 52&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_create_async_engine_with_kwargs(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test engine creation with custom kwargs&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine(&#10;              echo=True,&#10;              pool_timeout=60&#10;          )&#10;&#10;          assert isinstance(engine, AsyncEngine)&#10;          assert engine.echo is True&#10;&#10;          # Test connectivity&#10;          async with engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;SELECT 42&quot;))&#10;              value = result.scalar()&#10;              assert value == 42&#10;&#10;          await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 52
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_create_async_engine_with_kwargs(self, real_services_fixture):
          """Test engine creation with custom kwargs"""
          engine = AuthDatabaseManager.create_async_engine(
              echo=True,
              pool_timeout=60
          )

          assert isinstance(engine, AsyncEngine)
          assert engine.echo is True

          # Test connectivity
          async with engine.connect() as conn:
              result = await conn.execute(text("SELECT 42"))
              value = result.scalar()
              assert value == 42

          await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine_no_url_error" time="0.007" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEngineCreation" name="test_create_async_engine_empty_url_error" time="0.004" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_normal_mode" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 90&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      def test_get_database_url_normal_mode(self, real_services_fixture):&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 90
      @pytest.mark.unit
      @pytest.mark.real_services
      def test_get_database_url_normal_mode(self, real_services_fixture):
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_fast_test_mode" time="0.004"><failure message="AssertionError: assert 'sqlite+aiosq..._test_1508.db' == 'sqlite+aiosqlite:///:memory:'&#10;  &#10;  - sqlite+aiosqlite:///:memory:&#10;  + sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db">auth_service\tests\unit\test_database_manager_comprehensive.py:114: in test_get_database_url_fast_test_mode
    assert url == "sqlite+aiosqlite:///:memory:"
E   AssertionError: assert 'sqlite+aiosq..._test_1508.db' == 'sqlite+aiosqlite:///:memory:'
E     
E     - sqlite+aiosqlite:///:memory:
E     + sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_environment_variables" time="0.009"><failure message="AssertionError: assert 'postgresql+a...:5432/test_db' == 'postgresql:/...:5432/test_db'&#10;  &#10;  - postgresql://test_user:test_pass@localhost:5432/test_db&#10;  + postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db&#10;  ?           ++++++++">auth_service\tests\unit\test_database_manager_comprehensive.py:141: in test_get_database_url_environment_variables
    assert url == "postgresql://test_user:test_pass@localhost:5432/test_db"
E   AssertionError: assert 'postgresql+a...:5432/test_db' == 'postgresql:/...:5432/test_db'
E     
E     - postgresql://test_user:test_pass@localhost:5432/test_db
E     + postgresql+asyncpg://test_user:test_pass@localhost:5432/test_db
E     ?           ++++++++</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_validation_failure" time="0.005"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">auth_service\tests\unit\test_database_manager_comprehensive.py:164: in test_get_database_url_validation_failure
    with pytest.raises(ValueError, match="Database configuration error"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerURLConstruction" name="test_get_database_url_no_url_generated" time="0.008"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">auth_service\tests\unit\test_database_manager_comprehensive.py:183: in test_get_database_url_no_url_generated
    with pytest.raises(ValueError, match="DatabaseURLBuilder failed to generate URL"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_development" time="0.006"><failure message="TypeError: 'NoneType' object is not subscriptable">auth_service\tests\unit\test_database_manager_comprehensive.py:208: in test_environment_detection_development
    call_args = mock_builder_class.call_args[0][0]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: 'NoneType' object is not subscriptable</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_staging" time="0.005"><failure message="ValueError: Database configuration error in staging environment: Missing required variables for staging: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.">auth_service\tests\unit\test_database_manager_comprehensive.py:226: in test_environment_detection_staging
    url = AuthDatabaseManager.get_database_url()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_service\auth_core\database\database_manager.py:77: in get_database_url
    raise ValueError(
E   ValueError: Database configuration error in staging environment: Missing required variables for staging: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_production" time="0.004"><failure message="ValueError: Database configuration error in production environment: Missing required variables for production: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.">auth_service\tests\unit\test_database_manager_comprehensive.py:247: in test_environment_detection_production
    url = AuthDatabaseManager.get_database_url()
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_service\auth_core\database\database_manager.py:77: in get_database_url
    raise ValueError(
E   ValueError: Database configuration error in production environment: Missing required variables for production: POSTGRES_HOST, POSTGRES_USER, POSTGRES_DB, POSTGRES_PASSWORD. DatabaseURLBuilder must be able to construct a valid URL. Check your environment variables.</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerEnvironmentHandling" name="test_environment_detection_default" time="0.005"><failure message="TypeError: 'NoneType' object is not subscriptable">auth_service\tests\unit\test_database_manager_comprehensive.py:271: in test_environment_detection_default
    call_args = mock_builder_class.call_args[0][0]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   TypeError: 'NoneType' object is not subscriptable</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerIntegrationWithSharedComponents" name="test_integration_with_database_url_builder" time="0.004" /><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerIntegrationWithSharedComponents" name="test_integration_with_isolated_environment" time="0.003"><failure message="AssertionError: assert 'sqlite+aiosq..._test_1508.db' == 'sqlite+aiosqlite:///:memory:'&#10;  &#10;  - sqlite+aiosqlite:///:memory:&#10;  + sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db">auth_service\tests\unit\test_database_manager_comprehensive.py:324: in test_integration_with_isolated_environment
    assert url == "sqlite+aiosqlite:///:memory:"
E   AssertionError: assert 'sqlite+aiosq..._test_1508.db' == 'sqlite+aiosqlite:///:memory:'
E     
E     - sqlite+aiosqlite:///:memory:
E     + sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerIntegrationWithSharedComponents" name="test_url_masking_for_logging" time="0.005"><failure message="AssertionError: expected call not found.&#10;Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')&#10;  Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')&#10;&#10;pytest introspection follows:&#10;&#10;Args:&#10;assert ('sqlite+aios...///:memory:',) == ('postgresql:...ost:5432/db',)&#10;  &#10;  At index 0 diff: 'sqlite+aiosqlite:///:memory:' != 'postgresql://user:password@host:5432/db'&#10;  &#10;  Full diff:&#10;    (&#10;  -     'postgresql://user:password@host:5432/db',&#10;  +     'sqlite+aiosqlite:///:memory:',&#10;    )">..\..\..\..\miniconda3\Lib\unittest\mock.py:944: in assert_called_with
    raise AssertionError(_error_message()) from cause
E   AssertionError: expected call not found.
E   Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')
E     Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')

During handling of the above exception, another exception occurred:
..\..\..\..\miniconda3\Lib\unittest\mock.py:956: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AssertionError: expected call not found.
E   Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')
E     Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')
E   
E   pytest introspection follows:
E   
E   Args:
E   assert ('sqlite+aios...///:memory:',) == ('postgresql:...ost:5432/db',)
E     
E     At index 0 diff: 'sqlite+aiosqlite:///:memory:' != 'postgresql://user:password@host:5432/db'
E     
E     Full diff:
E       (
E     -     'postgresql://user:password@host:5432/db',
E     +     'sqlite+aiosqlite:///:memory:',
E       )

During handling of the above exception, another exception occurred:
auth_service\tests\unit\test_database_manager_comprehensive.py:352: in test_url_masking_for_logging
    mock_mask.assert_called_once_with("postgresql://user:password@host:5432/db")
E   AssertionError: expected call not found.
E   Expected: mask_url_for_logging('postgresql://user:password@host:5432/db')
E     Actual: mask_url_for_logging('sqlite+aiosqlite:///:memory:')
E   
E   pytest introspection follows:
E   
E   Args:
E   assert ('sqlite+aios...///:memory:',) == ('postgresql:...ost:5432/db',)
E     
E     At index 0 diff: 'sqlite+aiosqlite:///:memory:' != 'postgresql://user:password@host:5432/db'
E     
E     Full diff:
E       (
E     -     'postgresql://user:password@host:5432/db',
E     +     'sqlite+aiosqlite:///:memory:',
E       )</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_missing_environment_variables" time="0.002"><failure message="AttributeError: 'NoneType' object has no attribute 'lower'">auth_service\tests\unit\test_database_manager_comprehensive.py:371: in test_missing_environment_variables
    AuthDatabaseManager.get_database_url()
auth_service\auth_core\database\database_manager.py:44: in get_database_url
    fast_test_mode = env.get("AUTH_FAST_TEST_MODE", "false").lower() == "true"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'lower'</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_invalid_environment_values" time="0.003"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">auth_service\tests\unit\test_database_manager_comprehensive.py:391: in test_invalid_environment_values
    with pytest.raises(ValueError, match="Database configuration error"):
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_database_url_builder_exception" time="0.004"><failure message="Failed: DID NOT RAISE &lt;class 'Exception'&gt;">auth_service\tests\unit\test_database_manager_comprehensive.py:406: in test_database_url_builder_exception
    with pytest.raises(Exception, match="Builder initialization failed"):
E   Failed: DID NOT RAISE &lt;class 'Exception'&gt;</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerErrorHandlingAndEdgeCases" name="test_fast_test_mode_variations" time="0.003"><failure message="AssertionError: assert 'sqlite+aiosq..._test_1508.db' == 'sqlite+aiosqlite:///:memory:'&#10;  &#10;  - sqlite+aiosqlite:///:memory:&#10;  + sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db">auth_service\tests\unit\test_database_manager_comprehensive.py:433: in test_fast_test_mode_variations
    assert url == "sqlite+aiosqlite:///:memory:"
E   AssertionError: assert 'sqlite+aiosq..._test_1508.db' == 'sqlite+aiosqlite:///:memory:'
E     
E     - sqlite+aiosqlite:///:memory:
E     + sqlite+aiosqlite:///C:\Users\antho\AppData\Local\Temp\auth_service_test_1508.db</failure></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_engine_creation_full_flow" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 450&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_engine_creation_full_flow(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test complete engine creation flow with real database&quot;&quot;&quot;&#10;          # Test URL construction&#10;          url = AuthDatabaseManager.get_database_url()&#10;          assert url is not None&#10;&#10;          # Test engine creation&#10;          engine = AuthDatabaseManager.create_async_engine()&#10;          assert engine is not None&#10;&#10;          # Test engine usage&#10;          async with engine.connect() as conn:&#10;              result = await conn.execute(text(&quot;SELECT version()&quot;))&#10;              version = result.scalar()&#10;              assert version is not None&#10;              assert &quot;PostgreSQL&quot; in version&#10;&#10;          await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 450
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_engine_creation_full_flow(self, real_services_fixture):
          """Test complete engine creation flow with real database"""
          # Test URL construction
          url = AuthDatabaseManager.get_database_url()
          assert url is not None

          # Test engine creation
          engine = AuthDatabaseManager.create_async_engine()
          assert engine is not None

          # Test engine usage
          async with engine.connect() as conn:
              result = await conn.execute(text("SELECT version()"))
              version = result.scalar()
              assert version is not None
              assert "PostgreSQL" in version

          await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_multiple_engine_creation" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 471&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_multiple_engine_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test creating multiple engines (should work independently)&quot;&quot;&quot;&#10;          engines = []&#10;&#10;          try:&#10;              # Create multiple engines&#10;              for i in range(3):&#10;                  engine = AuthDatabaseManager.create_async_engine()&#10;                  engines.append(engine)&#10;&#10;                  # Each should work independently&#10;                  async with engine.connect() as conn:&#10;                      result = await conn.execute(text(f&quot;SELECT {i + 1}&quot;))&#10;                      value = result.scalar()&#10;                      assert value == i + 1&#10;&#10;          finally:&#10;              # Clean up all engines&#10;              for engine in engines:&#10;                  await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 471
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_multiple_engine_creation(self, real_services_fixture):
          """Test creating multiple engines (should work independently)"""
          engines = []

          try:
              # Create multiple engines
              for i in range(3):
                  engine = AuthDatabaseManager.create_async_engine()
                  engines.append(engine)

                  # Each should work independently
                  async with engine.connect() as conn:
                      result = await conn.execute(text(f"SELECT {i + 1}"))
                      value = result.scalar()
                      assert value == i + 1

          finally:
              # Clean up all engines
              for engine in engines:
                  await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_engine_with_custom_configuration" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 494&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_engine_with_custom_configuration(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test engine creation with custom configuration&quot;&quot;&quot;&#10;          engine = AuthDatabaseManager.create_async_engine(&#10;              echo=False,  # Disable logging&#10;              pool_timeout=30,  # Custom timeout&#10;          )&#10;&#10;          try:&#10;              # Test custom configuration works&#10;              assert engine.echo is False&#10;&#10;              # Test connectivity&#10;              async with engine.connect() as conn:&#10;                  result = await conn.execute(text(&quot;SELECT current_database()&quot;))&#10;                  db_name = result.scalar()&#10;                  assert db_name is not None&#10;&#10;          finally:&#10;              await engine.dispose()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_manager_comprehensive.py, line 494
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_engine_with_custom_configuration(self, real_services_fixture):
          """Test engine creation with custom configuration"""
          engine = AuthDatabaseManager.create_async_engine(
              echo=False,  # Disable logging
              pool_timeout=30,  # Custom timeout
          )

          try:
              # Test custom configuration works
              assert engine.echo is False

              # Test connectivity
              async with engine.connect() as conn:
                  result = await conn.execute(text("SELECT current_database()"))
                  db_name = result.scalar()
                  assert db_name is not None

          finally:
              await engine.dispose()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_manager_comprehensive.TestAuthDatabaseManagerRealWorldScenarios" name="test_environment_specific_url_construction" time="0.004"><failure message="AssertionError: assert 'postgresql+a...432/netra_dev' == 'postgresql://development_url'&#10;  &#10;  - postgresql://development_url&#10;  + postgresql+asyncpg://postgres:postgres@localhost:5432/netra_dev">auth_service\tests\unit\test_database_manager_comprehensive.py:537: in test_environment_specific_url_construction
    assert url == f"postgresql://{env}_url"
E   AssertionError: assert 'postgresql+a...432/netra_dev' == 'postgresql://development_url'
E     
E     - postgresql://development_url
E     + postgresql+asyncpg://postgres:postgres@localhost:5432/netra_dev</failure></testcase><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_user_model_supports_comprehensive_user_management" time="0.005"><failure message="AssertionError: Failed attempts tracking required for security&#10;assert None == 0&#10; +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x000001E5C5C0E990&gt;.failed_login_attempts">auth_service\tests\unit\test_database_models_business_value.py:62: in test_auth_user_model_supports_comprehensive_user_management
    assert user.failed_login_attempts == 0, "Failed attempts tracking required for security"
E   AssertionError: Failed attempts tracking required for security
E   assert None == 0
E    +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x000001E5C5C0E990&gt;.failed_login_attempts</failure></testcase><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_user_model_supports_oauth_business_integration" time="0.005" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_session_model_enables_secure_session_management" time="0.003" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_auth_audit_log_model_supports_security_compliance" time="0.006" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_password_reset_token_model_enables_secure_password_recovery" time="0.003" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_support_data_integrity_for_business_operations" time="0.004"><failure message="AssertionError: Users should be active by default for business operations&#10;assert None is True&#10; +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x000001E5C5C08680&gt;.is_active">auth_service\tests\unit\test_database_models_business_value.py:261: in test_database_models_support_data_integrity_for_business_operations
    assert new_user.is_active is True, "Users should be active by default for business operations"
E   AssertionError: Users should be active by default for business operations
E   assert None is True
E    +  where None = &lt;auth_service.auth_core.database.models.AuthUser object at 0x000001E5C5C08680&gt;.is_active</failure></testcase><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_support_time_zone_aware_operations" time="0.004" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_support_business_query_patterns" time="0.003" /><testcase classname="tests.unit.test_database_models_business_value.TestDatabaseModelsBusinessValue" name="test_database_models_handle_json_metadata_for_business_flexibility" time="0.003" /><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_model_creation" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 54&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_model_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic AuthUser model creation with all fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              user = AuthUser(&#10;                  email=&quot;test_model_user@example.com&quot;,&#10;                  full_name=&quot;Test Model User&quot;,&#10;                  hashed_password=&quot;hashed_password_123&quot;,&#10;                  auth_provider=&quot;local&quot;,&#10;                  is_active=True,&#10;                  is_verified=False,&#10;                  failed_login_attempts=0&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify all fields are set correctly&#10;              assert user.id is not None&#10;              assert len(user.id) == 36  # UUID4 format&#10;              assert user.email == &quot;test_model_user@example.com&quot;&#10;              assert user.full_name == &quot;Test Model User&quot;&#10;              assert user.hashed_password == &quot;hashed_password_123&quot;&#10;              assert user.auth_provider == &quot;local&quot;&#10;              assert user.is_active is True&#10;              assert user.is_verified is False&#10;              assert user.failed_login_attempts == 0&#10;              assert user.created_at is not None&#10;              assert user.updated_at is not None&#10;              assert user.last_login_at is None&#10;              assert user.locked_until is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 54
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_model_creation(self, real_services_fixture):
          """Test basic AuthUser model creation with all fields"""
          async with auth_db.get_session() as session:
              user = AuthUser(
                  email="test_model_user@example.com",
                  full_name="Test Model User",
                  hashed_password="hashed_password_123",
                  auth_provider="local",
                  is_active=True,
                  is_verified=False,
                  failed_login_attempts=0
              )

              session.add(user)
              await session.commit()

              # Verify all fields are set correctly
              assert user.id is not None
              assert len(user.id) == 36  # UUID4 format
              assert user.email == "test_model_user@example.com"
              assert user.full_name == "Test Model User"
              assert user.hashed_password == "hashed_password_123"
              assert user.auth_provider == "local"
              assert user.is_active is True
              assert user.is_verified is False
              assert user.failed_login_attempts == 0
              assert user.created_at is not None
              assert user.updated_at is not None
              assert user.last_login_at is None
              assert user.locked_until is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_model_defaults" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 87&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_model_defaults(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test AuthUser model default values&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              user = AuthUser(email=&quot;test_defaults@example.com&quot;)&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify defaults&#10;              assert user.auth_provider == &quot;local&quot;&#10;              assert user.is_active is True&#10;              assert user.is_verified is False&#10;              assert user.failed_login_attempts == 0&#10;              assert user.full_name is None&#10;              assert user.hashed_password is None&#10;              assert user.provider_user_id is None&#10;              assert user.provider_data is None&#10;              assert user.last_login_at is None&#10;              assert user.locked_until is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 87
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_model_defaults(self, real_services_fixture):
          """Test AuthUser model default values"""
          async with auth_db.get_session() as session:
              user = AuthUser(email="test_defaults@example.com")

              session.add(user)
              await session.commit()

              # Verify defaults
              assert user.auth_provider == "local"
              assert user.is_active is True
              assert user.is_verified is False
              assert user.failed_login_attempts == 0
              assert user.full_name is None
              assert user.hashed_password is None
              assert user.provider_user_id is None
              assert user.provider_data is None
              assert user.last_login_at is None
              assert user.locked_until is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_email_uniqueness" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 109&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_email_uniqueness(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that email field enforces uniqueness constraint&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create first user&#10;              user1 = AuthUser(email=&quot;duplicate_test@example.com&quot;)&#10;              session.add(user1)&#10;              await session.commit()&#10;&#10;              # Attempt to create second user with same email&#10;              user2 = AuthUser(email=&quot;duplicate_test@example.com&quot;)&#10;              session.add(user2)&#10;&#10;              # Should raise IntegrityError due to unique constraint&#10;              with pytest.raises(IntegrityError):&#10;                  await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 109
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_email_uniqueness(self, real_services_fixture):
          """Test that email field enforces uniqueness constraint"""
          async with auth_db.get_session() as session:
              # Create first user
              user1 = AuthUser(email="duplicate_test@example.com")
              session.add(user1)
              await session.commit()

              # Attempt to create second user with same email
              user2 = AuthUser(email="duplicate_test@example.com")
              session.add(user2)

              # Should raise IntegrityError due to unique constraint
              with pytest.raises(IntegrityError):
                  await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_oauth_fields" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 127&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_oauth_fields(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test OAuth-specific fields in AuthUser model&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              provider_data = {&#10;                  &quot;sub&quot;: &quot;google_12345&quot;,&#10;                  &quot;name&quot;: &quot;OAuth Test User&quot;,&#10;                  &quot;picture&quot;: &quot;https://example.com/pic.jpg&quot;,&#10;                  &quot;locale&quot;: &quot;en&quot;&#10;              }&#10;&#10;              user = AuthUser(&#10;                  email=&quot;oauth_test@example.com&quot;,&#10;                  full_name=&quot;OAuth Test User&quot;,&#10;                  auth_provider=&quot;google&quot;,&#10;                  provider_user_id=&quot;google_12345&quot;,&#10;                  provider_data=provider_data,&#10;                  is_verified=True  # OAuth users are pre-verified&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify OAuth fields&#10;              assert user.auth_provider == &quot;google&quot;&#10;              assert user.provider_user_id == &quot;google_12345&quot;&#10;              assert user.provider_data == provider_data&#10;              assert user.is_verified is True&#10;              assert user.hashed_password is None  # OAuth users don't have passwords&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 127
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_oauth_fields(self, real_services_fixture):
          """Test OAuth-specific fields in AuthUser model"""
          async with auth_db.get_session() as session:
              provider_data = {
                  "sub": "google_12345",
                  "name": "OAuth Test User",
                  "picture": "https://example.com/pic.jpg",
                  "locale": "en"
              }

              user = AuthUser(
                  email="oauth_test@example.com",
                  full_name="OAuth Test User",
                  auth_provider="google",
                  provider_user_id="google_12345",
                  provider_data=provider_data,
                  is_verified=True  # OAuth users are pre-verified
              )

              session.add(user)
              await session.commit()

              # Verify OAuth fields
              assert user.auth_provider == "google"
              assert user.provider_user_id == "google_12345"
              assert user.provider_data == provider_data
              assert user.is_verified is True
              assert user.hashed_password is None  # OAuth users don't have passwords
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_security_fields" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 158&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_security_fields(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test security-related fields (failed attempts, locking)&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              lock_time = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              user = AuthUser(&#10;                  email=&quot;security_test@example.com&quot;,&#10;                  failed_login_attempts=5,&#10;                  locked_until=lock_time,&#10;                  is_active=False&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify security fields&#10;              assert user.failed_login_attempts == 5&#10;              assert user.locked_until == lock_time&#10;              assert user.is_active is False&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 158
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_security_fields(self, real_services_fixture):
          """Test security-related fields (failed attempts, locking)"""
          async with auth_db.get_session() as session:
              lock_time = datetime.now(timezone.utc) + timedelta(hours=1)

              user = AuthUser(
                  email="security_test@example.com",
                  failed_login_attempts=5,
                  locked_until=lock_time,
                  is_active=False
              )

              session.add(user)
              await session.commit()

              # Verify security fields
              assert user.failed_login_attempts == 5
              assert user.locked_until == lock_time
              assert user.is_active is False
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_timestamps" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 180&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_timestamps(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test timestamp fields behavior&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user&#10;              user = AuthUser(email=&quot;timestamp_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              original_created = user.created_at&#10;              original_updated = user.updated_at&#10;&#10;              assert original_created is not None&#10;              assert original_updated is not None&#10;&#10;              # Update user&#10;              user.full_name = &quot;Updated Name&quot;&#10;              await session.commit()&#10;&#10;              # Check that updated_at changed but created_at didn't&#10;              assert user.created_at == original_created&#10;              assert user.updated_at &gt; original_updated&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 180
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_timestamps(self, real_services_fixture):
          """Test timestamp fields behavior"""
          async with auth_db.get_session() as session:
              # Create user
              user = AuthUser(email="timestamp_test@example.com")
              session.add(user)
              await session.commit()

              original_created = user.created_at
              original_updated = user.updated_at

              assert original_created is not None
              assert original_updated is not None

              # Update user
              user.full_name = "Updated Name"
              await session.commit()

              # Check that updated_at changed but created_at didn't
              assert user.created_at == original_created
              assert user.updated_at &gt; original_updated
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthUserModel" name="test_auth_user_json_provider_data" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 204&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_user_json_provider_data(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test JSON field storage for provider_data&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              complex_data = {&#10;                  &quot;sub&quot;: &quot;google_12345&quot;,&#10;                  &quot;name&quot;: &quot;Complex User&quot;,&#10;                  &quot;picture&quot;: &quot;https://example.com/pic.jpg&quot;,&#10;                  &quot;emails&quot;: [&quot;primary@example.com&quot;, &quot;secondary@example.com&quot;],&#10;                  &quot;groups&quot;: [&quot;admin&quot;, &quot;user&quot;],&#10;                  &quot;metadata&quot;: {&#10;                      &quot;last_login&quot;: &quot;2024-01-01T12:00:00Z&quot;,&#10;                      &quot;preferences&quot;: {&#10;                          &quot;theme&quot;: &quot;dark&quot;,&#10;                          &quot;notifications&quot;: True&#10;                      }&#10;                  },&#10;                  &quot;numbers&quot;: [1, 2, 3, 42],&#10;                  &quot;boolean_flag&quot;: True&#10;              }&#10;&#10;              user = AuthUser(&#10;                  email=&quot;json_test@example.com&quot;,&#10;                  provider_data=complex_data&#10;              )&#10;&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Retrieve and verify JSON data integrity&#10;              retrieved_user = await session.get(AuthUser, user.id)&#10;              assert retrieved_user.provider_data == complex_data&#10;              assert retrieved_user.provider_data[&quot;metadata&quot;][&quot;preferences&quot;][&quot;theme&quot;] == &quot;dark&quot;&#10;              assert retrieved_user.provider_data[&quot;numbers&quot;] == [1, 2, 3, 42]&#10;              assert retrieved_user.provider_data[&quot;boolean_flag&quot;] is True&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          # Ensure database is initialized and tables exist&#10;          if not auth_db._initialized:&#10;              await auth_db.initialize()&#10;&#10;          # Ensure tables are created&#10;          await auth_db.create_tables()&#10;&#10;          async with auth_db.get_session() as session:&#10;              try:&#10;                  # Clean up any existing test data - handle table not existing gracefully&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'&quot;))&#10;                  await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'&quot;))&#10;                  await session.commit()&#10;              except Exception:&#10;                  # If delete fails (e.g. tables don't exist), just ensure tables are created&#10;                  await auth_db.create_tables()&#10;                  # No need to commit for table creation&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 204
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_user_json_provider_data(self, real_services_fixture):
          """Test JSON field storage for provider_data"""
          async with auth_db.get_session() as session:
              complex_data = {
                  "sub": "google_12345",
                  "name": "Complex User",
                  "picture": "https://example.com/pic.jpg",
                  "emails": ["primary@example.com", "secondary@example.com"],
                  "groups": ["admin", "user"],
                  "metadata": {
                      "last_login": "2024-01-01T12:00:00Z",
                      "preferences": {
                          "theme": "dark",
                          "notifications": True
                      }
                  },
                  "numbers": [1, 2, 3, 42],
                  "boolean_flag": True
              }

              user = AuthUser(
                  email="json_test@example.com",
                  provider_data=complex_data
              )

              session.add(user)
              await session.commit()

              # Retrieve and verify JSON data integrity
              retrieved_user = await session.get(AuthUser, user.id)
              assert retrieved_user.provider_data == complex_data
              assert retrieved_user.provider_data["metadata"]["preferences"]["theme"] == "dark"
              assert retrieved_user.provider_data["numbers"] == [1, 2, 3, 42]
              assert retrieved_user.provider_data["boolean_flag"] is True
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 32
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          # Ensure database is initialized and tables exist
          if not auth_db._initialized:
              await auth_db.initialize()

          # Ensure tables are created
          await auth_db.create_tables()

          async with auth_db.get_session() as session:
              try:
                  # Clean up any existing test data - handle table not existing gracefully
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'test_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'oauth_%@example.com'"))
                  await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'model_test_%@example.com'"))
                  await session.commit()
              except Exception:
                  # If delete fails (e.g. tables don't exist), just ensure tables are created
                  await auth_db.create_tables()
                  # No need to commit for table creation
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_model_creation" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 259&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_model_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic AuthSession model creation&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              session_obj = AuthSession(&#10;                  user_id=self.test_user.id,&#10;                  refresh_token_hash=&quot;hashed_token_123&quot;,&#10;                  ip_address=&quot;127.0.0.1&quot;,&#10;                  user_agent=&quot;TestAgent/1.0&quot;,&#10;                  device_id=&quot;test_device_123&quot;,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Verify all fields&#10;              assert session_obj.id is not None&#10;              assert len(session_obj.id) == 36  # UUID4 format&#10;              assert session_obj.user_id == self.test_user.id&#10;              assert session_obj.refresh_token_hash == &quot;hashed_token_123&quot;&#10;              assert session_obj.ip_address == &quot;127.0.0.1&quot;&#10;              assert session_obj.user_agent == &quot;TestAgent/1.0&quot;&#10;              assert session_obj.device_id == &quot;test_device_123&quot;&#10;              assert session_obj.expires_at == expires_at&#10;              assert session_obj.is_active is True&#10;              assert session_obj.created_at is not None&#10;              assert session_obj.last_activity is not None&#10;              assert session_obj.revoked_at is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 259
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_model_creation(self, real_services_fixture):
          """Test basic AuthSession model creation"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              session_obj = AuthSession(
                  user_id=self.test_user.id,
                  refresh_token_hash="hashed_token_123",
                  ip_address="127.0.0.1",
                  user_agent="TestAgent/1.0",
                  device_id="test_device_123",
                  expires_at=expires_at
              )

              session.add(session_obj)
              await session.commit()

              # Verify all fields
              assert session_obj.id is not None
              assert len(session_obj.id) == 36  # UUID4 format
              assert session_obj.user_id == self.test_user.id
              assert session_obj.refresh_token_hash == "hashed_token_123"
              assert session_obj.ip_address == "127.0.0.1"
              assert session_obj.user_agent == "TestAgent/1.0"
              assert session_obj.device_id == "test_device_123"
              assert session_obj.expires_at == expires_at
              assert session_obj.is_active is True
              assert session_obj.created_at is not None
              assert session_obj.last_activity is not None
              assert session_obj.revoked_at is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_model_defaults" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 292&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_model_defaults(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test AuthSession model default values&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              session_obj = AuthSession(&#10;                  user_id=self.test_user.id,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Verify defaults&#10;              assert session_obj.is_active is True&#10;              assert session_obj.refresh_token_hash is None&#10;              assert session_obj.ip_address is None&#10;              assert session_obj.user_agent is None&#10;              assert session_obj.device_id is None&#10;              assert session_obj.revoked_at is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 292
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_model_defaults(self, real_services_fixture):
          """Test AuthSession model default values"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              session_obj = AuthSession(
                  user_id=self.test_user.id,
                  expires_at=expires_at
              )

              session.add(session_obj)
              await session.commit()

              # Verify defaults
              assert session_obj.is_active is True
              assert session_obj.refresh_token_hash is None
              assert session_obj.ip_address is None
              assert session_obj.user_agent is None
              assert session_obj.device_id is None
              assert session_obj.revoked_at is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_revocation" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 315&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_revocation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test session revocation functionality&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              session_obj = AuthSession(&#10;                  user_id=self.test_user.id,&#10;                  expires_at=expires_at,&#10;                  device_id=&quot;test_revoke_device&quot;&#10;              )&#10;&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Revoke session&#10;              revoke_time = datetime.now(timezone.utc)&#10;              session_obj.is_active = False&#10;              session_obj.revoked_at = revoke_time&#10;              await session.commit()&#10;&#10;              # Verify revocation&#10;              assert session_obj.is_active is False&#10;              assert session_obj.revoked_at == revoke_time&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 315
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_revocation(self, real_services_fixture):
          """Test session revocation functionality"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              session_obj = AuthSession(
                  user_id=self.test_user.id,
                  expires_at=expires_at,
                  device_id="test_revoke_device"
              )

              session.add(session_obj)
              await session.commit()

              # Revoke session
              revoke_time = datetime.now(timezone.utc)
              session_obj.is_active = False
              session_obj.revoked_at = revoke_time
              await session.commit()

              # Verify revocation
              assert session_obj.is_active is False
              assert session_obj.revoked_at == revoke_time
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthSessionModel" name="test_auth_session_multiple_per_user" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 341&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_session_multiple_per_user(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that users can have multiple active sessions&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;&#10;              # Create multiple sessions for same user&#10;              sessions = []&#10;              for i in range(3):&#10;                  session_obj = AuthSession(&#10;                      user_id=self.test_user.id,&#10;                      expires_at=expires_at,&#10;                      device_id=f&quot;test_device_{i}&quot;,&#10;                      ip_address=f&quot;192.168.1.{i+1}&quot;&#10;                  )&#10;                  sessions.append(session_obj)&#10;                  session.add(session_obj)&#10;&#10;              await session.commit()&#10;&#10;              # Verify all sessions exist&#10;              for i, session_obj in enumerate(sessions):&#10;                  assert session_obj.device_id == f&quot;test_device_{i}&quot;&#10;                  assert session_obj.ip_address == f&quot;192.168.1.{i+1}&quot;&#10;                  assert session_obj.user_id == self.test_user.id&#10;                  assert session_obj.is_active is True&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;session_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 341
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_session_multiple_per_user(self, real_services_fixture):
          """Test that users can have multiple active sessions"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)

              # Create multiple sessions for same user
              sessions = []
              for i in range(3):
                  session_obj = AuthSession(
                      user_id=self.test_user.id,
                      expires_at=expires_at,
                      device_id=f"test_device_{i}",
                      ip_address=f"192.168.1.{i+1}"
                  )
                  sessions.append(session_obj)
                  session.add(session_obj)

              await session.commit()

              # Verify all sessions exist
              for i, session_obj in enumerate(sessions):
                  assert session_obj.device_id == f"test_device_{i}"
                  assert session_obj.ip_address == f"192.168.1.{i+1}"
                  assert session_obj.user_id == self.test_user.id
                  assert session_obj.is_active is True
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 245
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'session_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="session_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_model_creation" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 387&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_model_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic AuthAuditLog model creation&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              metadata = {&quot;action&quot;: &quot;test_action&quot;, &quot;resource&quot;: &quot;user&quot;}&#10;&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_login&quot;,&#10;                  user_id=self.test_user.id,&#10;                  success=True,&#10;                  event_metadata=metadata,&#10;                  ip_address=&quot;127.0.0.1&quot;,&#10;                  user_agent=&quot;TestAgent/1.0&quot;&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify all fields&#10;              assert audit_log.id is not None&#10;              assert len(audit_log.id) == 36  # UUID4 format&#10;              assert audit_log.event_type == &quot;test_login&quot;&#10;              assert audit_log.user_id == self.test_user.id&#10;              assert audit_log.success is True&#10;              assert audit_log.event_metadata == metadata&#10;              assert audit_log.ip_address == &quot;127.0.0.1&quot;&#10;              assert audit_log.user_agent == &quot;TestAgent/1.0&quot;&#10;              assert audit_log.error_message is None&#10;              assert audit_log.created_at is not None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 387
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_model_creation(self, real_services_fixture):
          """Test basic AuthAuditLog model creation"""
          async with auth_db.get_session() as session:
              metadata = {"action": "test_action", "resource": "user"}

              audit_log = AuthAuditLog(
                  event_type="test_login",
                  user_id=self.test_user.id,
                  success=True,
                  event_metadata=metadata,
                  ip_address="127.0.0.1",
                  user_agent="TestAgent/1.0"
              )

              session.add(audit_log)
              await session.commit()

              # Verify all fields
              assert audit_log.id is not None
              assert len(audit_log.id) == 36  # UUID4 format
              assert audit_log.event_type == "test_login"
              assert audit_log.user_id == self.test_user.id
              assert audit_log.success is True
              assert audit_log.event_metadata == metadata
              assert audit_log.ip_address == "127.0.0.1"
              assert audit_log.user_agent == "TestAgent/1.0"
              assert audit_log.error_message is None
              assert audit_log.created_at is not None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_failure_case" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 418&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_failure_case(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test audit log for failed events&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_login_failed&quot;,&#10;                  user_id=self.test_user.id,&#10;                  success=False,&#10;                  error_message=&quot;Invalid credentials&quot;,&#10;                  ip_address=&quot;192.168.1.100&quot;&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify failure fields&#10;              assert audit_log.success is False&#10;              assert audit_log.error_message == &quot;Invalid credentials&quot;&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 418
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_failure_case(self, real_services_fixture):
          """Test audit log for failed events"""
          async with auth_db.get_session() as session:
              audit_log = AuthAuditLog(
                  event_type="test_login_failed",
                  user_id=self.test_user.id,
                  success=False,
                  error_message="Invalid credentials",
                  ip_address="192.168.1.100"
              )

              session.add(audit_log)
              await session.commit()

              # Verify failure fields
              assert audit_log.success is False
              assert audit_log.error_message == "Invalid credentials"
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_without_user" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 438&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_without_user(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test audit log for system events without user&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_system_event&quot;,&#10;                  success=True,&#10;                  event_metadata={&quot;system&quot;: &quot;auth_service&quot;}&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify system event&#10;              assert audit_log.user_id is None&#10;              assert audit_log.event_type == &quot;test_system_event&quot;&#10;              assert audit_log.success is True&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 438
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_without_user(self, real_services_fixture):
          """Test audit log for system events without user"""
          async with auth_db.get_session() as session:
              audit_log = AuthAuditLog(
                  event_type="test_system_event",
                  success=True,
                  event_metadata={"system": "auth_service"}
              )

              session.add(audit_log)
              await session.commit()

              # Verify system event
              assert audit_log.user_id is None
              assert audit_log.event_type == "test_system_event"
              assert audit_log.success is True
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestAuthAuditLogModel" name="test_auth_audit_log_json_metadata" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 457&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_auth_audit_log_json_metadata(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test JSON metadata storage in audit log&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              complex_metadata = {&#10;                  &quot;action&quot;: &quot;password_change&quot;,&#10;                  &quot;old_password_strength&quot;: &quot;strong&quot;,&#10;                  &quot;new_password_strength&quot;: &quot;very_strong&quot;,&#10;                  &quot;security_checks&quot;: {&#10;                      &quot;common_password&quot;: False,&#10;                      &quot;breached&quot;: False,&#10;                      &quot;similar_to_old&quot;: False&#10;                  },&#10;                  &quot;attempt_count&quot;: 1,&#10;                  &quot;browser_fingerprint&quot;: {&#10;                      &quot;user_agent&quot;: &quot;Mozilla/5.0...&quot;,&#10;                      &quot;screen_resolution&quot;: &quot;1920x1080&quot;,&#10;                      &quot;timezone&quot;: &quot;UTC-5&quot;&#10;                  }&#10;              }&#10;&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;test_complex_event&quot;,&#10;                  user_id=self.test_user.id,&#10;                  success=True,&#10;                  event_metadata=complex_metadata&#10;              )&#10;&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify JSON data integrity&#10;              retrieved_log = await session.get(AuthAuditLog, audit_log.id)&#10;              assert retrieved_log.event_metadata == complex_metadata&#10;              assert retrieved_log.event_metadata[&quot;security_checks&quot;][&quot;breached&quot;] is False&#10;              assert retrieved_log.event_metadata[&quot;attempt_count&quot;] == 1&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;audit_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 457
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_auth_audit_log_json_metadata(self, real_services_fixture):
          """Test JSON metadata storage in audit log"""
          async with auth_db.get_session() as session:
              complex_metadata = {
                  "action": "password_change",
                  "old_password_strength": "strong",
                  "new_password_strength": "very_strong",
                  "security_checks": {
                      "common_password": False,
                      "breached": False,
                      "similar_to_old": False
                  },
                  "attempt_count": 1,
                  "browser_fingerprint": {
                      "user_agent": "Mozilla/5.0...",
                      "screen_resolution": "1920x1080",
                      "timezone": "UTC-5"
                  }
              }

              audit_log = AuthAuditLog(
                  event_type="test_complex_event",
                  user_id=self.test_user.id,
                  success=True,
                  event_metadata=complex_metadata
              )

              session.add(audit_log)
              await session.commit()

              # Verify JSON data integrity
              retrieved_log = await session.get(AuthAuditLog, audit_log.id)
              assert retrieved_log.event_metadata == complex_metadata
              assert retrieved_log.event_metadata["security_checks"]["breached"] is False
              assert retrieved_log.event_metadata["attempt_count"] == 1
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 373
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'test_%'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'audit_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="audit_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_creation" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 513&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_creation(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test basic PasswordResetToken model creation&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              token = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;hashed_reset_token_123&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Verify all fields&#10;              assert token.id is not None&#10;              assert len(token.id) == 36  # UUID4 format&#10;              assert token.user_id == self.test_user.id&#10;              assert token.token_hash == &quot;hashed_reset_token_123&quot;&#10;              assert token.email == self.test_user.email&#10;              assert token.expires_at == expires_at&#10;              assert token.is_used is False&#10;              assert token.created_at is not None&#10;              assert token.used_at is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 513
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_creation(self, real_services_fixture):
          """Test basic PasswordResetToken model creation"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              token = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="hashed_reset_token_123",
                  email=self.test_user.email,
                  expires_at=expires_at
              )

              session.add(token)
              await session.commit()

              # Verify all fields
              assert token.id is not None
              assert len(token.id) == 36  # UUID4 format
              assert token.user_id == self.test_user.id
              assert token.token_hash == "hashed_reset_token_123"
              assert token.email == self.test_user.email
              assert token.expires_at == expires_at
              assert token.is_used is False
              assert token.created_at is not None
              assert token.used_at is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_defaults" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 541&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_defaults(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test PasswordResetToken model default values&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              token = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;hashed_reset_token_456&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Verify defaults&#10;              assert token.is_used is False&#10;              assert token.used_at is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 541
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_defaults(self, real_services_fixture):
          """Test PasswordResetToken model default values"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              token = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="hashed_reset_token_456",
                  email=self.test_user.email,
                  expires_at=expires_at
              )

              session.add(token)
              await session.commit()

              # Verify defaults
              assert token.is_used is False
              assert token.used_at is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_usage" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 562&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_usage(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test token usage tracking&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              token = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;hashed_reset_token_789&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Mark token as used&#10;              used_time = datetime.now(timezone.utc)&#10;              token.is_used = True&#10;              token.used_at = used_time&#10;              await session.commit()&#10;&#10;              # Verify usage tracking&#10;              assert token.is_used is True&#10;              assert token.used_at == used_time&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 562
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_usage(self, real_services_fixture):
          """Test token usage tracking"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              token = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="hashed_reset_token_789",
                  email=self.test_user.email,
                  expires_at=expires_at
              )

              session.add(token)
              await session.commit()

              # Mark token as used
              used_time = datetime.now(timezone.utc)
              token.is_used = True
              token.used_at = used_time
              await session.commit()

              # Verify usage tracking
              assert token.is_used is True
              assert token.used_at == used_time
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestPasswordResetTokenModel" name="test_password_reset_token_uniqueness" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 589&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_password_reset_token_uniqueness(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test that token_hash enforces uniqueness constraint&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;&#10;              # Create first token&#10;              token1 = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;duplicate_token_hash&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;              session.add(token1)&#10;              await session.commit()&#10;&#10;              # Attempt to create second token with same hash&#10;              token2 = PasswordResetToken(&#10;                  user_id=self.test_user.id,&#10;                  token_hash=&quot;duplicate_token_hash&quot;,&#10;                  email=self.test_user.email,&#10;                  expires_at=expires_at&#10;              )&#10;              session.add(token2)&#10;&#10;              # Should raise IntegrityError due to unique constraint&#10;              with pytest.raises(IntegrityError):&#10;                  await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database and test user for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up any existing test data&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'&quot;))&#10;              await session.commit()&#10;&#10;              # Create test user&#10;              self.test_user = AuthUser(email=&quot;reset_test_user@example.com&quot;)&#10;              session.add(self.test_user)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 589
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_password_reset_token_uniqueness(self, real_services_fixture):
          """Test that token_hash enforces uniqueness constraint"""
          async with auth_db.get_session() as session:
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)

              # Create first token
              token1 = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="duplicate_token_hash",
                  email=self.test_user.email,
                  expires_at=expires_at
              )
              session.add(token1)
              await session.commit()

              # Attempt to create second token with same hash
              token2 = PasswordResetToken(
                  user_id=self.test_user.id,
                  token_hash="duplicate_token_hash",
                  email=self.test_user.email,
                  expires_at=expires_at
              )
              session.add(token2)

              # Should raise IntegrityError due to unique constraint
              with pytest.raises(IntegrityError):
                  await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 499
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database and test user for each test"""
          async with auth_db.get_session() as session:
              # Clean up any existing test data
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'reset_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'reset_%@example.com'"))
              await session.commit()

              # Create test user
              self.test_user = AuthUser(email="reset_test_user@example.com")
              session.add(self.test_user)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelIntegration" name="test_user_session_audit_integration" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 634&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_user_session_audit_integration(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test integration between User, Session, and Audit models&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user&#10;              user = AuthUser(email=&quot;integration_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create session&#10;              expires_at = datetime.now(timezone.utc) + timedelta(days=30)&#10;              session_obj = AuthSession(&#10;                  user_id=user.id,&#10;                  expires_at=expires_at,&#10;                  device_id=&quot;integration_device&quot;,&#10;                  ip_address=&quot;192.168.1.1&quot;&#10;              )&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Create audit log&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;integration_login&quot;,&#10;                  user_id=user.id,&#10;                  success=True,&#10;                  event_metadata={&quot;session_id&quot;: session_obj.id},&#10;                  ip_address=&quot;192.168.1.1&quot;&#10;              )&#10;              session.add(audit_log)&#10;              await session.commit()&#10;&#10;              # Verify all models are linked correctly&#10;              assert session_obj.user_id == user.id&#10;              assert audit_log.user_id == user.id&#10;              assert audit_log.event_metadata[&quot;session_id&quot;] == session_obj.id&#10;              assert session_obj.ip_address == audit_log.ip_address&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 623&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up all test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 634
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_user_session_audit_integration(self, real_services_fixture):
          """Test integration between User, Session, and Audit models"""
          async with auth_db.get_session() as session:
              # Create user
              user = AuthUser(email="integration_test@example.com")
              session.add(user)
              await session.commit()

              # Create session
              expires_at = datetime.now(timezone.utc) + timedelta(days=30)
              session_obj = AuthSession(
                  user_id=user.id,
                  expires_at=expires_at,
                  device_id="integration_device",
                  ip_address="192.168.1.1"
              )
              session.add(session_obj)
              await session.commit()

              # Create audit log
              audit_log = AuthAuditLog(
                  event_type="integration_login",
                  user_id=user.id,
                  success=True,
                  event_metadata={"session_id": session_obj.id},
                  ip_address="192.168.1.1"
              )
              session.add(audit_log)
              await session.commit()

              # Verify all models are linked correctly
              assert session_obj.user_id == user.id
              assert audit_log.user_id == user.id
              assert audit_log.event_metadata["session_id"] == session_obj.id
              assert session_obj.ip_address == audit_log.ip_address
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 623
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              # Clean up all test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'"))
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelIntegration" name="test_user_password_reset_integration" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 672&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_user_password_reset_integration(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test integration between User and PasswordResetToken models&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user&#10;              user = AuthUser(email=&quot;integration_reset@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create password reset token&#10;              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)&#10;              token = PasswordResetToken(&#10;                  user_id=user.id,&#10;                  token_hash=&quot;integration_token_hash&quot;,&#10;                  email=user.email,&#10;                  expires_at=expires_at&#10;              )&#10;              session.add(token)&#10;              await session.commit()&#10;&#10;              # Verify integration&#10;              assert token.user_id == user.id&#10;              assert token.email == user.email&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 623&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up all test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 672
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_user_password_reset_integration(self, real_services_fixture):
          """Test integration between User and PasswordResetToken models"""
          async with auth_db.get_session() as session:
              # Create user
              user = AuthUser(email="integration_reset@example.com")
              session.add(user)
              await session.commit()

              # Create password reset token
              expires_at = datetime.now(timezone.utc) + timedelta(hours=1)
              token = PasswordResetToken(
                  user_id=user.id,
                  token_hash="integration_token_hash",
                  email=user.email,
                  expires_at=expires_at
              )
              session.add(token)
              await session.commit()

              # Verify integration
              assert token.user_id == user.id
              assert token.email == user.email
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 623
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              # Clean up all test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'"))
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelIntegration" name="test_model_cascade_behavior" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 697&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_model_cascade_behavior(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test model behavior when related data exists (no foreign key constraints)&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with related data&#10;              user = AuthUser(email=&quot;integration_cascade@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create related records&#10;              session_obj = AuthSession(&#10;                  user_id=user.id,&#10;                  expires_at=datetime.now(timezone.utc) + timedelta(days=30),&#10;                  device_id=&quot;integration_cascade_device&quot;&#10;              )&#10;              session.add(session_obj)&#10;&#10;              audit_log = AuthAuditLog(&#10;                  event_type=&quot;integration_cascade_event&quot;,&#10;                  user_id=user.id,&#10;                  success=True&#10;              )&#10;              session.add(audit_log)&#10;&#10;              reset_token = PasswordResetToken(&#10;                  user_id=user.id,&#10;                  token_hash=&quot;integration_cascade_token&quot;,&#10;                  email=user.email,&#10;                  expires_at=datetime.now(timezone.utc) + timedelta(hours=1)&#10;              )&#10;              session.add(reset_token)&#10;              await session.commit()&#10;&#10;              # Delete user (no cascade constraints, so related records remain orphaned)&#10;              await session.delete(user)&#10;              await session.commit()&#10;&#10;              # Verify related records still exist but are orphaned&#10;              orphaned_session = await session.get(AuthSession, session_obj.id)&#10;              orphaned_audit = await session.get(AuthAuditLog, audit_log.id)&#10;              orphaned_token = await session.get(PasswordResetToken, reset_token.id)&#10;&#10;              assert orphaned_session is not None&#10;              assert orphaned_audit is not None&#10;              assert orphaned_token is not None&#10;&#10;              # Clean up orphaned records&#10;              await session.delete(orphaned_session)&#10;              await session.delete(orphaned_audit)&#10;              await session.delete(orphaned_token)&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 623&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Clean up all test data&#10;              await session.execute(text(&quot;DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'&quot;))&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 697
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_model_cascade_behavior(self, real_services_fixture):
          """Test model behavior when related data exists (no foreign key constraints)"""
          async with auth_db.get_session() as session:
              # Create user with related data
              user = AuthUser(email="integration_cascade@example.com")
              session.add(user)
              await session.commit()

              # Create related records
              session_obj = AuthSession(
                  user_id=user.id,
                  expires_at=datetime.now(timezone.utc) + timedelta(days=30),
                  device_id="integration_cascade_device"
              )
              session.add(session_obj)

              audit_log = AuthAuditLog(
                  event_type="integration_cascade_event",
                  user_id=user.id,
                  success=True
              )
              session.add(audit_log)

              reset_token = PasswordResetToken(
                  user_id=user.id,
                  token_hash="integration_cascade_token",
                  email=user.email,
                  expires_at=datetime.now(timezone.utc) + timedelta(hours=1)
              )
              session.add(reset_token)
              await session.commit()

              # Delete user (no cascade constraints, so related records remain orphaned)
              await session.delete(user)
              await session.commit()

              # Verify related records still exist but are orphaned
              orphaned_session = await session.get(AuthSession, session_obj.id)
              orphaned_audit = await session.get(AuthAuditLog, audit_log.id)
              orphaned_token = await session.get(PasswordResetToken, reset_token.id)

              assert orphaned_session is not None
              assert orphaned_audit is not None
              assert orphaned_token is not None

              # Clean up orphaned records
              await session.delete(orphaned_session)
              await session.delete(orphaned_audit)
              await session.delete(orphaned_token)
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 623
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              # Clean up all test data
              await session.execute(text("DELETE FROM auth_audit_logs WHERE event_type LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM auth_sessions WHERE device_id LIKE 'integration_%'"))
              await session.execute(text("DELETE FROM password_reset_tokens WHERE email LIKE 'integration_%@example.com'"))
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'integration_%@example.com'"))
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_email_case_sensitivity" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 761&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_email_case_sensitivity(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test email case sensitivity in database&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with lowercase email&#10;              user1 = AuthUser(email=&quot;edge_case@example.com&quot;)&#10;              session.add(user1)&#10;              await session.commit()&#10;&#10;              # Try to create user with uppercase email (should be treated as different)&#10;              user2 = AuthUser(email=&quot;EDGE_CASE@EXAMPLE.COM&quot;)&#10;              session.add(user2)&#10;              await session.commit()&#10;&#10;              # Verify both users exist (database is case-sensitive)&#10;              lowercase_user = await session.execute(&#10;                  select(AuthUser).where(AuthUser.email == &quot;edge_case@example.com&quot;)&#10;              )&#10;              uppercase_user = await session.execute(&#10;                  select(AuthUser).where(AuthUser.email == &quot;EDGE_CASE@EXAMPLE.COM&quot;)&#10;              )&#10;&#10;              assert lowercase_user.scalar_one_or_none() is not None&#10;              assert uppercase_user.scalar_one_or_none() is not None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 761
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_email_case_sensitivity(self, real_services_fixture):
          """Test email case sensitivity in database"""
          async with auth_db.get_session() as session:
              # Create user with lowercase email
              user1 = AuthUser(email="edge_case@example.com")
              session.add(user1)
              await session.commit()

              # Try to create user with uppercase email (should be treated as different)
              user2 = AuthUser(email="EDGE_CASE@EXAMPLE.COM")
              session.add(user2)
              await session.commit()

              # Verify both users exist (database is case-sensitive)
              lowercase_user = await session.execute(
                  select(AuthUser).where(AuthUser.email == "edge_case@example.com")
              )
              uppercase_user = await session.execute(
                  select(AuthUser).where(AuthUser.email == "EDGE_CASE@EXAMPLE.COM")
              )

              assert lowercase_user.scalar_one_or_none() is not None
              assert uppercase_user.scalar_one_or_none() is not None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_long_text_fields" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 787&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_long_text_fields(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test handling of long text in string fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with very long name and user agent&#10;              long_name = &quot;A&quot; * 1000  # Very long name&#10;              long_user_agent = &quot;Mozilla/5.0 &quot; + &quot;X&quot; * 2000  # Very long user agent&#10;&#10;              user = AuthUser(&#10;                  email=&quot;edge_long_fields@example.com&quot;,&#10;                  full_name=long_name&#10;              )&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Create session with long user agent&#10;              session_obj = AuthSession(&#10;                  user_id=user.id,&#10;                  user_agent=long_user_agent,&#10;                  expires_at=datetime.now(timezone.utc) + timedelta(days=30)&#10;              )&#10;              session.add(session_obj)&#10;              await session.commit()&#10;&#10;              # Verify data is stored correctly (database handles long strings)&#10;              assert user.full_name == long_name&#10;              assert session_obj.user_agent == long_user_agent&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 787
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_long_text_fields(self, real_services_fixture):
          """Test handling of long text in string fields"""
          async with auth_db.get_session() as session:
              # Create user with very long name and user agent
              long_name = "A" * 1000  # Very long name
              long_user_agent = "Mozilla/5.0 " + "X" * 2000  # Very long user agent

              user = AuthUser(
                  email="edge_long_fields@example.com",
                  full_name=long_name
              )
              session.add(user)
              await session.commit()

              # Create session with long user agent
              session_obj = AuthSession(
                  user_id=user.id,
                  user_agent=long_user_agent,
                  expires_at=datetime.now(timezone.utc) + timedelta(days=30)
              )
              session.add(session_obj)
              await session.commit()

              # Verify data is stored correctly (database handles long strings)
              assert user.full_name == long_name
              assert session_obj.user_agent == long_user_agent
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_null_handling" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 816&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_null_handling(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test handling of NULL values in optional fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with minimal required fields&#10;              user = AuthUser(email=&quot;edge_null_test@example.com&quot;)&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Verify NULL fields are handled correctly&#10;              assert user.full_name is None&#10;              assert user.hashed_password is None&#10;              assert user.provider_user_id is None&#10;              assert user.provider_data is None&#10;              assert user.last_login_at is None&#10;              assert user.locked_until is None&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 816
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_null_handling(self, real_services_fixture):
          """Test handling of NULL values in optional fields"""
          async with auth_db.get_session() as session:
              # Create user with minimal required fields
              user = AuthUser(email="edge_null_test@example.com")
              session.add(user)
              await session.commit()

              # Verify NULL fields are handled correctly
              assert user.full_name is None
              assert user.hashed_password is None
              assert user.provider_user_id is None
              assert user.provider_data is None
              assert user.last_login_at is None
              assert user.locked_until is None
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_models_comprehensive.TestDatabaseModelConstraintsAndEdgeCases" name="test_timezone_handling" time="0.001"><error message="failed on setup with &quot;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 834&#10;      @pytest.mark.unit&#10;      @pytest.mark.real_services&#10;      async def test_timezone_handling(self, real_services_fixture):&#10;          &quot;&quot;&quot;Test timezone handling in datetime fields&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              # Create user with specific timezone&#10;              specific_time = datetime(2024, 1, 1, 12, 0, 0, tzinfo=timezone.utc)&#10;&#10;              user = AuthUser(&#10;                  email=&quot;edge_timezone@example.com&quot;,&#10;                  last_login_at=specific_time&#10;              )&#10;              session.add(user)&#10;              await session.commit()&#10;&#10;              # Retrieve and verify timezone is preserved&#10;              retrieved_user = await session.get(AuthUser, user.id)&#10;              assert retrieved_user.last_login_at == specific_time&#10;              assert retrieved_user.last_login_at.tzinfo == timezone.utc&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754&#10;      @pytest_asyncio.fixture(autouse=True)&#10;      async def setup_method(self, real_services_fixture):&#10;          &quot;&quot;&quot;Setup clean database for each test&quot;&quot;&quot;&#10;          async with auth_db.get_session() as session:&#10;              await session.execute(text(&quot;DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'&quot;))&#10;              await session.commit()&#10;file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213&#10;  @pytest.fixture(scope=&quot;function&quot;)&#10;  async def real_services_fixture(real_postgres_connection, with_test_database):&#10;      &quot;&quot;&quot;REAL services fixture - provides access to actual running services.&#10;&#10;      This fixture provides connections to actual running services including:&#10;      - Real PostgreSQL database with active session&#10;      - Backend service endpoints&#10;      - Auth service endpoints&#10;      - Environment configuration&#10;&#10;      CRITICAL: This replaces placeholder implementations with real services.&#10;&#10;      Args:&#10;          real_postgres_connection: Real database connection info&#10;          with_test_database: Real database session&#10;&#10;      Yields:&#10;          Dict: Real service connections and configuration&#10;      &quot;&quot;&quot;&#10;      postgres_info = real_postgres_connection&#10;      db_session = with_test_database&#10;      env = get_env()&#10;&#10;      # Determine service URLs based on environment&#10;      backend_port = env.get(&quot;BACKEND_PORT&quot;, &quot;8000&quot;)&#10;      auth_port = env.get(&quot;AUTH_SERVICE_PORT&quot;, &quot;8081&quot;)&#10;      redis_port = env.get(&quot;REDIS_PORT&quot;, &quot;6381&quot;)  # Test Redis port&#10;&#10;      backend_url = f&quot;http://localhost:{backend_port}&quot;&#10;      auth_url = f&quot;http://localhost:{auth_port}&quot;&#10;      redis_url = f&quot;redis://localhost:{redis_port}&quot;&#10;&#10;      # Validate services are reachable (optional - don't fail if not available)&#10;      services_available = {&#10;          &quot;backend&quot;: False,&#10;          &quot;auth&quot;: False,&#10;          &quot;database&quot;: postgres_info[&quot;available&quot;],&#10;          &quot;redis&quot;: False&#10;      }&#10;&#10;      # Test Redis connection&#10;      try:&#10;          import redis&#10;          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)&#10;          redis_client.ping()&#10;          services_available[&quot;redis&quot;] = True&#10;          redis_client.close()&#10;      except Exception:&#10;          logger.info(&quot;Redis service not reachable - tests will use URL only&quot;)&#10;&#10;      try:&#10;          import aiohttp&#10;          timeout = aiohttp.ClientTimeout(total=2)&#10;          async with aiohttp.ClientSession(timeout=timeout) as session:&#10;              # Test backend service&#10;              try:&#10;                  async with session.get(f&quot;{backend_url}/health&quot;) as resp:&#10;                      services_available[&quot;backend&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Backend service not reachable - tests will use URL only&quot;)&#10;&#10;              # Test auth service&#10;              try:&#10;                  async with session.get(f&quot;{auth_url}/health&quot;) as resp:&#10;                      services_available[&quot;auth&quot;] = resp.status == 200&#10;              except Exception:&#10;                  logger.info(&quot;Auth service not reachable - tests will use URL only&quot;)&#10;      except ImportError:&#10;          logger.info(&quot;aiohttp not available - skipping service health checks&quot;)&#10;&#10;      yield {&#10;          &quot;backend_url&quot;: backend_url,&#10;          &quot;auth_url&quot;: auth_url,&#10;          &quot;redis_url&quot;: redis_url,&#10;          &quot;postgres&quot;: postgres_info[&quot;engine&quot;],&#10;          &quot;db&quot;: db_session,&#10;          &quot;redis&quot;: redis_url,  # Add redis key for compatibility&#10;          &quot;database_url&quot;: postgres_info[&quot;database_url&quot;],&#10;          &quot;environment&quot;: postgres_info[&quot;environment&quot;],&#10;          &quot;services_available&quot;: services_available,&#10;          &quot;database_available&quot;: postgres_info[&quot;available&quot;]&#10;      }&#10;E       fixture 'real_postgres_connection' not found&#10;&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id&#10;&gt;       use 'pytest --fixtures [testpath]' for help on them.&#10;&#10;C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213&quot;">file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 834
      @pytest.mark.unit
      @pytest.mark.real_services
      async def test_timezone_handling(self, real_services_fixture):
          """Test timezone handling in datetime fields"""
          async with auth_db.get_session() as session:
              # Create user with specific timezone
              specific_time = datetime(2024, 1, 1, 12, 0, 0, tzinfo=timezone.utc)

              user = AuthUser(
                  email="edge_timezone@example.com",
                  last_login_at=specific_time
              )
              session.add(user)
              await session.commit()

              # Retrieve and verify timezone is preserved
              retrieved_user = await session.get(AuthUser, user.id)
              assert retrieved_user.last_login_at == specific_time
              assert retrieved_user.last_login_at.tzinfo == timezone.utc
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\auth_service\tests\unit\test_database_models_comprehensive.py, line 754
      @pytest_asyncio.fixture(autouse=True)
      async def setup_method(self, real_services_fixture):
          """Setup clean database for each test"""
          async with auth_db.get_session() as session:
              await session.execute(text("DELETE FROM auth_users WHERE email LIKE 'edge_%@example.com'"))
              await session.commit()
file C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py, line 213
  @pytest.fixture(scope="function")
  async def real_services_fixture(real_postgres_connection, with_test_database):
      """REAL services fixture - provides access to actual running services.

      This fixture provides connections to actual running services including:
      - Real PostgreSQL database with active session
      - Backend service endpoints
      - Auth service endpoints
      - Environment configuration

      CRITICAL: This replaces placeholder implementations with real services.

      Args:
          real_postgres_connection: Real database connection info
          with_test_database: Real database session

      Yields:
          Dict: Real service connections and configuration
      """
      postgres_info = real_postgres_connection
      db_session = with_test_database
      env = get_env()

      # Determine service URLs based on environment
      backend_port = env.get("BACKEND_PORT", "8000")
      auth_port = env.get("AUTH_SERVICE_PORT", "8081")
      redis_port = env.get("REDIS_PORT", "6381")  # Test Redis port

      backend_url = f"http://localhost:{backend_port}"
      auth_url = f"http://localhost:{auth_port}"
      redis_url = f"redis://localhost:{redis_port}"

      # Validate services are reachable (optional - don't fail if not available)
      services_available = {
          "backend": False,
          "auth": False,
          "database": postgres_info["available"],
          "redis": False
      }

      # Test Redis connection
      try:
          import redis
          redis_client = redis.Redis.from_url(redis_url, socket_timeout=2)
          redis_client.ping()
          services_available["redis"] = True
          redis_client.close()
      except Exception:
          logger.info("Redis service not reachable - tests will use URL only")

      try:
          import aiohttp
          timeout = aiohttp.ClientTimeout(total=2)
          async with aiohttp.ClientSession(timeout=timeout) as session:
              # Test backend service
              try:
                  async with session.get(f"{backend_url}/health") as resp:
                      services_available["backend"] = resp.status == 200
              except Exception:
                  logger.info("Backend service not reachable - tests will use URL only")

              # Test auth service
              try:
                  async with session.get(f"{auth_url}/health") as resp:
                      services_available["auth"] = resp.status == 200
              except Exception:
                  logger.info("Auth service not reachable - tests will use URL only")
      except ImportError:
          logger.info("aiohttp not available - skipping service health checks")

      yield {
          "backend_url": backend_url,
          "auth_url": auth_url,
          "redis_url": redis_url,
          "postgres": postgres_info["engine"],
          "db": db_session,
          "redis": redis_url,  # Add redis key for compatibility
          "database_url": postgres_info["database_url"],
          "environment": postgres_info["environment"],
          "services_available": services_available,
          "database_available": postgres_info["available"]
      }
E       fixture 'real_postgres_connection' not found
&gt;       available fixtures: _class_scoped_runner, _function_scoped_runner, _module_scoped_runner, _package_scoped_runner, _session_faker, _session_scoped_runner, anyio_backend, anyio_backend_name, anyio_backend_options, api_client, auth_service_client, authenticated_api_client, authenticated_websocket, backend_service_client, cache, capfd, capfdbinary, caplog, capsys, capsysbinary, capteesys, class_mocker, clean_database, clickhouse_client, common_test_user, cov, database_connection, database_transaction, docker_test_manager, doctest_namespace, e2e_logger, e2e_services, e2e_test_config, ensure_no_mocks, event_loop, event_loop_policy, extra, extras, faker, free_tcp_port, free_tcp_port_factory, free_udp_port, free_udp_port_factory, include_metadata_in_junit_xml, isolated_test_env, isolated_test_users, json_metadata, metadata, mock_agent_service, mock_agent_supervisor, mock_auth_redis, mock_background_task_manager, mock_clickhouse_client, mock_database_factory, mock_key_manager, mock_llm_manager, mock_redis_client, mock_redis_manager, mock_security_service, mock_tool_dispatcher, mock_websocket_manager, mocker, module_mocker, monkeypatch, no_cover, package_mocker, performance_monitor, pytestconfig, real_auth_db, real_auth_redis, real_auth_service, real_clickhouse, real_http_client, real_jwt_manager, real_llm_config, real_oauth_endpoints, real_postgres, real_redis, real_services, real_services_fixture, real_services_function, real_websocket_client, record_property, record_testsuite_property, record_xml_attribute, recwarn, redis_client, redis_manager, sample_data, service_urls, session_mocker, setup_method, setup_real_services, sync_auth_db, test_agent, test_conversation, test_organization, test_services, test_user, test_user_data, test_user_token, testrun_uid, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory, unused_tcp_port, unused_tcp_port_factory, unused_udp_port, unused_udp_port_factory, websocket_connection, worker_id
&gt;       use 'pytest --fixtures [testpath]' for help on them.

C:\Users\antho\OneDrive\Desktop\Netra\netra-core-generation-1\test_framework\fixtures\real_services.py:213</error></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_empty_url" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_none_url" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_invalid_scheme" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_postgresql_scheme" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_postgres_scheme" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_cloud_sql_url" time="0.003" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_cloud_sql_url_with_ssl_params" time="0.002"><failure message="AssertionError: assert 'SSL parameters will be automatically removed' in ['SSL parameters will be automatically removed for Cloud SQL Unix sockets']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:94: in test_validate_cloud_sql_url_with_ssl_params
    assert "SSL parameters will be automatically removed" in result["recommendations"]
E   AssertionError: assert 'SSL parameters will be automatically removed' in ['SSL parameters will be automatically removed for Cloud SQL Unix sockets']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_tcp_url_with_sslmode" time="0.001"><failure message="AssertionError: assert 'sslmode will be converted to ssl' in ['sslmode will be converted to ssl for asyncpg compatibility']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:105: in test_validate_tcp_url_with_sslmode
    assert "sslmode will be converted to ssl" in result["recommendations"]
E   AssertionError: assert 'sslmode will be converted to ssl' in ['sslmode will be converted to ssl for asyncpg compatibility']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_tcp_url_with_ssl_param" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_tcp_url_no_ssl" time="0.001"><failure message="AssertionError: assert 'No SSL parameters specified' in ['No SSL parameters specified for TCP connection']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:126: in test_validate_tcp_url_no_ssl
    assert "No SSL parameters specified" in result["warnings"]
E   AssertionError: assert 'No SSL parameters specified' in ['No SSL parameters specified for TCP connection']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_localhost_warning" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_no_port_warning" time="0.001"><failure message="AssertionError: assert 'Port not specified' in ['No SSL parameters specified for TCP connection', 'Port not specified, will use default']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:146: in test_validate_no_port_warning
    assert "Port not specified" in result["warnings"]
E   AssertionError: assert 'Port not specified' in ['No SSL parameters specified for TCP connection', 'Port not specified, will use default']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_no_hostname" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_malformed_cloud_sql_path" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorURLFormat" name="test_validate_cloud_sql_missing_db_name" time="0.002"><failure message="AssertionError: assert 'Database name not specified' in []">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:175: in test_validate_cloud_sql_missing_db_name
    assert "Database name not specified" in result["warnings"]
E   AssertionError: assert 'Database name not specified' in []</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_no_username" time="0.008" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_no_password" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_problematic_username_pattern" time="0.001"><failure message="assert &quot;Invalid username pattern 'user_pr-4'&quot; in [&quot;Invalid username pattern 'user_pr-4' - this will cause authentication failures&quot;, 'Using insecure default password']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:209: in test_validate_credentials_problematic_username_pattern
    assert "Invalid username pattern 'user_pr-4'" in result["credential_issues"]
E   assert "Invalid username pattern 'user_pr-4'" in ["Invalid username pattern 'user_pr-4' - this will cause authentication failures", 'Using insecure default password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_pr_pattern_username" time="0.001"><failure message="assert 'appears to be misconfigured PR-specific user' in [&quot;Invalid username pattern 'user_pr-123' - appears to be misconfigured PR-specific user&quot;, 'Using insecure default password']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:219: in test_validate_credentials_pr_pattern_username
    assert "appears to be misconfigured PR-specific user" in result["credential_issues"]
E   assert 'appears to be misconfigured PR-specific user' in ["Invalid username pattern 'user_pr-123' - appears to be misconfigured PR-specific user", 'Using insecure default password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_postgres_username" time="0.002"><failure message="assert &quot;Username 'postgres' is acceptable for Cloud SQL&quot; in [&quot;Username 'postgres' is acceptable for Cloud SQL but ensure password is secure&quot;]">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:229: in test_validate_credentials_postgres_username
    assert "Username 'postgres' is acceptable for Cloud SQL" in result["recommendations"]
E   assert "Username 'postgres' is acceptable for Cloud SQL" in ["Username 'postgres' is acceptable for Cloud SQL but ensure password is secure"]</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_root_username" time="0.001"><failure message="assert False is True">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:237: in test_validate_credentials_root_username
    assert result["valid"] is True
E   assert False is True</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_insecure_password" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_short_password" time="0.001"><failure message="AssertionError: assert 'Use password with at least 8 characters' in ['Use password with at least 8 characters for security']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:259: in test_validate_credentials_short_password
    assert "Use password with at least 8 characters" in result["recommendations"]
E   AssertionError: assert 'Use password with at least 8 characters' in ['Use password with at least 8 characters for security']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_numeric_password" time="0.001"><failure message="AssertionError: assert 'Password contains only numbers' in ['Using insecure default password']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:268: in test_validate_credentials_numeric_password
    assert "Password contains only numbers" in result["credential_issues"]
E   AssertionError: assert 'Password contains only numbers' in ['Using insecure default password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_test_password" time="0.002"><failure message="AssertionError: assert 'appears to be a test/development password' in ['Password appears to be a test/development password']">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:278: in test_validate_credentials_test_password
    assert "appears to be a test/development password" in result["credential_issues"]
E   AssertionError: assert 'appears to be a test/development password' in ['Password appears to be a test/development password']</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_placeholder_password" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_variable_placeholder" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_staging_specific_checks" time="0.001"><failure message="assert 'Username appears to be development-specific' in ['Username appears to be development-specific in staging environment', &quot;Password contains 'dev' which may indicate development credentials&quot;]">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:306: in test_validate_credentials_staging_specific_checks
    assert "Username appears to be development-specific" in result["warnings"]
E   assert 'Username appears to be development-specific' in ['Username appears to be development-specific in staging environment', "Password contains 'dev' which may indicate development credentials"]</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_secure_example" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorCredentials" name="test_validate_credentials_parsing_error" time="0.001"><failure message="KeyError: 'error'">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:327: in test_validate_credentials_parsing_error
    assert "Credential validation failed" in result["error"]
                                             ^^^^^^^^^^^^^^^
E   KeyError: 'error'</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_cloud_sql_with_ssl_params" time="0.003" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_cloud_sql_ssl_not_removed" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_tcp_sslmode_conversion" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_tcp_sslmode_not_converted" time="0.005"><failure message="ModuleNotFoundError: No module named 'str'">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:369: in test_ssl_compatibility_tcp_sslmode_not_converted
    with patch('str.replace', return_value=tcp_url):
..\..\..\..\miniconda3\Lib\unittest\mock.py:1442: in __enter__
    self.target = self.getter()
                  ^^^^^^^^^^^^^
..\..\..\..\miniconda3\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\miniconda3\Lib\importlib\__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
&lt;frozen importlib._bootstrap&gt;:1324: in _find_and_load_unlocked
    ???
E   ModuleNotFoundError: No module named 'str'</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_tcp_with_ssl_param" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorSSLCompatibility" name="test_ssl_compatibility_error_handling" time="0.002"><failure message="assert True is False">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:391: in test_ssl_compatibility_error_handling
    assert result["valid"] is False
E   assert True is False</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_with_url" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_without_url" time="0.003"><failure message="AssertionError: assert 'postgresql:/...5432/env_d...' == 'postgresql:/...t:5432/env_db'&#10;  &#10;  - postgresql://env_user:env_pass@env_host:5432/env_db&#10;  ?                                                   ^&#10;  + postgresql://env_user:env_pass@env_host:5432/env_d...&#10;  ?                                                   ^^^">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:429: in test_pre_deployment_validation_without_url
    assert report["database_url"] == "postgresql://env_user:env_pass@env_host:5432/env_db"
E   AssertionError: assert 'postgresql:/...5432/env_d...' == 'postgresql:/...t:5432/env_db'
E     
E     - postgresql://env_user:env_pass@env_host:5432/env_db
E     ?                                                   ^
E     + postgresql://env_user:env_pass@env_host:5432/env_d...
E     ?                                                   ^^^</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_url_format_failure" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_credential_failure" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_ssl_failure" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_warnings_only" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_success" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorPreDeployment" name="test_pre_deployment_validation_long_url_truncation" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_passed" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_failed" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_warning" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorReporting" name="test_print_validation_report_unknown_status" time="0.002" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestValidateStagingDeploymentFunction" name="test_validate_staging_deployment_success" time="0.002"><failure message="AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n'&#10; +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n', err='').out">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:598: in test_validate_staging_deployment_success
    assert "Validation passed" in captured.out
E   AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n'
E    +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: PASS PASSED\nDatabase URL: postgresql://secure_url\n\n==================================================\n', err='').out</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestValidateStagingDeploymentFunction" name="test_validate_staging_deployment_warning" time="0.002"><failure message="AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n'&#10; +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n', err='').out">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:616: in test_validate_staging_deployment_warning
    assert "Validation passed" in captured.out
E   AssertionError: assert 'Validation passed' in 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n'
E    +  where 'Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n' = CaptureResult(out='Validating Auth Service for Staging Deployment...\n\nAuth Service Staging Validation Report\n==================================================\nOverall Status: WARN WARNING\nDatabase URL: postgresql://localhost_url\n\nWarnings (1):\n  ! Using localhost\n\n==================================================\n', err='').out</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestValidateStagingDeploymentFunction" name="test_validate_staging_deployment_failure" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_url_format_validation_exception" time="0.001"><failure message="AssertionError: assert 'URL parsing failed: Parse error' in 'Invalid scheme: '">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:646: in test_url_format_validation_exception
    assert "URL parsing failed: Parse error" in result["error"]
E   AssertionError: assert 'URL parsing failed: Parse error' in 'Invalid scheme: '</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_credential_validation_exception" time="0.002"><failure message="KeyError: 'error'">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:655: in test_credential_validation_exception
    assert "Credential validation failed: Parse error" in result["error"]
                                                          ^^^^^^^^^^^^^^^
E   KeyError: 'error'</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_cloud_sql_database_name_extraction_edge_cases" time="0.001"><failure message="AssertionError: assert 'Database name not specified' in []">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:668: in test_cloud_sql_database_name_extraction_edge_cases
    assert "Database name not specified" in result2["warnings"]
E   AssertionError: assert 'Database name not specified' in []</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_regex_patterns_comprehensive" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_environment_specific_validation_branches" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestStagingDatabaseValidatorEdgeCases" name="test_password_security_checks_comprehensive" time="0.001" /><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestMainModuleBehavior" name="test_main_module_success" time="0.002"><failure message="  File &quot;&lt;string&gt;&quot;, line 3&#10;    success = validate_staging_deployment()&#10;IndentationError: unexpected indent">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:743: in test_main_module_success
    exec(open('auth_service/auth_core/database/staging_validation.py').read().split('if __name__ == "__main__":')[1])
E     File "&lt;string&gt;", line 3
E       success = validate_staging_deployment()
E   IndentationError: unexpected indent</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestMainModuleBehavior" name="test_main_module_success" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;_io.FileIO name='auth_service/auth_core/database/staging_validation.py' mode='rb' closefd=True&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:743: in test_main_module_success
    exec(open('auth_service/auth_core/database/staging_validation.py').read().split('if __name__ == "__main__":')[1])
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ResourceWarning: unclosed file &lt;_io.TextIOWrapper name='auth_service/auth_core/database/staging_validation.py' mode='r' encoding='utf-8'&gt;

The above exception was the direct cause of the following exception:
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\logging.py:858: in pytest_runtest_teardown
    yield
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:79: in collect_unraisable
    raise errors[0]
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;_io.FileIO name='auth_service/auth_core/database/staging_validation.py' mode='rb' closefd=True&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestMainModuleBehavior" name="test_main_module_failure" time="0.003"><failure message="  File &quot;&lt;string&gt;&quot;, line 3&#10;    success = validate_staging_deployment()&#10;IndentationError: unexpected indent">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:756: in test_main_module_failure
    exec(open('auth_service/auth_core/database/staging_validation.py').read().split('if __name__ == "__main__":')[1])
E     File "&lt;string&gt;", line 3
E       success = validate_staging_deployment()
E   IndentationError: unexpected indent</failure></testcase><testcase classname="tests.unit.test_database_staging_validation_comprehensive.TestMainModuleBehavior" name="test_main_module_failure" time="0.000"><error message="failed on teardown with &quot;pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;_io.FileIO name='auth_service/auth_core/database/staging_validation.py' mode='rb' closefd=True&gt;&#10;Enable tracemalloc to get traceback where the object was allocated.&#10;See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.&quot;">auth_service\tests\unit\test_database_staging_validation_comprehensive.py:756: in test_main_module_failure
    exec(open('auth_service/auth_core/database/staging_validation.py').read().split('if __name__ == "__main__":')[1])
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   ResourceWarning: unclosed file &lt;_io.TextIOWrapper name='auth_service/auth_core/database/staging_validation.py' mode='r' encoding='utf-8'&gt;

The above exception was the direct cause of the following exception:
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:344: in from_call
    result: TResult | None = func()
                             ^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\runner.py:246: in &lt;lambda&gt;
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_hooks.py:512: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\pluggy\_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\logging.py:858: in pytest_runtest_teardown
    yield
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\capture.py:905: in pytest_runtest_teardown
    return (yield)
            ^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:163: in pytest_runtest_teardown
    collect_unraisable(item.config)
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:79: in collect_unraisable
    raise errors[0]
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\_pytest\unraisableexception.py:67: in collect_unraisable
    warnings.warn(pytest.PytestUnraisableExceptionWarning(msg))
E   pytest.PytestUnraisableExceptionWarning: Exception ignored in: &lt;_io.FileIO name='auth_service/auth_core/database/staging_validation.py' mode='rb' closefd=True&gt;
E   Enable tracemalloc to get traceback where the object was allocated.
E   See https://docs.pytest.org/en/stable/how-to/capture-warnings.html#resource-warnings for more info.</error></testcase><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_service_token_creation_validation" time="0.014" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_cross_service_audience_validation" time="0.011" /><testcase classname="tests.unit.test_jwt_cross_service_validation.TestJWTCrossServiceValidation" name="test_environment_bound_token_validation" time="0.013" /><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_jwt_handler_enforces_production_security_standards" time="0.006" /><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_jwt_handler_fails_fast_with_insufficient_production_security" time="0.008"><failure message="Failed: DID NOT RAISE &lt;class 'ValueError'&gt;">auth_service\tests\unit\test_jwt_security_business_value.py:70: in test_jwt_handler_fails_fast_with_insufficient_production_security
    with pytest.raises(ValueError) as exc_info:
E   Failed: DID NOT RAISE &lt;class 'ValueError'&gt;</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_access_token_creation_supports_business_authorization_flows" time="0.007"><failure message="jwt.exceptions.InvalidAudienceError: Invalid audience">auth_service\tests\unit\test_jwt_security_business_value.py:102: in test_access_token_creation_supports_business_authorization_flows
    decoded = jwt.decode(access_token, jwt_handler.secret, algorithms=[jwt_handler.algorithm])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:222: in decode
    decoded = self.decode_complete(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:167: in decode_complete
    self._validate_claims(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:268: in _validate_claims
    self._validate_aud(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:377: in _validate_aud
    raise InvalidAudienceError("Invalid audience")
E   jwt.exceptions.InvalidAudienceError: Invalid audience</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_refresh_token_creation_enables_secure_session_management" time="0.006"><failure message="jwt.exceptions.InvalidAudienceError: Invalid audience">auth_service\tests\unit\test_jwt_security_business_value.py:138: in test_refresh_token_creation_enables_secure_session_management
    decoded = jwt.decode(refresh_token, jwt_handler.secret, algorithms=[jwt_handler.algorithm])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:222: in decode
    decoded = self.decode_complete(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:167: in decode_complete
    self._validate_claims(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:268: in _validate_claims
    self._validate_aud(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:377: in _validate_aud
    raise InvalidAudienceError("Invalid audience")
E   jwt.exceptions.InvalidAudienceError: Invalid audience</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_service_token_creation_enables_secure_microservice_communication" time="0.007"><failure message="jwt.exceptions.InvalidAudienceError: Invalid audience">auth_service\tests\unit\test_jwt_security_business_value.py:173: in test_service_token_creation_enables_secure_microservice_communication
    decoded = jwt.decode(service_token, jwt_handler.secret, algorithms=[jwt_handler.algorithm])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:222: in decode
    decoded = self.decode_complete(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:167: in decode_complete
    self._validate_claims(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:268: in _validate_claims
    self._validate_aud(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:377: in _validate_aud
    raise InvalidAudienceError("Invalid audience")
E   jwt.exceptions.InvalidAudienceError: Invalid audience</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_token_validation_protects_business_operations_from_tampering" time="0.014"><failure message="AssertionError: Expired tokens must be rejected for security&#10;assert {'aud': 'netra-platform', 'email': 'user@company.com', 'env': 'test', 'exp': 1757384742, ...} is None">auth_service\tests\unit\test_jwt_security_business_value.py:216: in test_token_validation_protects_business_operations_from_tampering
    assert expired_result is None, "Expired tokens must be rejected for security"
E   AssertionError: Expired tokens must be rejected for security
E   assert {'aud': 'netra-platform', 'email': 'user@company.com', 'env': 'test', 'exp': 1757384742, ...} is None</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_token_blacklist_prevents_unauthorized_access_after_logout" time="0.013"><failure message="AttributeError: 'JWTHandler' object has no attribute 'blacklist_user_tokens'. Did you mean: 'blacklist_token'?">auth_service\tests\unit\test_jwt_security_business_value.py:254: in test_token_blacklist_prevents_unauthorized_access_after_logout
    jwt_handler.blacklist_user_tokens(user_id)
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'JWTHandler' object has no attribute 'blacklist_user_tokens'. Did you mean: 'blacklist_token'?</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_jwt_cache_improves_business_performance_while_maintaining_security" time="0.013"><failure message="AssertionError: Cached validation should work&#10;assert None is not None">auth_service\tests\unit\test_jwt_security_business_value.py:287: in test_jwt_cache_improves_business_performance_while_maintaining_security
    assert result1 is not None, "Cached validation should work"
E   AssertionError: Cached validation should work
E   assert None is not None</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_jwt_security_headers_and_claims_follow_business_standards" time="0.006"><failure message="jwt.exceptions.InvalidAudienceError: Invalid audience">auth_service\tests\unit\test_jwt_security_business_value.py:307: in test_jwt_security_headers_and_claims_follow_business_standards
    payload = jwt.decode(token, jwt_handler.secret, algorithms=[jwt_handler.algorithm])
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:222: in decode
    decoded = self.decode_complete(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:167: in decode_complete
    self._validate_claims(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:268: in _validate_claims
    self._validate_aud(
..\..\..\..\AppData\Roaming\Python\Python312\site-packages\jwt\api_jwt.py:377: in _validate_aud
    raise InvalidAudienceError("Invalid audience")
E   jwt.exceptions.InvalidAudienceError: Invalid audience</failure></testcase><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_jwt_error_handling_prevents_information_disclosure" time="0.019" /><testcase classname="tests.unit.test_jwt_security_business_value.TestJWTSecurityBusinessValue" name="test_jwt_performance_meets_business_latency_requirements" time="0.116" /><testcase classname="tests.unit.test_jwt_token_security_validation.TestJWTTokenSecurityValidation" name="test_jwt_structure_validation_security" time="0.017" /><testcase classname="tests.unit.test_jwt_token_security_validation.TestJWTTokenSecurityValidation" name="test_jwt_algorithm_security_validation" time="0.005" /><testcase classname="tests.unit.test_jwt_token_security_validation.TestJWTTokenSecurityValidation" name="test_jwt_claims_security_validation" time="0.008"><failure message="assert (1757391642 - 1757384442) == 900">auth_service\tests\unit\test_jwt_token_security_validation.py:163: in test_jwt_claims_security_validation
    assert expires_at - issued_at == 900  # 15 minutes for access token
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   assert (1757391642 - 1757384442) == 900</failure></testcase><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_google_oauth_user_processing_standard_flow" time="0.007" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_github_oauth_user_processing_developer_tier" time="0.005" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_business_email_detection_and_tier_upgrade" time="0.007" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_business_email_domain_detection_comprehensive" time="0.007" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_subscription_tier_determination_logic" time="0.006" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_oauth_business_rules_validation_comprehensive" time="0.006" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_oauth_account_linking_business_logic" time="0.005" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_oauth_provider_validation_security" time="0.004" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_tier_bypass_attack_prevention" time="0.005" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_email_domain_spoofing_prevention" time="0.006" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_oauth_data_completeness_validation" time="0.007" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_existing_user_account_linking_detection" time="0.006" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_oauth_tier_upgrade_suggestions" time="0.007" /><testcase classname="tests.unit.test_oauth_business_logic_comprehensive.TestOAuthBusinessLogicComprehensive" name="test_email_verification_requirements" time="0.006" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_manager_initialization_comprehensive" time="0.006" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_google_oauth_provider_configuration_validation" time="0.008" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_provider_missing_configuration_scenarios" time="0.007"><failure message="assert True is False&#10; +  where True = is_configured()&#10; +    where is_configured = &lt;test_oauth_flows.MockGoogleOAuthProvider object at 0x000001E5C5E7FCB0&gt;.is_configured">auth_service\tests\unit\test_oauth_flows.py:271: in test_oauth_provider_missing_configuration_scenarios
    assert test_provider.is_configured() is False
E   assert True is False
E    +  where True = is_configured()
E    +    where is_configured = &lt;test_oauth_flows.MockGoogleOAuthProvider object at 0x000001E5C5E7FCB0&gt;.is_configured</failure></testcase><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_authorization_url_generation_comprehensive" time="0.006" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_state_parameter_security" time="0.012" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_authorization_code_exchange_user_scenarios" time="0.006" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_invalid_authorization_code_handling" time="0.005"><failure message="AttributeError: 'NoneType' object has no attribute 'startswith'">auth_service\tests\unit\test_oauth_flows.py:381: in test_invalid_authorization_code_handling
    self.provider.exchange_code_for_user_info(invalid_code, self.test_state)
auth_service\tests\unit\test_oauth_flows.py:153: in exchange_code_for_user_info
    if code.startswith("valid_"):
       ^^^^^^^^^^^^^^^
E   AttributeError: 'NoneType' object has no attribute 'startswith'</failure></testcase><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_manager_provider_integration" time="0.008" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_provider_self_check_comprehensive" time="0.008" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_security_misconfiguration_detection" time="0.007" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_error_handling_comprehensive" time="0.009" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_flow_state_management" time="0.011" /><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_provider_availability_monitoring" time="0.006"><failure message="assert True is False">auth_service\tests\unit\test_oauth_flows.py:548: in test_oauth_provider_availability_monitoring
    assert degraded_health["is_healthy"] is False
E   assert True is False</failure></testcase><testcase classname="tests.unit.test_oauth_flows.TestOAuthFlowsEnhanced" name="test_oauth_redirect_uri_validation" time="0.007" /><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_manager_provides_business_ready_providers" time="0.007" /><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_google_oauth_provider_supports_business_authentication_flow" time="0.006" /><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_authorization_url_enables_user_acquisition" time="0.008"><failure message="AssertionError: Must use proper OAuth endpoint&#10;assert 'oauth2/v2/auth' in 'https://accounts.google.com/o/oauth2/auth?client_id=staging-client.apps.googleusercontent.com&amp;redirect_uri=https%3A%2F%2Fauth.staging.netrasystems.ai%2Fauth%2Fcallback&amp;scope=openid+email+profile&amp;response_type=code&amp;state=secure-state-token-123&amp;access_type=offline&amp;prompt=consent'">auth_service\tests\unit\test_oauth_provider_business_value.py:102: in test_oauth_authorization_url_enables_user_acquisition
    assert "oauth2/v2/auth" in auth_url, "Must use proper OAuth endpoint"
E   AssertionError: Must use proper OAuth endpoint
E   assert 'oauth2/v2/auth' in 'https://accounts.google.com/o/oauth2/auth?client_id=staging-client.apps.googleusercontent.com&amp;redirect_uri=https%3A%2F%2Fauth.staging.netrasystems.ai%2Fauth%2Fcallback&amp;scope=openid+email+profile&amp;response_type=code&amp;state=secure-state-token-123&amp;access_type=offline&amp;prompt=consent'</failure></testcase><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_provider_handles_business_environment_configurations" time="0.008" /><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_configuration_validation_protects_business_operations" time="0.006" /><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_provider_graceful_degradation_in_development" time="0.007" /><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_provider_self_check_validates_business_readiness" time="0.005"><failure message="AssertionError: OAuth must be healthy for user acquisition&#10;assert False is True&#10; +  where False = &lt;built-in method get of dict object at 0x000001E5C5B9A380&gt;('is_healthy')&#10; +    where &lt;built-in method get of dict object at 0x000001E5C5B9A380&gt; = {'checks_failed': ['configuration_validation: OAuth client ID appears too short (38 chars)'], 'checks_passed': [], 'environment': 'production', 'error': 'OAuth client ID appears too short (38 chars)', ...}.get">auth_service\tests\unit\test_oauth_provider_business_value.py:208: in test_oauth_provider_self_check_validates_business_readiness
    assert self_check.get("is_healthy") is True, "OAuth must be healthy for user acquisition"
E   AssertionError: OAuth must be healthy for user acquisition
E   assert False is True
E    +  where False = &lt;built-in method get of dict object at 0x000001E5C5B9A380&gt;('is_healthy')
E    +    where &lt;built-in method get of dict object at 0x000001E5C5B9A380&gt; = {'checks_failed': ['configuration_validation: OAuth client ID appears too short (38 chars)'], 'checks_passed': [], 'environment': 'production', 'error': 'OAuth client ID appears too short (38 chars)', ...}.get</failure></testcase><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_token_exchange_supports_user_authentication_business_flow" time="0.004"><failure message="AttributeError: 'GoogleOAuthProvider' object has no attribute 'exchange_code_for_token'. Did you mean: 'exchange_code_for_user_info'?">auth_service\tests\unit\test_oauth_provider_business_value.py:243: in test_oauth_token_exchange_supports_user_authentication_business_flow
    token_data = google_provider.exchange_code_for_token(oauth_code)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'GoogleOAuthProvider' object has no attribute 'exchange_code_for_token'. Did you mean: 'exchange_code_for_user_info'?</failure></testcase><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_user_info_retrieval_enables_user_profile_creation" time="0.004"><failure message="AttributeError: 'GoogleOAuthProvider' object has no attribute 'get_user_info'">auth_service\tests\unit\test_oauth_provider_business_value.py:286: in test_oauth_user_info_retrieval_enables_user_profile_creation
    user_info = google_provider.get_user_info(access_token)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E   AttributeError: 'GoogleOAuthProvider' object has no attribute 'get_user_info'</failure></testcase><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_error_handling_protects_business_continuity" time="0.004"><failure message="NameError: name 'requests' is not defined">auth_service\tests\unit\test_oauth_provider_business_value.py:317: in test_oauth_error_handling_protects_business_continuity
    mock_post.side_effect = requests.exceptions.RequestException("Network error")
                            ^^^^^^^^
E   NameError: name 'requests' is not defined</failure></testcase><testcase classname="tests.unit.test_oauth_provider_business_value.TestOAuthProviderBusinessValue" name="test_oauth_manager_status_monitoring_supports_business_operations" time="0.006"><failure message="AssertionError: Provider identification required&#10;assert None == 'google'&#10; +  where None = &lt;built-in method get of dict object at 0x000001E5C62BAA00&gt;('provider_name')&#10; +    where &lt;built-in method get of dict object at 0x000001E5C62BAA00&gt; = {'available': True, 'config_status': {'client_id_configured': True, 'client_secret_configured': True, 'environment': 'production', 'is_configured': True, ...}, 'configured': True, 'provider': 'google'}.get">auth_service\tests\unit\test_oauth_provider_business_value.py:363: in test_oauth_manager_status_monitoring_supports_business_operations
    assert google_status.get("provider_name") == "google", "Provider identification required"
E   AssertionError: Provider identification required
E   assert None == 'google'
E    +  where None = &lt;built-in method get of dict object at 0x000001E5C62BAA00&gt;('provider_name')
E    +    where &lt;built-in method get of dict object at 0x000001E5C62BAA00&gt; = {'available': True, 'config_status': {'client_id_configured': True, 'client_secret_configured': True, 'environment': 'production', 'is_configured': True, ...}, 'configured': True, 'provider': 'google'}.get</failure></testcase><testcase classname="tests.unit.test_oauth_security_validation.TestOAuthSecurityValidation" name="test_oauth_state_csrf_protection" time="0.003" /><testcase classname="tests.unit.test_oauth_security_validation.TestOAuthSecurityValidation" name="test_oauth_redirect_uri_validation_security" time="0.004"><failure message="AssertionError: Redirect URI should use HTTPS or localhost: http://dev-auth:8081/auth/callback&#10;assert False">auth_service\tests\unit\test_oauth_security_validation.py:100: in test_oauth_redirect_uri_validation_security
    assert False, f"Redirect URI should use HTTPS or localhost: {redirect_uri}"
E   AssertionError: Redirect URI should use HTTPS or localhost: http://dev-auth:8081/auth/callback
E   assert False</failure></testcase><testcase classname="tests.unit.test_password_security_comprehensive.TestPasswordSecurityComprehensive" name="test_password_policy_validation_comprehensive" time="0.030"><failure message="AssertionError: Invalid input should have zero score:    &#10;assert 10 == 0&#10; +  where 10 = PasswordPolicyResult(meets_policy=False, strength_score=10, requirements_missing=['Password must be at least 8 characters long', 'Password must contain at least one special characters', 'Password must contain at least one uppercase letter', 'Password must contain at least one lowercase letter', 'Password must contain at least one number'], recommendations=['Avoid excessive character repetition']).strength_score">auth_service\tests\unit\test_password_security_comprehensive.py:211: in test_password_policy_validation_comprehensive
    assert result.strength_score == 0, f"Invalid input should have zero score: {invalid_input}"
E   AssertionError: Invalid input should have zero score:    
E   assert 10 == 0
E    +  where 10 = PasswordPolicyResult(meets_policy=False, strength_score=10, requirements_missing=['Password must be at least 8 characters long', 'Password must contain at least one special characters', 'Password must contain at least one uppercase letter', 'Password must contain at least one lowercase letter', 'Password must contain at least one number'], recommendations=['Avoid excessive character repetition']).strength_score</failure></testcase><testcase classname="tests.unit.test_password_security_comprehensive.TestPasswordSecurityComprehensive" name="test_password_strength_scoring_algorithm" time="0.018"><failure message="AssertionError: Password with common patterns should have lower score: Password123! (got 98, expected &lt;= 50)&#10;assert 98 &lt;= 50&#10; +  where 98 = PasswordPolicyResult(meets_policy=True, strength_score=98, requirements_missing=[], recommendations=['Avoid common words and patterns', 'Avoid sequential characters']).strength_score">auth_service\tests\unit\test_password_security_comprehensive.py:290: in test_password_strength_scoring_algorithm
    assert result.strength_score &lt;= max_expected_score, (
E   AssertionError: Password with common patterns should have lower score: Password123! (got 98, expected &lt;= 50)
E   assert 98 &lt;= 50
E    +  where 98 = PasswordPolicyResult(meets_policy=True, strength_score=98, requirements_missing=[], recommendations=['Avoid common words and patterns', 'Avoid sequential characters']).strength_score</failure></testcase><testcase classname="tests.unit.test_password_security_comprehensive.TestPasswordSecurityComprehensive" name="test_password_hashing_security" time="0.018"><failure message="auth_service.services.password_service.PasswordPolicyError: Password contains weak patterns and is not secure">auth_service\tests\unit\test_password_security_comprehensive.py:307: in test_password_hashing_security
    password_hash = self.password_service.hash_password(strong_password)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
auth_service\services\password_service.py:67: in hash_password
    self.validate_password_policy(password)
auth_service\services\password_service.py:157: in validate_password_policy
    raise PasswordPolicyError("Password contains weak patterns and is not secure")
E   auth_service.services.password_service.PasswordPolicyError: Password contains weak patterns and is not secure</failure></testcase><testcase classname="tests.unit.test_password_security_comprehensive.TestPasswordSecurityComprehensive" name="test_password_attack_pattern_prevention" time="0.020"><failure message="AssertionError: Sequential password should have sequence recommendations: 987654321a!A&#10;assert False">auth_service\tests\unit\test_password_security_comprehensive.py:427: in test_password_attack_pattern_prevention
    assert recommendations_found, (
E   AssertionError: Sequential password should have sequence recommendations: 987654321a!A
E   assert False</failure></testcase><testcase classname="tests.unit.test_password_security_comprehensive.TestPasswordSecurityComprehensive" name="test_password_reset_security" time="0.018"><failure message="AssertionError: Reset token should be stored correctly: FKh5LgQ5Q2qahckJdZ2lppO4JGIkqQYHvyFroikwunw&#10;assert None == 'test@example.com'">auth_service\tests\unit\test_password_security_comprehensive.py:520: in test_password_reset_security
    assert stored_email == user_email, f"Reset token should be stored correctly: {token}"
E   AssertionError: Reset token should be stored correctly: FKh5LgQ5Q2qahckJdZ2lppO4JGIkqQYHvyFroikwunw
E   assert None == 'test@example.com'</failure></testcase><testcase classname="tests.unit.test_password_security_comprehensive.TestPasswordSecurityComprehensive" name="test_password_complexity_scoring_edge_cases" time="0.027" /><testcase classname="tests.unit.test_refresh_endpoint.TestRefreshEndpointUnit" name="test_refresh_with_valid_token_in_body" time="0.052" /><testcase classname="tests.unit.test_refresh_endpoint.TestRefreshEndpointUnit" name="test_refresh_with_camelcase_field" time="0.038" /><testcase classname="tests.unit.test_refresh_endpoint.TestRefreshEndpointUnit" name="test_refresh_with_token_field" time="0.036" /><testcase classname="tests.unit.test_refresh_endpoint.TestRefreshEndpointUnit" name="test_refresh_missing_token_field" time="0.042" /><testcase classname="tests.unit.test_refresh_endpoint.TestRefreshEndpointUnit" name="test_refresh_with_invalid_json" time="0.032" /><testcase classname="tests.unit.test_refresh_endpoint.TestRefreshEndpointUnit" name="test_refresh_with_invalid_token" time="0.033" /><testcase classname="tests.unit.test_refresh_endpoint.TestRefreshEndpointUnit" name="test_refresh_with_service_error" time="0.035" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestAuthSecretLoaderCore" name="test_auth_secret_loader_class_exists" time="0.001" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestAuthSecretLoaderCore" name="test_all_methods_are_static" time="0.001" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestJWTSecretLoading" name="test_get_jwt_secret_with_central_validator_success" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestJWTSecretLoading" name="test_get_jwt_secret_central_validator_failure" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestJWTSecretLoading" name="test_get_jwt_secret_no_central_validator_available" time="0.001" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestJWTSecretLoading" name="test_get_jwt_secret_validator_instantiation_error" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestOAuthCredentialLoading" name="test_get_google_client_id_success_with_environment_logging" time="0.004" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestOAuthCredentialLoading" name="test_get_google_client_id_validation_failure" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestOAuthCredentialLoading" name="test_get_google_client_secret_success_with_environment_logging" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestOAuthCredentialLoading" name="test_get_google_client_secret_validation_failure" time="0.004" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestOAuthCredentialLoading" name="test_oauth_methods_fail_without_central_validator" time="0.001" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestDatabaseUrlConstruction" name="test_get_database_url_from_postgres_variables_development" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestDatabaseUrlConstruction" name="test_get_database_url_from_postgres_variables_staging_with_ssl" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestDatabaseUrlConstruction" name="test_get_database_url_cloud_sql_configuration" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestDatabaseUrlConstruction" name="test_get_database_url_missing_required_variables" time="0.003"><failure message="AssertionError: assert ('postgresql+a...432/netra_dev' == ''&#10;  &#10;  + postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev or 'test' in 'postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev')&#10; +  where 'postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev' = &lt;built-in method lower of str object at 0x000001E5C632A640&gt;()&#10; +    where &lt;built-in method lower of str object at 0x000001E5C632A640&gt; = 'postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev'.lower">auth_service\tests\unit\test_secret_loader_comprehensive.py:351: in test_get_database_url_missing_required_variables
    assert result == "" or "test" in result.lower()
E   AssertionError: assert ('postgresql+a...432/netra_dev' == ''
E     
E     + postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev or 'test' in 'postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev')
E    +  where 'postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev' = &lt;built-in method lower of str object at 0x000001E5C632A640&gt;()
E    +    where &lt;built-in method lower of str object at 0x000001E5C632A640&gt; = 'postgresql+asyncpg://netra:netra123@dev-postgres:5432/netra_dev'.lower</failure></testcase><testcase classname="tests.unit.test_secret_loader_comprehensive.TestDatabaseUrlConstruction" name="test_get_database_url_secret_manager_fallback_staging" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestE2EBypassKey" name="test_get_e2e_oauth_simulation_key_staging_environment_variable" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestE2EBypassKey" name="test_get_e2e_oauth_simulation_key_staging_secret_manager" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestE2EBypassKey" name="test_get_e2e_oauth_simulation_key_non_staging_environment_denied" time="0.006" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestE2EBypassKey" name="test_get_e2e_oauth_simulation_key_staging_not_configured" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretManagerIntegration" name="test_load_from_secret_manager_success" time="0.006" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretManagerIntegration" name="test_load_from_secret_manager_no_gcp_project" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretManagerIntegration" name="test_load_from_secret_manager_import_error" time="1.786" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretManagerIntegration" name="test_load_from_secret_manager_access_error" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretManagerIntegration" name="test_load_from_secret_manager_configuration_error" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderErrorHandling" name="test_all_methods_handle_environment_access_errors" time="0.002"><failure message="Failed: DID NOT RAISE &lt;class 'Exception'&gt;">auth_service\tests\unit\test_secret_loader_comprehensive.py:552: in test_all_methods_handle_environment_access_errors
    with pytest.raises(Exception):
E   Failed: DID NOT RAISE &lt;class 'Exception'&gt;</failure></testcase><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderErrorHandling" name="test_secret_loading_with_invalid_central_validator_response" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderErrorHandling" name="test_oauth_credential_loading_with_unicode_handling" time="0.003" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderConfiguration" name="test_database_url_construction_respects_environment_precedence" time="0.004" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderConfiguration" name="test_secret_loader_methods_maintain_service_independence" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderBusinessValue" name="test_jwt_secret_loading_prevents_authentication_failures" time="0.002" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderBusinessValue" name="test_oauth_credentials_support_multi_environment_isolation" time="0.015" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderBusinessValue" name="test_database_url_construction_supports_multiple_deployment_patterns" time="0.008" /><testcase classname="tests.unit.test_secret_loader_comprehensive.TestSecretLoaderBusinessValue" name="test_e2e_bypass_key_enables_staging_testing_while_maintaining_security" time="0.008" /></testsuite></testsuites>