# Request-Scoped Dependency Injection System

## Business Value Justification (BVJ)
- **Segment:** Platform/Internal (affects all tiers)  
- **Business Goal:** Platform Stability & Data Isolation
- **Value Impact:** Prevents data leakage between user requests, ensuring secure multi-tenant operations
- **Strategic Impact:** Enables safe concurrent user operations required for production deployment

## Overview

The Request-Scoped Dependency Injection system ensures database sessions are properly isolated per HTTP request and never stored globally. This prevents data leakage between users and enables safe concurrent operations.

## Critical Principles

### 1. Sessions Must Be Request-Scoped Only
- **NEVER** store database sessions in global objects
- Sessions are created when requests start and closed when requests complete
- Each request gets its own isolated session

### 2. Context Separation  
- **RequestScopedContext**: Contains only request metadata (user_id, thread_id, etc.)
- **Database Sessions**: Passed separately as dependencies, never stored in context objects

### 3. Validation & Monitoring
- All sessions are validated to ensure they're not globally stored
- Session lifecycle is logged for debugging and monitoring
- Runtime checks prevent globally stored sessions from being used

## New Dependency System

### Core Dependencies

#### 1. RequestScopedDbDep
```python
from netra_backend.app.dependencies import RequestScopedDbDep

@router.post(\"/api/endpoint\")\nasync def my_endpoint(\n    data: MyModel,\n    db: RequestScopedDbDep  # Auto-managed session lifecycle\n) -> Dict[str, Any]:\n    # Session is automatically created and closed\n    result = await db.execute(text(\"SELECT * FROM table\"))\n    return {\"data\": result.fetchall()}\n```

#### 2. RequestScopedContextDep
```python\nfrom netra_backend.app.dependencies import RequestScopedContextDep\n\n@router.post(\"/api/endpoint\")\nasync def my_endpoint(\n    data: MyModel,\n    context: RequestScopedContextDep  # Request metadata only\n) -> Dict[str, Any]:\n    # Context contains user_id, thread_id, run_id, etc.\n    # NO database sessions stored here\n    logger.info(f\"Processing request for user {context.user_id}\")\n    return {\"user_id\": context.user_id}\n```

#### 3. RequestScopedSupervisorDep
```python\nfrom netra_backend.app.dependencies import RequestScopedSupervisorDep\n\n@router.post(\"/api/agent/run\")\nasync def run_agent(\n    request: AgentRequest,\n    supervisor: RequestScopedSupervisorDep  # Isolated supervisor with request-scoped session\n) -> Dict[str, Any]:\n    # Supervisor has access to request-scoped session via session factory\n    # Session is automatically closed when request completes\n    await supervisor.run(request.query, request.id)\n    return {\"status\": \"started\"}\n```\n\n## Migration Guide\n\n### From Legacy to Request-Scoped Dependencies\n\n#### Before (Legacy - DEPRECATED)\n```python\n@router.post(\"/legacy/endpoint\")\nasync def legacy_endpoint(\n    data: MyModel,\n    supervisor: Supervisor = Depends(get_agent_supervisor),  # Global supervisor\n    db: AsyncSession = Depends(get_db_dependency)  # Basic session\n) -> Dict[str, Any]:\n    # PROBLEM: supervisor is global, may have stored sessions\n    # PROBLEM: no validation that session is request-scoped\n    pass\n```\n\n#### After (Request-Scoped - PREFERRED)\n```python\n@router.post(\"/v2/endpoint\")\nasync def request_scoped_endpoint(\n    data: MyModel,\n    context: RequestScopedContextDep,  # Request metadata\n    supervisor: RequestScopedSupervisorDep,  # Isolated supervisor\n    db: RequestScopedDbDep  # Validated request-scoped session\n) -> Dict[str, Any]:\n    # ✓ supervisor is created fresh for this request\n    # ✓ db session is validated as request-scoped\n    # ✓ context contains no stored sessions\n    # ✓ all resources automatically cleaned up\n    pass\n```\n\n### Migration Steps\n\n1. **Add new v2 routes** alongside existing routes\n2. **Update imports** to include new dependency types\n3. **Replace legacy dependencies** with request-scoped equivalents\n4. **Add session_scoped: true** to response for tracking\n5. **Test both versions** during transition period\n6. **Remove legacy routes** after validation\n\n## Session Validation System\n\n### Validation Functions\n\n```python\n# Validate session is request-scoped\nvalidate_session_is_request_scoped(session, \"my_operation\")\n\n# Mark session as globally stored (for testing)\nmark_session_as_global(session)\n\n# Log session lifecycle events\nensure_session_lifecycle_logging(session, \"operation_name\")\n```\n\n### Runtime Checks\n\nThe system includes multiple layers of validation:\n\n1. **Dependency Level**: Sessions are validated when injected\n2. **Context Level**: RequestScopedContext never stores sessions\n3. **Supervisor Level**: Global supervisors checked for stored sessions\n4. **Lifecycle Level**: Session creation and cleanup is logged\n\n## API Route Examples\n\n### Complete Request-Scoped Route\n\n```python\nfrom netra_backend.app.dependencies import (\n    RequestScopedContextDep,\n    RequestScopedSupervisorDep,\n    RequestScopedDbDep\n)\n\n@router.post(\"/api/agents/v2/run\")\nasync def run_agent_v2(\n    request_model: RequestModel,\n    context: RequestScopedContextDep,\n    supervisor: RequestScopedSupervisorDep\n) -> Dict[str, Any]:\n    \"\"\"Run agent with proper request-scoped dependencies.\n    \n    This route demonstrates complete request-scoped session management.\n    Database sessions are never stored globally and are automatically\n    closed when the request completes.\n    \"\"\"\n    logger.info(f\"Processing request for user {context.user_id}\")\n    \n    # Execute using request-scoped supervisor\n    await supervisor.run(\n        request_model.query, \n        context.run_id, \n        stream_updates=True\n    )\n    \n    return {\n        \"run_id\": context.run_id,\n        \"status\": \"started\", \n        \"user_id\": context.user_id,\n        \"session_scoped\": True  # Indicates new pattern usage\n    }\n```\n\n### Database Operations Route\n\n```python\n@router.get(\"/api/data/v2/{resource_id}\")\nasync def get_resource_v2(\n    resource_id: str,\n    context: RequestScopedContextDep,\n    db: RequestScopedDbDep\n) -> Dict[str, Any]:\n    \"\"\"Get resource with request-scoped database session.\"\"\"\n    \n    # Session is automatically validated and managed\n    result = await db.execute(\n        text(\"SELECT * FROM resources WHERE id = :id AND user_id = :user_id\"),\n        {\"id\": resource_id, \"user_id\": context.user_id}\n    )\n    \n    resource = result.fetchone()\n    if not resource:\n        raise HTTPException(status_code=404, detail=\"Resource not found\")\n    \n    return {\n        \"resource\": dict(resource),\n        \"user_id\": context.user_id,\n        \"session_scoped\": True\n    }\n```\n\n## Testing Request-Scoped Dependencies\n\n### Unit Tests\n\n```python\nimport pytest\nfrom netra_backend.app.dependencies import (\n    get_request_scoped_db_session,\n    validate_session_is_request_scoped\n)\n\n@pytest.mark.asyncio\nasync def test_session_isolation():\n    \"\"\"Test that sessions are properly isolated.\"\"\"\n    sessions = []\n    \n    # Create multiple sessions\n    async with get_request_scoped_db_session() as session1:\n        sessions.append(session1)\n        \n    async with get_request_scoped_db_session() as session2:\n        sessions.append(session2)\n    \n    # Verify sessions are different\n    assert sessions[0] is not sessions[1]\n    \n    # Verify sessions are request-scoped\n    for session in sessions:\n        validate_session_is_request_scoped(session, \"test\")\n```\n\n### Integration Tests\n\n```python\n@pytest.mark.asyncio\nasync def test_route_session_isolation(client):\n    \"\"\"Test that API routes use isolated sessions.\"\"\"\n    \n    # Make multiple concurrent requests\n    tasks = [\n        client.post(\"/api/agents/v2/run\", json={\"query\": f\"test {i}\"})\n        for i in range(5)\n    ]\n    \n    responses = await asyncio.gather(*tasks)\n    \n    # Verify all responses indicate session scoping\n    for response in responses:\n        assert response.json()[\"session_scoped\"] is True\n```\n\n## Troubleshooting\n\n### Common Issues\n\n#### 1. \"Session must be request-scoped\" Error\n\n**Cause**: Attempting to use a globally stored session\n\n**Solution**: Ensure sessions are obtained via RequestScopedDbDep\n\n```python\n# ❌ Wrong - may use globally stored session\ndb = get_global_session()\n\n# ✅ Correct - guaranteed request-scoped session\ndb: RequestScopedDbDep\n```\n\n#### 2. \"Global supervisor has stored session\" Error\n\n**Cause**: Legacy supervisor has a stored database session\n\n**Solution**: Use RequestScopedSupervisorDep instead\n\n```python\n# ❌ Wrong - legacy global supervisor\nsupervisor = Depends(get_agent_supervisor)\n\n# ✅ Correct - request-scoped supervisor\nsupervisor: RequestScopedSupervisorDep\n```\n\n#### 3. Session Not Closed After Request\n\n**Cause**: Manual session management or exception handling\n\n**Solution**: Use context managers and let dependency system handle lifecycle\n\n```python\n# ❌ Wrong - manual session management\nsession = create_session()\ntry:\n    # operations\nfinally:\n    await session.close()\n\n# ✅ Correct - automatic lifecycle management\nasync with get_request_scoped_db_session() as session:\n    # operations - automatically closed\n```\n\n### Debugging Session Issues\n\n1. **Check logs** for session lifecycle events\n2. **Verify dependency types** in route signatures\n3. **Run validation tests** to confirm session isolation\n4. **Monitor session counts** to detect leaks\n\n## Best Practices\n\n### 1. Always Use Request-Scoped Dependencies\n```python\n# ✅ Preferred for new code\nfrom netra_backend.app.dependencies import (\n    RequestScopedContextDep,\n    RequestScopedDbDep,\n    RequestScopedSupervisorDep\n)\n```\n\n### 2. Never Store Sessions in Objects\n```python\nclass MyService:\n    def __init__(self):\n        # ❌ NEVER store sessions in class attributes\n        self.db_session = None\n    \n    async def operation(self, db: RequestScopedDbDep):\n        # ✅ Receive session as parameter\n        result = await db.execute(text(\"SELECT 1\"))\n        return result\n```\n\n### 3. Use Context for Metadata Only\n```python\nasync def my_endpoint(context: RequestScopedContextDep, db: RequestScopedDbDep):\n    # ✅ Context contains metadata\n    user_id = context.user_id\n    \n    # ✅ Session passed separately\n    result = await db.execute(\n        text(\"SELECT * FROM table WHERE user_id = :user_id\"),\n        {\"user_id\": user_id}\n    )\n```\n\n### 4. Add Session Scoping Indicators\n```python\nreturn {\n    \"data\": result,\n    \"session_scoped\": True  # Helps track migration progress\n}\n```\n\n## Migration Checklist\n\n### For Each Route:\n- [ ] Add new v2 route with request-scoped dependencies\n- [ ] Update imports to include new dependency types\n- [ ] Replace legacy dependencies with request-scoped equivalents\n- [ ] Add `session_scoped: true` to responses\n- [ ] Test both legacy and new routes\n- [ ] Verify session isolation with concurrent requests\n- [ ] Remove legacy route after validation\n\n### For Each Service:\n- [ ] Remove any stored database sessions from class attributes\n- [ ] Update methods to receive sessions as parameters\n- [ ] Validate session lifecycle in service operations\n- [ ] Add session validation in critical paths\n\n### For Each Test:\n- [ ] Update test fixtures to use request-scoped dependencies\n- [ ] Add session isolation validation tests\n- [ ] Test concurrent request scenarios\n- [ ] Verify session cleanup after exceptions\n\n## Summary\n\nThe Request-Scoped Dependency Injection system provides:\n\n1. **Data Isolation**: Each request gets its own database session\n2. **Automatic Lifecycle Management**: Sessions are created and closed automatically\n3. **Validation & Monitoring**: Runtime checks prevent session storage violations\n4. **Migration Path**: Gradual transition from legacy to request-scoped patterns\n5. **Production Safety**: Enables safe concurrent user operations\n\nThis system is critical for production deployment where multiple users must be safely isolated from each other while sharing the same application instance.