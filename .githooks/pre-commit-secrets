#!/usr/bin/env python
"""
Pre-commit hook to scan for secrets in staged files.
Prevents committing hardcoded passwords, API keys, and other sensitive data.
"""

import subprocess
import sys
import re
from pathlib import Path
from typing import List, Set


class SecretsPreCommitScanner:
    """Lightweight secrets scanner for pre-commit hook."""
    
    def __init__(self):
        self.critical_patterns = [
            # The specific Redis password that was found
            (r'cpmdn7pVpsJSK2mb7lUTj2VaQhSC1L3S', 'Hardcoded Redis password'),
            
            # Hardcoded passwords (excluding test patterns)
            (r'password\s*=\s*["\'](?!your-|test|example|placeholder|mock|dummy|wrong|correct|valid)[^"\']{8,}["\']', 
             'Potential hardcoded password'),
            
            # JWT secrets
            (r'JWT_SECRET(?:_KEY)?\s*=\s*["\'][^"\']{16,}["\']', 'Hardcoded JWT secret'),
            
            # API keys
            (r'(?:api[_-]?key|apikey)\s*=\s*["\'][A-Za-z0-9_\-]{20,}["\']', 'Hardcoded API key'),
            
            # Google OAuth secrets
            (r'GOOGLE_(?:OAUTH_)?CLIENT_SECRET\s*=\s*["\'](?!your-)[^"\']+["\']', 
             'Google OAuth client secret'),
            
            # Private keys
            (r'-----BEGIN (?:RSA |EC |DSA |OPENSSH )?PRIVATE KEY', 'Private key'),
            
            # Service account keys
            (r'"private_key"\s*:\s*"[^"]+-----BEGIN', 'Service account private key'),
        ]
        
        self.allowed_paths = [
            'tests/',
            'test_',
            '__tests__/',
            '.test.',
            '.spec.',
            'cypress/',
            'fixtures/',
            'mocks/',
            'examples/'
        ]
    
    def get_staged_files(self) -> List[str]:
        """Get list of staged files."""
        try:
            result = subprocess.run(
                ['git', 'diff', '--cached', '--name-only', '--diff-filter=ACM'],
                capture_output=True,
                text=True
            )
            return [f for f in result.stdout.strip().split('\n') if f]
        except Exception as e:
            print(f"Error getting staged files: {e}", file=sys.stderr)
            return []
    
    def should_scan_file(self, file_path: str) -> bool:
        """Check if file should be scanned."""
        # Only scan code files
        extensions = ['.py', '.js', '.ts', '.jsx', '.tsx', '.json', '.yaml', '.yml', 
                     '.env', '.config', '.conf', '.ini']
        
        path = Path(file_path)
        
        # Skip if not a code file
        if path.suffix not in extensions and not path.name.startswith('.env'):
            return False
        
        # Allow test files (they often have test passwords)
        for allowed in self.allowed_paths:
            if allowed in str(path):
                return False
        
        return True
    
    def scan_file(self, file_path: str) -> List[tuple]:
        """Scan a file for secrets."""
        findings = []
        
        try:
            # Get file content from git staging area
            result = subprocess.run(
                ['git', 'show', f':{file_path}'],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                return findings
            
            content = result.stdout
            
            for line_num, line in enumerate(content.split('\n'), 1):
                # Skip comments
                if line.strip().startswith('#') or line.strip().startswith('//'):
                    continue
                
                # Skip lines with template/example markers
                if any(skip in line.lower() for skip in 
                      ['your-', 'example', 'placeholder', 'template', 'mock']):
                    continue
                
                # Check against patterns
                for pattern, description in self.critical_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        findings.append((line_num, line.strip(), description))
                        break
        
        except Exception as e:
            print(f"Error scanning {file_path}: {e}", file=sys.stderr)
        
        return findings
    
    def run(self) -> bool:
        """Run the scanner on staged files."""
        staged_files = self.get_staged_files()
        
        if not staged_files:
            return True
        
        all_findings = {}
        
        for file_path in staged_files:
            if not self.should_scan_file(file_path):
                continue
            
            findings = self.scan_file(file_path)
            if findings:
                all_findings[file_path] = findings
        
        if all_findings:
            print("\n" + "="*70)
            print("SECURITY: Potential secrets detected in staged files!")
            print("="*70)
            
            for file_path, findings in all_findings.items():
                print(f"\nFile: {file_path}")
                for line_num, content, description in findings:
                    print(f"  Line {line_num}: {description}")
                    print(f"    {content[:100]}...")
            
            print("\n" + "="*70)
            print("COMMIT BLOCKED: Please remove secrets before committing.")
            print("="*70)
            print("\nTo bypass (NOT RECOMMENDED): git commit --no-verify")
            print("To fix: Move secrets to environment variables or .env files")
            
            return False
        
        return True


def main():
    """Main entry point."""
    scanner = SecretsPreCommitScanner()
    
    if not scanner.run():
        sys.exit(1)
    
    sys.exit(0)


if __name__ == '__main__':
    main()