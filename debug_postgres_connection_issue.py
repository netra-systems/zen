#!/usr/bin/env python3
"""
Critical PostgreSQL Connection Issue Debug Script

This script replicates the exact connection flow used by the dev launcher
to identify the root cause of the PostgreSQL connection failure.
"""
import asyncio
import logging
import sys
import traceback
from typing import Dict, Any
from pathlib import Path

# Add project root to path for imports
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

from dev_launcher.isolated_environment import get_env
from dev_launcher.database_connector import DatabaseConnector, DatabaseConnection
from dev_launcher.network_resilience import NetworkResilientClient, RetryPolicy
from shared.database_url_builder import DatabaseURLBuilder

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

async def direct_asyncpg_test():
    """Test direct asyncpg connection using the known working URL."""
    logger.info("=== DIRECT ASYNCPG CONNECTION TEST ===")
    
    try:
        import asyncpg
        
        # Known working URL from user
        direct_url = "postgresql://postgres:DTprdt5KoQXlEG4Gh9lF@localhost:5433/netra_dev"
        logger.info(f"Testing direct connection with URL: {direct_url}")
        
        conn = await asyncio.wait_for(
            asyncpg.connect(direct_url),
            timeout=15.0
        )
        
        result = await conn.fetchval("SELECT 1")
        await conn.close()
        
        logger.info(f"‚úÖ Direct connection SUCCESS: {result}")
        return True
        
    except Exception as e:
        logger.error(f"‚ùå Direct connection FAILED: {e}")
        logger.error(traceback.format_exc())
        return False

async def test_database_url_builder():
    """Test DatabaseURLBuilder URL construction."""
    logger.info("\n=== DATABASE URL BUILDER TEST ===")
    
    try:
        env = get_env()
        env_vars = env.get_all()
        
        logger.info("Environment variables:")
        for key in ['DATABASE_URL', 'POSTGRES_HOST', 'POSTGRES_PORT', 'POSTGRES_USER', 'POSTGRES_PASSWORD', 'POSTGRES_DB']:
            value = env_vars.get(key, 'NOT SET')
            masked_value = value if key not in ['POSTGRES_PASSWORD'] else f"{value[:3]}***" if value else 'NOT SET'
            logger.info(f"  {key}: {masked_value}")
        
        # Test DatabaseURLBuilder
        builder = DatabaseURLBuilder(env_vars)
        
        logger.info(f"Environment: {builder.environment}")
        logger.info(f"Has TCP config: {builder.tcp.has_config}")
        logger.info(f"Has Cloud SQL config: {builder.cloud_sql.is_cloud_sql}")
        
        # Get URLs
        tcp_url = builder.tcp.async_url
        development_url = builder.development.auto_url
        final_url = builder.get_url_for_environment(sync=False)
        
        logger.info(f"TCP async URL: {DatabaseURLBuilder.mask_url_for_logging(tcp_url)}")
        logger.info(f"Development auto URL: {DatabaseURLBuilder.mask_url_for_logging(development_url)}")
        logger.info(f"Final URL for environment: {DatabaseURLBuilder.mask_url_for_logging(final_url)}")
        
        # Test URL normalization
        if final_url:
            normalized_url = DatabaseURLBuilder.normalize_postgres_url(final_url)
            logger.info(f"Normalized URL: {DatabaseURLBuilder.mask_url_for_logging(normalized_url)}")
            
            # Test driver formatting
            asyncpg_url = DatabaseURLBuilder.format_url_for_driver(normalized_url, 'asyncpg')
            logger.info(f"AsyncPG formatted URL: {DatabaseURLBuilder.mask_url_for_logging(asyncpg_url)}")
            
            return final_url, asyncpg_url
        else:
            logger.error("‚ùå No URL generated by DatabaseURLBuilder")
            return None, None
        
    except Exception as e:
        logger.error(f"‚ùå DatabaseURLBuilder test FAILED: {e}")
        logger.error(traceback.format_exc())
        return None, None

async def test_database_connector():
    """Test DatabaseConnector connection validation."""
    logger.info("\n=== DATABASE CONNECTOR TEST ===")
    
    try:
        connector = DatabaseConnector(use_emoji=False)
        
        # Get the URL that would be used
        env = get_env()
        database_url = env.get('DATABASE_URL')
        
        if not database_url:
            logger.error("‚ùå No DATABASE_URL in environment")
            return False
            
        logger.info(f"Using DATABASE_URL: {DatabaseURLBuilder.mask_url_for_logging(database_url)}")
        
        # Create a connection object
        connection = DatabaseConnection(
            url=database_url,
            name="postgres",
            required=True
        )
        
        # Test the connection
        logger.info("Testing PostgreSQL connection...")
        success = await connector._test_postgresql_connection(connection)
        
        if success:
            logger.info("‚úÖ DatabaseConnector connection SUCCESS")
        else:
            logger.error(f"‚ùå DatabaseConnector connection FAILED: {connection.last_error}")
            
        return success
        
    except Exception as e:
        logger.error(f"‚ùå DatabaseConnector test FAILED: {e}")
        logger.error(traceback.format_exc())
        return False

async def test_network_resilience():
    """Test network resilience client PostgreSQL check."""
    logger.info("\n=== NETWORK RESILIENCE TEST ===")
    
    try:
        client = NetworkResilientClient()
        
        env = get_env()
        database_url = env.get('DATABASE_URL')
        
        if not database_url:
            logger.error("‚ùå No DATABASE_URL in environment")
            return False
            
        logger.info(f"Testing resilient connection with URL: {DatabaseURLBuilder.mask_url_for_logging(database_url)}")
        
        # Test with the same policy as dev launcher
        policy = RetryPolicy(
            max_attempts=5,
            initial_delay=2.0,
            max_delay=10.0,
            timeout_per_attempt=15.0
        )
        
        success, error = await client.resilient_database_check(
            database_url,
            db_type='postgresql',
            retry_policy=policy
        )
        
        if success:
            logger.info("‚úÖ Network resilience connection SUCCESS")
        else:
            logger.error(f"‚ùå Network resilience connection FAILED: {error}")
            
        return success
        
    except Exception as e:
        logger.error(f"‚ùå Network resilience test FAILED: {e}")
        logger.error(traceback.format_exc())
        return False

async def test_url_variations():
    """Test various URL variations to identify the issue."""
    logger.info("\n=== URL VARIATIONS TEST ===")
    
    # Known working URL
    working_url = "postgresql://postgres:DTprdt5KoQXlEG4Gh9lF@localhost:5433/netra_dev"
    
    # Variations to test
    variations = [
        ("Working URL", working_url),
        ("With asyncpg driver", "postgresql+asyncpg://postgres:DTprdt5KoQXlEG4Gh9lF@localhost:5433/netra_dev"),
        ("Normalized", DatabaseURLBuilder.normalize_postgres_url(working_url)),
        ("Formatted for asyncpg", DatabaseURLBuilder.format_url_for_driver(working_url, 'asyncpg')),
    ]
    
    results = {}
    
    for name, url in variations:
        logger.info(f"\nTesting {name}: {DatabaseURLBuilder.mask_url_for_logging(url)}")
        
        try:
            import asyncpg
            
            # Strip driver prefix if present for direct asyncpg test
            clean_url = url.replace("postgresql+asyncpg://", "postgresql://")
            
            conn = await asyncio.wait_for(
                asyncpg.connect(clean_url),
                timeout=10.0
            )
            
            result = await conn.fetchval("SELECT 1")
            await conn.close()
            
            logger.info(f"  ‚úÖ SUCCESS: {result}")
            results[name] = True
            
        except Exception as e:
            logger.error(f"  ‚ùå FAILED: {e}")
            results[name] = False
    
    return results

async def comprehensive_diagnostic():
    """Run comprehensive diagnostic tests."""
    logger.info("üîç STARTING COMPREHENSIVE POSTGRESQL CONNECTION DIAGNOSTIC")
    logger.info("=" * 80)
    
    results = {}
    
    # Test 1: Direct asyncpg connection
    results['direct_asyncpg'] = await direct_asyncpg_test()
    
    # Test 2: DatabaseURLBuilder
    builder_url, asyncpg_url = await test_database_url_builder()
    results['url_builder'] = builder_url is not None
    
    # Test 3: DatabaseConnector
    results['database_connector'] = await test_database_connector()
    
    # Test 4: Network resilience
    results['network_resilience'] = await test_network_resilience()
    
    # Test 5: URL variations
    url_results = await test_url_variations()
    results.update(url_results)
    
    # Summary
    logger.info("\n" + "=" * 80)
    logger.info("üîç DIAGNOSTIC SUMMARY")
    logger.info("=" * 80)
    
    for test_name, success in results.items():
        status = "‚úÖ PASS" if success else "‚ùå FAIL"
        logger.info(f"{test_name:30} {status}")
    
    # Analysis
    logger.info("\n" + "=" * 80)
    logger.info("üß† ROOT CAUSE ANALYSIS")
    logger.info("=" * 80)
    
    if results.get('direct_asyncpg') and not results.get('database_connector'):
        logger.info("‚ö†Ô∏è  ISSUE: Direct connection works but DatabaseConnector fails")
        logger.info("   This suggests URL transformation or connection method differences")
        
    if results.get('direct_asyncpg') and not results.get('network_resilience'):
        logger.info("‚ö†Ô∏è  ISSUE: Direct connection works but NetworkResilientClient fails")
        logger.info("   This suggests retry logic or timeout issues")
        
    if builder_url and asyncpg_url:
        logger.info(f"üìã DatabaseURLBuilder generated: {DatabaseURLBuilder.mask_url_for_logging(builder_url)}")
        logger.info(f"üìã AsyncPG formatted URL: {DatabaseURLBuilder.mask_url_for_logging(asyncpg_url)}")
    
    return results

if __name__ == "__main__":
    asyncio.run(comprehensive_diagnostic())