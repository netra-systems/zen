name: Staging Environment Management (Enhanced)

on:
  pull_request:
    types: [opened, synchronize, closed, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      action:
        description: 'Manual action'
        required: true
        type: choice
        options:
          - deploy
          - destroy
          - redeploy
      pr_number:
        description: 'PR number'
        required: true
        type: string

# Enhanced concurrency control with commit detection
concurrency:
  group: staging-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}
  # Cancel in-progress runs when new commits are pushed, except cleanup operations
  cancel-in-progress: ${{ github.event.action == 'synchronize' || (!contains(github.job, 'destroy') && !contains(github.job, 'cleanup')) }}

env:
  GCP_PROJECT_ID: netra-staging
  GCP_REGION: us-central1
  TERRAFORM_VERSION: 1.5.0
  STAGING_DOMAIN: staging.netrasystems.ai
  # Track the commit SHA for this deployment
  DEPLOYMENT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}

jobs:
  # Initialize deployment tracking and create initial comment
  initialize-deployment:
    name: Initialize Deployment Tracking
    runs-on: ubuntu-latest
    outputs:
      comment_id: ${{ steps.comment.outputs.comment_id }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment_name: ${{ steps.check.outputs.environment_name }}
    steps:
      - name: Check deployment eligibility
        id: check
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Check for exclusion labels
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'no-staging') }}" == "true" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "reason=no-staging label present" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'WIP') }}" == "true" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "reason=WIP label present" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check for manual trigger
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.action }}" == "destroy" ]]; then
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              echo "action=destroy" >> $GITHUB_OUTPUT
            else
              echo "should_deploy=true" >> $GITHUB_OUTPUT
              echo "action=deploy" >> $GITHUB_OUTPUT
            fi
          # Check for PR close
          elif [[ "${{ github.event.action }}" == "closed" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "action=destroy" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "action=deploy" >> $GITHUB_OUTPUT
          fi
          
          echo "environment_name=pr-${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "deployment_sha=${{ env.DEPLOYMENT_SHA }}" >> $GITHUB_OUTPUT

      - name: Generate deployment ID
        id: deployment
        run: |
          # Generate unique deployment ID for tracking
          DEPLOYMENT_ID="${{ github.run_id }}-${{ github.run_attempt }}"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "Generated deployment ID: $DEPLOYMENT_ID"

      - name: Create or update initial PR comment
        id: comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.payload.pull_request.number;
            const deployment_id = '${{ steps.deployment.outputs.deployment_id }}';
            const deployment_sha = '${{ env.DEPLOYMENT_SHA }}';
            const should_deploy = '${{ steps.check.outputs.should_deploy }}';
            const reason = '${{ steps.check.outputs.reason }}';
            const action = '${{ steps.check.outputs.action }}';
            
            // Determine initial status
            let statusEmoji = 'ğŸ”„';
            let statusText = 'Initializing';
            let mainMessage = '';
            
            if (should_deploy === 'false' && reason) {
              statusEmoji = 'â­ï¸';
              statusText = 'Skipped';
              mainMessage = `Deployment skipped: ${reason}`;
            } else if (action === 'destroy') {
              statusEmoji = 'ğŸ§¹';
              statusText = 'Destroying';
              mainMessage = 'Environment destruction initiated';
            } else {
              statusEmoji = 'ğŸš€';
              statusText = 'Deploying';
              mainMessage = 'Deployment pipeline started';
            }
            
            const comment = `## ${statusEmoji} Staging Environment Status
            
            **Environment:** pr-${pr_number}
            **Status:** ${statusText}
            **Deployment ID:** ${deployment_id}
            **Commit:** \`${deployment_sha.substring(0, 8)}\`
            **Started:** ${new Date().toISOString()}
            
            ### ğŸ“Š Current Status
            ${mainMessage}
            
            <details>
            <summary>ğŸ“‹ Deployment Progress</summary>
            
            | Stage | Status | Details | Time |
            |-------|--------|---------|------|
            | ğŸ¯ **Initialization** | âœ… Complete | Environment check passed | ${new Date().toISOString()} |
            | ğŸ“¦ **Backend Build** | â³ Pending | - | - |
            | ğŸ“¦ **Frontend Build** | â³ Pending | - | - |
            | ğŸš€ **Deployment** | â³ Pending | - | - |
            | ğŸ—„ï¸ **Database Setup** | â³ Pending | - | - |
            | ğŸ§ª **Testing** | â³ Pending | - | - |
            
            </details>
            
            <details>
            <summary>ğŸ“ Activity Log</summary>
            
            \`\`\`
            [${new Date().toISOString()}] Deployment initialized
            [${new Date().toISOString()}] Checking environment eligibility...
            [${new Date().toISOString()}] ${mainMessage}
            \`\`\`
            
            </details>
            
            ---
            *Last updated: ${new Date().toISOString()} | Run: [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Staging Environment Status')
            );
            
            let comment_id;
            if (botComment) {
              // Update existing comment
              const { data: updated } = await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
              comment_id = updated.id;
              console.log(`Updated existing comment: ${comment_id}`);
            } else {
              // Create new comment
              const { data: created } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                body: comment
              });
              comment_id = created.id;
              console.log(`Created new comment: ${comment_id}`);
            }
            
            // Output comment ID for other jobs to use
            core.setOutput('comment_id', comment_id);
            return comment_id;

  # Monitor for new commits during deployment
  commit-monitor:
    name: Monitor for New Commits
    needs: initialize-deployment
    if: needs.initialize-deployment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      new_commit_detected: ${{ steps.monitor.outputs.new_commit_detected }}
    steps:
      - name: Monitor for new commits
        id: monitor
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          INITIAL_SHA="${{ env.DEPLOYMENT_SHA }}"
          
          echo "Monitoring PR #${PR_NUMBER} for new commits"
          echo "Initial SHA: ${INITIAL_SHA}"
          
          # Check every 30 seconds for 5 minutes
          for i in {1..10}; do
            # Get current PR head SHA
            CURRENT_SHA=$(gh pr view ${PR_NUMBER} --json headRefOid -q .headRefOid)
            
            if [[ "$CURRENT_SHA" != "$INITIAL_SHA" ]]; then
              echo "âš ï¸ New commit detected: ${CURRENT_SHA}"
              echo "new_commit_detected=true" >> $GITHUB_OUTPUT
              echo "new_sha=${CURRENT_SHA}" >> $GITHUB_OUTPUT
              
              # Update comment about new commit
              if [[ -n "${{ needs.initialize-deployment.outputs.comment_id }}" ]]; then
                gh api repos/${{ github.repository }}/issues/comments/${{ needs.initialize-deployment.outputs.comment_id }} \
                  --method PATCH \
                  --field body="## âš ï¸ Deployment Cancelled
                  
                  **Reason:** New commit detected
                  **New SHA:** \`${CURRENT_SHA:0:8}\`
                  **Previous SHA:** \`${INITIAL_SHA:0:8}\`
                  
                  This deployment has been cancelled because a new commit was pushed to the PR.
                  A new deployment will start automatically for the latest commit.
                  
                  ---
                  *Cancelled at: $(date -u +"%Y-%m-%dT%H:%M:%SZ")*"
              fi
              
              exit 0
            fi
            
            sleep 30
          done
          
          echo "new_commit_detected=false" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

  

  build-backend:
    name: Build Backend Container
    needs: [initialize-deployment, commit-monitor]
    if: |
      needs.initialize-deployment.outputs.should_deploy == 'true' && 
      needs.commit-monitor.outputs.new_commit_detected != 'true' &&
      (github.event.pull_request.head.sha == env.DEPLOYMENT_SHA || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      backend_image: ${{ steps.backend-build.outputs.backend_image }}
      build_duration: ${{ steps.timing.outputs.duration }}
    steps:
      - name: Start timing
        id: timing
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Update comment - Backend build started
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update the backend build status in the progress table
            let body = currentComment.body;
            body = body.replace(
              /\| ğŸ“¦ \*\*Backend Build\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸ“¦ **Backend Build** | ğŸ”„ In Progress | Building container image... | ${new Date().toISOString()} |`
            );
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Backend build started`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0

      - name: Cache gcloud SDK
        uses: actions/cache@v4
        with:
          path: |
            ~/.config/gcloud
            ~/google-cloud-sdk
          key: gcloud-sdk-${{ runner.os }}-${{ hashFiles('.github/workflows/staging-environment-enhanced.yml') }}
          restore-keys: |
            gcloud-sdk-${{ runner.os }}-

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          skip_install: false

      - name: Configure Docker for GCP
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Check for backend changes
        id: backend-changes
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          CURRENT_SHA=${{ github.sha }}
          
          # Try to get the last successful build SHA from cache
          CACHE_KEY="backend-build-cache-pr-${PR_NUMBER}"
          LAST_BUILD_SHA=""
          LAST_BUILD_IMAGE=""
          
          # Check if we have a cached build record in GCS
          if gsutil -q stat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null; then
            CACHE_DATA=$(gsutil cat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null || echo "{}")
            LAST_BUILD_SHA=$(echo "$CACHE_DATA" | jq -r '.sha // ""')
            LAST_BUILD_IMAGE=$(echo "$CACHE_DATA" | jq -r '.image // ""')
            echo "Found cached build: SHA=$LAST_BUILD_SHA"
          fi
          
          # Check if files changed
          CHANGED="true"
          CHANGED_FILES=""
          
          if [[ -n "$LAST_BUILD_SHA" ]] && [[ "$LAST_BUILD_SHA" != "null" ]]; then
            if git rev-parse "$LAST_BUILD_SHA" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only "$LAST_BUILD_SHA" HEAD 2>/dev/null || echo "force-rebuild")
            else
              CHANGED_FILES="force-rebuild"
            fi
          else
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }} --depth=50
              MERGE_BASE=$(git merge-base origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              
              if [[ -n "$MERGE_BASE" ]]; then
                CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              fi
            else
              CHANGED_FILES="force-rebuild"
            fi
          fi
          
          # Check for backend-related changes
          if [[ "$CHANGED_FILES" == "force-rebuild" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          elif [[ -z "$CHANGED_FILES" ]]; then
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
            else
              echo "changed=true" >> $GITHUB_OUTPUT
            fi
          elif echo "$CHANGED_FILES" | grep -E '^(app/|requirements\.txt|Dockerfile\.backend|alembic/|pyproject\.toml|poetry\.lock)' > /dev/null 2>&1; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
            else
              echo "changed=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Build and push backend container
        id: backend-build
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          IMAGE_TAG="pr-${PR_NUMBER}-${{ github.sha }}"
          IMAGE_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/backend:${IMAGE_TAG}"
          
          # Check if we should use cached image
          if [[ "${{ steps.backend-changes.outputs.changed }}" == "false" ]]; then
            CACHED_IMAGE="${{ steps.backend-changes.outputs.cached_image }}"
            if [[ -n "$CACHED_IMAGE" ]] && [[ "$CACHED_IMAGE" != "null" ]]; then
              echo "Using cached backend image: $CACHED_IMAGE"
              echo "backend_image=$CACHED_IMAGE" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Build new image
          echo "Building new backend image..."
          DOCKER_BUILDKIT=1 timeout 600 docker build \
            --progress=plain \
            --network=host \
            -t $IMAGE_URL \
            -f Dockerfile.backend . || {
            echo "Docker build failed"
            exit 1
          }
          
          # Push with timeout
          timeout 300 docker push $IMAGE_URL || {
            echo "Docker push failed"
            exit 1
          }
          
          echo "backend_image=$IMAGE_URL" >> $GITHUB_OUTPUT
          
          # Update build cache
          CACHE_KEY="backend-build-cache-pr-${PR_NUMBER}"
          echo '{"sha": "'${{ github.sha }}'", "image": "'$IMAGE_URL'", "timestamp": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"}' | \
            gsutil cp - "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json"

      - name: Calculate duration
        if: always()
        run: |
          END_TIME=$(date +%s)
          START_TIME=${{ steps.timing.outputs.start_time }}
          DURATION=$((END_TIME - START_TIME))
          echo "duration=$DURATION" >> $GITHUB_OUTPUT

      - name: Update comment - Backend build complete
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            const success = '${{ job.status }}' === 'success';
            const duration = '${{ steps.timing.outputs.duration }}' || '0';
            const image = '${{ steps.backend-build.outputs.backend_image }}' || 'N/A';
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update the backend build status
            let body = currentComment.body;
            const status = success ? 'âœ… Complete' : 'âŒ Failed';
            const details = success ? `Image: \`${image.split('/').pop()}\`` : 'Check logs for details';
            
            body = body.replace(
              /\| ğŸ“¦ \*\*Backend Build\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸ“¦ **Backend Build** | ${status} | ${details} (${duration}s) | ${new Date().toISOString()} |`
            );
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const result = success ? 'completed successfully' : 'failed';
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Backend build ${result} (${duration}s)`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            // Update overall status if failed
            if (!success) {
              body = body.replace(/## .+ Staging Environment Status/, '## âŒ Staging Environment Status');
              body = body.replace(/\*\*Status:\*\* .+/, '**Status:** Failed - Backend build error');
            }
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

  build-frontend:
    name: Build Frontend Container
    needs: [initialize-deployment, commit-monitor]
    if: |
      needs.initialize-deployment.outputs.should_deploy == 'true' && 
      needs.commit-monitor.outputs.new_commit_detected != 'true' &&
      (github.event.pull_request.head.sha == env.DEPLOYMENT_SHA || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      frontend_image: ${{ steps.frontend-build.outputs.frontend_image }}
      build_duration: ${{ steps.timing.outputs.duration }}
    steps:
      - name: Start timing
        id: timing
        run: echo "start_time=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Update comment - Frontend build started
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update the frontend build status
            let body = currentComment.body;
            body = body.replace(
              /\| ğŸ“¦ \*\*Frontend Build\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸ“¦ **Frontend Build** | ğŸ”„ In Progress | Building container image... | ${new Date().toISOString()} |`
            );
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Frontend build started`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0

      - name: Cache gcloud SDK
        uses: actions/cache@v4
        with:
          path: |
            ~/.config/gcloud
            ~/google-cloud-sdk
          key: gcloud-sdk-${{ runner.os }}-${{ hashFiles('.github/workflows/staging-environment-enhanced.yml') }}
          restore-keys: |
            gcloud-sdk-${{ runner.os }}-

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          skip_install: false

      - name: Configure Docker for GCP
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Check for frontend changes
        id: frontend-changes
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          CURRENT_SHA=${{ github.sha }}
          
          # Similar logic to backend changes check
          CACHE_KEY="frontend-build-cache-pr-${PR_NUMBER}"
          LAST_BUILD_SHA=""
          LAST_BUILD_IMAGE=""
          
          if gsutil -q stat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null; then
            CACHE_DATA=$(gsutil cat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null || echo "{}")
            LAST_BUILD_SHA=$(echo "$CACHE_DATA" | jq -r '.sha // ""')
            LAST_BUILD_IMAGE=$(echo "$CACHE_DATA" | jq -r '.image // ""')
          fi
          
          # Check for changes
          CHANGED="true"
          CHANGED_FILES=""
          
          if [[ -n "$LAST_BUILD_SHA" ]] && [[ "$LAST_BUILD_SHA" != "null" ]]; then
            if git rev-parse "$LAST_BUILD_SHA" >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only "$LAST_BUILD_SHA" HEAD 2>/dev/null || echo "force-rebuild")
            else
              CHANGED_FILES="force-rebuild"
            fi
          else
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }} --depth=50 2>/dev/null || true
              MERGE_BASE=$(git merge-base origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              
              if [[ -n "$MERGE_BASE" ]]; then
                CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              fi
            else
              CHANGED_FILES="force-rebuild"
            fi
          fi
          
          # Check for frontend-related changes
          if [[ "$CHANGED_FILES" == "force-rebuild" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          elif [[ -z "$CHANGED_FILES" ]]; then
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
            else
              echo "changed=true" >> $GITHUB_OUTPUT
            fi
          elif echo "$CHANGED_FILES" | grep -E '^frontend/' > /dev/null 2>&1; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
            else
              echo "changed=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Build and push frontend container
        id: frontend-build
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          IMAGE_TAG="pr-${PR_NUMBER}-${{ github.sha }}"
          IMAGE_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/frontend:${IMAGE_TAG}"
          
          # Check if we should use cached image
          if [[ "${{ steps.frontend-changes.outputs.changed }}" == "false" ]]; then
            CACHED_IMAGE="${{ steps.frontend-changes.outputs.cached_image }}"
            if [[ -n "$CACHED_IMAGE" ]] && [[ "$CACHED_IMAGE" != "null" ]]; then
              echo "Using cached frontend image: $CACHED_IMAGE"
              echo "frontend_image=$CACHED_IMAGE" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Build new image
          echo "Building new frontend image..."
          
          if [[ -f "frontend/Dockerfile.frontend" ]]; then
            cd frontend
            DOCKER_BUILDKIT=1 timeout 600 docker build \
              --progress=plain \
              --network=host \
              -t $IMAGE_URL \
              -f Dockerfile.frontend \
              --build-arg NEXT_PUBLIC_API_URL=https://pr-${PR_NUMBER}-api.${{ env.STAGING_DOMAIN }} . || {
              echo "Frontend Docker build failed"
              exit 1
            }
            cd ..
          elif [[ -f "Dockerfile.frontend" ]]; then
            DOCKER_BUILDKIT=1 timeout 600 docker build \
              --progress=plain \
              --network=host \
              -t $IMAGE_URL \
              -f Dockerfile.frontend \
              --build-arg NEXT_PUBLIC_API_URL=https://pr-${PR_NUMBER}-api.${{ env.STAGING_DOMAIN }} . || {
              echo "Frontend Docker build failed"
              exit 1
            }
          else
            echo "Error: Dockerfile.frontend not found"
            exit 1
          fi
          
          # Push with timeout
          timeout 300 docker push $IMAGE_URL || {
            echo "Docker push failed"
            exit 1
          }
          
          echo "frontend_image=$IMAGE_URL" >> $GITHUB_OUTPUT
          
          # Update build cache
          CACHE_KEY="frontend-build-cache-pr-${PR_NUMBER}"
          echo '{"sha": "'${{ github.sha }}'", "image": "'$IMAGE_URL'", "timestamp": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"}' | \
            gsutil cp - "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json"

      - name: Calculate duration
        if: always()
        run: |
          END_TIME=$(date +%s)
          START_TIME=${{ steps.timing.outputs.start_time }}
          DURATION=$((END_TIME - START_TIME))
          echo "duration=$DURATION" >> $GITHUB_OUTPUT

      - name: Update comment - Frontend build complete
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            const success = '${{ job.status }}' === 'success';
            const duration = '${{ steps.timing.outputs.duration }}' || '0';
            const image = '${{ steps.frontend-build.outputs.frontend_image }}' || 'N/A';
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update the frontend build status
            let body = currentComment.body;
            const status = success ? 'âœ… Complete' : 'âŒ Failed';
            const details = success ? `Image: \`${image.split('/').pop()}\`` : 'Check logs for details';
            
            body = body.replace(
              /\| ğŸ“¦ \*\*Frontend Build\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸ“¦ **Frontend Build** | ${status} | ${details} (${duration}s) | ${new Date().toISOString()} |`
            );
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const result = success ? 'completed successfully' : 'failed';
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Frontend build ${result} (${duration}s)`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            // Update overall status if failed
            if (!success) {
              body = body.replace(/## .+ Staging Environment Status/, '## âŒ Staging Environment Status');
              body = body.replace(/\*\*Status:\*\* .+/, '**Status:** Failed - Frontend build error');
            }
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

  deploy-staging:
    name: Deploy Staging Environment
    needs: [initialize-deployment, build-backend, build-frontend, commit-monitor]
    if: |
      needs.initialize-deployment.outputs.should_deploy == 'true' && 
      needs.commit-monitor.outputs.new_commit_detected != 'true' &&
      (github.event.pull_request.head.sha == env.DEPLOYMENT_SHA || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment:
      name: staging-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}
      url: https://pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}.${{ env.STAGING_DOMAIN }}
    outputs:
      frontend_url: ${{ steps.terraform.outputs.frontend_url }}
      backend_url: ${{ steps.terraform.outputs.backend_url }}
      database_name: ${{ steps.terraform.outputs.database_name }}
    
    steps:
      - name: Update comment - Deployment started
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update deployment status
            let body = currentComment.body;
            body = body.replace(
              /\| ğŸš€ \*\*Deployment\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸš€ **Deployment** | ğŸ”„ In Progress | Provisioning infrastructure... | ${new Date().toISOString()} |`
            );
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Infrastructure deployment started`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

      - name: Check for new commits before proceeding
        run: |
          if [[ "${{ needs.commit-monitor.outputs.new_commit_detected }}" == "true" ]]; then
            echo "New commit detected, cancelling deployment"
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0

      - name: Cache gcloud SDK
        uses: actions/cache@v4
        with:
          path: |
            ~/.config/gcloud
            ~/google-cloud-sdk
          key: gcloud-sdk-${{ runner.os }}-${{ hashFiles('.github/workflows/staging-environment-enhanced.yml') }}
          restore-keys: |
            gcloud-sdk-${{ runner.os }}-

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          skip_install: false

      - name: Configure OAuth for PR Environment
        id: oauth
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          echo "PR_NUMBER=${PR_NUMBER}" >> $GITHUB_ENV
          echo "GOOGLE_OAUTH_CLIENT_ID_STAGING=${{ secrets.GOOGLE_OAUTH_CLIENT_ID_STAGING }}" >> $GITHUB_ENV
          echo "GOOGLE_OAUTH_CLIENT_SECRET_STAGING=${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET_STAGING }}" >> $GITHUB_ENV
          echo "USE_OAUTH_PROXY=true" >> $GITHUB_ENV
          echo "OAUTH_PROXY_URL=https://auth.staging.netrasystems.ai" >> $GITHUB_ENV
          
          echo "frontend_url=https://pr-${PR_NUMBER}.${{ env.STAGING_DOMAIN }}" >> $GITHUB_OUTPUT
          echo "api_url=https://pr-${PR_NUMBER}-api.${{ env.STAGING_DOMAIN }}" >> $GITHUB_OUTPUT

      - name: Load staging configuration
        id: config
        run: |
          PROJECT_ID_NUMERICAL_STAGING=$(gcloud projects describe ${{ env.GCP_PROJECT_ID }} --format="value(projectNumber)")
          echo "project_id_numerical=$PROJECT_ID_NUMERICAL_STAGING" >> $GITHUB_OUTPUT
          
          if [ -f .github/staging.yml ]; then
            TEST_LEVEL=$(yq e '.default_test_level // "integration"' .github/staging.yml)
            MAX_INSTANCES=$(yq e '.resource_limits.compute.max_instances // 3' .github/staging.yml)
          else
            TEST_LEVEL="integration"
            MAX_INSTANCES="3"
          fi
          
          echo "test_level=$TEST_LEVEL" >> $GITHUB_OUTPUT
          echo "max_instances=$MAX_INSTANCES" >> $GITHUB_OUTPUT

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Handle Terraform State Lock
        id: handle-lock
        working-directory: ./terraform/staging
        timeout-minutes: 2
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          LOCK_FILE="gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${PR_NUMBER}/default.tflock"
          
          check_and_handle_lock() {
            if ! gsutil stat "$LOCK_FILE" 2>/dev/null; then
              echo "No existing lock file found"
              return 0
            fi
            
            LOCK_INFO=$(gsutil cat "$LOCK_FILE" 2>/dev/null || echo "{}")
            LOCK_ID=$(echo "$LOCK_INFO" | jq -r '.ID // "unknown"')
            LOCK_HOLDER=$(echo "$LOCK_INFO" | jq -r '.Who // "unknown"')
            LOCK_CREATED=$(echo "$LOCK_INFO" | jq -r '.Created // ""')
            
            if [[ -n "$LOCK_CREATED" ]] && [[ "$LOCK_CREATED" != "null" ]]; then
              LOCK_TIMESTAMP=$(date -d "${LOCK_CREATED}" +%s 2>/dev/null || echo "0")
              CURRENT_TIME=$(date +%s)
              AGE_MINUTES=$(( (CURRENT_TIME - LOCK_TIMESTAMP) / 60 ))
              
              if echo "$LOCK_HOLDER" | grep -q "runner@"; then
                if [ $AGE_MINUTES -gt 15 ]; then
                  echo "Found stale lock from GitHub Actions runner (${AGE_MINUTES} minutes old)"
                  gsutil rm "$LOCK_FILE" 2>/dev/null || true
                  sleep 2
                  return 0
                else
                  echo "Active lock found (${AGE_MINUTES} minutes old)"
                  return 1
                fi
              else
                if [ $AGE_MINUTES -gt 30 ]; then
                  echo "Found stale lock (${AGE_MINUTES} minutes old)"
                  gsutil rm "$LOCK_FILE" 2>/dev/null || true
                  sleep 2
                  return 0
                else
                  echo "Active lock found (${AGE_MINUTES} minutes old)"
                  return 1
                fi
              fi
            else
              LOCK_MOD_TIME=$(gsutil stat "$LOCK_FILE" | grep "Creation time:" | cut -d':' -f2- | xargs -I {} date -d "{}" +%s 2>/dev/null || echo "0")
              if [ "$LOCK_MOD_TIME" -ne "0" ]; then
                CURRENT_TIME=$(date +%s)
                AGE_MINUTES=$(( (CURRENT_TIME - LOCK_MOD_TIME) / 60 ))
                
                if [ $AGE_MINUTES -gt 15 ]; then
                  echo "Found stale lock based on file modification time"
                  gsutil rm "$LOCK_FILE" 2>/dev/null || true
                  sleep 2
                  return 0
                fi
              fi
              
              echo "Unable to determine lock age, assuming active"
              return 1
            fi
          }
          
          check_and_handle_lock
          RESULT=$?
          
          if [ $RESULT -eq 0 ]; then
            echo "lock_cleared=true" >> $GITHUB_OUTPUT
          else
            echo "lock_cleared=false" >> $GITHUB_OUTPUT
            echo "::warning::Terraform state may be locked by another operation."
          fi

      - name: Terraform Init with Retry
        working-directory: ./terraform/staging
        timeout-minutes: 5
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          terraform_init_with_retry() {
            local max_attempts=3
            local attempt=1
            local wait_time=5
            
            while [ $attempt -le $max_attempts ]; do
              echo "Terraform init attempt $attempt of $max_attempts..."
              
              if terraform init \
                -backend-config="bucket=${{ env.GCP_PROJECT_ID }}-terraform-state" \
                -backend-config="prefix=staging/pr-${PR_NUMBER}" \
                -lock-timeout=120s \
                -upgrade=false \
                -reconfigure=false; then
                echo "Terraform init successful"
                return 0
              else
                EXIT_CODE=$?
                echo "Terraform init failed with exit code $EXIT_CODE"
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "Failed after $max_attempts attempts"
                  return $EXIT_CODE
                fi
                
                echo "Waiting ${wait_time} seconds before retry..."
                sleep $wait_time
                wait_time=$((wait_time * 2))
                attempt=$((attempt + 1))
                
                if [ $attempt -eq 2 ] && [ "${{ steps.handle-lock.outputs.lock_cleared }}" == "false" ]; then
                  echo "Attempting to force unlock before retry..."
                  LOCK_FILE="gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${PR_NUMBER}/default.tflock"
                  gsutil rm "$LOCK_FILE" 2>/dev/null || true
                  sleep 3
                fi
              fi
            done
            
            return 1
          }
          
          terraform_init_with_retry

      - name: Terraform Plan with Retry
        working-directory: ./terraform/staging
        timeout-minutes: 8
        env:
          TF_VAR_project_id: ${{ env.GCP_PROJECT_ID }}
          TF_VAR_project_id_numerical: ${{ steps.config.outputs.project_id_numerical }}
          TF_VAR_region: ${{ env.GCP_REGION }}
          TF_VAR_pr_number: ${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          TF_VAR_backend_image: ${{ needs.build-backend.outputs.backend_image }}
          TF_VAR_frontend_image: ${{ needs.build-frontend.outputs.frontend_image }}
          TF_VAR_max_instances: ${{ steps.config.outputs.max_instances }}
          TF_VAR_domain: ${{ env.STAGING_DOMAIN }}
          TF_VAR_postgres_password: ${{ secrets.STAGING_DB_PASSWORD }}
          TF_VAR_clickhouse_password: ${{ secrets.CLICKHOUSE_PASSWORD || 'placeholder_password' }}
        run: |
          terraform_plan_with_retry() {
            local max_attempts=3
            local attempt=1
            local wait_time=10
            
            while [ $attempt -le $max_attempts ]; do
              echo "Terraform plan attempt $attempt of $max_attempts..."
              
              cat > terraform.tfvars << 'EOF'
          project_id = "${{ env.GCP_PROJECT_ID }}"
          project_id_numerical = "${{ steps.config.outputs.project_id_numerical }}"
          region = "${{ env.GCP_REGION }}"
          pr_number = "${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          backend_image = "${{ needs.build-backend.outputs.backend_image }}"
          frontend_image = "${{ needs.build-frontend.outputs.frontend_image }}"
          max_instances = ${{ steps.config.outputs.max_instances }}
          domain = "${{ env.STAGING_DOMAIN }}"
          EOF
              
              echo "postgres_password = \"${TF_VAR_postgres_password}\"" >> terraform.tfvars
              echo "clickhouse_password = \"${TF_VAR_clickhouse_password}\"" >> terraform.tfvars
              
              chmod 600 terraform.tfvars
              
              if terraform plan \
                -var-file=terraform.tfvars \
                -lock-timeout=180s \
                -out=tfplan \
                -input=false; then
                echo "Terraform plan successful"
                rm -f terraform.tfvars
                return 0
              else
                EXIT_CODE=$?
                rm -f terraform.tfvars
                echo "Terraform plan failed with exit code $EXIT_CODE"
                
                if terraform plan -var-file=terraform.tfvars -lock-timeout=1s -out=tfplan 2>&1 | grep -q "lock"; then
                  echo "Lock-related error detected"
                  
                  if [ $attempt -lt $max_attempts ]; then
                    PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
                    LOCK_FILE="gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${PR_NUMBER}/default.tflock"
                    
                    echo "Checking lock status..."
                    if gsutil stat "$LOCK_FILE" 2>/dev/null; then
                      echo "Lock file exists, attempting to remove..."
                      gsutil rm "$LOCK_FILE" 2>/dev/null || true
                      sleep 5
                    fi
                  fi
                fi
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "Failed after $max_attempts attempts"
                  return $EXIT_CODE
                fi
                
                echo "Waiting ${wait_time} seconds before retry..."
                sleep $wait_time
                wait_time=$((wait_time * 2))
                attempt=$((attempt + 1))
              fi
            done
            
            return 1
          }
          
          terraform_plan_with_retry

      - name: Terraform Apply with Retry
        working-directory: ./terraform/staging
        id: terraform
        timeout-minutes: 25
        run: |
          terraform_apply_with_retry() {
            local max_attempts=2
            local attempt=1
            local wait_time=15
            
            while [ $attempt -le $max_attempts ]; do
              echo "Terraform apply attempt $attempt of $max_attempts..."
              
              if timeout 1200 terraform apply \
                -auto-approve \
                -lock-timeout=180s \
                -input=false \
                tfplan; then
                echo "Terraform apply successful"
                return 0
              else
                EXIT_CODE=$?
                echo "Terraform apply failed with exit code $EXIT_CODE"
                
                echo "Current Terraform state:"
                terraform show -no-color 2>/dev/null | head -100 || true
                
                if [ $attempt -eq $max_attempts ]; then
                  echo "Failed after $max_attempts attempts"
                  
                  echo "Attempting to refresh state..."
                  terraform refresh -lock-timeout=60s 2>/dev/null || true
                  
                  return $EXIT_CODE
                fi
                
                PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
                LOCK_FILE="gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${PR_NUMBER}/default.tflock"
                
                echo "Checking for stale locks..."
                if gsutil stat "$LOCK_FILE" 2>/dev/null; then
                  echo "Lock file found, checking age..."
                  LOCK_INFO=$(gsutil cat "$LOCK_FILE" 2>/dev/null || echo "{}")
                  LOCK_CREATED=$(echo "$LOCK_INFO" | jq -r '.Created // ""')
                  
                  if [[ -n "$LOCK_CREATED" ]] && [[ "$LOCK_CREATED" != "null" ]]; then
                    LOCK_TIMESTAMP=$(date -d "${LOCK_CREATED}" +%s 2>/dev/null || echo "0")
                    CURRENT_TIME=$(date +%s)
                    AGE_MINUTES=$(( (CURRENT_TIME - LOCK_TIMESTAMP) / 60 ))
                    
                    if [ $AGE_MINUTES -gt 10 ]; then
                      echo "Removing stale lock (${AGE_MINUTES} minutes old)..."
                      gsutil rm "$LOCK_FILE" 2>/dev/null || true
                      sleep 5
                    fi
                  fi
                fi
                
                echo "Waiting ${wait_time} seconds before retry..."
                sleep $wait_time
                wait_time=$((wait_time * 2))
                attempt=$((attempt + 1))
              fi
            done
            
            return 1
          }
          
          terraform_apply_with_retry
          APPLY_RESULT=$?
          
          echo "Capturing Terraform outputs..."
          BACKEND_URL=$(terraform output -raw backend_url 2>/dev/null || echo "")
          FRONTEND_URL=$(terraform output -raw frontend_url 2>/dev/null || echo "")
          DATABASE_NAME=$(terraform output -raw database_name 2>/dev/null || echo "")
          
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "database_name=$DATABASE_NAME" >> $GITHUB_OUTPUT
          
          echo "DB_NAME=$DATABASE_NAME" >> $GITHUB_ENV
          echo "DB_USER=user_pr_${{ github.event.pull_request.number || github.event.inputs.pr_number }}" >> $GITHUB_ENV
          
          exit $APPLY_RESULT

      - name: Update comment - Deployment complete
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            const success = '${{ job.status }}' === 'success';
            const frontend_url = '${{ steps.terraform.outputs.frontend_url }}';
            const backend_url = '${{ steps.terraform.outputs.backend_url }}';
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update deployment status
            let body = currentComment.body;
            const status = success ? 'âœ… Complete' : 'âŒ Failed';
            const details = success ? 'Infrastructure provisioned' : 'Check logs for details';
            
            body = body.replace(
              /\| ğŸš€ \*\*Deployment\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸš€ **Deployment** | ${status} | ${details} | ${new Date().toISOString()} |`
            );
            
            // Add URLs if successful
            if (success && frontend_url && backend_url) {
              // Check if URLs section exists, if not add it
              if (!body.includes('### ğŸ”— Access URLs')) {
                const urlSection = `\n### ğŸ”— Access URLs\n- **Frontend:** ${frontend_url}\n- **API:** ${backend_url}/docs\n- **Health:** ${backend_url}/health\n`;
                // Insert after Current Status section
                body = body.replace(/### ğŸ“Š Current Status[\s\S]*?\n\n/, (match) => match + urlSection);
              } else {
                // Update existing URLs
                body = body.replace(/### ğŸ”— Access URLs[\s\S]*?\n\n/, 
                  `### ğŸ”— Access URLs\n- **Frontend:** ${frontend_url}\n- **API:** ${backend_url}/docs\n- **Health:** ${backend_url}/health\n\n`);
              }
            }
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const result = success ? 'completed successfully' : 'failed';
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Infrastructure deployment ${result}`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            // Update overall status if failed
            if (!success) {
              body = body.replace(/## .+ Staging Environment Status/, '## âŒ Staging Environment Status');
              body = body.replace(/\*\*Status:\*\* .+/, '**Status:** Failed - Deployment error');
            }
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

      - name: Run database migrations
        id: migrations
        timeout-minutes: 5
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Update comment - Database setup started
          if [[ -n "${{ needs.initialize-deployment.outputs.comment_id }}" ]]; then
            gh api repos/${{ github.repository }}/issues/comments/${{ needs.initialize-deployment.outputs.comment_id }} \
              --method GET | jq -r '.body' > comment.txt
            
            # Update database status to in progress
            sed -i 's/| ğŸ—„ï¸ \*\*Database Setup\*\* | .* | .* | .* |/| ğŸ—„ï¸ **Database Setup** | ğŸ”„ In Progress | Running migrations... | '$(date -u +"%Y-%m-%dT%H:%M:%SZ")' |/' comment.txt
            
            # Add to activity log
            echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] Database migrations started" >> activity.log
            
            gh api repos/${{ github.repository }}/issues/comments/${{ needs.initialize-deployment.outputs.comment_id }} \
              --method PATCH --field body="$(cat comment.txt)"
          fi
          
          SQL_INSTANCE_CONNECTION=$(cd terraform/staging && terraform output -raw -state=terraform.tfstate sql_instance_connection 2>/dev/null || echo "")
          
          if [ -z "$SQL_INSTANCE_CONNECTION" ]; then
            SQL_INSTANCE_CONNECTION="${{ env.GCP_PROJECT_ID }}:${{ env.GCP_REGION }}:staging-shared-postgres"
          fi
          
          export DATABASE_URL="postgresql://user_pr_${PR_NUMBER}:${{ secrets.STAGING_DB_PASSWORD }}@/netra_pr_${PR_NUMBER}?host=/cloudsql/${SQL_INSTANCE_CONNECTION}"
          
          if ! command -v cloud_sql_proxy &> /dev/null; then
            echo "Installing Cloud SQL Proxy..."
            wget -q https://dl.google.com/cloudsql/cloud_sql_proxy.linux.amd64 -O cloud_sql_proxy
            chmod +x cloud_sql_proxy
            sudo mv cloud_sql_proxy /usr/local/bin/
          fi
          
          cloud_sql_proxy -instances=${SQL_INSTANCE_CONNECTION}=tcp:5432 &
          PROXY_PID=$!
          sleep 5
          
          export DATABASE_URL="postgresql://user_pr_${PR_NUMBER}:${{ secrets.STAGING_DB_PASSWORD }}@localhost:5432/netra_pr_${PR_NUMBER}"
          
          echo "Waiting for database to be ready..."
          for i in {1..24}; do
            if pg_isready -h localhost -p 5432 -U user_pr_${PR_NUMBER} 2>/dev/null; then
              echo "Database is ready!"
              break
            fi
            if [ $i -eq 24 ]; then
              echo "Database did not become ready in time"
              kill $PROXY_PID 2>/dev/null || true
              exit 1
            fi
            echo "Attempt $i/24: Database not ready, waiting 5 seconds..."
            sleep 5
          done
          
          cd app
          timeout 180 alembic upgrade head || {
            echo "Database migrations failed"
            kill $PROXY_PID 2>/dev/null || true
            exit 1
          }
          
          kill $PROXY_PID 2>/dev/null || true
          echo "migration_status=success" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Seed test data
        id: seeding
        timeout-minutes: 3
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          REDIS_DB_INDEX=$((PR_NUMBER % 16))
          
          SQL_INSTANCE_CONNECTION=$(cd terraform/staging && terraform output -raw -state=terraform.tfstate sql_instance_connection 2>/dev/null || echo "")
          
          if [ -z "$SQL_INSTANCE_CONNECTION" ]; then
            SQL_INSTANCE_CONNECTION="${{ env.GCP_PROJECT_ID }}:${{ env.GCP_REGION }}:staging-shared-postgres"
          fi
          
          cloud_sql_proxy -instances=${SQL_INSTANCE_CONNECTION}=tcp:5432 &
          PROXY_PID=$!
          sleep 5
          
          export DATABASE_URL="postgresql://user_pr_${PR_NUMBER}:${{ secrets.STAGING_DB_PASSWORD }}@localhost:5432/netra_pr_${PR_NUMBER}"
          export REDIS_URL="redis://10.0.0.2:6379/${REDIS_DB_INDEX}"
          export CLICKHOUSE_PASSWORD="${{ secrets.CLICKHOUSE_PASSWORD }}"
          export CLICKHOUSE_URL="clickhouse://default:${{ secrets.CLICKHOUSE_PASSWORD }}@xedvrr4c3r.us-central1.gcp.clickhouse.cloud:8443/default?secure=1"
          
          if [ -f "scripts/seed_staging_data.py" ]; then
            timeout 150 python scripts/seed_staging_data.py \
              --pr-number "${PR_NUMBER}" || {
              echo "Data seeding failed"
              kill $PROXY_PID 2>/dev/null || true
              exit 1
            }
          else
            echo "Seed script not found, skipping data seeding"
          fi
          
          kill $PROXY_PID 2>/dev/null || true
          echo "seeding_status=success" >> $GITHUB_OUTPUT

      - name: Update comment - Database complete
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            const migration_success = '${{ steps.migrations.outputs.migration_status }}' === 'success';
            const seeding_success = '${{ steps.seeding.outputs.seeding_status }}' === 'success';
            const overall_success = migration_success && seeding_success;
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update database status
            let body = currentComment.body;
            const status = overall_success ? 'âœ… Complete' : 'âŒ Failed';
            const details = overall_success ? 'Migrations and seeding complete' : 
              (!migration_success ? 'Migration failed' : 'Seeding failed');
            
            body = body.replace(
              /\| ğŸ—„ï¸ \*\*Database Setup\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸ—„ï¸ **Database Setup** | ${status} | ${details} | ${new Date().toISOString()} |`
            );
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const result = overall_success ? 'completed successfully' : 'failed';
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Database setup ${result}`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            // Update overall status if failed
            if (!overall_success) {
              body = body.replace(/## .+ Staging Environment Status/, '## âŒ Staging Environment Status');
              body = body.replace(/\*\*Status:\*\* .+/, '**Status:** Failed - Database setup error');
            }
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

      - name: Wait for services to be healthy
        timeout-minutes: 10
        run: |
          STAGING_URL="${{ steps.terraform.outputs.frontend_url }}"
          API_URL="${{ steps.terraform.outputs.backend_url }}"
          
          echo "Waiting for frontend at $STAGING_URL..."
          for i in {1..30}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$STAGING_URL" 2>/dev/null || echo "000")
            if [[ "$HTTP_CODE" == "200" ]] || [[ "$HTTP_CODE" == "301" ]] || [[ "$HTTP_CODE" == "302" ]]; then
              echo "Frontend is ready! (HTTP $HTTP_CODE)"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Frontend did not become ready in time (last HTTP code: $HTTP_CODE)"
              gcloud run services describe frontend-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }} \
                --region=${{ env.GCP_REGION }} --format="value(status.conditions[0].message)" || true
            fi
            echo "Attempt $i/30: Frontend not ready yet (HTTP $HTTP_CODE)..."
            sleep 10
          done
          
          echo "Waiting for API at $API_URL/health..."
          for i in {1..40}; do
            HEALTH_RESPONSE=$(curl -s --max-time 10 "$API_URL/health/" 2>/dev/null || echo "")
            if echo "$HEALTH_RESPONSE" | grep -q "healthy\|ok\|ready"; then
              echo "API is ready!"
              break
            fi
            if [ $i -eq 40 ]; then
              echo "API health check timed out, but continuing anyway"
              echo "Last health response: $HEALTH_RESPONSE"
              gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=backend-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}" \
                --limit=30 --format=json --project=${{ env.GCP_PROJECT_ID }} | jq -r '.[].textPayload // .[].jsonPayload.message // empty' | head -50 || true
            fi
            echo "Attempt $i/40: API not ready yet..."
            sleep 10
          done
          
          echo "Final service verification..."
          echo "Frontend status:"
          curl -s --max-time 5 -I "$STAGING_URL" || echo "Frontend not responding"
          echo ""
          echo "API status:"
          curl -s --max-time 5 "$API_URL/health/" || echo "API health endpoint not responding"
          echo ""

      - name: Run staging tests
        id: tests
        timeout-minutes: 15
        run: |
          # Update comment - Testing started
          if [[ -n "${{ needs.initialize-deployment.outputs.comment_id }}" ]]; then
            gh api repos/${{ github.repository }}/issues/comments/${{ needs.initialize-deployment.outputs.comment_id }} \
              --method GET | jq -r '.body' > comment.txt
            
            # Update testing status to in progress
            sed -i 's/| ğŸ§ª \*\*Testing\*\* | .* | .* | .* |/| ğŸ§ª **Testing** | ğŸ”„ In Progress | Running test suite... | '$(date -u +"%Y-%m-%dT%H:%M:%SZ")' |/' comment.txt
            
            gh api repos/${{ github.repository }}/issues/comments/${{ needs.initialize-deployment.outputs.comment_id }} \
              --method PATCH --field body="$(cat comment.txt)"
          fi
          
          export STAGING_URL="${{ steps.terraform.outputs.frontend_url }}"
          export STAGING_API_URL="${{ steps.terraform.outputs.backend_url }}"
          
          python test_runner.py \
            --level "${{ steps.config.outputs.test_level }}" \
            --staging \
            --report-format json \
            --output test_results.json
          
          PASSED=$(jq -r '.summary.passed' test_results.json)
          FAILED=$(jq -r '.summary.failed' test_results.json)
          SKIPPED=$(jq -r '.summary.skipped' test_results.json)
          DURATION=$(jq -r '.summary.duration' test_results.json)
          
          echo "test_passed=$PASSED" >> $GITHUB_OUTPUT
          echo "test_failed=$FAILED" >> $GITHUB_OUTPUT
          echo "test_skipped=$SKIPPED" >> $GITHUB_OUTPUT
          echo "test_duration=$DURATION" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            test_results.json
            test_reports/
          retention-days: 7
          compression-level: 6

      - name: Update comment - Final status
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment_id = '${{ needs.initialize-deployment.outputs.comment_id }}';
            if (!comment_id) return;
            
            const test_passed = '${{ steps.tests.outputs.test_passed }}' || '0';
            const test_failed = '${{ steps.tests.outputs.test_failed }}' || '0';
            const test_skipped = '${{ steps.tests.outputs.test_skipped }}' || '0';
            const test_duration = '${{ steps.tests.outputs.test_duration }}' || '0';
            const frontend_url = '${{ steps.terraform.outputs.frontend_url }}';
            const backend_url = '${{ steps.terraform.outputs.backend_url }}';
            
            const test_success = test_failed === '0';
            const overall_success = '${{ job.status }}' === 'success' && test_success;
            
            // Get current comment
            const { data: currentComment } = await github.rest.issues.getComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id)
            });
            
            // Update testing status
            let body = currentComment.body;
            const test_status = test_success ? 'âœ… Complete' : 'âŒ Failed';
            const test_details = `Passed: ${test_passed}, Failed: ${test_failed}, Skipped: ${test_skipped}`;
            
            body = body.replace(
              /\| ğŸ§ª \*\*Testing\*\* \| .+ \| .+ \| .+ \|/,
              `| ğŸ§ª **Testing** | ${test_status} | ${test_details} (${test_duration}s) | ${new Date().toISOString()} |`
            );
            
            // Update overall status
            const overall_emoji = overall_success ? 'âœ…' : 'âŒ';
            const overall_status = overall_success ? 'Ready' : 'Failed';
            body = body.replace(/## .+ Staging Environment Status/, `## ${overall_emoji} Staging Environment Status`);
            body = body.replace(/\*\*Status:\*\* .+/, `**Status:** ${overall_status}`);
            
            // Add test results section if not exists
            if (!body.includes('### ğŸ§ª Test Results')) {
              const testSection = `\n### ğŸ§ª Test Results\n- **Passed:** ${test_passed} tests\n- **Failed:** ${test_failed} tests\n- **Skipped:** ${test_skipped} tests\n- **Duration:** ${test_duration}s\n- **Test Level:** ${{ steps.config.outputs.test_level }}\n`;
              body = body.replace(/### ğŸ“Š Resource Configuration/, testSection + '\n### ğŸ“Š Resource Configuration');
            } else {
              // Update existing test results
              body = body.replace(/### ğŸ§ª Test Results[\s\S]*?(?=\n###|\n\n---)/,
                `### ğŸ§ª Test Results\n- **Passed:** ${test_passed} tests\n- **Failed:** ${test_failed} tests\n- **Skipped:** ${test_skipped} tests\n- **Duration:** ${test_duration}s\n- **Test Level:** ${{ steps.config.outputs.test_level }}`);
            }
            
            // Add to activity log
            const activityLog = body.match(/```\n([\s\S]*?)\n```/);
            if (activityLog) {
              const result = test_success ? 'completed successfully' : `failed (${test_failed} failures)`;
              const newLog = activityLog[1] + `\n[${new Date().toISOString()}] Testing ${result}`;
              body = body.replace(/```\n[\s\S]*?\n```/, '```\n' + newLog + '\n```');
            }
            
            // Update last updated timestamp
            body = body.replace(/\*Last updated: .+\*/, `*Last updated: ${new Date().toISOString()} | Run: [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`);
            
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: parseInt(comment_id),
              body: body
            });

      - name: Set commit status
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const test_failed = '${{ steps.tests.outputs.test_failed }}' || '0';
            const state = test_failed === '0' ? 'success' : 'failure';
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              target_url: '${{ steps.terraform.outputs.frontend_url }}',
              description: `Staging deployed with ${test_failed} test failures`,
              context: 'staging/deployment'
            });

  # Destroy job remains mostly the same with enhanced comment updates
  destroy-staging:
    name: Destroy Staging Environment
    needs: initialize-deployment
    if: |
      (github.event.action == 'closed' && needs.initialize-deployment.outputs.action == 'destroy') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'destroy')
    runs-on: ubuntu-latest
    timeout-minutes: 20
    concurrency:
      group: staging-destroy-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}
      cancel-in-progress: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Export logs before destruction
        continue-on-error: true  # Continue even if log export fails
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Export Cloud Run logs (may fail if permissions are insufficient)
          if gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=staging-pr-${PR_NUMBER}" \
            --format=json \
            --project=${{ env.GCP_PROJECT_ID }} \
            > staging-logs-pr-${PR_NUMBER}.json 2>/dev/null; then
            echo "âœ… Logs exported for PR ${PR_NUMBER}"
          else
            echo "âš ï¸ Could not export logs (insufficient permissions or no logs found)"
            echo "{}" > staging-logs-pr-${PR_NUMBER}.json  # Create empty file for artifact
          fi

      # UPDATED FOR V4: Use actions/upload-artifact@v4 with unique naming
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: staging-logs-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.run_id }}
          path: staging-logs-*.json
          retention-days: 7
          compression-level: 9  # Maximum compression for logs

      - name: Terraform Destroy with Lock Handling
        working-directory: ./terraform/staging
        env:
          TF_VAR_postgres_password: ${{ secrets.STAGING_DB_PASSWORD }}
          TF_VAR_clickhouse_password: ${{ secrets.CLICKHOUSE_PASSWORD || 'placeholder_password' }}
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Initialize Terraform
          terraform init \
            -backend-config="bucket=${{ env.GCP_PROJECT_ID }}-terraform-state"
            -backend-config="prefix=staging/pr-${PR_NUMBER}"
            -lock-timeout=120s
          
          # Create secure tfvars file for destroy operation
          cat > terraform.tfvars << 'EOF'
          project_id = "${{ env.GCP_PROJECT_ID }}"
          region = "${{ env.GCP_REGION }}"
          pr_number = "${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          backend_image = "gcr.io/PROJECT_ID/backend:latest"
          frontend_image = "gcr.io/PROJECT_ID/frontend:latest"
          max_instances = 1
          domain = "${{ env.STAGING_DOMAIN }}"
          EOF
          
          # Add sensitive variables securely
          echo "postgres_password = \"${TF_VAR_postgres_password}\"" >> terraform.tfvars
          echo "clickhouse_password = \"${TF_VAR_clickhouse_password}\"" >> terraform.tfvars
          
          # Secure the file
          chmod 600 terraform.tfvars
          
          # Run destroy with retries
          MAX_DESTROY_ATTEMPTS=2
          DESTROY_ATTEMPT=1
          while [ $DESTROY_ATTEMPT -le $MAX_DESTROY_ATTEMPTS ]; do
            echo "Terraform destroy attempt $DESTROY_ATTEMPT of $MAX_DESTROY_ATTEMPTS..."
            
            if terraform destroy \
              -auto-approve \
              -var-file=terraform.tfvars \
              -lock-timeout=180s \
              -parallelism=10; then
              echo "âœ… Terraform destroy successful"
              break
            else
              echo "âŒ Terraform destroy failed"
              
              if [ $DESTROY_ATTEMPT -eq $MAX_DESTROY_ATTEMPTS ]; then
                echo "Failed to destroy after $MAX_DESTROY_ATTEMPTS attempts"
                echo "::warning::Terraform destroy failed but continuing with cleanup"
                break
              fi
              
              echo "Waiting 10 seconds before retry..."
              sleep 10
              DESTROY_ATTEMPT=$((DESTROY_ATTEMPT + 1))
            fi
          done
          
          # Clean up sensitive file
          rm -f terraform.tfvars
          
          # Final cleanup - remove state files
          echo "Cleaning up Terraform state files..."
          gsutil -m rm -r "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${PR_NUMBER}/" 2>/dev/null || true

      - name: Clean up container images and build cache
        continue-on-error: true
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Delete backend images
          gcloud artifacts docker images delete \
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/backend:pr-${PR_NUMBER}-* \
            --quiet || true
          
          # Delete frontend images
          gcloud artifacts docker images delete \
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/frontend:pr-${PR_NUMBER}-* \
            --quiet || true
          
          # Clean up build cache files
          echo "Cleaning up build cache for PR #${PR_NUMBER}..."
          gsutil rm "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/backend-build-cache-pr-${PR_NUMBER}.json" 2>/dev/null || true
          gsutil rm "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/frontend-build-cache-pr-${PR_NUMBER}.json" 2>/dev/null || true
          echo "âœ… Build cache cleaned up"

      - name: Update PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.payload.pull_request.number;
            
            const comment = `## ğŸ§¹ Staging Environment Destroyed
            
            **Environment:** pr-${pr_number}
            **Status:** âœ… Successfully cleaned up
            **Destroyed at:** ${new Date().toISOString()}
            
            All resources associated with this staging environment have been removed.
            Logs have been archived and are available as workflow artifacts for 7 days.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: comment
            });

  cleanup-on-cancel:
    name: Cleanup on Workflow Cancellation
    needs: [deploy-staging]
    if: always() && (cancelled() || failure())
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Force unlock Terraform state
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          if [ -z "$PR_NUMBER" ]; then
            echo "No PR number available, skipping lock cleanup"
            exit 0
          fi
          
          LOCK_FILE="gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${PR_NUMBER}/default.tflock"
          
          echo "Checking for stale lock from cancelled/failed workflow..."
          if gsutil stat "$LOCK_FILE" 2>/dev/null; then
            LOCK_INFO=$(gsutil cat "$LOCK_FILE" 2>/dev/null || echo "{}")
            LOCK_HOLDER=$(echo "$LOCK_INFO" | jq -r '.Who // "unknown"')
            
            # Only remove if it's from a GitHub Actions runner
            if echo "$LOCK_HOLDER" | grep -q "runner@"; then
              echo "âš ï¸ Found lock from GitHub Actions runner: $LOCK_HOLDER"
              echo "Removing lock from cancelled/failed workflow..."
              gsutil rm "$LOCK_FILE" 2>/dev/null || true
              echo "âœ… Lock removed successfully"
            else
              echo "Lock held by: $LOCK_HOLDER (not a runner, keeping lock)"
            fi
          else
            echo "No lock file found"
          fi
          
          # Also check for any orphaned tfplan files
          echo "Cleaning up orphaned plan files..."
          cd terraform/staging 2>/dev/null && rm -f tfplan terraform.tfvars 2>/dev/null || true

  cleanup-stale-environments:
    name: Cleanup Stale Environments
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Find and destroy stale environments
        run: |
          # List all Cloud Run services with staging prefix
          SERVICES=$(gcloud run services list \
            --platform=managed \
            --region=${{ env.GCP_REGION }} \
            --format="value(name)" \
            --filter="name:staging-pr-*")
          
          for SERVICE in $SERVICES; do
            # Extract PR number from service name
            PR_NUMBER=$(echo $SERVICE | grep -oP 'pr-\K[0-9]+')
            
            # Check if PR is still open
            PR_STATE=$(gh pr view $PR_NUMBER --json state -q .state 2>/dev/null || echo "CLOSED")
            
            if [[ "$PR_STATE" == "CLOSED" ]] || [[ "$PR_STATE" == "MERGED" ]]; then
              echo "Cleaning up stale environment for PR #$PR_NUMBER (state: $PR_STATE)"
              
              # Trigger destroy workflow
              gh workflow run staging-environment.yml \
                -f action=destroy \
                -f pr_number=$PR_NUMBER
            fi
          done
        env:
          GH_TOKEN: ${{ github.token }}

  # NEW JOB FOR V4: Download artifacts from other workflows
  download-previous-artifacts:
    name: Download Previous Test Results
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'redeploy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # UPDATED FOR V4: Download artifacts from previous runs with github-token
      - name: Download previous test results
        uses: actions/download-artifact@v4
        with:
          name: test-results-pr-${{ github.event.inputs.pr_number }}-*
          path: ./previous-test-results
          github-token: ${{ secrets.GITHUB_TOKEN }}  # Required for cross-run downloads in v4
          
      - name: Process previous results
        run: |
          echo "Processing previous test results..."
          ls -la ./previous-test-results/
          # Add processing logic here