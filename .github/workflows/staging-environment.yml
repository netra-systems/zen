name: Staging Environment
description: Fast parallel staging deployment with shared infrastructure

permissions:
  contents: read
  deployments: write
  pull-requests: write
  issues: write
  statuses: write
  packages: write

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - main
      - develop
      - 'release/**'
  
  push:
    branches:
      - main
      - develop
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/workflows/test-*.yml'
  
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - deploy
          - destroy
          - restart
          - status
          - rebuild
      pr_number:
        description: 'Pull request number (optional for branch deployments)'
        required: false
        type: string
      branch:
        description: 'Branch to deploy (optional, defaults to current)'
        required: false
        type: string
      force:
        description: 'Force deployment even if checks fail'
        required: false
        type: boolean
        default: false

env:
  PROJECT_NAME: netra-staging
  GCP_REGION: us-central1
  TERRAFORM_VERSION: 1.5.0
  NODE_VERSION: 20
  PYTHON_VERSION: 3.11
  MAX_RETRIES: 3
  RETRY_DELAY: 30
  # Enable BuildKit for faster Docker builds
  DOCKER_BUILDKIT: 1
  BUILDKIT_PROGRESS: plain

concurrency:
  group: staging-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  setup:
    name: Environment Setup
    runs-on: ubuntu-latest
    outputs:
      environment_name: ${{ steps.config.outputs.environment_name }}
      action: ${{ steps.config.outputs.action }}
      pr_number: ${{ steps.config.outputs.pr_number }}
      branch_name: ${{ steps.config.outputs.branch_name }}
      commit_sha: ${{ steps.config.outputs.commit_sha }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      should_deploy: ${{ steps.config.outputs.should_deploy }}
    
    steps:
      - name: Configure environment
        id: config
        run: |
          # Determine PR number and action based on trigger
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
            COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
            if [[ "${{ github.event.action }}" == "closed" ]]; then
              ACTION="destroy"
              SHOULD_DEPLOY="false"
            else
              ACTION="deploy"
              SHOULD_DEPLOY="true"
            fi
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            BRANCH_NAME="${{ github.ref_name }}"
            COMMIT_SHA="${{ github.sha }}"
            PR_NUMBER="branch-${BRANCH_NAME//\//-}"
            ACTION="deploy"
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            PR_NUMBER="${{ github.event.inputs.pr_number }}"
            ACTION="${{ github.event.inputs.action }}"
            BRANCH_NAME="${{ github.event.inputs.branch || github.ref_name }}"
            COMMIT_SHA="${{ github.sha }}"
            SHOULD_DEPLOY=$([[ "$ACTION" == "deploy" || "$ACTION" == "rebuild" ]] && echo "true" || echo "false")
            
            if [[ -z "$PR_NUMBER" ]]; then
              PR_NUMBER="branch-${BRANCH_NAME//\//-}"
            fi
          fi
          
          # Sanitize environment name
          ENV_NAME="${{ env.PROJECT_NAME }}-${PR_NUMBER//[^a-zA-Z0-9-]/-}"
          ENV_NAME="${ENV_NAME,,}"
          ENV_NAME="${ENV_NAME:0:63}"
          
          echo "environment_name=$ENV_NAME" >> $GITHUB_OUTPUT
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          
          echo "::notice::Environment: $ENV_NAME, Action: $ACTION, Deploy: $SHOULD_DEPLOY"
      
      - name: Create GitHub deployment
        id: deployment
        if: steps.config.outputs.should_deploy == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ steps.config.outputs.commit_sha }}',
              environment: '${{ steps.config.outputs.environment_name }}',
              description: 'Staging deployment for ${{ steps.config.outputs.pr_number }}',
              auto_merge: false,
              required_contexts: [],
              production_environment: false
            });
            
            core.setOutput('deployment_id', deployment.data.id);
            return deployment.data.id;

  # Parallel build jobs for maximum speed
  build-backend:
    name: Build Backend
    needs: [setup]
    if: needs.setup.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      image_url: ${{ steps.build.outputs.image_url }}
      build_time: ${{ steps.build.outputs.build_time }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.commit_sha }}
      
      - name: Setup Python cache
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Configure GCP credentials
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}
          project_id: ${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:latest
      
      - name: Configure Docker
        run: gcloud auth configure-docker gcr.io --quiet
      
      - name: Build and push backend
        id: build
        run: |
          START_TIME=$(date +%s)
          PROJECT_ID="${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          IMAGE_TAG="${{ needs.setup.outputs.commit_sha }}"
          IMAGE_URL="gcr.io/${PROJECT_ID}/backend:${IMAGE_TAG}"
          
          # Check if image already exists
          if gcloud container images describe ${IMAGE_URL} 2>/dev/null; then
            echo "::notice::Image already exists, skipping build: ${IMAGE_URL}"
            echo "image_url=${IMAGE_URL}" >> $GITHUB_OUTPUT
            echo "build_time=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Build with advanced caching
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=registry,ref=gcr.io/${PROJECT_ID}/backend:buildcache \
            --cache-to type=registry,ref=gcr.io/${PROJECT_ID}/backend:buildcache,mode=max \
            --build-arg COMMIT_SHA=${{ needs.setup.outputs.commit_sha }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t ${IMAGE_URL} \
            -t gcr.io/${PROJECT_ID}/backend:latest \
            -f Dockerfile.backend \
            --push \
            --progress=plain \
            .
          
          END_TIME=$(date +%s)
          BUILD_TIME=$((END_TIME - START_TIME))
          
          echo "image_url=${IMAGE_URL}" >> $GITHUB_OUTPUT
          echo "build_time=${BUILD_TIME}" >> $GITHUB_OUTPUT
          echo "::notice::Backend built in ${BUILD_TIME}s: ${IMAGE_URL}"

  build-frontend:
    name: Build Frontend
    needs: [setup]
    if: needs.setup.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    outputs:
      image_url: ${{ steps.build.outputs.image_url }}
      build_time: ${{ steps.build.outputs.build_time }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.commit_sha }}
      
      - name: Setup Node.js cache
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Configure GCP credentials
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}
          project_id: ${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}
      
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:latest
      
      - name: Configure Docker
        run: gcloud auth configure-docker gcr.io --quiet
      
      - name: Build and push frontend
        id: build
        run: |
          START_TIME=$(date +%s)
          PROJECT_ID="${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          IMAGE_TAG="${{ needs.setup.outputs.commit_sha }}"
          IMAGE_URL="gcr.io/${PROJECT_ID}/frontend:${IMAGE_TAG}"
          
          # Check if image already exists
          if gcloud container images describe ${IMAGE_URL} 2>/dev/null; then
            echo "::notice::Image already exists, skipping build: ${IMAGE_URL}"
            echo "image_url=${IMAGE_URL}" >> $GITHUB_OUTPUT
            echo "build_time=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Build with advanced caching
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=registry,ref=gcr.io/${PROJECT_ID}/frontend:buildcache \
            --cache-to type=registry,ref=gcr.io/${PROJECT_ID}/frontend:buildcache,mode=max \
            --build-arg COMMIT_SHA=${{ needs.setup.outputs.commit_sha }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t ${IMAGE_URL} \
            -t gcr.io/${PROJECT_ID}/frontend:latest \
            -f Dockerfile.frontend.staging \
            --push \
            --progress=plain \
            .
          
          END_TIME=$(date +%s)
          BUILD_TIME=$((END_TIME - START_TIME))
          
          echo "image_url=${IMAGE_URL}" >> $GITHUB_OUTPUT
          echo "build_time=${BUILD_TIME}" >> $GITHUB_OUTPUT
          echo "::notice::Frontend built in ${BUILD_TIME}s: ${IMAGE_URL}"

  # Terraform runs after builds complete
  terraform:
    name: Deploy Infrastructure
    needs: [setup, build-backend, build-frontend]
    if: |
      always() && 
      needs.setup.result == 'success' &&
      (needs.build-backend.result == 'success' || needs.build-backend.result == 'skipped') &&
      (needs.build-frontend.result == 'success' || needs.build-frontend.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      backend_url: ${{ steps.outputs.outputs.backend_url }}
      frontend_url: ${{ steps.outputs.outputs.frontend_url }}
      deploy_time: ${{ steps.outputs.outputs.deploy_time }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.commit_sha }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false
      
      - name: Configure GCP credentials
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}
          project_id: ${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}
      
      - name: Terraform Deploy
        id: deploy
        if: needs.setup.outputs.action == 'deploy'
        working-directory: ./terraform/staging
        run: |
          START_TIME=$(date +%s)
          BUCKET="${{ secrets.TF_STAGING_STATE_BUCKET || secrets.TF_STATE_BUCKET || 'netra-staging-terraform-state' }}"
          PREFIX="${{ needs.setup.outputs.environment_name }}"
          PROJECT_ID="${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          
          # Create state bucket if needed
          if ! gcloud storage buckets describe "gs://$BUCKET" --project="${PROJECT_ID}" 2>/dev/null; then
            gcloud storage buckets create "gs://$BUCKET" \
              --project="${PROJECT_ID}" \
              --location="${{ env.GCP_REGION }}" \
              --uniform-bucket-level-access \
              --public-access-prevention
          fi
          
          # Fast init without downloading unnecessary providers
          terraform init \
            -backend-config="bucket=$BUCKET" \
            -backend-config="prefix=$PREFIX" \
            -upgrade=false \
            -get=true \
            -reconfigure \
            -input=false
          
          # Create tfvars file for better performance
          cat > terraform.tfvars <<EOF
          environment_name = "${{ needs.setup.outputs.environment_name }}"
          pr_number = "${{ needs.setup.outputs.pr_number }}"
          branch_name = "${{ needs.setup.outputs.branch_name }}"
          commit_sha = "${{ needs.setup.outputs.commit_sha }}"
          project_id = "${PROJECT_ID}"
          backend_image = "${{ needs.build-backend.outputs.image_url }}"
          frontend_image = "${{ needs.build-frontend.outputs.image_url }}"
          postgres_password = "${{ secrets.POSTGRES_PASSWORD_STAGING || 'staging-password' }}"
          clickhouse_password = "${{ secrets.CLICKHOUSE_PASSWORD_STAGING || 'staging-clickhouse' }}"
          jwt_secret_key = "${{ secrets.JWT_SECRET_KEY_STAGING || '' }}"
          fernet_key = "${{ secrets.FERNET_KEY_STAGING || '' }}"
          gemini_api_key = "${{ secrets.GEMINI_API_KEY_STAGING || '' }}"
          EOF
          
          # Apply with minimal refresh for speed
          terraform apply \
            -auto-approve \
            -parallelism=20 \
            -refresh=false \
            -input=false
          
          END_TIME=$(date +%s)
          DEPLOY_TIME=$((END_TIME - START_TIME))
          echo "::notice::Infrastructure deployed in ${DEPLOY_TIME}s"
      
      - name: Terraform Destroy
        if: needs.setup.outputs.action == 'destroy'
        working-directory: ./terraform/staging
        run: |
          BUCKET="${{ secrets.TF_STAGING_STATE_BUCKET || secrets.TF_STATE_BUCKET || 'netra-staging-terraform-state' }}"
          PREFIX="${{ needs.setup.outputs.environment_name }}"
          PROJECT_ID="${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          
          terraform init \
            -backend-config="bucket=$BUCKET" \
            -backend-config="prefix=$PREFIX" \
            -upgrade=false \
            -reconfigure \
            -input=false
          
          terraform destroy \
            -auto-approve \
            -var="environment_name=${{ needs.setup.outputs.environment_name }}" \
            -var="pr_number=${{ needs.setup.outputs.pr_number }}" \
            -var="project_id=${PROJECT_ID}" \
            -refresh=false \
            -input=false
        continue-on-error: true
      
      - name: Extract outputs
        id: outputs
        if: needs.setup.outputs.action == 'deploy' && steps.deploy.outcome == 'success'
        working-directory: ./terraform/staging
        run: |
          BACKEND_URL=$(terraform output -raw backend_url 2>/dev/null || echo "")
          FRONTEND_URL=$(terraform output -raw frontend_url 2>/dev/null || echo "")
          
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "deploy_time=${{ steps.deploy.outputs.DEPLOY_TIME || '0' }}" >> $GITHUB_OUTPUT
          
          echo "::notice::Deployment URLs - Frontend: $FRONTEND_URL, Backend: $BACKEND_URL"

  # Quick smoke test
  smoke-test:
    name: Smoke Test
    needs: [setup, terraform]
    if: |
      needs.setup.outputs.action == 'deploy' && 
      needs.terraform.result == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Wait for services
        run: sleep 15
      
      - name: Test backend health
        run: |
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f "${{ needs.terraform.outputs.backend_url }}/health" \
                 --max-time 10 \
                 --retry 3 \
                 --retry-delay 2; then
              echo "::notice::Backend is healthy"
              break
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "::warning::Backend not ready, retry $RETRY_COUNT/$MAX_RETRIES"
            sleep 5
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "::error::Backend health check failed after $MAX_RETRIES retries"
            exit 1
          fi
      
      - name: Test frontend
        run: |
          if curl -f "${{ needs.terraform.outputs.frontend_url }}" \
               --max-time 10 \
               --retry 3 \
               --retry-delay 2 \
               -o /dev/null \
               -s \
               -w "%{http_code}"; then
            echo "::notice::Frontend is accessible"
          else
            echo "::warning::Frontend may not be fully ready yet"
          fi

  # Update deployment status and post comments
  finalize:
    name: Finalize Deployment
    needs: [setup, terraform, smoke-test, build-backend, build-frontend]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Calculate total time
        id: timing
        run: |
          BACKEND_TIME="${{ needs.build-backend.outputs.build_time || '0' }}"
          FRONTEND_TIME="${{ needs.build-frontend.outputs.build_time || '0' }}"
          DEPLOY_TIME="${{ needs.terraform.outputs.deploy_time || '0' }}"
          
          # Calculate max of backend and frontend (since they run in parallel)
          BUILD_TIME=$((BACKEND_TIME > FRONTEND_TIME ? BACKEND_TIME : FRONTEND_TIME))
          TOTAL_TIME=$((BUILD_TIME + DEPLOY_TIME))
          
          echo "total_time=${TOTAL_TIME}" >> $GITHUB_OUTPUT
          echo "::notice::Total deployment time: ${TOTAL_TIME}s (Build: ${BUILD_TIME}s, Deploy: ${DEPLOY_TIME}s)"
      
      - name: Update deployment status
        if: needs.setup.outputs.deployment_id != ''
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ needs.smoke-test.result }}' === 'success' ? 'success' : 
                          '${{ needs.terraform.result }}' === 'success' ? 'pending' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.setup.outputs.deployment_id }},
              state: status,
              environment_url: '${{ needs.terraform.outputs.frontend_url }}',
              description: `Deployed in ${{ steps.timing.outputs.total_time }}s`,
              auto_inactive: true
            });
      
      - name: Post PR comment
        if: |
          github.event_name == 'pull_request' && 
          needs.setup.outputs.action == 'deploy' &&
          needs.terraform.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const totalTime = '${{ steps.timing.outputs.total_time }}';
            const smokeStatus = '${{ needs.smoke-test.result }}' === 'success' ? 'âœ… Healthy' : 'âš ï¸ Pending';
            
            const comment = `## ğŸš€ Staging Environment Deployed
            
            **Status:** ${smokeStatus} | **Deploy Time:** ${totalTime}s
            
            **Frontend:** ${{ needs.terraform.outputs.frontend_url }}
            **Backend:** ${{ needs.terraform.outputs.backend_url }}
            
            **Environment:** \`${{ needs.setup.outputs.environment_name }}\`
            **Commit:** \`${{ needs.setup.outputs.commit_sha }}\`
            
            <details>
            <summary>Performance Metrics</summary>
            
            - Backend Build: ${{ needs.build-backend.outputs.build_time }}s
            - Frontend Build: ${{ needs.build-frontend.outputs.build_time }}s
            - Infrastructure: ${{ needs.terraform.outputs.deploy_time }}s
            - Total Time: ${totalTime}s
            
            </details>
            
            <details>
            <summary>Quick Actions</summary>
            
            - ğŸ”„ **Restart:** Run workflow with \`restart\` action
            - ğŸ“Š **Status:** Run workflow with \`status\` action
            - ğŸ—‘ï¸ **Destroy:** Close PR or run workflow with \`destroy\` action
            
            </details>`;
            
            // Find and update existing comment or create new
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.pull_request.number }}
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Staging Environment')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ github.event.pull_request.number }},
                body: comment
              });
            }
      
      - name: Create summary
        run: |
          STATUS_EMOJI="${{ needs.smoke-test.result == 'success' && 'âœ…' || 'âš ï¸' }}"
          
          echo "## Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${STATUS_EMOJI} ${{ needs.smoke-test.result || needs.terraform.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Time:** ${{ steps.timing.outputs.total_time }}s" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ needs.setup.outputs.environment_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ needs.setup.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.terraform.result }}" == "success" ]]; then
            echo "### ğŸ”— Access URLs" >> $GITHUB_STEP_SUMMARY
            echo "- Frontend: ${{ needs.terraform.outputs.frontend_url }}" >> $GITHUB_STEP_SUMMARY
            echo "- Backend: ${{ needs.terraform.outputs.backend_url }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "### â±ï¸ Performance Breakdown" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Time |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| Backend Build | ${{ needs.build-backend.outputs.build_time }}s |" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend Build | ${{ needs.build-frontend.outputs.build_time }}s |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.terraform.outputs.deploy_time }}s |" >> $GITHUB_STEP_SUMMARY
          echo "| **Total** | **${{ steps.timing.outputs.total_time }}s** |" >> $GITHUB_STEP_SUMMARY