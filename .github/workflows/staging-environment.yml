name: Staging Environment Management

on:
  pull_request:
    types: [opened, synchronize, closed, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      action:
        description: 'Manual action'
        required: true
        type: choice
        options:
          - deploy
          - destroy
          - redeploy
      pr_number:
        description: 'PR number'
        required: true
        type: string

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: us-central1
  TERRAFORM_VERSION: 1.5.0
  STAGING_DOMAIN: staging.netrasystems.ai

jobs:
  check-eligibility:
    name: Check Staging Eligibility
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment_name: ${{ steps.check.outputs.environment_name }}
    steps:
      - name: Check labels and configuration
        id: check
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Check for exclusion labels
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'no-staging') }}" == "true" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "âŒ Staging skipped: 'no-staging' label present"
            exit 0
          fi
          
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'WIP') }}" == "true" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "âŒ Staging skipped: 'WIP' label present"
            exit 0
          fi
          
          # Check for manual trigger
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.action }}" == "destroy" ]]; then
              echo "should_deploy=false" >> $GITHUB_OUTPUT
            else
              echo "should_deploy=true" >> $GITHUB_OUTPUT
            fi
          # Check for PR close
          elif [[ "${{ github.event.action }}" == "closed" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi
          
          echo "environment_name=pr-${PR_NUMBER}" >> $GITHUB_OUTPUT

  deploy-staging:
    name: Deploy Staging Environment
    needs: check-eligibility
    if: needs.check-eligibility.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45  # Prevent hanging beyond 45 minutes
    environment:
      name: staging-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}
      url: https://pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}.${{ env.STAGING_DOMAIN }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0  # Fetch all history for proper change detection
      
      - name: Fetch base branch for comparison
        if: github.event_name == 'pull_request'
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Configure Docker for GCP
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Load staging configuration
        id: config
        run: |
          # Load configuration with defaults
          if [ -f .github/staging.yml ]; then
            TEST_LEVEL=$(yq e '.default_test_level // "integration"' .github/staging.yml)
            MAX_INSTANCES=$(yq e '.resource_limits.compute.max_instances // 3' .github/staging.yml)
          else
            TEST_LEVEL="integration"
            MAX_INSTANCES="3"
          fi
          
          echo "test_level=$TEST_LEVEL" >> $GITHUB_OUTPUT
          echo "max_instances=$MAX_INSTANCES" >> $GITHUB_OUTPUT

      - name: Check for backend changes
        id: backend-changes
        run: |
          # Initialize as changed by default (safe for first commits or when unsure)
          CHANGED="true"
          CHANGED_FILES=""
          
          # Try to detect changes based on the context
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, compare against the base branch
            echo "Checking PR changes against base branch..."
            
            # For synchronize events (new commits pushed to PR), check all changes in the PR
            if [[ "${{ github.event.action }}" == "synchronize" ]]; then
              echo "PR synchronized - checking all changes since branch diverged from base..."
              # Get the merge base and compare all changes
              MERGE_BASE=$(git merge-base origin/${{ github.event.pull_request.base.ref }} HEAD)
              CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
            else
              # For initial PR open or other events, check against base
              CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD 2>/dev/null || echo "")
            fi
            
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual triggers, try to find the associated PR and check all its changes
            PR_NUMBER="${{ github.event.inputs.pr_number }}"
            if [[ -n "$PR_NUMBER" ]]; then
              echo "Manual trigger for PR #$PR_NUMBER - checking all PR changes..."
              # Try to get the base branch from GitHub API or default to main
              BASE_BRANCH=$(gh pr view $PR_NUMBER --json baseRefName -q .baseRefName 2>/dev/null || echo "main")
              git fetch origin $BASE_BRANCH:refs/remotes/origin/$BASE_BRANCH 2>/dev/null || true
              MERGE_BASE=$(git merge-base origin/$BASE_BRANCH HEAD 2>/dev/null || echo "")
              if [[ -n "$MERGE_BASE" ]]; then
                CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES="force-rebuild"
              fi
            else
              # No PR number, check last commit
              if git rev-parse HEAD^ >/dev/null 2>&1; then
                CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES="force-rebuild"
              fi
            fi
          else
            # For other events, check last commit
            if git rev-parse HEAD^ >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null || echo "")
            else
              CHANGED_FILES="force-rebuild"
            fi
          fi
          
          # Debug output
          echo "Event: ${{ github.event_name }}, Action: ${{ github.event.action }}"
          echo "Changed files detected:"
          echo "$CHANGED_FILES" | head -20
          
          # Check for backend-related changes
          if [[ "$CHANGED_FILES" == "force-rebuild" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Forcing backend rebuild (unable to determine changes)"
          elif echo "$CHANGED_FILES" | grep -E '^(app/|requirements\.txt|Dockerfile\.backend|alembic/|pyproject\.toml|poetry\.lock)' > /dev/null 2>&1; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… Backend changes detected"
            echo "Backend files changed:"
            echo "$CHANGED_FILES" | grep -E '^(app/|requirements\.txt|Dockerfile\.backend|alembic/|pyproject\.toml|poetry\.lock)' | head -10
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No backend changes detected"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build and push backend container
        id: backend-build
        timeout-minutes: 15  # Docker builds should complete within 15 minutes
        run: |
          IMAGE_TAG="pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.sha }}"
          IMAGE_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/backend:${IMAGE_TAG}"
          
          # Check if image already exists and no changes detected
          if [[ "${{ steps.backend-changes.outputs.changed }}" == "false" ]]; then
            # Try to find the latest existing image for this PR
            LATEST_IMAGE=$(gcloud artifacts docker images list \
              ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/backend \
              --filter="tags:pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-*" \
              --limit=1 --format="value(IMAGE)" 2>/dev/null || echo "")
            
            if [[ -n "$LATEST_IMAGE" ]]; then
              echo "â™»ï¸ Reusing existing backend image: $LATEST_IMAGE"
              echo "backend_image=$LATEST_IMAGE" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Build new image if changes detected or no existing image
          echo "ðŸ”¨ Building new backend image..."
          # Add timeout and progress tracking for docker build
          DOCKER_BUILDKIT=1 timeout 600 docker build \
            --progress=plain \
            --network=host \
            -t $IMAGE_URL \
            -f Dockerfile.backend . || {
            echo "Docker build timed out after 10 minutes"
            echo "This might be due to network issues or pip hanging"
            exit 1
          }
          
          # Push with timeout
          timeout 300 docker push $IMAGE_URL || {
            echo "Docker push timed out after 5 minutes"
            exit 1
          }
          
          echo "backend_image=$IMAGE_URL" >> $GITHUB_OUTPUT

      - name: Check for frontend changes
        id: frontend-changes
        run: |
          # Initialize as changed by default (safe for first commits or when unsure)
          CHANGED="true"
          CHANGED_FILES=""
          
          # Try to detect changes based on the context
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, compare against the base branch
            echo "Checking PR changes against base branch..."
            
            # For synchronize events (new commits pushed to PR), check all changes in the PR
            if [[ "${{ github.event.action }}" == "synchronize" ]]; then
              echo "PR synchronized - checking all changes since branch diverged from base..."
              # Get the merge base and compare all changes
              MERGE_BASE=$(git merge-base origin/${{ github.event.pull_request.base.ref }} HEAD)
              CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
            else
              # For initial PR open or other events, check against base
              CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }}...HEAD 2>/dev/null || echo "")
            fi
            
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual triggers, try to find the associated PR and check all its changes
            PR_NUMBER="${{ github.event.inputs.pr_number }}"
            if [[ -n "$PR_NUMBER" ]]; then
              echo "Manual trigger for PR #$PR_NUMBER - checking all PR changes..."
              # Try to get the base branch from GitHub API or default to main
              BASE_BRANCH=$(gh pr view $PR_NUMBER --json baseRefName -q .baseRefName 2>/dev/null || echo "main")
              git fetch origin $BASE_BRANCH:refs/remotes/origin/$BASE_BRANCH 2>/dev/null || true
              MERGE_BASE=$(git merge-base origin/$BASE_BRANCH HEAD 2>/dev/null || echo "")
              if [[ -n "$MERGE_BASE" ]]; then
                CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES="force-rebuild"
              fi
            else
              # No PR number, check last commit
              if git rev-parse HEAD^ >/dev/null 2>&1; then
                CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES="force-rebuild"
              fi
            fi
          else
            # For other events, check last commit
            if git rev-parse HEAD^ >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null || echo "")
            else
              CHANGED_FILES="force-rebuild"
            fi
          fi
          
          # Debug output
          echo "Event: ${{ github.event_name }}, Action: ${{ github.event.action }}"
          echo "Changed files detected:"
          echo "$CHANGED_FILES" | head -20
          
          # Check for frontend-related changes
          if [[ "$CHANGED_FILES" == "force-rebuild" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Forcing frontend rebuild (unable to determine changes)"
          elif echo "$CHANGED_FILES" | grep -E '^frontend/' > /dev/null 2>&1; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… Frontend changes detected"
            echo "Frontend files changed:"
            echo "$CHANGED_FILES" | grep -E '^frontend/' | head -10
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No frontend changes detected"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build and push frontend container
        id: frontend-build
        timeout-minutes: 15  # Frontend builds should complete within 15 minutes
        run: |
          IMAGE_TAG="pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.sha }}"
          IMAGE_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/frontend:${IMAGE_TAG}"
          
          # Check if image already exists and no changes detected
          if [[ "${{ steps.frontend-changes.outputs.changed }}" == "false" ]]; then
            # Try to find the latest existing image for this PR
            LATEST_IMAGE=$(gcloud artifacts docker images list \
              ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/frontend \
              --filter="tags:pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-*" \
              --limit=1 --format="value(IMAGE)" 2>/dev/null || echo "")
            
            if [[ -n "$LATEST_IMAGE" ]]; then
              echo "â™»ï¸ Reusing existing frontend image: $LATEST_IMAGE"
              echo "frontend_image=$LATEST_IMAGE" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Build new image if changes detected or no existing image
          echo "ðŸ”¨ Building new frontend image..."
          
          # Check if we're in the root directory and Dockerfile.frontend is in frontend/
          if [[ -f "frontend/Dockerfile.frontend" ]]; then
            cd frontend
            DOCKER_BUILDKIT=1 timeout 600 docker build \
              --progress=plain \
              --network=host \
              -t $IMAGE_URL \
              -f Dockerfile.frontend \
              --build-arg NEXT_PUBLIC_API_URL=https://pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-api.${{ env.STAGING_DOMAIN }} . || {
              echo "Frontend Docker build timed out after 10 minutes"
              exit 1
            }
            cd ..
          elif [[ -f "Dockerfile.frontend" ]]; then
            # Fallback if Dockerfile.frontend is in root
            DOCKER_BUILDKIT=1 timeout 600 docker build \
              --progress=plain \
              --network=host \
              -t $IMAGE_URL \
              -f Dockerfile.frontend \
              --build-arg NEXT_PUBLIC_API_URL=https://pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-api.${{ env.STAGING_DOMAIN }} . || {
              echo "Frontend Docker build timed out after 10 minutes"
              exit 1
            }
          else
            echo "âŒ Error: Dockerfile.frontend not found in expected locations"
            exit 1
          fi
          
          # Push with timeout
          timeout 300 docker push $IMAGE_URL || {
            echo "Docker push timed out after 5 minutes"
            exit 1
          }
          
          echo "frontend_image=$IMAGE_URL" >> $GITHUB_OUTPUT

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        working-directory: ./terraform/staging
        timeout-minutes: 5
        run: |
          # Check for state lock and clear if stale
          LOCK_FILE="gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}/default.tflock"
          
          # Check if lock exists and is older than 30 minutes
          if gsutil stat "$LOCK_FILE" 2>/dev/null; then
            LOCK_AGE=$(gsutil stat "$LOCK_FILE" | grep "Creation time:" | cut -d':' -f2- | xargs -I {} date -d "{}" +%s)
            CURRENT_TIME=$(date +%s)
            AGE_MINUTES=$(( ($CURRENT_TIME - $LOCK_AGE) / 60 ))
            
            if [ $AGE_MINUTES -gt 30 ]; then
              echo "âš ï¸ Found stale lock file (${AGE_MINUTES} minutes old), removing..."
              gsutil rm "$LOCK_FILE" || true
            else
              echo "âš ï¸ Active lock file found (${AGE_MINUTES} minutes old)"
              echo "Another Terraform operation may be in progress"
            fi
          fi
          
          # Initialize with lock timeout
          terraform init \
            -backend-config="bucket=${{ env.GCP_PROJECT_ID }}-terraform-state" \
            -backend-config="prefix=staging/pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}" \
            -lock-timeout=120s

      - name: Terraform Plan
        working-directory: ./terraform/staging
        timeout-minutes: 5
        run: |
          terraform plan \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="pr_number=${{ github.event.pull_request.number || github.event.inputs.pr_number }}" \
            -var="backend_image=${{ steps.backend-build.outputs.backend_image }}" \
            -var="frontend_image=${{ steps.frontend-build.outputs.frontend_image }}" \
            -var="max_instances=${{ steps.config.outputs.max_instances }}" \
            -var="domain=${{ env.STAGING_DOMAIN }}" \
            -var="postgres_password=${{ secrets.STAGING_DB_PASSWORD }}" \
            -lock-timeout=120s \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ./terraform/staging
        id: terraform
        timeout-minutes: 20  # Terraform should complete within 20 minutes
        run: |
          # Set timeout for terraform apply itself
          timeout 1200 terraform apply -auto-approve tfplan || {
            echo "Terraform apply timed out after 20 minutes"
            echo "Attempting to show current state..."
            terraform show
            exit 1
          }
          
          # Capture outputs
          BACKEND_URL=$(terraform output -raw backend_url)
          FRONTEND_URL=$(terraform output -raw frontend_url)
          DATABASE_HOST=$(terraform output -raw database_host)
          REDIS_HOST=$(terraform output -raw redis_host)
          
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "database_host=$DATABASE_HOST" >> $GITHUB_OUTPUT
          echo "redis_host=$REDIS_HOST" >> $GITHUB_OUTPUT

      - name: Run database migrations
        timeout-minutes: 5  # Migrations should complete quickly
        run: |
          # Set database URL for migrations
          export DATABASE_URL="postgresql://staging:${{ secrets.STAGING_DB_PASSWORD }}@${{ steps.terraform.outputs.database_host }}/netra_pr_${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          
          # Wait for database to be ready (max 2 minutes)
          echo "Waiting for database to be ready..."
          for i in {1..24}; do
            if pg_isready -h "${{ steps.terraform.outputs.database_host }}" -p 5432 -U staging 2>/dev/null; then
              echo "Database is ready!"
              break
            fi
            if [ $i -eq 24 ]; then
              echo "Database did not become ready in time"
              exit 1
            fi
            echo "Attempt $i/24: Database not ready, waiting 5 seconds..."
            sleep 5
          done
          
          # Run Alembic migrations with timeout
          cd app
          timeout 180 alembic upgrade head || {
            echo "Database migrations timed out after 3 minutes"
            exit 1
          }

      - name: Seed test data
        timeout-minutes: 3  # Data seeding should be quick
        run: |
          export DATABASE_URL="postgresql://staging:${{ secrets.STAGING_DB_PASSWORD }}@${{ steps.terraform.outputs.database_host }}/netra_pr_${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          export REDIS_URL="redis://${{ steps.terraform.outputs.redis_host }}:6379/0"
          
          timeout 150 python scripts/seed_staging_data.py \
            --pr-number "${{ github.event.pull_request.number || github.event.inputs.pr_number }}" || {
            echo "Data seeding timed out after 2.5 minutes"
            exit 1
          }

      - name: Wait for services to be healthy
        timeout-minutes: 10  # Services should be up within 10 minutes
        run: |
          STAGING_URL="${{ steps.terraform.outputs.frontend_url }}"
          API_URL="${{ steps.terraform.outputs.backend_url }}"
          
          echo "Waiting for frontend at $STAGING_URL..."
          for i in {1..30}; do
            if curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$STAGING_URL" | grep -q "200\|301\|302"; then
              echo "âœ… Frontend is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Frontend did not become ready in time"
              exit 1
            fi
            echo "Attempt $i/30: Frontend not ready yet..."
            sleep 10
          done
          
          echo "Waiting for API at $API_URL/health..."
          for i in {1..30}; do
            if curl -s --max-time 10 "$API_URL/health" | grep -q "healthy"; then
              echo "âœ… API is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ API did not become ready in time"
              exit 1
            fi
            echo "Attempt $i/30: API not ready yet..."
            sleep 10
          done

      - name: Run staging tests
        id: tests
        timeout-minutes: 15  # Tests should complete within 15 minutes
        run: |
          export STAGING_URL="${{ steps.terraform.outputs.frontend_url }}"
          export STAGING_API_URL="${{ steps.terraform.outputs.backend_url }}"
          
          # Run test suite with staging flag
          python test_runner.py \
            --level "${{ steps.config.outputs.test_level }}" \
            --staging \
            --report-format json \
            --output test_results.json
          
          # Extract summary for PR comment
          PASSED=$(jq -r '.summary.passed' test_results.json)
          FAILED=$(jq -r '.summary.failed' test_results.json)
          SKIPPED=$(jq -r '.summary.skipped' test_results.json)
          DURATION=$(jq -r '.summary.duration' test_results.json)
          
          echo "test_passed=$PASSED" >> $GITHUB_OUTPUT
          echo "test_failed=$FAILED" >> $GITHUB_OUTPUT
          echo "test_skipped=$SKIPPED" >> $GITHUB_OUTPUT
          echo "test_duration=$DURATION" >> $GITHUB_OUTPUT

      # UPDATED FOR V4: Use actions/upload-artifact@v4
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            test_results.json
            test_reports/
          retention-days: 7
          compression-level: 6  # New v4 feature for compression control

      - name: Update PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.payload.pull_request.number;
            const staging_url = '${{ steps.terraform.outputs.frontend_url }}';
            const api_url = '${{ steps.terraform.outputs.backend_url }}';
            const test_passed = '${{ steps.tests.outputs.test_passed }}';
            const test_failed = '${{ steps.tests.outputs.test_failed }}';
            const test_duration = '${{ steps.tests.outputs.test_duration }}';
            
            const test_status = test_failed === '0' ? 'âœ…' : 'âŒ';
            
            const comment = `## ðŸš€ Staging Environment Ready
            
            **Environment:** pr-${pr_number}
            **Status:** ${test_status} Deployed and Tested
            
            ### ðŸ”— Access URLs
            - **Frontend:** ${staging_url}
            - **API:** ${api_url}/docs
            - **Health:** ${api_url}/health
            
            ### ðŸ§ª Test Results
            - **Passed:** ${test_passed} tests
            - **Failed:** ${test_failed} tests
            - **Duration:** ${test_duration}s
            - **Test Level:** ${{ steps.config.outputs.test_level }}
            
            ### ðŸ“Š Resource Configuration
            - **Max Instances:** ${{ steps.config.outputs.max_instances }}
            - **Region:** ${{ env.GCP_REGION }}
            
            ### ðŸ” Access Control
            This staging environment is protected and only accessible to:
            - PR author and reviewers
            - Repository maintainers
            
            ---
            
            *This environment will be automatically destroyed when the PR is closed or merged.*
            *Last updated: ${new Date().toISOString()}*`;
            
            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Staging Environment')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                body: comment
              });
            }

      - name: Set commit status
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const test_failed = '${{ steps.tests.outputs.test_failed }}';
            const state = test_failed === '0' ? 'success' : 'failure';
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              target_url: '${{ steps.terraform.outputs.frontend_url }}',
              description: `Staging deployed with ${test_failed} test failures`,
              context: 'staging/deployment'
            });

  destroy-staging:
    name: Destroy Staging Environment
    needs: check-eligibility
    if: |
      needs.check-eligibility.outputs.should_deploy == 'false' && 
      (github.event.action == 'closed' || github.event.inputs.action == 'destroy')
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Destruction should be quick
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Export logs before destruction
        continue-on-error: true  # Continue even if log export fails
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Export Cloud Run logs (may fail if permissions are insufficient)
          if gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=staging-pr-${PR_NUMBER}" \
            --format=json \
            --project=${{ env.GCP_PROJECT_ID }} \
            > staging-logs-pr-${PR_NUMBER}.json 2>/dev/null; then
            echo "âœ… Logs exported for PR ${PR_NUMBER}"
          else
            echo "âš ï¸ Could not export logs (insufficient permissions or no logs found)"
            echo "{}" > staging-logs-pr-${PR_NUMBER}.json  # Create empty file for artifact
          fi

      # UPDATED FOR V4: Use actions/upload-artifact@v4 with unique naming
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: staging-logs-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.run_id }}
          path: staging-logs-*.json
          retention-days: 7
          compression-level: 9  # Maximum compression for logs

      - name: Terraform Destroy
        working-directory: ./terraform/staging
        run: |
          terraform init \
            -backend-config="bucket=${{ env.GCP_PROJECT_ID }}-terraform-state" \
            -backend-config="prefix=staging/pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          
          terraform destroy -auto-approve \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="pr_number=${{ github.event.pull_request.number || github.event.inputs.pr_number }}" \
            -var="backend_image=${{ steps.backend-build.outputs.backend_image || 'gcr.io/PROJECT_ID/backend:latest' }}" \
            -var="frontend_image=${{ steps.frontend-build.outputs.frontend_image || 'gcr.io/PROJECT_ID/frontend:latest' }}" \
            -var="max_instances=1" \
            -var="domain=${{ env.STAGING_DOMAIN }}" \
            -var="postgres_password=${{ secrets.STAGING_DB_PASSWORD }}"

      - name: Clean up container images
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Delete backend images
          gcloud artifacts docker images delete \
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/backend:pr-${PR_NUMBER}-* \
            --quiet || true
          
          # Delete frontend images
          gcloud artifacts docker images delete \
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/frontend:pr-${PR_NUMBER}-* \
            --quiet || true

      - name: Update PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.payload.pull_request.number;
            
            const comment = `## ðŸ§¹ Staging Environment Destroyed
            
            **Environment:** pr-${pr_number}
            **Status:** âœ… Successfully cleaned up
            **Destroyed at:** ${new Date().toISOString()}
            
            All resources associated with this staging environment have been removed.
            Logs have been archived and are available as workflow artifacts for 7 days.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: comment
            });

  cleanup-stale-environments:
    name: Cleanup Stale Environments
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Find and destroy stale environments
        run: |
          # List all Cloud Run services with staging prefix
          SERVICES=$(gcloud run services list \
            --platform=managed \
            --region=${{ env.GCP_REGION }} \
            --format="value(name)" \
            --filter="name:staging-pr-*")
          
          for SERVICE in $SERVICES; do
            # Extract PR number from service name
            PR_NUMBER=$(echo $SERVICE | grep -oP 'pr-\K[0-9]+')
            
            # Check if PR is still open
            PR_STATE=$(gh pr view $PR_NUMBER --json state -q .state 2>/dev/null || echo "CLOSED")
            
            if [[ "$PR_STATE" == "CLOSED" ]] || [[ "$PR_STATE" == "MERGED" ]]; then
              echo "Cleaning up stale environment for PR #$PR_NUMBER (state: $PR_STATE)"
              
              # Trigger destroy workflow
              gh workflow run staging-environment.yml \
                -f action=destroy \
                -f pr_number=$PR_NUMBER
            fi
          done
        env:
          GH_TOKEN: ${{ github.token }}

  # NEW JOB FOR V4: Download artifacts from other workflows
  download-previous-artifacts:
    name: Download Previous Test Results
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'redeploy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # UPDATED FOR V4: Download artifacts from previous runs with github-token
      - name: Download previous test results
        uses: actions/download-artifact@v4
        with:
          name: test-results-pr-${{ github.event.inputs.pr_number }}-*
          path: ./previous-test-results
          github-token: ${{ secrets.GITHUB_TOKEN }}  # Required for cross-run downloads in v4
          
      - name: Process previous results
        run: |
          echo "Processing previous test results..."
          ls -la ./previous-test-results/
          # Add processing logic here