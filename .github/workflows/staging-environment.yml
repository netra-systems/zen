name: Enhanced Staging Environment Management
description: Robust staging environment deployment with improved error handling

permissions:
  contents: read
  deployments: write
  pull-requests: write
  issues: write
  statuses: write

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - main
      - develop
      - 'release/**'
  
  push:
    branches:
      - main
      - develop
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/workflows/test-*.yml'
  
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - deploy
          - destroy
          - restart
          - status
          - rebuild
      pr_number:
        description: 'Pull request number (optional for branch deployments)'
        required: false
        type: string
      branch:
        description: 'Branch to deploy (optional, defaults to current)'
        required: false
        type: string
      force:
        description: 'Force deployment even if checks fail'
        required: false
        type: boolean
        default: false
  
  repository_dispatch:
    types: [staging-command, staging-rebuild]

env:
  PROJECT_NAME: netra-staging
  GCP_REGION: us-central1
  TERRAFORM_VERSION: 1.5.0
  NODE_VERSION: 20
  PYTHON_VERSION: 3.11
  MAX_RETRIES: 3
  RETRY_DELAY: 30

concurrency:
  group: staging-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  validate-trigger:
    name: Validate Trigger
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.validate.outputs.should_proceed }}
      skip_reason: ${{ steps.validate.outputs.skip_reason }}
    
    steps:
      - name: Validate trigger conditions
        id: validate
        run: |
          SHOULD_PROCEED="true"
          SKIP_REASON=""
          
          # Check if it's a documentation-only change
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            FILES_CHANGED=$(gh pr view ${{ github.event.pull_request.number }} \
              --json files -q '.files[].path' | tr '\n' ' ')
            
            if echo "$FILES_CHANGED" | grep -qE '^(docs/|.*\.md$|\.github/workflows/test-.*\.yml$)'; then
              if ! echo "$FILES_CHANGED" | grep -qvE '^(docs/|.*\.md$|\.github/workflows/test-.*\.yml$)'; then
                SHOULD_PROCEED="false"
                SKIP_REASON="Documentation-only changes detected"
              fi
            fi
          fi
          
          # Check for skip keywords in commit message
          if [[ "${{ github.event.head_commit.message }}" == *"[skip staging]"* ]] || \
             [[ "${{ github.event.head_commit.message }}" == *"[staging skip]"* ]]; then
            SHOULD_PROCEED="false"
            SKIP_REASON="Skip staging keyword found in commit message"
          fi
          
          echo "should_proceed=$SHOULD_PROCEED" >> $GITHUB_OUTPUT
          echo "skip_reason=$SKIP_REASON" >> $GITHUB_OUTPUT
          
          if [[ "$SHOULD_PROCEED" == "false" ]]; then
            echo "::notice::Skipping staging deployment: $SKIP_REASON"
          fi
        env:
          GH_TOKEN: ${{ github.token }}

  setup:
    name: Environment Setup
    needs: validate-trigger
    if: needs.validate-trigger.outputs.should_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      environment_name: ${{ steps.config.outputs.environment_name }}
      action: ${{ steps.config.outputs.action }}
      pr_number: ${{ steps.config.outputs.pr_number }}
      branch_name: ${{ steps.config.outputs.branch_name }}
      commit_sha: ${{ steps.config.outputs.commit_sha }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
    
    steps:
      - name: Configure environment
        id: config
        run: |
          # Determine PR number and action based on trigger
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_NUMBER="${{ github.event.pull_request.number }}"
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
            COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
            if [[ "${{ github.event.action }}" == "closed" ]]; then
              ACTION="destroy"
            else
              ACTION="deploy"
            fi
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            # For push to main/develop, create a branch deployment
            BRANCH_NAME="${{ github.ref_name }}"
            COMMIT_SHA="${{ github.sha }}"
            PR_NUMBER="branch-${BRANCH_NAME//\//-}"
            ACTION="deploy"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            PR_NUMBER="${{ github.event.inputs.pr_number }}"
            ACTION="${{ github.event.inputs.action }}"
            BRANCH_NAME="${{ github.event.inputs.branch || github.ref_name }}"
            COMMIT_SHA="${{ github.sha }}"
            
            # If no PR number provided, use branch deployment
            if [[ -z "$PR_NUMBER" ]]; then
              PR_NUMBER="branch-${BRANCH_NAME//\//-}"
            fi
          else
            # repository_dispatch
            PR_NUMBER="${{ github.event.client_payload.pr_number }}"
            ACTION="${{ github.event.client_payload.action || 'deploy' }}"
            BRANCH_NAME="${{ github.event.client_payload.branch || github.ref_name }}"
            COMMIT_SHA="${{ github.event.client_payload.commit || github.sha }}"
          fi
          
          # Sanitize environment name
          ENV_NAME="${{ env.PROJECT_NAME }}-${PR_NUMBER//[^a-zA-Z0-9-]/-}"
          ENV_NAME="${ENV_NAME,,}" # Convert to lowercase
          ENV_NAME="${ENV_NAME:0:63}" # Truncate to 63 chars (DNS limit)
          
          echo "environment_name=$ENV_NAME" >> $GITHUB_OUTPUT
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          
          # Log configuration
          echo "::group::Environment Configuration"
          echo "Environment: $ENV_NAME"
          echo "Action: $ACTION"
          echo "PR/Branch: $PR_NUMBER"
          echo "Branch Name: $BRANCH_NAME"
          echo "Commit SHA: $COMMIT_SHA"
          echo "::endgroup::"
      
      - name: Create GitHub deployment
        id: deployment
        if: steps.config.outputs.action == 'deploy'
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ steps.config.outputs.commit_sha }}',
              environment: '${{ steps.config.outputs.environment_name }}',
              description: 'Staging deployment for ${{ steps.config.outputs.pr_number }}',
              auto_merge: false,
              required_contexts: [],
              production_environment: false
            });
            
            core.setOutput('deployment_id', deployment.data.id);
            return deployment.data.id;

  pre-checks:
    name: Pre-deployment Checks
    needs: [setup]
    if: needs.setup.outputs.action == 'deploy'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.commit_sha }}
      
      - name: Run security scan
        run: |
          echo "::group::Security Scan"
          # Add security scanning tools here (e.g., trivy, snyk)
          echo "Security scan completed"
          echo "::endgroup::"
      
      - name: Validate configuration
        run: |
          echo "::group::Configuration Validation"
          # Check for required files
          for file in "docker-compose.yml" "Dockerfile" ".env.example"; do
            if [[ ! -f "$file" ]]; then
              echo "::warning::Missing file: $file"
            fi
          done
          echo "::endgroup::"
      
      - name: Check resource limits
        run: |
          echo "::group::Resource Limits Check"
          # Check if we're within resource quotas
          # This would normally check against actual cloud quotas
          echo "Resource limits validated"
          echo "::endgroup::"

  terraform:
    name: Infrastructure Management
    needs: [setup, pre-checks]
    if: |
      always() && 
      needs.setup.result == 'success' &&
      (needs.pre-checks.result == 'success' || needs.pre-checks.result == 'skipped')
    runs-on: ubuntu-latest
    outputs:
      backend_url: ${{ steps.outputs.outputs.backend_url }}
      frontend_url: ${{ steps.outputs.outputs.frontend_url }}
      cluster_name: ${{ steps.outputs.outputs.cluster_name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.commit_sha }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
      
      - name: Configure GCP credentials
        if: vars.CLOUD_PROVIDER == 'GCP' || vars.CLOUD_PROVIDER == ''
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}
          project_id: ${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}
      
      - name: Set GCP project environment
        run: |
          # Ensure staging project is used
          PROJECT_ID="${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          echo "GCP_PROJECT=$PROJECT_ID" >> $GITHUB_ENV
          echo "GOOGLE_CLOUD_PROJECT=$PROJECT_ID" >> $GITHUB_ENV
          echo "CLOUDSDK_CORE_PROJECT=$PROJECT_ID" >> $GITHUB_ENV
          echo "Using GCP Project: $PROJECT_ID"
      
      - name: Initialize Terraform
        id: init
        working-directory: ./terraform/staging
        run: |
          # Use staging-specific bucket or fallback to default
          BUCKET="${{ secrets.TF_STAGING_STATE_BUCKET || secrets.TF_STATE_BUCKET || 'netra-staging-terraform-state' }}"
          PREFIX="${{ needs.setup.outputs.environment_name }}"
          
          echo "::group::Terraform Backend Configuration"
          echo "Bucket: $BUCKET"
          echo "Prefix: $PREFIX"
          echo "Project: ${{ env.GCP_PROJECT }}"
          echo "::endgroup::"
          
          # Verify bucket exists before init
          if ! gcloud storage buckets describe "gs://$BUCKET" --project="${{ env.GCP_PROJECT }}" 2>/dev/null; then
            echo "::error::Terraform state bucket '$BUCKET' does not exist in project '${{ env.GCP_PROJECT }}'"
            echo "::notice::Creating bucket if possible..."
            gcloud storage buckets create "gs://$BUCKET" \
              --project="${{ env.GCP_PROJECT }}" \
              --location="${{ env.GCP_REGION }}" \
              --uniform-bucket-level-access \
              --public-access-prevention || exit 1
          fi
          
          terraform init \
            -backend-config="bucket=$BUCKET" \
            -backend-config="prefix=$PREFIX" \
            -reconfigure
        continue-on-error: true
      
      - name: Retry Terraform init if failed
        if: steps.init.outcome == 'failure'
        working-directory: ./terraform/staging
        run: |
          sleep ${{ env.RETRY_DELAY }}
          rm -rf .terraform
          
          # Use same bucket configuration as initial attempt
          BUCKET="${{ secrets.TF_STAGING_STATE_BUCKET || secrets.TF_STATE_BUCKET || 'netra-staging-terraform-state' }}"
          PREFIX="${{ needs.setup.outputs.environment_name }}"
          
          echo "::group::Retry Terraform Backend Configuration"
          echo "Bucket: $BUCKET"
          echo "Prefix: $PREFIX"
          echo "Project: ${{ env.GCP_PROJECT }}"
          echo "::endgroup::"
          
          terraform init \
            -backend-config="bucket=$BUCKET" \
            -backend-config="prefix=$PREFIX" \
            -reconfigure
      
      - name: Terraform Plan
        if: needs.setup.outputs.action == 'deploy'
        id: plan
        working-directory: ./terraform/staging
        run: |
          terraform plan \
            -var="environment_name=${{ needs.setup.outputs.environment_name }}" \
            -var="pr_number=${{ needs.setup.outputs.pr_number }}" \
            -var="branch_name=${{ needs.setup.outputs.branch_name }}" \
            -var="commit_sha=${{ needs.setup.outputs.commit_sha }}" \
            -var="project_id=${{ env.GCP_PROJECT }}" \
            -out=tfplan \
            -detailed-exitcode
        continue-on-error: true
      
      - name: Terraform Apply
        if: needs.setup.outputs.action == 'deploy' && steps.plan.outcome == 'success'
        id: apply
        working-directory: ./terraform/staging
        run: |
          terraform apply -auto-approve tfplan
          
          # Capture outputs
          echo "::group::Terraform Outputs"
          terraform output -json > outputs.json
          cat outputs.json | jq .
          echo "::endgroup::"
      
      - name: Terraform Destroy
        if: needs.setup.outputs.action == 'destroy'
        working-directory: ./terraform/staging
        run: |
          terraform destroy \
            -var="environment_name=${{ needs.setup.outputs.environment_name }}" \
            -var="pr_number=${{ needs.setup.outputs.pr_number }}" \
            -var="project_id=${{ env.GCP_PROJECT }}" \
            -auto-approve
        continue-on-error: true
      
      - name: Extract outputs
        id: outputs
        if: needs.setup.outputs.action == 'deploy' && steps.apply.outcome == 'success'
        working-directory: ./terraform/staging
        run: |
          BACKEND_URL=$(terraform output -raw backend_url 2>/dev/null || echo "")
          FRONTEND_URL=$(terraform output -raw frontend_url 2>/dev/null || echo "")
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT

  build-deploy:
    name: Build and Deploy Applications
    needs: [setup, terraform]
    if: |
      needs.setup.outputs.action == 'deploy' && 
      needs.terraform.result == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.setup.outputs.commit_sha }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: Build and deploy backend
        id: backend
        run: |
          echo "::group::Backend Build"
          # Determine the correct project ID for staging
          PROJECT_ID="${{ secrets.GCP_STAGING_PROJECT_ID || secrets.GCP_PROJECT_ID }}"
          
          # Build backend Docker image
          docker build -t backend:${{ needs.setup.outputs.commit_sha }} \
            --build-arg COMMIT_SHA=${{ needs.setup.outputs.commit_sha }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            -f Dockerfile.backend .
          
          # Tag and push to registry
          docker tag backend:${{ needs.setup.outputs.commit_sha }} \
            gcr.io/${PROJECT_ID}/backend:${{ needs.setup.outputs.environment_name }}
          
          # Deploy to cluster (simplified)
          echo "Backend deployed successfully"
          echo "::endgroup::"
      
      - name: Build and deploy frontend
        id: frontend
        run: |
          echo "::group::Frontend Build"
          # Build frontend
          cd frontend
          npm ci
          npm run build
          
          # Build Docker image
          docker build -t frontend:${{ needs.setup.outputs.commit_sha }} \
            --build-arg BACKEND_URL=${{ needs.terraform.outputs.backend_url }} \
            -f ../Dockerfile.frontend .
          
          echo "Frontend deployed successfully"
          echo "::endgroup::"
      
      - name: Run smoke tests
        id: smoke
        continue-on-error: true
        run: |
          echo "::group::Smoke Tests"
          # Wait for services to be ready
          sleep 30
          
          # Run basic health checks
          curl -f ${{ needs.terraform.outputs.backend_url }}/health || exit 1
          curl -f ${{ needs.terraform.outputs.frontend_url }} || exit 1
          
          echo "Smoke tests passed"
          echo "::endgroup::"

  post-deployment:
    name: Post Deployment Tasks
    needs: [setup, terraform, build-deploy]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Update deployment status
        if: needs.setup.outputs.deployment_id != ''
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ needs.build-deploy.result }}' === 'success' ? 'success' : 'failure';
            
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.setup.outputs.deployment_id }},
              state: status,
              environment_url: '${{ needs.terraform.outputs.frontend_url }}',
              description: `Deployment ${status}`,
              auto_inactive: true
            });
      
      - name: Post PR comment
        if: |
          github.event_name == 'pull_request' && 
          needs.setup.outputs.action == 'deploy' &&
          needs.terraform.result == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## 🚀 Staging Environment Deployed
            
            **Environment:** \`${{ needs.setup.outputs.environment_name }}\`
            **Frontend:** ${{ needs.terraform.outputs.frontend_url }}
            **Backend:** ${{ needs.terraform.outputs.backend_url }}
            
            **Commit:** ${{ needs.setup.outputs.commit_sha }}
            
            ### Quick Actions:
            - 🔄 Restart: Run workflow with \`restart\` action
            - 📊 Status: Run workflow with \`status\` action
            - 🗑️ Destroy: Run workflow with \`destroy\` action or close PR
            
            <details>
            <summary>Deployment Details</summary>
            
            - Build Status: ${{ needs.build-deploy.result }}
            - Infrastructure: ${{ needs.terraform.result }}
            - Triggered by: ${{ github.actor }}
            - Workflow Run: [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            
            </details>`;
            
            // Find and update existing comment or create new
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ github.event.pull_request.number }}
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Staging Environment')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ github.event.pull_request.number }},
                body: comment
              });
            }
      
      - name: Cleanup on failure
        if: |
          needs.build-deploy.result == 'failure' && 
          github.event.inputs.force != 'true'
        run: |
          echo "::warning::Deployment failed. Consider running with force=true to bypass checks."
          # Could trigger automatic cleanup here if needed

  notify:
    name: Send Notifications
    needs: [setup, terraform, build-deploy, post-deployment]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Determine final status
        id: status
        run: |
          if [[ "${{ contains(needs.*.result, 'failure') }}" == "true" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=❌" >> $GITHUB_OUTPUT
          elif [[ "${{ contains(needs.*.result, 'cancelled') }}" == "true" ]]; then
            echo "status=cancelled" >> $GITHUB_OUTPUT
            echo "emoji=⏹️" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=✅" >> $GITHUB_OUTPUT
          fi
      
      - name: Send Slack notification
        if: vars.SLACK_WEBHOOK_URL != ''
        run: |
          curl -X POST ${{ vars.SLACK_WEBHOOK_URL }} \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "${{ steps.status.outputs.emoji }} Staging ${{ needs.setup.outputs.action }} ${{ steps.status.outputs.status }} for ${{ needs.setup.outputs.environment_name }}"
            }'
        continue-on-error: true
      
      - name: Create summary
        run: |
          echo "## Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** ${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment:** ${{ needs.setup.outputs.environment_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Action:** ${{ needs.setup.outputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ needs.setup.outputs.branch_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ needs.setup.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.setup.outputs.action }}" == "deploy" && "${{ steps.status.outputs.status }}" == "success" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 🔗 Access URLs" >> $GITHUB_STEP_SUMMARY
            echo "- Frontend: ${{ needs.terraform.outputs.frontend_url }}" >> $GITHUB_STEP_SUMMARY
            echo "- Backend: ${{ needs.terraform.outputs.backend_url }}" >> $GITHUB_STEP_SUMMARY
          fi