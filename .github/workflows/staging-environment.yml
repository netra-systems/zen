name: Staging Environment Management

on:
  pull_request:
    types: [opened, synchronize, closed, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      action:
        description: 'Manual action'
        required: true
        type: choice
        options:
          - deploy
          - destroy
          - redeploy
      pr_number:
        description: 'PR number'
        required: true
        type: string

env:
  GCP_PROJECT_ID: netra-staging
  GCP_REGION: us-central1
  TERRAFORM_VERSION: 1.5.0
  STAGING_DOMAIN: staging.netrasystems.ai

jobs:
  check-eligibility:
    name: Check Staging Eligibility
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      environment_name: ${{ steps.check.outputs.environment_name }}
    steps:
      - name: Check labels and configuration
        id: check
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Check for exclusion labels
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'no-staging') }}" == "true" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "âŒ Staging skipped: 'no-staging' label present"
            exit 0
          fi
          
          if [[ "${{ contains(github.event.pull_request.labels.*.name, 'WIP') }}" == "true" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "âŒ Staging skipped: 'WIP' label present"
            exit 0
          fi
          
          # Check for manual trigger
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.action }}" == "destroy" ]]; then
              echo "should_deploy=false" >> $GITHUB_OUTPUT
            else
              echo "should_deploy=true" >> $GITHUB_OUTPUT
            fi
          # Check for PR close
          elif [[ "${{ github.event.action }}" == "closed" ]]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi
          
          echo "environment_name=pr-${PR_NUMBER}" >> $GITHUB_OUTPUT

  deploy-staging:
    name: Deploy Staging Environment
    needs: check-eligibility
    if: needs.check-eligibility.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45  # Prevent hanging beyond 45 minutes
    environment:
      name: staging-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}
      url: https://pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}.${{ env.STAGING_DOMAIN }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.sha }}
          fetch-depth: 0  # Fetch all history for proper change detection

      # Cache gcloud SDK installation to save ~20-30 seconds
      - name: Cache gcloud SDK
        uses: actions/cache@v4
        with:
          path: |
            ~/.config/gcloud
            ~/google-cloud-sdk
          key: gcloud-sdk-${{ runner.os }}-${{ hashFiles('.github/workflows/staging-environment.yml') }}
          restore-keys: |
            gcloud-sdk-${{ runner.os }}-

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          skip_install: false  # Still install if not cached

      - name: Configure Docker for GCP
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

      - name: Configure OAuth for PR Environment
        id: oauth
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Set OAuth environment variables for this PR
          echo "PR_NUMBER=${PR_NUMBER}" >> $GITHUB_ENV
          echo "GOOGLE_OAUTH_CLIENT_ID_STAGING=${{ secrets.GOOGLE_OAUTH_CLIENT_ID_STAGING }}" >> $GITHUB_ENV
          echo "GOOGLE_OAUTH_CLIENT_SECRET_STAGING=${{ secrets.GOOGLE_OAUTH_CLIENT_SECRET_STAGING }}" >> $GITHUB_ENV
          echo "USE_OAUTH_PROXY=true" >> $GITHUB_ENV
          echo "OAUTH_PROXY_URL=https://auth.staging.netrasystems.ai" >> $GITHUB_ENV
          
          # Generate URLs for this PR environment
          echo "frontend_url=https://pr-${PR_NUMBER}.${{ env.STAGING_DOMAIN }}" >> $GITHUB_OUTPUT
          echo "api_url=https://pr-${PR_NUMBER}-api.${{ env.STAGING_DOMAIN }}" >> $GITHUB_OUTPUT
          
          echo "âœ… OAuth configured for PR #${PR_NUMBER}"

      - name: Load staging configuration
        id: config
        run: |
          # Get the numerical project ID for Secret Manager
          PROJECT_ID_NUMERICAL_STAGING=$(gcloud projects describe ${{ env.GCP_PROJECT_ID }} --format="value(projectNumber)")
          echo "project_id_numerical=$PROJECT_ID_NUMERICAL_STAGING" >> $GITHUB_OUTPUT
          echo "Using numerical project ID: $PROJECT_ID_NUMERICAL_STAGING"
          
          # Load configuration with defaults
          if [ -f .github/staging.yml ]; then
            TEST_LEVEL=$(yq e '.default_test_level // "integration"' .github/staging.yml)
            MAX_INSTANCES=$(yq e '.resource_limits.compute.max_instances // 3' .github/staging.yml)
          else
            TEST_LEVEL="integration"
            MAX_INSTANCES="3"
          fi
          
          echo "test_level=$TEST_LEVEL" >> $GITHUB_OUTPUT
          echo "max_instances=$MAX_INSTANCES" >> $GITHUB_OUTPUT

      - name: Check for backend changes
        id: backend-changes
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          CURRENT_SHA=${{ github.sha }}
          
          # Try to get the last successful build SHA from cache
          CACHE_KEY="backend-build-cache-pr-${PR_NUMBER}"
          LAST_BUILD_SHA=""
          LAST_BUILD_IMAGE=""
          
          # Check if we have a cached build record in GCS
          if gsutil -q stat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null; then
            CACHE_DATA=$(gsutil cat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null || echo "{}")
            LAST_BUILD_SHA=$(echo "$CACHE_DATA" | jq -r '.sha // ""')
            LAST_BUILD_IMAGE=$(echo "$CACHE_DATA" | jq -r '.image // ""')
            echo "Found cached build: SHA=$LAST_BUILD_SHA"
          fi
          
          # Initialize as changed by default (safe for first commits or when unsure)
          CHANGED="true"
          CHANGED_FILES=""
          
          # If we have a last build SHA, check if files changed since then
          if [[ -n "$LAST_BUILD_SHA" ]] && [[ "$LAST_BUILD_SHA" != "null" ]]; then
            echo "Checking for changes since last successful build at $LAST_BUILD_SHA"
            
            # Check if the commit exists in our history
            if git rev-parse "$LAST_BUILD_SHA" >/dev/null 2>&1; then
              # Get files changed since last successful build
              CHANGED_FILES=$(git diff --name-only "$LAST_BUILD_SHA" HEAD 2>/dev/null || echo "force-rebuild")
            else
              echo "Last build SHA not found in history, checking all PR changes"
              CHANGED_FILES="force-rebuild"
            fi
          else
            # No cache, check all PR changes
            echo "No build cache found, checking all PR changes"
            
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              # For PRs, check ALL changes in the PR
              git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }} --depth=50
              MERGE_BASE=$(git merge-base origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              
              if [[ -n "$MERGE_BASE" ]]; then
                CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              fi
            else
              CHANGED_FILES="force-rebuild"
            fi
          fi
          
          # Debug output
          echo "Event: ${{ github.event_name }}, Action: ${{ github.event.action }}"
          echo "Current SHA: $CURRENT_SHA"
          echo "Last Build SHA: $LAST_BUILD_SHA"
          if [[ "$CHANGED_FILES" != "force-rebuild" ]]; then
            echo "Total files changed: $(echo "$CHANGED_FILES" | wc -l)"
            echo "Changed files:"
            echo "$CHANGED_FILES" | head -20
          fi
          
          # Check for backend-related changes
          if [[ "$CHANGED_FILES" == "force-rebuild" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Forcing backend rebuild"
          elif [[ -z "$CHANGED_FILES" ]]; then
            # No changes detected and we have a valid last build
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
              echo "â™»ï¸ No backend changes detected, will use cached image: $LAST_BUILD_IMAGE"
            else
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "âš ï¸ No changes but no cached image available, forcing rebuild"
            fi
          elif echo "$CHANGED_FILES" | grep -E '^(app/|requirements\.txt|Dockerfile\.backend|alembic/|pyproject\.toml|poetry\.lock)' > /dev/null 2>&1; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… Backend changes detected"
            echo "Backend files changed:"
            echo "$CHANGED_FILES" | grep -E '^(app/|requirements\.txt|Dockerfile\.backend|alembic/|pyproject\.toml|poetry\.lock)' | head -10
          else
            # No backend changes, use cached image if available
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
              echo "â™»ï¸ No backend changes detected, will use cached image: $LAST_BUILD_IMAGE"
            else
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "âš ï¸ No backend changes but no cached image available, forcing rebuild"
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build and push backend container
        id: backend-build
        timeout-minutes: 15  # Docker builds should complete within 15 minutes
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          IMAGE_TAG="pr-${PR_NUMBER}-${{ github.sha }}"
          IMAGE_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/backend:${IMAGE_TAG}"
          
          # Check if we should use cached image
          if [[ "${{ steps.backend-changes.outputs.changed }}" == "false" ]]; then
            CACHED_IMAGE="${{ steps.backend-changes.outputs.cached_image }}"
            if [[ -n "$CACHED_IMAGE" ]] && [[ "$CACHED_IMAGE" != "null" ]]; then
              echo "â™»ï¸ Using cached backend image: $CACHED_IMAGE"
              echo "backend_image=$CACHED_IMAGE" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Build new image
          echo "ðŸ”¨ Building new backend image..."
          DOCKER_BUILDKIT=1 timeout 600 docker build \
            --progress=plain \
            --network=host \
            -t $IMAGE_URL \
            -f Dockerfile.backend . || {
            echo "Docker build timed out after 10 minutes"
            echo "This might be due to network issues or pip hanging"
            exit 1
          }
          
          # Push with timeout
          timeout 300 docker push $IMAGE_URL || {
            echo "Docker push timed out after 5 minutes"
            exit 1
          }
          
          echo "backend_image=$IMAGE_URL" >> $GITHUB_OUTPUT
          
          # Update build cache
          CACHE_KEY="backend-build-cache-pr-${PR_NUMBER}"
          echo '{"sha": "'${{ github.sha }}'", "image": "'$IMAGE_URL'", "timestamp": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"}' | \
            gsutil cp - "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json"
          echo "âœ… Build cache updated"

      - name: Check for frontend changes
        id: frontend-changes
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          CURRENT_SHA=${{ github.sha }}
          
          # Try to get the last successful build SHA from cache
          CACHE_KEY="frontend-build-cache-pr-${PR_NUMBER}"
          LAST_BUILD_SHA=""
          LAST_BUILD_IMAGE=""
          
          # Check if we have a cached build record in GCS
          if gsutil -q stat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null; then
            CACHE_DATA=$(gsutil cat "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json" 2>/dev/null || echo "{}")
            LAST_BUILD_SHA=$(echo "$CACHE_DATA" | jq -r '.sha // ""')
            LAST_BUILD_IMAGE=$(echo "$CACHE_DATA" | jq -r '.image // ""')
            echo "Found cached build: SHA=$LAST_BUILD_SHA"
          fi
          
          # Initialize as changed by default (safe for first commits or when unsure)
          CHANGED="true"
          CHANGED_FILES=""
          
          # If we have a last build SHA, check if files changed since then
          if [[ -n "$LAST_BUILD_SHA" ]] && [[ "$LAST_BUILD_SHA" != "null" ]]; then
            echo "Checking for changes since last successful build at $LAST_BUILD_SHA"
            
            # Check if the commit exists in our history
            if git rev-parse "$LAST_BUILD_SHA" >/dev/null 2>&1; then
              # Get files changed since last successful build
              CHANGED_FILES=$(git diff --name-only "$LAST_BUILD_SHA" HEAD 2>/dev/null || echo "force-rebuild")
            else
              echo "Last build SHA not found in history, checking all PR changes"
              CHANGED_FILES="force-rebuild"
            fi
          else
            # No cache, check all PR changes
            echo "No build cache found, checking all PR changes"
            
            if [[ "${{ github.event_name }}" == "pull_request" ]]; then
              # For PRs, check ALL changes in the PR
              git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }} --depth=50 2>/dev/null || true
              MERGE_BASE=$(git merge-base origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              
              if [[ -n "$MERGE_BASE" ]]; then
                CHANGED_FILES=$(git diff --name-only $MERGE_BASE HEAD 2>/dev/null || echo "")
              else
                CHANGED_FILES=$(git diff --name-only origin/${{ github.event.pull_request.base.ref }} HEAD 2>/dev/null || echo "")
              fi
            else
              CHANGED_FILES="force-rebuild"
            fi
          fi
          
          # Debug output
          echo "Event: ${{ github.event_name }}, Action: ${{ github.event.action }}"
          echo "Current SHA: $CURRENT_SHA"
          echo "Last Build SHA: $LAST_BUILD_SHA"
          if [[ "$CHANGED_FILES" != "force-rebuild" ]]; then
            echo "Total files changed: $(echo "$CHANGED_FILES" | wc -l)"
            echo "Changed files:"
            echo "$CHANGED_FILES" | head -20
          fi
          
          # Check for frontend-related changes
          if [[ "$CHANGED_FILES" == "force-rebuild" ]]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Forcing frontend rebuild"
          elif [[ -z "$CHANGED_FILES" ]]; then
            # No changes detected and we have a valid last build
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
              echo "â™»ï¸ No frontend changes detected, will use cached image: $LAST_BUILD_IMAGE"
            else
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "âš ï¸ No changes but no cached image available, forcing rebuild"
            fi
          elif echo "$CHANGED_FILES" | grep -E '^frontend/' > /dev/null 2>&1; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "âœ… Frontend changes detected"
            echo "Frontend files changed:"
            echo "$CHANGED_FILES" | grep -E '^frontend/' | head -10
          else
            # No frontend changes, use cached image if available
            if [[ -n "$LAST_BUILD_IMAGE" ]] && [[ "$LAST_BUILD_IMAGE" != "null" ]]; then
              echo "changed=false" >> $GITHUB_OUTPUT
              echo "cached_image=$LAST_BUILD_IMAGE" >> $GITHUB_OUTPUT
              echo "â™»ï¸ No frontend changes detected, will use cached image: $LAST_BUILD_IMAGE"
            else
              echo "changed=true" >> $GITHUB_OUTPUT
              echo "âš ï¸ No frontend changes but no cached image available, forcing rebuild"
            fi
          fi
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Build and push frontend container
        id: frontend-build
        timeout-minutes: 15  # Frontend builds should complete within 15 minutes
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          IMAGE_TAG="pr-${PR_NUMBER}-${{ github.sha }}"
          IMAGE_URL="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/frontend:${IMAGE_TAG}"
          
          # Check if we should use cached image
          if [[ "${{ steps.frontend-changes.outputs.changed }}" == "false" ]]; then
            CACHED_IMAGE="${{ steps.frontend-changes.outputs.cached_image }}"
            if [[ -n "$CACHED_IMAGE" ]] && [[ "$CACHED_IMAGE" != "null" ]]; then
              echo "â™»ï¸ Using cached frontend image: $CACHED_IMAGE"
              echo "frontend_image=$CACHED_IMAGE" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Build new image
          echo "ðŸ”¨ Building new frontend image..."
          
          # Check if we're in the root directory and Dockerfile.frontend is in frontend/
          if [[ -f "frontend/Dockerfile.frontend" ]]; then
            cd frontend
            DOCKER_BUILDKIT=1 timeout 600 docker build \
              --progress=plain \
              --network=host \
              -t $IMAGE_URL \
              -f Dockerfile.frontend \
              --build-arg NEXT_PUBLIC_API_URL=https://pr-${PR_NUMBER}-api.${{ env.STAGING_DOMAIN }} . || {
              echo "Frontend Docker build timed out after 10 minutes"
              exit 1
            }
            cd ..
          elif [[ -f "Dockerfile.frontend" ]]; then
            # Fallback if Dockerfile.frontend is in root
            DOCKER_BUILDKIT=1 timeout 600 docker build \
              --progress=plain \
              --network=host \
              -t $IMAGE_URL \
              -f Dockerfile.frontend \
              --build-arg NEXT_PUBLIC_API_URL=https://pr-${PR_NUMBER}-api.${{ env.STAGING_DOMAIN }} . || {
              echo "Frontend Docker build timed out after 10 minutes"
              exit 1
            }
          else
            echo "âŒ Error: Dockerfile.frontend not found in expected locations"
            exit 1
          fi
          
          # Push with timeout
          timeout 300 docker push $IMAGE_URL || {
            echo "Docker push timed out after 5 minutes"
            exit 1
          }
          
          echo "frontend_image=$IMAGE_URL" >> $GITHUB_OUTPUT
          
          # Update build cache
          CACHE_KEY="frontend-build-cache-pr-${PR_NUMBER}"
          echo '{"sha": "'${{ github.sha }}'", "image": "'$IMAGE_URL'", "timestamp": "'$(date -u +"%Y-%m-%dT%H:%M:%SZ")'"}' | \
            gsutil cp - "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/${CACHE_KEY}.json"
          echo "âœ… Build cache updated"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        working-directory: ./terraform/staging
        timeout-minutes: 5
        run: |
          # Check for state lock and clear if stale
          LOCK_FILE="gs://${{ env.GCP_PROJECT_ID }}-terraform-state/staging/pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}/default.tflock"
          
          # Check if lock exists and is older than 30 minutes
          if gsutil stat "$LOCK_FILE" 2>/dev/null; then
            LOCK_AGE=$(gsutil stat "$LOCK_FILE" | grep "Creation time:" | cut -d':' -f2- | xargs -I {} date -d "{}" +%s)
            CURRENT_TIME=$(date +%s)
            AGE_MINUTES=$(( ($CURRENT_TIME - $LOCK_AGE) / 60 ))
            
            if [ $AGE_MINUTES -gt 30 ]; then
              echo "âš ï¸ Found stale lock file (${AGE_MINUTES} minutes old), removing..."
              gsutil rm "$LOCK_FILE" || true
            else
              echo "âš ï¸ Active lock file found (${AGE_MINUTES} minutes old)"
              echo "Another Terraform operation may be in progress"
            fi
          fi
          
          # Initialize with lock timeout
          terraform init \
            -backend-config="bucket=${{ env.GCP_PROJECT_ID }}-terraform-state" \
            -backend-config="prefix=staging/pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}" \
            -lock-timeout=120s

      - name: Terraform Plan
        working-directory: ./terraform/staging
        timeout-minutes: 5
        run: |
          terraform plan \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="project_id_numerical=${{ steps.config.outputs.project_id_numerical }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="pr_number=${{ github.event.pull_request.number || github.event.inputs.pr_number }}" \
            -var="backend_image=${{ steps.backend-build.outputs.backend_image }}" \
            -var="frontend_image=${{ steps.frontend-build.outputs.frontend_image }}" \
            -var="max_instances=${{ steps.config.outputs.max_instances }}" \
            -var="domain=${{ env.STAGING_DOMAIN }}" \
            -var="postgres_password=${{ secrets.STAGING_DB_PASSWORD }}" \
            -lock-timeout=120s \
            -out=tfplan

      - name: Terraform Apply
        working-directory: ./terraform/staging
        id: terraform
        timeout-minutes: 20  # Terraform should complete within 20 minutes
        run: |
          # Set timeout for terraform apply itself
          timeout 1200 terraform apply -auto-approve tfplan || {
            echo "Terraform apply timed out after 20 minutes"
            echo "Attempting to show current state..."
            terraform show
            exit 1
          }
          
          # Capture outputs
          BACKEND_URL=$(terraform output -raw backend_url)
          FRONTEND_URL=$(terraform output -raw frontend_url)
          DATABASE_HOST=$(terraform output -raw database_host)
          REDIS_HOST=$(terraform output -raw redis_host)
          
          echo "backend_url=$BACKEND_URL" >> $GITHUB_OUTPUT
          echo "frontend_url=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "database_host=$DATABASE_HOST" >> $GITHUB_OUTPUT
          echo "redis_host=$REDIS_HOST" >> $GITHUB_OUTPUT

      - name: Run database migrations
        timeout-minutes: 5  # Migrations should complete quickly
        run: |
          # Set database URL for migrations
          export DATABASE_URL="postgresql://staging:${{ secrets.STAGING_DB_PASSWORD }}@${{ steps.terraform.outputs.database_host }}/netra_pr_${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          
          # Wait for database to be ready (max 2 minutes)
          echo "Waiting for database to be ready..."
          for i in {1..24}; do
            if pg_isready -h "${{ steps.terraform.outputs.database_host }}" -p 5432 -U staging 2>/dev/null; then
              echo "Database is ready!"
              break
            fi
            if [ $i -eq 24 ]; then
              echo "Database did not become ready in time"
              exit 1
            fi
            echo "Attempt $i/24: Database not ready, waiting 5 seconds..."
            sleep 5
          done
          
          # Run Alembic migrations with timeout
          cd app
          timeout 180 alembic upgrade head || {
            echo "Database migrations timed out after 3 minutes"
            exit 1
          }

      - name: Seed test data
        timeout-minutes: 3  # Data seeding should be quick
        run: |
          export DATABASE_URL="postgresql://staging:${{ secrets.STAGING_DB_PASSWORD }}@${{ steps.terraform.outputs.database_host }}/netra_pr_${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          export REDIS_URL="redis://${{ steps.terraform.outputs.redis_host }}:6379/0"
          
          timeout 150 python scripts/seed_staging_data.py \
            --pr-number "${{ github.event.pull_request.number || github.event.inputs.pr_number }}" || {
            echo "Data seeding timed out after 2.5 minutes"
            exit 1
          }

      - name: Wait for services to be healthy
        timeout-minutes: 10  # Services should be up within 10 minutes
        run: |
          STAGING_URL="${{ steps.terraform.outputs.frontend_url }}"
          API_URL="${{ steps.terraform.outputs.backend_url }}"
          
          echo "Waiting for frontend at $STAGING_URL..."
          for i in {1..30}; do
            if curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$STAGING_URL" | grep -q "200\|301\|302"; then
              echo "âœ… Frontend is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ Frontend did not become ready in time"
              exit 1
            fi
            echo "Attempt $i/30: Frontend not ready yet..."
            sleep 10
          done
          
          echo "Waiting for API at $API_URL/health..."
          for i in {1..30}; do
            if curl -s --max-time 10 "$API_URL/health" | grep -q "healthy"; then
              echo "âœ… API is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "âŒ API did not become ready in time"
              exit 1
            fi
            echo "Attempt $i/30: API not ready yet..."
            sleep 10
          done

      - name: Run staging tests
        id: tests
        timeout-minutes: 15  # Tests should complete within 15 minutes
        run: |
          export STAGING_URL="${{ steps.terraform.outputs.frontend_url }}"
          export STAGING_API_URL="${{ steps.terraform.outputs.backend_url }}"
          
          # Run test suite with staging flag
          python test_runner.py \
            --level "${{ steps.config.outputs.test_level }}" \
            --staging \
            --report-format json \
            --output test_results.json
          
          # Extract summary for PR comment
          PASSED=$(jq -r '.summary.passed' test_results.json)
          FAILED=$(jq -r '.summary.failed' test_results.json)
          SKIPPED=$(jq -r '.summary.skipped' test_results.json)
          DURATION=$(jq -r '.summary.duration' test_results.json)
          
          echo "test_passed=$PASSED" >> $GITHUB_OUTPUT
          echo "test_failed=$FAILED" >> $GITHUB_OUTPUT
          echo "test_skipped=$SKIPPED" >> $GITHUB_OUTPUT
          echo "test_duration=$DURATION" >> $GITHUB_OUTPUT

      # UPDATED FOR V4: Use actions/upload-artifact@v4
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            test_results.json
            test_reports/
          retention-days: 7
          compression-level: 6  # New v4 feature for compression control

      - name: Update PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.payload.pull_request.number;
            const staging_url = '${{ steps.terraform.outputs.frontend_url }}';
            const api_url = '${{ steps.terraform.outputs.backend_url }}';
            const test_passed = '${{ steps.tests.outputs.test_passed }}';
            const test_failed = '${{ steps.tests.outputs.test_failed }}';
            const test_duration = '${{ steps.tests.outputs.test_duration }}';
            
            const test_status = test_failed === '0' ? 'âœ…' : 'âŒ';
            
            const comment = `## ðŸš€ Staging Environment Ready
            
            **Environment:** pr-${pr_number}
            **Status:** ${test_status} Deployed and Tested
            
            ### ðŸ”— Access URLs
            - **Frontend:** ${staging_url}
            - **API:** ${api_url}/docs
            - **Health:** ${api_url}/health
            
            ### ðŸ§ª Test Results
            - **Passed:** ${test_passed} tests
            - **Failed:** ${test_failed} tests
            - **Duration:** ${test_duration}s
            - **Test Level:** ${{ steps.config.outputs.test_level }}
            
            ### ðŸ“Š Resource Configuration
            - **Max Instances:** ${{ steps.config.outputs.max_instances }}
            - **Region:** ${{ env.GCP_REGION }}
            
            ### ðŸ” Access Control
            This staging environment is protected and only accessible to:
            - PR author and reviewers
            - Repository maintainers
            
            ---
            
            *This environment will be automatically destroyed when the PR is closed or merged.*
            *Last updated: ${new Date().toISOString()}*`;
            
            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Staging Environment')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr_number,
                body: comment
              });
            }

      - name: Set commit status
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const test_failed = '${{ steps.tests.outputs.test_failed }}';
            const state = test_failed === '0' ? 'success' : 'failure';
            
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.payload.pull_request.head.sha,
              state: state,
              target_url: '${{ steps.terraform.outputs.frontend_url }}',
              description: `Staging deployed with ${test_failed} test failures`,
              context: 'staging/deployment'
            });

  destroy-staging:
    name: Destroy Staging Environment
    needs: check-eligibility
    if: |
      needs.check-eligibility.outputs.should_deploy == 'false' && 
      (github.event.action == 'closed' || github.event.inputs.action == 'destroy')
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Destruction should be quick
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Export logs before destruction
        continue-on-error: true  # Continue even if log export fails
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Export Cloud Run logs (may fail if permissions are insufficient)
          if gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=staging-pr-${PR_NUMBER}" \
            --format=json \
            --project=${{ env.GCP_PROJECT_ID }} \
            > staging-logs-pr-${PR_NUMBER}.json 2>/dev/null; then
            echo "âœ… Logs exported for PR ${PR_NUMBER}"
          else
            echo "âš ï¸ Could not export logs (insufficient permissions or no logs found)"
            echo "{}" > staging-logs-pr-${PR_NUMBER}.json  # Create empty file for artifact
          fi

      # UPDATED FOR V4: Use actions/upload-artifact@v4 with unique naming
      - name: Upload logs
        uses: actions/upload-artifact@v4
        with:
          name: staging-logs-pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}-${{ github.run_id }}
          path: staging-logs-*.json
          retention-days: 7
          compression-level: 9  # Maximum compression for logs

      - name: Terraform Destroy
        working-directory: ./terraform/staging
        run: |
          terraform init \
            -backend-config="bucket=${{ env.GCP_PROJECT_ID }}-terraform-state" \
            -backend-config="prefix=staging/pr-${{ github.event.pull_request.number || github.event.inputs.pr_number }}"
          
          terraform destroy -auto-approve \
            -var="project_id=${{ env.GCP_PROJECT_ID }}" \
            -var="region=${{ env.GCP_REGION }}" \
            -var="pr_number=${{ github.event.pull_request.number || github.event.inputs.pr_number }}" \
            -var="backend_image=${{ steps.backend-build.outputs.backend_image || 'gcr.io/PROJECT_ID/backend:latest' }}" \
            -var="frontend_image=${{ steps.frontend-build.outputs.frontend_image || 'gcr.io/PROJECT_ID/frontend:latest' }}" \
            -var="max_instances=1" \
            -var="domain=${{ env.STAGING_DOMAIN }}" \
            -var="postgres_password=${{ secrets.STAGING_DB_PASSWORD }}"

      - name: Clean up container images and build cache
        run: |
          PR_NUMBER=${{ github.event.pull_request.number || github.event.inputs.pr_number }}
          
          # Delete backend images
          gcloud artifacts docker images delete \
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/backend:pr-${PR_NUMBER}-* \
            --quiet || true
          
          # Delete frontend images
          gcloud artifacts docker images delete \
            ${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/staging/frontend:pr-${PR_NUMBER}-* \
            --quiet || true
          
          # Clean up build cache files
          echo "Cleaning up build cache for PR #${PR_NUMBER}..."
          gsutil rm "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/backend-build-cache-pr-${PR_NUMBER}.json" 2>/dev/null || true
          gsutil rm "gs://${{ env.GCP_PROJECT_ID }}-terraform-state/build-cache/frontend-build-cache-pr-${PR_NUMBER}.json" 2>/dev/null || true
          echo "âœ… Build cache cleaned up"

      - name: Update PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.payload.pull_request.number;
            
            const comment = `## ðŸ§¹ Staging Environment Destroyed
            
            **Environment:** pr-${pr_number}
            **Status:** âœ… Successfully cleaned up
            **Destroyed at:** ${new Date().toISOString()}
            
            All resources associated with this staging environment have been removed.
            Logs have been archived and are available as workflow artifacts for 7 days.`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr_number,
              body: comment
            });

  cleanup-stale-environments:
    name: Cleanup Stale Environments
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Find and destroy stale environments
        run: |
          # List all Cloud Run services with staging prefix
          SERVICES=$(gcloud run services list \
            --platform=managed \
            --region=${{ env.GCP_REGION }} \
            --format="value(name)" \
            --filter="name:staging-pr-*")
          
          for SERVICE in $SERVICES; do
            # Extract PR number from service name
            PR_NUMBER=$(echo $SERVICE | grep -oP 'pr-\K[0-9]+')
            
            # Check if PR is still open
            PR_STATE=$(gh pr view $PR_NUMBER --json state -q .state 2>/dev/null || echo "CLOSED")
            
            if [[ "$PR_STATE" == "CLOSED" ]] || [[ "$PR_STATE" == "MERGED" ]]; then
              echo "Cleaning up stale environment for PR #$PR_NUMBER (state: $PR_STATE)"
              
              # Trigger destroy workflow
              gh workflow run staging-environment.yml \
                -f action=destroy \
                -f pr_number=$PR_NUMBER
            fi
          done
        env:
          GH_TOKEN: ${{ github.token }}

  # NEW JOB FOR V4: Download artifacts from other workflows
  download-previous-artifacts:
    name: Download Previous Test Results
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'redeploy'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      # UPDATED FOR V4: Download artifacts from previous runs with github-token
      - name: Download previous test results
        uses: actions/download-artifact@v4
        with:
          name: test-results-pr-${{ github.event.inputs.pr_number }}-*
          path: ./previous-test-results
          github-token: ${{ secrets.GITHUB_TOKEN }}  # Required for cross-run downloads in v4
          
      - name: Process previous results
        run: |
          echo "Processing previous test results..."
          ls -la ./previous-test-results/
          # Add processing logic here