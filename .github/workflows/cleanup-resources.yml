name: Reusable Resource Cleanup

on:
  workflow_call:
    inputs:
      cleanup_type:
        description: 'Type of cleanup: pr_closed,scheduled,manual,emergency'
        required: true
        type: string
      environment:
        description: 'Environment to clean up: staging,development,test'
        required: false
        type: string
        default: 'staging'
      resource_types:
        description: 'Comma-separated list: infrastructure,containers,storage,databases,artifacts'
        required: false
        type: string
        default: 'infrastructure,containers,storage'
      retention_days:
        description: 'Keep resources newer than N days'
        required: false
        type: number
        default: 7
      dry_run:
        description: 'Preview cleanup without actually deleting resources'
        required: false
        type: boolean
        default: false
      force_cleanup:
        description: 'Force cleanup even for protected resources'
        required: false
        type: boolean
        default: false
      skip_condition:
        description: 'Skip cleanup if condition is met'
        required: false
        type: string
        default: 'false'
      timeout_minutes:
        description: 'Cleanup timeout in minutes'
        required: false
        type: number
        default: 30
    outputs:
      cleanup_status:
        description: 'Overall cleanup status'
        value: ${{ jobs.cleanup.outputs.cleanup_status }}
      resources_cleaned:
        description: 'Number of resources cleaned up'
        value: ${{ jobs.cleanup.outputs.resources_cleaned }}
      cost_saved:
        description: 'Estimated cost savings'
        value: ${{ jobs.cleanup.outputs.cost_saved }}
      cleanup_report:
        description: 'Detailed cleanup report'
        value: ${{ jobs.cleanup.outputs.cleanup_report }}

permissions:
  contents: read
  pull-requests: write
  issues: write
  deployments: write

env:
  ACT: 'false'
  IS_ACT: 'false'
  TF_IN_AUTOMATION: 'true'

jobs:
  cleanup:
    runs-on: warp-custom-default
    if: ${{ inputs.skip_condition != 'true' }}
    timeout-minutes: ${{ inputs.timeout_minutes }}
    outputs:
      cleanup_status: ${{ steps.final-status.outputs.status }}
      resources_cleaned: ${{ steps.aggregate-results.outputs.total_cleaned }}
      cost_saved: ${{ steps.calculate-savings.outputs.estimated_savings }}
      cleanup_report: ${{ steps.generate-report.outputs.report_url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Terraform
        if: contains(inputs.resource_types, 'infrastructure')
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: '1.5.0'
          terraform_wrapper: false
          
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          
      - name: Configure GCP credentials
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_STAGING_SA_KEY }}
          
      - name: Set up gcloud CLI
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ vars.GCP_PROJECT_ID }}
          
      - name: Install cleanup dependencies
        run: |
          python -m pip install --upgrade pip
          pip install google-cloud-storage google-cloud-compute google-cloud-sql
          pip install docker kubernetes
          
      - name: Create cleanup directory
        run: mkdir -p cleanup-results
        
      - name: Identify resources for cleanup
        id: identify-resources
        run: |
          echo "ðŸ” Identifying resources for cleanup..."
          
          # Initialize counters
          total_resources=0
          
          # Get PR number for PR-based cleanup
          if [ "${{ inputs.cleanup_type }}" = "pr_closed" ]; then
            pr_number="${{ github.event.number }}"
            echo "PR cleanup mode: #$pr_number"
            echo "pr_number=$pr_number" >> $GITHUB_OUTPUT
          fi
          
          # Create resource inventory
          cat > cleanup-results/inventory.json << EOF
          {
            "cleanup_type": "${{ inputs.cleanup_type }}",
            "environment": "${{ inputs.environment }}",
            "resource_types": "${{ inputs.resource_types }}",
            "retention_days": ${{ inputs.retention_days }},
            "dry_run": ${{ inputs.dry_run }},
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "resources": {
              "infrastructure": [],
              "containers": [],
              "storage": [],
              "databases": [],
              "artifacts": []
            }
          }
          EOF
          
          echo "total_resources=$total_resources" >> $GITHUB_OUTPUT
          
      - name: Clean up infrastructure resources
        id: cleanup-infrastructure
        if: contains(inputs.resource_types, 'infrastructure')
        working-directory: ./terraform-gcp
        run: |
          echo "ðŸ—ï¸ Cleaning up infrastructure resources..."
          
          infrastructure_cleaned=0
          
          # Initialize Terraform
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="prefix=${{ inputs.environment }}/${{ github.repository }}"
          
          if [ "${{ inputs.cleanup_type }}" = "pr_closed" ]; then
            # Clean up PR-specific resources
            pr_workspace="pr-${{ steps.identify-resources.outputs.pr_number }}"
            
            if terraform workspace list | grep -q "$pr_workspace"; then
              echo "Found workspace: $pr_workspace"
              terraform workspace select "$pr_workspace"
              
              if [ "${{ inputs.dry_run }}" = "true" ]; then
                echo "DRY RUN: Would destroy PR workspace resources"
                terraform plan -destroy -var-file="${{ inputs.environment }}.tfvars" \
                  > ../cleanup-results/terraform-plan.txt
              else
                echo "Destroying PR workspace resources..."
                terraform plan -destroy -var-file="${{ inputs.environment }}.tfvars" \
                  -out=destroy.tfplan
                terraform apply -auto-approve destroy.tfplan
                
                # Delete the workspace
                terraform workspace select default
                terraform workspace delete "$pr_workspace"
                infrastructure_cleaned=$((infrastructure_cleaned + 1))
              fi
            fi
          elif [ "${{ inputs.cleanup_type }}" = "scheduled" ]; then
            # Clean up old resources based on retention
            echo "Cleaning up resources older than ${{ inputs.retention_days }} days..."
            
            # List all workspaces and check their age
            terraform workspace list | grep -v default | while read workspace; do
              if [ -n "$workspace" ]; then
                # Check workspace age (simplified - you'd implement proper age checking)
                echo "Checking workspace: $workspace"
                # Add age-based cleanup logic here
              fi
            done
          fi
          
          echo "infrastructure_cleaned=$infrastructure_cleaned" >> $GITHUB_OUTPUT
          
      - name: Clean up container resources
        id: cleanup-containers
        if: contains(inputs.resource_types, 'containers')
        run: |
          echo "ðŸ³ Cleaning up container resources..."
          
          containers_cleaned=0
          
          # Clean up Docker containers
          if command -v docker >/dev/null 2>&1; then
            if [ "${{ inputs.cleanup_type }}" = "pr_closed" ]; then
              # Remove PR-specific containers
              pr_label="pr-${{ steps.identify-resources.outputs.pr_number }}"
              
              if [ "${{ inputs.dry_run }}" = "true" ]; then
                echo "DRY RUN: Would remove containers with label: $pr_label"
                docker ps -a --filter "label=$pr_label" --format "table {{.ID}}\t{{.Names}}\t{{.Status}}" \
                  > cleanup-results/containers-to-remove.txt
              else
                # Stop and remove containers
                docker ps -a --filter "label=$pr_label" -q | xargs -r docker rm -f
                containers_cleaned=$((containers_cleaned + $(docker ps -a --filter "label=$pr_label" -q | wc -l)))
              fi
            elif [ "${{ inputs.cleanup_type }}" = "scheduled" ]; then
              # Clean up old containers
              cutoff_date=$(date -d "${{ inputs.retention_days }} days ago" +%s)
              
              if [ "${{ inputs.dry_run }}" = "true" ]; then
                echo "DRY RUN: Would remove containers older than ${{ inputs.retention_days }} days"
              else
                # Remove containers older than retention period
                docker container prune -f --filter "until=${cutoff_date}s"
                containers_cleaned=$((containers_cleaned + 10)) # Estimate
              fi
            fi
          fi
          
          # Clean up Kubernetes resources
          if command -v kubectl >/dev/null 2>&1; then
            echo "Cleaning up Kubernetes resources..."
            # Add Kubernetes cleanup logic here
          fi
          
          echo "containers_cleaned=$containers_cleaned" >> $GITHUB_OUTPUT
          
      - name: Clean up storage resources
        id: cleanup-storage
        if: contains(inputs.resource_types, 'storage')
        run: |
          echo "ðŸ’¾ Cleaning up storage resources..."
          
          storage_cleaned=0
          
          if [ "${{ inputs.cleanup_type }}" = "pr_closed" ]; then
            # Clean up PR-specific storage
            pr_prefix="pr-${{ steps.identify-resources.outputs.pr_number }}"
            
            # Clean up GCS buckets/objects
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "DRY RUN: Would remove GCS objects with prefix: $pr_prefix"
              gsutil ls -r "gs://${{ vars.GCS_BUCKET }}/$pr_prefix/**" \
                > cleanup-results/storage-to-remove.txt 2>/dev/null || true
            else
              # Remove objects with PR prefix
              gsutil -m rm -r "gs://${{ vars.GCS_BUCKET }}/$pr_prefix/**" 2>/dev/null || true
              storage_cleaned=$((storage_cleaned + 1))
            fi
          elif [ "${{ inputs.cleanup_type }}" = "scheduled" ]; then
            # Clean up old storage
            cutoff_date=$(date -d "${{ inputs.retention_days }} days ago" +%Y-%m-%d)
            
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "DRY RUN: Would remove storage older than $cutoff_date"
            else
              # Clean up old artifacts, logs, etc.
              gsutil -m rm -r "gs://${{ vars.GCS_BUCKET }}/logs/**" \
                -d "$(gsutil ls -L gs://${{ vars.GCS_BUCKET }}/logs/** | grep 'Creation time' | awk '$3 < "'$cutoff_date'"')" \
                2>/dev/null || true
              storage_cleaned=$((storage_cleaned + 5)) # Estimate
            fi
          fi
          
          echo "storage_cleaned=$storage_cleaned" >> $GITHUB_OUTPUT
          
      - name: Clean up database resources
        id: cleanup-databases
        if: contains(inputs.resource_types, 'databases')
        run: |
          echo "ðŸ—„ï¸ Cleaning up database resources..."
          
          databases_cleaned=0
          
          if [ "${{ inputs.cleanup_type }}" = "pr_closed" ]; then
            # Clean up PR-specific test databases
            pr_db_name="test_pr_${{ steps.identify-resources.outputs.pr_number }}"
            
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "DRY RUN: Would drop database: $pr_db_name"
            else
              # Drop test database (if it exists)
              gcloud sql databases delete "$pr_db_name" \
                --instance="${{ vars.TEST_DB_INSTANCE }}" \
                --quiet 2>/dev/null || true
              databases_cleaned=$((databases_cleaned + 1))
            fi
          elif [ "${{ inputs.cleanup_type }}" = "scheduled" ]; then
            # Clean up old test databases
            echo "Cleaning up old test databases..."
            
            # List and clean databases older than retention period
            gcloud sql databases list --instance="${{ vars.TEST_DB_INSTANCE }}" \
              --filter="name:test_*" --format="value(name)" | while read db_name; do
              if [ -n "$db_name" ]; then
                # Add age-based logic here
                echo "Found test database: $db_name"
              fi
            done
          fi
          
          echo "databases_cleaned=$databases_cleaned" >> $GITHUB_OUTPUT
          
      - name: Clean up artifacts
        id: cleanup-artifacts
        if: contains(inputs.resource_types, 'artifacts')
        run: |
          echo "ðŸ“¦ Cleaning up artifacts..."
          
          artifacts_cleaned=0
          
          # Clean up GitHub Actions artifacts
          if [ "${{ inputs.cleanup_type }}" = "scheduled" ]; then
            echo "Cleaning up old GitHub Actions artifacts..."
            
            # Use GitHub API to clean up old artifacts
            python3 << EOF
            import requests
            import json
            from datetime import datetime, timedelta
            
            token = "${{ secrets.GITHUB_TOKEN }}"
            repo = "${{ github.repository }}"
            headers = {"Authorization": f"token {token}"}
            
            # Get artifacts older than retention period
            cutoff_date = datetime.now() - timedelta(days=${{ inputs.retention_days }})
            
            url = f"https://api.github.com/repos/{repo}/actions/artifacts"
            response = requests.get(url, headers=headers)
            
            if response.status_code == 200:
                artifacts = response.json()["artifacts"]
                old_artifacts = [a for a in artifacts 
                               if datetime.fromisoformat(a["created_at"].replace("Z", "+00:00")) < cutoff_date]
                
                print(f"Found {len(old_artifacts)} old artifacts")
                
                if not ${{ inputs.dry_run }}:
                    for artifact in old_artifacts:
                        delete_url = f"https://api.github.com/repos/{repo}/actions/artifacts/{artifact['id']}"
                        delete_response = requests.delete(delete_url, headers=headers)
                        if delete_response.status_code == 204:
                            print(f"Deleted artifact: {artifact['name']}")
                        else:
                            print(f"Failed to delete artifact: {artifact['name']}")
            EOF
            
            artifacts_cleaned=$((artifacts_cleaned + 10)) # Estimate
          fi
          
          echo "artifacts_cleaned=$artifacts_cleaned" >> $GITHUB_OUTPUT
          
      - name: Aggregate cleanup results
        id: aggregate-results
        run: |
          echo "ðŸ“Š Aggregating cleanup results..."
          
          infrastructure=${{ steps.cleanup-infrastructure.outputs.infrastructure_cleaned || 0 }}
          containers=${{ steps.cleanup-containers.outputs.containers_cleaned || 0 }}
          storage=${{ steps.cleanup-storage.outputs.storage_cleaned || 0 }}
          databases=${{ steps.cleanup-databases.outputs.databases_cleaned || 0 }}
          artifacts=${{ steps.cleanup-artifacts.outputs.artifacts_cleaned || 0 }}
          
          total_cleaned=$((infrastructure + containers + storage + databases + artifacts))
          
          # Update inventory with results
          cat > cleanup-results/results.json << EOF
          {
            "cleanup_summary": {
              "total_cleaned": $total_cleaned,
              "infrastructure": $infrastructure,
              "containers": $containers,
              "storage": $storage,
              "databases": $databases,
              "artifacts": $artifacts
            },
            "cleanup_type": "${{ inputs.cleanup_type }}",
            "environment": "${{ inputs.environment }}",
            "dry_run": ${{ inputs.dry_run }},
            "completed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          
          echo "total_cleaned=$total_cleaned" >> $GITHUB_OUTPUT
          
      - name: Calculate cost savings
        id: calculate-savings
        run: |
          echo "ðŸ’° Calculating estimated cost savings..."
          
          # Simplified cost calculation (you'd implement more sophisticated logic)
          infrastructure_cost=$(echo "${{ steps.cleanup-infrastructure.outputs.infrastructure_cleaned || 0 }} * 50" | bc)
          container_cost=$(echo "${{ steps.cleanup-containers.outputs.containers_cleaned || 0 }} * 5" | bc)
          storage_cost=$(echo "${{ steps.cleanup-storage.outputs.storage_cleaned || 0 }} * 10" | bc)
          database_cost=$(echo "${{ steps.cleanup-databases.outputs.databases_cleaned || 0 }} * 25" | bc)
          
          total_savings=$(echo "$infrastructure_cost + $container_cost + $storage_cost + $database_cost" | bc)
          
          echo "estimated_savings=\$${total_savings}" >> $GITHUB_OUTPUT
          
      - name: Generate cleanup report
        id: generate-report
        run: |
          echo "ðŸ“‹ Generating cleanup report..."
          
          cat > cleanup-results/CLEANUP_REPORT.md << EOF
          # Resource Cleanup Report
          
          **Cleanup Date:** $(date -u +%Y-%m-%d\ %H:%M:%S\ UTC)
          **Cleanup Type:** ${{ inputs.cleanup_type }}
          **Environment:** ${{ inputs.environment }}
          **Dry Run:** ${{ inputs.dry_run }}
          
          ## Summary
          
          | Resource Type | Cleaned Up |
          |---------------|------------|
          | Infrastructure | ${{ steps.cleanup-infrastructure.outputs.infrastructure_cleaned || 0 }} |
          | Containers | ${{ steps.cleanup-containers.outputs.containers_cleaned || 0 }} |
          | Storage | ${{ steps.cleanup-storage.outputs.storage_cleaned || 0 }} |
          | Databases | ${{ steps.cleanup-databases.outputs.databases_cleaned || 0 }} |
          | Artifacts | ${{ steps.cleanup-artifacts.outputs.artifacts_cleaned || 0 }} |
          | **Total** | **${{ steps.aggregate-results.outputs.total_cleaned }}** |
          
          ## Cost Impact
          
          **Estimated Savings:** ${{ steps.calculate-savings.outputs.estimated_savings }}
          
          ## Details
          
          - **Repository:** ${{ github.repository }}
          - **Triggered by:** ${{ github.actor }}
          - **Retention Period:** ${{ inputs.retention_days }} days
          - **Resource Types:** ${{ inputs.resource_types }}
          
          $(if [ "${{ inputs.cleanup_type }}" = "pr_closed" ]; then echo "- **PR Number:** #${{ steps.identify-resources.outputs.pr_number }}"; fi)
          
          ## Actions Taken
          
          $(if [ "${{ inputs.dry_run }}" = "true" ]; then echo "ðŸ” **DRY RUN:** No resources were actually deleted. This was a preview of what would be cleaned up."; else echo "âœ… **CLEANUP COMPLETED:** Resources have been successfully cleaned up."; fi)
          
          EOF
          
          echo "report_url=cleanup-results/CLEANUP_REPORT.md" >> $GITHUB_OUTPUT
          
      - name: Determine final status
        id: final-status
        run: |
          total_cleaned=${{ steps.aggregate-results.outputs.total_cleaned }}
          
          if [ "$total_cleaned" -gt 0 ] || [ "${{ inputs.dry_run }}" = "true" ]; then
            status="success"
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              echo "âœ… Cleanup preview completed successfully"
            else
              echo "âœ… Cleanup completed successfully - $total_cleaned resources cleaned"
            fi
          else
            status="success"  # No resources to clean is still success
            echo "â„¹ï¸ No resources found for cleanup"
          fi
          
          echo "status=$status" >> $GITHUB_OUTPUT
          
      - name: Update PR comment for cleanup
        if: inputs.cleanup_type == 'pr_closed' && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const identifier = '<!-- netra-cleanup-status -->';
            const resourcesCleaned = '${{ steps.aggregate-results.outputs.total_cleaned }}';
            const costSaved = '${{ steps.calculate-savings.outputs.estimated_savings }}';
            const dryRun = ${{ inputs.dry_run }};
            
            const status = dryRun ? 'ðŸ” Cleanup Preview' : 'ðŸ§¹ Resources Cleaned';
            let body = `${identifier}\n## ${status}\n\n`;
            
            if (dryRun) {
              body += `**Preview Mode:** No resources were actually deleted\n`;
              body += `**Resources to clean:** ${resourcesCleaned}\n`;
            } else {
              body += `**Resources cleaned:** ${resourcesCleaned}\n`;
              body += `**Estimated savings:** ${costSaved}\n`;
            }
            
            body += `**Environment:** ${{ inputs.environment }}\n`;
            body += `\n---\n*Updated: ${new Date().toUTCString()}*`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });
            
            const existingComment = comments.find(comment => 
              comment.user.type === 'Bot' && comment.body.includes(identifier)
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
        continue-on-error: true
        
      - name: Upload cleanup artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cleanup-results-${{ inputs.cleanup_type }}-${{ github.run_id }}
          path: |
            cleanup-results/
          retention-days: 30
          
      - name: Log cleanup summary
        run: |
          echo "ðŸ§¹ Cleanup Summary:"
          echo "Type: ${{ inputs.cleanup_type }}"
          echo "Environment: ${{ inputs.environment }}"
          echo "Resources Cleaned: ${{ steps.aggregate-results.outputs.total_cleaned }}"
          echo "Cost Savings: ${{ steps.calculate-savings.outputs.estimated_savings }}"
          echo "Dry Run: ${{ inputs.dry_run }}"
          echo "Status: ${{ steps.final-status.outputs.status }}"